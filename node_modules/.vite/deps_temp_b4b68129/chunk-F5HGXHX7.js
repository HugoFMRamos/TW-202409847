import {
  RGBDTextureTools
} from "./chunk-KGVZBY3O.js";
import {
  DetailMapConfiguration,
  ImageProcessingConfigurationDefines,
  ImageProcessingDefinesMixin,
  ImageProcessingMixin,
  Material,
  MaterialDefines,
  MaterialHelperGeometryRendering,
  MaterialPluginBase,
  PrePassConfiguration,
  PushMaterial,
  ShaderMaterial,
  UVDefinesMixin
} from "./chunk-LMGWFQ7D.js";
import {
  Camera,
  EffectFallbacks,
  ImageProcessingConfiguration,
  Light,
  Scene,
  SceneComponentConstants,
  ShadowLight
} from "./chunk-7EZS6YPK.js";
import {
  Node
} from "./chunk-F654HCBO.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindIBLParameters,
  BindIBLSamplers,
  BindLight,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindTextureMatrix,
  GetFogState,
  HandleFallbacksForShadows,
  MaterialFlags,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForBones,
  PrepareDefinesForCamera,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForIBL,
  PrepareDefinesForLight,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMorphTargets,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformLayoutForIBL,
  PrepareUniformsAndSamplersForIBL,
  PrepareUniformsAndSamplersForLight,
  PrepareUniformsAndSamplersList
} from "./chunk-DDYRC2WG.js";
import {
  UniqueIdGenerator
} from "./chunk-WKXRXUEO.js";
import {
  PostProcess,
  RenderTargetTexture,
  SmartArray
} from "./chunk-M4W6VIXV.js";
import {
  BaseTexture,
  Texture
} from "./chunk-YLKME4IS.js";
import {
  SerializationHelper
} from "./chunk-RS4OXQAU.js";
import {
  Color3,
  Color4,
  TmpColors
} from "./chunk-XWRKXSOJ.js";
import {
  Matrix,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-56DNVGLK.js";
import {
  DrawWrapper
} from "./chunk-MMAWE3MU.js";
import {
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  Tools
} from "./chunk-TMGS4QPG.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsMatrix,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-4I36N4OB.js";
import {
  WebRequest
} from "./chunk-2ZEUD233.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  RandomRange
} from "./chunk-QXB6L2HZ.js";
import {
  WebGLShaderProcessor
} from "./chunk-XWVHOUBP.js";
import {
  AbstractEngine,
  Effect,
  Process,
  TimingTools
} from "./chunk-ZFLE37NJ.js";
import {
  PrecisionDate
} from "./chunk-AZNEH5GV.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
(function(NodeMaterialBlockConnectionPointTypes2) {
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
  NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["All"] = 4095] = "All";
})(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
(function(NodeMaterialBlockTargets2) {
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
  NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
})(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates;
(function(NodeMaterialConnectionPointCompatibilityStates2) {
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
  NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["HierarchyIssue"] = 3] = "HierarchyIssue";
})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
var NodeMaterialConnectionPointDirection;
(function(NodeMaterialConnectionPointDirection2) {
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
  NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
var NodeMaterialConnectionPoint = class _NodeMaterialConnectionPoint {
  /**
   * Checks if two types are equivalent
   * @param type1 type 1 to check
   * @param type2 type 2 to check
   * @returns true if both types are equivalent, else false
   */
  static AreEquivalentTypes(type1, type2) {
    switch (type1) {
      case NodeMaterialBlockConnectionPointTypes.Vector3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Vector4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color3: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
          return true;
        }
        break;
      }
      case NodeMaterialBlockConnectionPointTypes.Color4: {
        if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
          return true;
        }
        break;
      }
    }
    return false;
  }
  /**
   * Boolean used to provide visual clue to users when some ports are not active in the current block configuration
   */
  get isInactive() {
    return this._isInactive;
  }
  get _connectedPoint() {
    return this._connectedPointBackingField;
  }
  set _connectedPoint(value) {
    if (this._connectedPointBackingField === value) {
      return;
    }
    this._connectedPointTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._connectedPointBackingField = value);
    if (this._connectedPointBackingField) {
      this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** @internal */
  get _typeConnectionSource() {
    return this._typeConnectionSourceBackingField;
  }
  /** @internal */
  set _typeConnectionSource(value) {
    if (this._typeConnectionSourceBackingField === value) {
      return;
    }
    this._typeConnectionSourceTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._typeConnectionSourceBackingField = value);
    if (this._typeConnectionSourceBackingField) {
      this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** @internal */
  get _defaultConnectionPointType() {
    return this._defaultConnectionPointTypeBackingField;
  }
  /** @internal */
  set _defaultConnectionPointType(value) {
    this._updateTypeDependentState(() => this._defaultConnectionPointTypeBackingField = value);
  }
  /** @internal */
  get _linkedConnectionSource() {
    return this._linkedConnectionSourceBackingField;
  }
  /** @internal */
  set _linkedConnectionSource(value) {
    if (this._linkedConnectionSourceBackingField === value) {
      return;
    }
    this._linkedConnectionSourceTypeChangedObserver?.remove();
    this._updateTypeDependentState(() => this._linkedConnectionSourceBackingField = value);
    this._isMainLinkSource = false;
    if (this._linkedConnectionSourceBackingField) {
      this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(() => {
        this._notifyTypeChanged();
      });
    }
  }
  /** Gets the direction of the point */
  get direction() {
    return this._direction;
  }
  /**
   * Gets the declaration variable name in the shader
   */
  get declarationVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.declarationVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.declarationVariableName;
    }
    return this._associatedVariableName;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    if (this._ownerBlock.isInput) {
      return this._ownerBlock.associatedVariableName;
    }
    if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
      return this._connectedPoint.associatedVariableName;
    }
    return this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
  get innerType() {
    if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
      return this.type;
    }
    return this._type;
  }
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this._ownerBlock.isInput) {
        return this._ownerBlock.type;
      }
      if (this._connectedPoint) {
        return this._connectedPoint.type;
      }
      if (this._linkedConnectionSource) {
        if (this._linkedConnectionSource.isConnected) {
          if (this._linkedConnectionSource.connectedPoint._redirectedSource && this._linkedConnectionSource.connectedPoint._redirectedSource.isConnected) {
            return this._linkedConnectionSource.connectedPoint._redirectedSource.type;
          }
          return this._linkedConnectionSource.type;
        }
        if (this._linkedConnectionSource._defaultConnectionPointType) {
          return this._linkedConnectionSource._defaultConnectionPointType;
        }
      }
      if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {
      if (this._typeConnectionSource) {
        if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
          return this._defaultConnectionPointType;
        }
        return this._typeConnectionSource.type;
      } else if (this._defaultConnectionPointType) {
        return this._defaultConnectionPointType;
      }
    }
    return this._type;
  }
  set type(value) {
    this._updateTypeDependentState(() => this._type = value);
  }
  /** Gets or sets the target of that connection point */
  get target() {
    if (!this._prioritizeVertex || !this._ownerBlock) {
      return this._target;
    }
    if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
      return this._target;
    }
    if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      return NodeMaterialBlockTargets.Fragment;
    }
    return NodeMaterialBlockTargets.Vertex;
  }
  set target(value) {
    this._target = value;
  }
  /**
   * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
   */
  get isConnected() {
    return this.connectedPoint !== null || this.hasEndpoints;
  }
  /**
   * Gets a boolean indicating that the current point is connected to an input block
   */
  get isConnectedToInputBlock() {
    return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
  }
  /**
   * Gets a the connected input block (if any)
   */
  get connectInputBlock() {
    if (!this.isConnectedToInputBlock) {
      return null;
    }
    return this.connectedPoint.ownerBlock;
  }
  /** Get the other side of the connection (if any) */
  get connectedPoint() {
    return this._connectedPoint;
  }
  /** Get the block that owns this connection point */
  get ownerBlock() {
    return this._ownerBlock;
  }
  /** Get the block connected on the other side of this connection (if any) */
  get sourceBlock() {
    if (!this._connectedPoint) {
      return null;
    }
    return this._connectedPoint.ownerBlock;
  }
  /** Get the block connected on the endpoints of this connection (if any) */
  get connectedBlocks() {
    if (this._endpoints.length === 0) {
      return [];
    }
    return this._endpoints.map((e) => e.ownerBlock);
  }
  /** Gets the list of connected endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /** Gets a boolean indicating if that output point is connected to at least one input */
  get hasEndpoints() {
    return this._endpoints && this._endpoints.length > 0;
  }
  /** Gets a boolean indicating that this connection has a path to the vertex output*/
  get isDirectlyConnectedToVertexOutput() {
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the vertex shader */
  get isConnectedInVertexShader() {
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {
          return true;
        }
      }
    }
    return false;
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader */
  get isConnectedInFragmentShader() {
    if (this.target === NodeMaterialBlockTargets.Fragment) {
      return true;
    }
    if (!this.hasEndpoints) {
      return false;
    }
    for (const endpoint of this._endpoints) {
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
        if (endpoint.ownerBlock.isConnectedInFragmentShader()) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Creates a block suitable to be used as an input for this input point.
   * If null is returned, a block based on the point type will be created.
   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
   */
  createCustomInputBlock() {
    return null;
  }
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   */
  constructor(name6, ownerBlock, direction) {
    this._isInactive = false;
    this._preventBubbleUp = false;
    this._connectedPointBackingField = null;
    this._endpoints = new Array();
    this._redirectedSource = null;
    this._typeConnectionSourceBackingField = null;
    this._defaultConnectionPointTypeBackingField = null;
    this._isMainLinkSource = false;
    this._linkedConnectionSourceBackingField = null;
    this._acceptedConnectionPointType = null;
    this._type = NodeMaterialBlockConnectionPointTypes.Float;
    this._enforceAssociatedVariableName = false;
    this._forPostBuild = false;
    this.needDualDirectionValidation = false;
    this.acceptedConnectionPointTypes = [];
    this.excludedConnectionPointTypes = [];
    this.onConnectionObservable = new Observable();
    this.onDisconnectionObservable = new Observable();
    this.onTypeChangedObservable = new Observable();
    this._isTypeChangeObservableNotifying = false;
    this.isExposedOnFrame = false;
    this.exposedPortPosition = -1;
    this._prioritizeVertex = false;
    this._target = NodeMaterialBlockTargets.VertexAndFragment;
    this._ownerBlock = ownerBlock;
    this.name = name6;
    this._direction = direction;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialConnectionPoint"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialConnectionPoint";
  }
  /**
   * Gets a boolean indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a boolean
   */
  canConnectTo(connectionPoint) {
    return this.checkCompatibilityState(connectionPoint) === 0;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    const ownerBlock = this._ownerBlock;
    const otherBlock = connectionPoint.ownerBlock;
    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
        return 2;
      }
      for (const output of otherBlock.outputs) {
        if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {
          return 2;
        }
      }
    }
    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (_NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {
        return 0;
      }
      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && _NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
        return 0;
      } else {
        return 1;
      }
    }
    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
      return 1;
    }
    let targetBlock = otherBlock;
    let sourceBlock = ownerBlock;
    if (this.direction === 0) {
      targetBlock = ownerBlock;
      sourceBlock = otherBlock;
    }
    if (targetBlock.isAnAncestorOf(sourceBlock)) {
      return 3;
    }
    return 0;
  }
  /**
   * Connect this point to another connection point
   * @param connectionPoint defines the other connection point
   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
   * @returns the current connection point
   */
  connectTo(connectionPoint, ignoreConstraints = false) {
    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
      throw `Cannot connect these two connectors. source: "${this.ownerBlock.name}".${this.name}, target: "${connectionPoint.ownerBlock.name}".${connectionPoint.name}`;
    }
    this._endpoints.push(connectionPoint);
    connectionPoint._connectedPoint = this;
    this._enforceAssociatedVariableName = false;
    this.onConnectionObservable.notifyObservers(connectionPoint);
    connectionPoint.onConnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Disconnect this point from one of his endpoint
   * @param endpoint defines the other connection point
   * @returns the current connection point
   */
  disconnectFrom(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index === -1) {
      return this;
    }
    this._endpoints.splice(index, 1);
    endpoint._connectedPoint = null;
    this._enforceAssociatedVariableName = false;
    endpoint._enforceAssociatedVariableName = false;
    this.onDisconnectionObservable.notifyObservers(endpoint);
    endpoint.onDisconnectionObservable.notifyObservers(this);
    return this;
  }
  /**
   * Fill the list of excluded connection point types with all types other than those passed in the parameter
   * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
   */
  addExcludedConnectionPointFromAllowedTypes(mask) {
    let bitmask = 1;
    while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {
      if (!(mask & bitmask)) {
        this.excludedConnectionPointTypes.push(bitmask);
      }
      bitmask = bitmask << 1;
    }
  }
  /**
   * Serializes this point in a JSON representation
   * @param isInput defines if the connection point is an input (default is true)
   * @returns the serialized point object
   */
  serialize(isInput = true) {
    const serializationObject = {};
    serializationObject.name = this.name;
    if (this.displayName) {
      serializationObject.displayName = this.displayName;
    }
    if (isInput && this.connectedPoint) {
      serializationObject.inputName = this.name;
      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
      serializationObject.targetConnectionName = this.connectedPoint.name;
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
      serializationObject.isExposedOnFrame = true;
      serializationObject.exposedPortPosition = this.exposedPortPosition;
    }
    return serializationObject;
  }
  /**
   * Release resources
   */
  dispose() {
    this.onConnectionObservable.clear();
    this.onDisconnectionObservable.clear();
    this.onTypeChangedObservable.clear();
    this._connectedPoint = null;
    this._typeConnectionSource = null;
    this._linkedConnectionSource = null;
  }
  _updateTypeDependentState(update) {
    const previousType = this.type;
    update();
    if (this.type !== previousType) {
      this._notifyTypeChanged();
    }
  }
  _notifyTypeChanged() {
    if (this._isTypeChangeObservableNotifying) {
      return;
    }
    this._isTypeChangeObservableNotifying = true;
    this.onTypeChangedObservable.notifyObservers(this.type);
    this._isTypeChangeObservableNotifying = false;
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock = class {
  /** @internal */
  get _isFinalOutputAndActive() {
    return this._isFinalOutput;
  }
  /** @internal */
  get _hasPrecedence() {
    return false;
  }
  /**
   * Gets the name of the block
   */
  get name() {
    return this._name;
  }
  /**
   * Gets a boolean indicating that this block has is code ready to be used
   */
  get codeIsReady() {
    return this._codeIsReady;
  }
  /**
   * Sets the name of the block. Will check if the name is valid.
   */
  set name(newName) {
    if (!this.validateBlockName(newName)) {
      return;
    }
    this._name = newName;
  }
  /**
   * Gets a boolean indicating that this block can only be used once per NodeMaterial
   */
  get isUnique() {
    return this._isUnique;
  }
  /**
   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
   */
  get isFinalMerger() {
    return this._isFinalMerger;
  }
  /**
   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
   */
  get isInput() {
    return this._isInput;
  }
  /**
   * Gets a boolean indicating if this block is a teleport out
   */
  get isTeleportOut() {
    return this._isTeleportOut;
  }
  /**
   * Gets a boolean indicating if this block is a teleport in
   */
  get isTeleportIn() {
    return this._isTeleportIn;
  }
  /**
   * Gets a boolean indicating if this block is a loop
   */
  get isLoop() {
    return this._isLoop;
  }
  /**
   * Gets or sets the build Id
   */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  /**
   * Gets the list of input points
   */
  get inputs() {
    return this._inputs;
  }
  /** Gets the list of output points */
  get outputs() {
    return this._outputs;
  }
  /**
   * Find an input by its name
   * @param name defines the name of the input to look for
   * @returns the input or null if not found
   */
  getInputByName(name6) {
    const filter = this._inputs.filter((e) => e.name === name6);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Find an output by its name
   * @param name defines the name of the output to look for
   * @returns the output or null if not found
   */
  getOutputByName(name6) {
    const filter = this._outputs.filter((e) => e.name === name6);
    if (filter.length) {
      return filter[0];
    }
    return null;
  }
  /**
   * Creates a new NodeMaterialBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
   * @param isFinalOutput defines a boolean indicating that this block is generating a final output and no other block should be generated after
   */
  constructor(name6, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isFinalOutput = false) {
    this._isFinalMerger = false;
    this._isInput = false;
    this._isLoop = false;
    this._isTeleportOut = false;
    this._isTeleportIn = false;
    this._name = "";
    this._isUnique = false;
    this._codeIsReady = true;
    this._isFinalOutput = false;
    this.onCodeIsReadyObservable = new Observable();
    this.inputsAreExclusive = false;
    this._codeVariableName = "";
    this._inputs = new Array();
    this._outputs = new Array();
    this.comments = "";
    this.visibleInInspector = false;
    this.visibleOnFrame = false;
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
    this._isFinalMerger = isFinalMerger;
    this._isFinalOutput = isFinalOutput;
    switch (this.getClassName()) {
      case "InputBlock":
        this._isInput = true;
        break;
      case "NodeMaterialTeleportOutBlock":
        this._isTeleportOut = true;
        break;
      case "NodeMaterialTeleportInBlock":
        this._isTeleportIn = true;
        break;
      case "LoopBlock":
        this._isLoop = true;
        break;
    }
    this._name = name6;
    this.uniqueId = UniqueIdGenerator.UniqueId;
  }
  /** @internal */
  _setInitialTarget(target) {
    this._target = target;
    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initialize(state) {
  }
  /**
   * Bind data to effect. Will only be called for blocks with isBindable === true
   * @param effect defines the effect to bind data to
   * @param nodeMaterial defines the hosting NodeMaterial
   * @param mesh defines the mesh that will be rendered
   * @param subMesh defines the submesh that will be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bind(effect, nodeMaterial, mesh, subMesh) {
  }
  _writeVariable(currentPoint) {
    const connectionPoint = currentPoint.connectedPoint;
    if (connectionPoint) {
      return `${currentPoint.associatedVariableName}`;
    }
    return `0.`;
  }
  _writeFloat(value) {
    let stringVersion = value.toString();
    if (stringVersion.indexOf(".") === -1) {
      stringVersion += ".0";
    }
    return `${stringVersion}`;
  }
  /**
   * Gets the current class name e.g. "NodeMaterialBlock"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialBlock";
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader
   * @returns true if connected in fragment shader
   */
  isConnectedInFragmentShader() {
    return this.outputs.some((o) => o.isConnectedInFragmentShader);
  }
  /**
   * Register a new input. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param isOptional defines a boolean indicating that this input can be omitted
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerInput(name6, type, isOptional = false, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(
      name6,
      this,
      0
      /* NodeMaterialConnectionPointDirection.Input */
    );
    point.type = type;
    point.isOptional = isOptional;
    if (target) {
      point.target = target;
    }
    this._inputs.push(point);
    return this;
  }
  /**
   * Register a new output. Must be called inside a block constructor
   * @param name defines the connection point name
   * @param type defines the connection point type
   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
   * @param point an already created connection point. If not provided, create a new one
   * @returns the current block
   */
  registerOutput(name6, type, target, point) {
    point = point ?? new NodeMaterialConnectionPoint(
      name6,
      this,
      1
      /* NodeMaterialConnectionPointDirection.Output */
    );
    point.type = type;
    if (target) {
      point.target = target;
    }
    this._outputs.push(point);
    return this;
  }
  /**
   * Will return the first available input e.g. the first one which is not an uniform or an attribute
   * @param forOutput defines an optional connection point to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableInput(forOutput = null) {
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect || input.acceptedConnectionPointTypes.indexOf(forOutput.type) !== -1) {
          return input;
        }
      }
    }
    return null;
  }
  /**
   * Will return the first available output e.g. the first one which is not yet connected and not a varying
   * @param forBlock defines an optional block to check compatibility with
   * @returns the first available input or null
   */
  getFirstAvailableOutput(forBlock = null) {
    for (const output of this._outputs) {
      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
        return output;
      }
    }
    return null;
  }
  /**
   * Gets the sibling of the given output
   * @param current defines the current output
   * @returns the next output in the list or null
   */
  getSiblingOutput(current) {
    const index = this._outputs.indexOf(current);
    if (index === -1 || index >= this._outputs.length) {
      return null;
    }
    return this._outputs[index + 1];
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const output of this._outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        if (endpoint.ownerBlock === block) {
          return true;
        }
        if (endpoint.ownerBlock.isAnAncestorOf(block)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Connect current block with another block
   * @param other defines the block to connect with
   * @param options define the various options to help pick the right connections
   * @param options.input
   * @param options.output
   * @param options.outputSwizzle
   * @returns the current block
   */
  connectTo(other, options) {
    if (this._outputs.length === 0) {
      return;
    }
    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
    let notFound = true;
    while (notFound) {
      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
      if (output && input && output.canConnectTo(input)) {
        output.connectTo(input);
        notFound = false;
      } else if (!output) {
        throw "Unable to find a compatible match";
      } else {
        output = this.getSiblingOutput(output);
      }
    }
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _buildBlock(state) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _postBuildBlock(state) {
  }
  /**
   * Add uniforms, samplers and uniform buffers at compilation time
   * @param state defines the state to update
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param uniformBuffers defines the list of uniform buffer names
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
  }
  /**
   * Add potential fallbacks if shader compilation fails
   * @param fallbacks defines the current prioritized list of fallbacks
   * @param mesh defines the mesh to be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  provideFallbacks(fallbacks, mesh) {
  }
  /**
   * Initialize defines for shader compilation
   * @param defines defines the material defines to update
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initializeDefines(defines) {
  }
  /**
   * Update defines for shader compilation
   * @param defines defines the material defines to update
   * @param nodeMaterial defines the node material requesting the update
   * @param mesh defines the mesh to be rendered
   * @param useInstances specifies that instances should be used
   * @param subMesh defines which submesh to render
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prepareDefines(defines, nodeMaterial, mesh, useInstances = false, subMesh) {
  }
  /**
   * Lets the block try to connect some inputs automatically
   * @param material defines the hosting NodeMaterial
   * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  autoConfigure(material, additionalFilteringInfo = () => true) {
  }
  /**
   * Function called when a block is declared as repeatable content generator
   * @param vertexShaderState defines the current compilation state for the vertex shader
   * @param defines defines the material defines to update
   * @param mesh defines the mesh to be rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  replaceRepeatableContent(vertexShaderState, defines, mesh) {
  }
  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */
  get willBeGeneratedIntoVertexShaderFromFragmentShader() {
    if (this.isInput || this.isFinalMerger) {
      return false;
    }
    if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.Vertex) {
      return false;
    }
    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {
      if (this._outputs.some((o) => o.isConnectedInVertexShader)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if the block is ready
   * @param mesh defines the mesh to be rendered
   * @param nodeMaterial defines the node material requesting the update
   * @param defines defines the material defines to update
   * @param useInstances specifies that instances should be used
   * @returns true if the block is ready
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReady(mesh, nodeMaterial, defines, useInstances = false) {
    return true;
  }
  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
    if (looseCoupling) {
      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
    } else {
      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
      this._inputs[inputIndex0]._isMainLinkSource = true;
    }
    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
  }
  _processBuild(block, state, input, activeBlocks) {
    block.build(state, activeBlocks);
    const localBlockIsFragment = state._vertexState != null;
    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
    if (block.isTeleportOut && block.entryPoint?.isConnectedToUniform) {
      return;
    }
    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
      if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader
      block.isInput && block.isAttribute && !block._noContextSwitch) {
        const connectedPoint = input.connectedPoint;
        if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.declarationVariableName, connectedPoint.type)) {
          const prefix2 = state.shaderLanguage === 1 ? "vertexOutputs." : "";
          if (state.shaderLanguage === 1 && connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Matrix) {
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r0 = ${connectedPoint.associatedVariableName}[0];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r1 = ${connectedPoint.associatedVariableName}[1];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r2 = ${connectedPoint.associatedVariableName}[2];
`;
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r3 = ${connectedPoint.associatedVariableName}[3];
`;
          } else {
            state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName} = ${connectedPoint.associatedVariableName};
`;
          }
        }
        const prefix = state.shaderLanguage === 1 && connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Matrix ? "fragmentInputs." : "";
        input.associatedVariableName = prefix + "v_" + connectedPoint.declarationVariableName;
        input._enforceAssociatedVariableName = true;
      }
    }
  }
  /**
   * Validates the new name for the block node.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    const reservedNames = [
      "position",
      "normal",
      "tangent",
      "particle_positionw",
      "uv",
      "uv2",
      "uv3",
      "uv4",
      "uv5",
      "uv6",
      "position2d",
      "particle_uv",
      "postprocess_uv",
      "matricesIndices",
      "matricesWeights",
      "world0",
      "world1",
      "world2",
      "world3",
      "particle_color",
      "particle_texturemask"
    ];
    for (const reservedName of reservedNames) {
      if (newName === reservedName) {
        return false;
      }
    }
    return true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _customBuildStep(state, activeBlocks) {
  }
  /**
   * Compile the current node and generate the shader code
   * @param state defines the current compilation state (uniforms, samplers, current string)
   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
   * @returns true if already built
   */
  build(state, activeBlocks) {
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (!this.isInput) {
      for (const output of this._outputs) {
        if (!output.associatedVariableName) {
          output.associatedVariableName = state._getFreeVariableName(output.name);
        }
      }
    }
    for (const input of this._inputs) {
      if (!input.connectedPoint) {
        if (!input.isOptional) {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
        }
        continue;
      }
      if (this.target !== NodeMaterialBlockTargets.Neutral) {
        if ((input.target & this.target) === 0) {
          continue;
        }
        if ((input.target & state.target) === 0) {
          continue;
        }
      }
      const block = input.connectedPoint.ownerBlock;
      if (block && block !== this) {
        this._processBuild(block, state, input, activeBlocks);
      }
    }
    this._customBuildStep(state, activeBlocks);
    if (this._buildId === state.sharedData.buildId) {
      return true;
    }
    if (state.sharedData.verbose) {
      Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader"}: Building ${this.name} [${this.getClassName()}]`);
    }
    if (this.isFinalMerger) {
      switch (state.target) {
        case NodeMaterialBlockTargets.Vertex:
          state.sharedData.checks.emitVertex = true;
          break;
        case NodeMaterialBlockTargets.Fragment:
          state.sharedData.checks.emitFragment = true;
          break;
      }
    }
    if (!this.isInput && state.sharedData.emitComments) {
      state.compilationString += `
//${this.name}
`;
    }
    this._buildBlock(state);
    this._buildId = state.sharedData.buildId;
    this._buildTarget = state.target;
    for (const output of this._outputs) {
      if (output._forPostBuild) {
        continue;
      }
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block) {
          if ((block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1 || state._terminalBlocks.has(block)) {
            this._processBuild(block, state, endpoint, activeBlocks);
          }
        }
      }
    }
    this._postBuildBlock(state);
    for (const output of this._outputs) {
      if (!output._forPostBuild) {
        continue;
      }
      if ((output.target & state.target) === 0) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const block = endpoint.ownerBlock;
        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
          this._processBuild(block, state, endpoint, activeBlocks);
        }
      }
    }
    return false;
  }
  _inputRename(name6) {
    return name6;
  }
  _outputRename(name6) {
    return name6;
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    return `${variableName}.visibleInInspector = ${this.visibleInInspector};
${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.target = ${this.target};
`;
  }
  /**
   * @internal
   */
  _dumpCode(uniqueNames, alreadyDumped) {
    alreadyDumped.push(this);
    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
      let index = 0;
      do {
        index++;
        this._codeVariableName = nameAsVariableName + index;
      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
    }
    uniqueNames.push(this._codeVariableName);
    let codeString = `
// ${this.getClassName()}
`;
    if (this.comments) {
      codeString += `// ${this.comments}
`;
    }
    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`;
    codeString += this._dumpPropertiesCode();
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      if (alreadyDumped.indexOf(connectedBlock) === -1) {
        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const output of this.outputs) {
      if (!output.hasEndpoints) {
        continue;
      }
      for (const endpoint of output.endpoints) {
        const connectedBlock = endpoint.ownerBlock;
        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
        }
      }
    }
    return codeString;
  }
  /**
   * @internal
   */
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = "";
    if (alreadyDumped.indexOf(this) !== -1) {
      return codeString;
    }
    alreadyDumped.push(this);
    for (const input of this.inputs) {
      if (!input.isConnected) {
        continue;
      }
      const connectedOutput = input.connectedPoint;
      const connectedBlock = connectedOutput.ownerBlock;
      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
    }
    return codeString;
  }
  /**
   * Clone the current block to a new identical block
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a copy of the current block
   */
  clone(scene, rootUrl = "") {
    const serializationObject = this.serialize();
    const blockType = GetClass(serializationObject.customType);
    if (blockType) {
      const block = new blockType();
      block._deserialize(serializationObject, scene, rootUrl);
      return block;
    }
    return null;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.id = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject.comments = this.comments;
    serializationObject.visibleInInspector = this.visibleInInspector;
    serializationObject.visibleOnFrame = this.visibleOnFrame;
    serializationObject.target = this.target;
    serializationObject.inputs = [];
    serializationObject.outputs = [];
    for (const input of this.inputs) {
      serializationObject.inputs.push(input.serialize());
    }
    for (const output of this.outputs) {
      serializationObject.outputs.push(output.serialize(false));
    }
    return serializationObject;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _deserialize(serializationObject, scene, rootUrl, urlRewriter) {
    this.name = serializationObject.name;
    this.comments = serializationObject.comments;
    this.visibleInInspector = !!serializationObject.visibleInInspector;
    this.visibleOnFrame = !!serializationObject.visibleOnFrame;
    this._target = serializationObject.target ?? this.target;
    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
  }
  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
    const serializedInputs = serializationObject.inputs;
    const serializedOutputs = serializationObject.outputs;
    if (serializedInputs) {
      for (let i = 0; i < serializedInputs.length; i++) {
        const port = serializedInputs[i];
        if (port.displayName) {
          this.inputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.inputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      }
    }
    if (serializedOutputs) {
      for (let i = 0; i < serializedOutputs.length; i++) {
        const port = serializedOutputs[i];
        if (port.displayName) {
          this.outputs[i].displayName = port.displayName;
        }
        if (port.isExposedOnFrame) {
          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
          this.outputs[i].exposedPortPosition = port.exposedPortPosition;
        }
      }
    }
  }
  /**
   * Release resources
   */
  dispose() {
    this.onCodeIsReadyObservable.clear();
    for (const input of this.inputs) {
      input.dispose();
    }
    for (const output of this.outputs) {
      output.dispose();
    }
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new VertexOutputBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex, true);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VertexOutputBlock";
  }
  /**
   * Gets the vector input component
   */
  get vector() {
    return this._inputs[0];
  }
  _isLogarithmicDepthEnabled(nodeList, useLogarithmicDepth) {
    if (useLogarithmicDepth) {
      return true;
    }
    for (const node of nodeList) {
      if (node.useLogarithmicDepth) {
        return true;
      }
    }
    return false;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.vector;
    const isWebGPU = state.shaderLanguage === 1;
    if (state.shaderLanguage === 1) {
      state.compilationString += `vertexOutputs.position = ${input.associatedVariableName};
`;
    } else {
      state.compilationString += `gl_Position = ${input.associatedVariableName};
`;
    }
    if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {
      state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
      state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
      const fragDepth = isWebGPU ? "vertexOutputs.vFragmentDepth" : "vFragmentDepth";
      const uniformP = isWebGPU ? "uniforms." : "";
      const position = isWebGPU ? "vertexOutputs.position" : "gl_Position";
      state.compilationString += `${fragDepth} = 1.0 + ${position}.w;
`;
      state.compilationString += `${position}.z = log2(max(0.000001, ${fragDepth})) * ${uniformP}logarithmicDepthConstant;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VertexOutputBlock", VertexOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
(function(NodeMaterialSystemValues2) {
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraParameters"] = 10] = "CameraParameters";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["MaterialAlpha"] = 11] = "MaterialAlpha";
  NodeMaterialSystemValues2[NodeMaterialSystemValues2["ProjectionInverse"] = 12] = "ProjectionInverse";
})(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
(function(AnimatedInputBlockTypes2) {
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["RealTime"] = 2] = "RealTime";
  AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["MouseInfo"] = 3] = "MouseInfo";
})(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName = {
  position2d: "position",
  // From particle.vertex:
  particle_uv: "vUV",
  particle_color: "vColor",
  particle_texturemask: "textureMask",
  particle_positionw: "vPositionW",
  // From postprocess.vertex:
  postprocess_uv: "vUV"
};
var attributeInFragmentOnly = {
  particle_uv: true,
  particle_color: true,
  particle_texturemask: true,
  particle_positionw: true,
  postprocess_uv: true
};
var attributeAsUniform = {
  particle_texturemask: true
};
var attributeDefine = {
  normal: "NORMAL",
  tangent: "TANGENT",
  uv: "UV1",
  uv2: "UV2",
  uv3: "UV3",
  uv4: "UV4",
  uv5: "UV5",
  uv6: "UV6",
  uv7: "UV7",
  uv8: "UV8"
};
var InputBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the connection point type (default is float)
   */
  get type() {
    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
      if (this.isUniform && this.value != null) {
        if (!isNaN(this.value)) {
          this._type = NodeMaterialBlockConnectionPointTypes.Float;
          return this._type;
        }
        switch (this.value.getClassName()) {
          case "Vector2":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "Vector3":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "Vector4":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "Color3":
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case "Color4":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
          case "Matrix":
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
        }
      }
      if (this.isAttribute) {
        switch (this.name) {
          case "splatIndex":
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case "position":
          case "normal":
          case "particle_positionw":
          case "splatPosition":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case "uv":
          case "uv2":
          case "uv3":
          case "uv4":
          case "uv5":
          case "uv6":
          case "position2d":
          case "particle_uv":
          case "splatScale":
          case "postprocess_uv":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
            return this._type;
          case "matricesIndices":
          case "matricesWeights":
          case "matricesIndicesExtra":
          case "matricesWeightsExtra":
          case "world0":
          case "world1":
          case "world2":
          case "world3":
          case "tangent":
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
          case "color":
          case "instanceColor":
          case "particle_color":
          case "particle_texturemask":
          case "splatColor":
            this._type = NodeMaterialBlockConnectionPointTypes.Color4;
            return this._type;
        }
      }
      if (this.isSystemValue) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.World:
          case NodeMaterialSystemValues.WorldView:
          case NodeMaterialSystemValues.WorldViewProjection:
          case NodeMaterialSystemValues.View:
          case NodeMaterialSystemValues.ViewProjection:
          case NodeMaterialSystemValues.Projection:
          case NodeMaterialSystemValues.ProjectionInverse:
            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
            return this._type;
          case NodeMaterialSystemValues.CameraPosition:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
            return this._type;
          case NodeMaterialSystemValues.FogColor:
            this._type = NodeMaterialBlockConnectionPointTypes.Color3;
            return this._type;
          case NodeMaterialSystemValues.DeltaTime:
          case NodeMaterialSystemValues.MaterialAlpha:
            this._type = NodeMaterialBlockConnectionPointTypes.Float;
            return this._type;
          case NodeMaterialSystemValues.CameraParameters:
            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
            return this._type;
        }
      }
    }
    return this._type;
  }
  /**
   * Creates a new InputBlock
   * @param name defines the block name
   * @param target defines the target of that block (Vertex by default)
   * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
   */
  constructor(name6, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {
    super(name6, target, false);
    this._mode = 3;
    this._animationType = AnimatedInputBlockTypes.None;
    this._prefix = "";
    this.min = 0;
    this.max = 0;
    this.isBoolean = false;
    this.matrixMode = 0;
    this._systemValue = null;
    this.isConstant = false;
    this.groupInInspector = "";
    this.onValueChangedObservable = new Observable();
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._type = type;
    this.setDefaultValue();
    this.registerOutput("output", type);
  }
  /**
   * Validates if a name is a reserve word.
   * @param newName the new name to be given to the node.
   * @returns false if the name is a reserve word, else true.
   */
  validateBlockName(newName) {
    if (!this.isAttribute) {
      return super.validateBlockName(newName);
    }
    return true;
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Set the source of this connection point to a vertex attribute
   * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
   * @returns the current connection point
   */
  setAsAttribute(attributeName) {
    this._mode = 1;
    if (attributeName) {
      this.name = attributeName;
    }
    return this;
  }
  /**
   * Set the source of this connection point to a system value
   * @param value define the system value to use (world, view, etc...) or null to switch to manual value
   * @returns the current connection point
   */
  setAsSystemValue(value) {
    this.systemValue = value;
    return this;
  }
  /**
   * Gets or sets the value of that point.
   * Please note that this value will be ignored if valueCallback is defined
   */
  get value() {
    return this._storedValue;
  }
  set value(value) {
    if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
      if (this.isBoolean) {
        value = value ? 1 : 0;
      } else if (this.min !== this.max) {
        value = Math.max(this.min, value);
        value = Math.min(this.max, value);
      }
    }
    this._storedValue = value;
    this._mode = 0;
    this.onValueChangedObservable.notifyObservers(this);
  }
  /**
   * Gets or sets a callback used to get the value of that point.
   * Please note that setting this value will force the connection point to ignore the value property
   */
  get valueCallback() {
    return this._valueCallback;
  }
  set valueCallback(value) {
    this._valueCallback = value;
    this._mode = 0;
  }
  /**
   * Gets the declaration variable name in the shader
   */
  get declarationVariableName() {
    return this._associatedVariableName;
  }
  /**
   * Gets or sets the associated variable name in the shader
   */
  get associatedVariableName() {
    return this._prefix + this._associatedVariableName;
  }
  set associatedVariableName(value) {
    this._associatedVariableName = value;
  }
  /** Gets or sets the type of animation applied to the input */
  get animationType() {
    return this._animationType;
  }
  set animationType(value) {
    this._animationType = value;
  }
  /**
   * Gets a boolean indicating that this connection point not defined yet
   */
  get isUndefined() {
    return this._mode === 3;
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an uniform.
   * In this case the connection point name must be the name of the uniform to use.
   * Can only be set on inputs
   */
  get isUniform() {
    return this._mode === 0;
  }
  set isUniform(value) {
    this._mode = value ? 0 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is coming from an attribute.
   * In this case the connection point name must be the name of the attribute to use
   * Can only be set on inputs
   */
  get isAttribute() {
    return this._mode === 1;
  }
  set isAttribute(value) {
    this._mode = value ? 1 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets or sets a boolean indicating that this connection point is generating a varying variable.
   * Can only be set on exit points
   */
  get isVarying() {
    return this._mode === 2;
  }
  set isVarying(value) {
    this._mode = value ? 2 : 3;
    this.associatedVariableName = "";
  }
  /**
   * Gets a boolean indicating that the current connection point is a system value
   */
  get isSystemValue() {
    return this._systemValue != null;
  }
  /**
   * Gets or sets the current well known value or null if not defined as a system value
   */
  get systemValue() {
    return this._systemValue;
  }
  set systemValue(value) {
    this._mode = 0;
    this.associatedVariableName = "";
    this._systemValue = value;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InputBlock";
  }
  /**
   * Animate the input if animationType !== None
   * @param scene defines the rendering scene
   */
  animate(scene) {
    switch (this._animationType) {
      case AnimatedInputBlockTypes.Time: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value += scene.getAnimationRatio() * 0.01;
        }
        break;
      }
      case AnimatedInputBlockTypes.RealTime: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1e3;
        }
        break;
      }
      case AnimatedInputBlockTypes.MouseInfo: {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
          const event = scene._inputManager._originMouseEvent;
          if (event) {
            const x = event.offsetX;
            const y = event.offsetY;
            const z = (event.buttons & 1) != 0 ? 1 : 0;
            const w = (event.buttons & 2) != 0 ? 1 : 0;
            this.value = new Vector4(x, y, z, w);
          } else {
            this.value = new Vector4(0, 0, 0, 0);
          }
        }
        break;
      }
    }
  }
  _emitDefine(define, notDefine = false) {
    return `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
  }
  initialize() {
    this.associatedVariableName = "";
  }
  /**
   * Set the input block to its default value (based on its type)
   */
  setDefaultValue() {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        this.value = 0;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        this.value = Vector2.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        this.value = Vector3.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        this.value = Vector4.Zero();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        this.value = Color3.White();
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        this.value = new Color4(1, 1, 1, 1);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        this.value = Matrix.Identity();
        break;
    }
  }
  _emitConstant(state) {
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return `${state._emitFloat(this.value)}`;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return `vec2(${this.value.x}, ${this.value.y})`;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
        }
        return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;
    }
    return "";
  }
  /** @internal */
  get _noContextSwitch() {
    return attributeInFragmentOnly[this.name];
  }
  _emit(state) {
    if (this.isUniform) {
      if (!this._associatedVariableName) {
        this._associatedVariableName = state._getFreeVariableName("u_" + this.name);
      }
      if (this.isConstant) {
        if (state.constants.indexOf(this.associatedVariableName) !== -1) {
          return;
        }
        state.constants.push(this.associatedVariableName);
        state._constantDeclaration += state._declareOutput(this.output, true) + ` = ${this._emitConstant(state)};
`;
        return;
      }
      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
        return;
      }
      state._emitUniformFromString(this._associatedVariableName, this.type);
      if (state.shaderLanguage === 1) {
        this._prefix = "uniforms.";
      }
      const hints = state.sharedData.hints;
      if (this._systemValue !== null && this._systemValue !== void 0) {
        switch (this._systemValue) {
          case NodeMaterialSystemValues.WorldView:
            hints.needWorldViewMatrix = true;
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            hints.needWorldViewProjectionMatrix = true;
            break;
        }
      } else {
        if (this._animationType !== AnimatedInputBlockTypes.None) {
          state.sharedData.animatedInputs.push(this);
        }
      }
      return;
    }
    if (this.isAttribute) {
      this.associatedVariableName = remapAttributeName[this.name] ?? this.name;
      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
        if (attributeInFragmentOnly[this.name]) {
          if (attributeAsUniform[this.name]) {
            state._emitUniformFromString(this.declarationVariableName, this.type);
            if (state.shaderLanguage === 1) {
              this._prefix = `vertexInputs.`;
            }
          } else {
            state._emitVaryingFromString(this.declarationVariableName, this.type);
          }
        } else {
          this._emit(state._vertexState);
        }
        return;
      }
      const alreadyDeclared = state.attributes.indexOf(this.declarationVariableName) !== -1;
      if (!alreadyDeclared) {
        state.attributes.push(this.declarationVariableName);
      }
      if (attributeInFragmentOnly[this.name]) {
        if (attributeAsUniform[this.name]) {
          if (!alreadyDeclared) {
            state._emitUniformFromString(this.declarationVariableName, this.type);
          }
          if (state.shaderLanguage === 1) {
            this._prefix = `uniforms.`;
          }
        } else {
          if (!alreadyDeclared) {
            state._emitVaryingFromString(this.declarationVariableName, this.type);
          }
          if (state.shaderLanguage === 1) {
            this._prefix = `fragmentInputs.`;
          }
        }
      } else {
        if (state.shaderLanguage === 1) {
          if (!alreadyDeclared) {
            const defineName = attributeDefine[this.name];
            if (defineName) {
              state._attributeDeclaration += this._emitDefine(defineName);
              state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
              state._attributeDeclaration += `#else
`;
              state._attributeDeclaration += `var<private> ${this.declarationVariableName}: ${state._getShaderType(this.type)} = ${state._getShaderType(this.type)}(0.);
`;
              state._attributeDeclaration += `#endif
`;
            } else {
              state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
            }
          }
          this._prefix = `vertexInputs.`;
        } else {
          if (!alreadyDeclared) {
            const defineName = attributeDefine[this.name];
            if (defineName) {
              state._attributeDeclaration += this._emitDefine(defineName);
              state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
              state._attributeDeclaration += `#else
`;
              state._attributeDeclaration += `${state._getShaderType(this.type)} ${this.declarationVariableName} = ${state._getShaderType(this.type)}(0.);
`;
              state._attributeDeclaration += `#endif
`;
            } else {
              state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   */
  _transmitWorld(effect, world, worldView, worldViewProjection) {
    if (!this._systemValue) {
      return;
    }
    const variableName = this._associatedVariableName;
    switch (this._systemValue) {
      case NodeMaterialSystemValues.World:
        effect.setMatrix(variableName, world);
        break;
      case NodeMaterialSystemValues.WorldView:
        effect.setMatrix(variableName, worldView);
        break;
      case NodeMaterialSystemValues.WorldViewProjection:
        effect.setMatrix(variableName, worldViewProjection);
        break;
    }
  }
  /**
   * @internal
   */
  _transmit(effect, scene, material) {
    if (this.isAttribute) {
      return;
    }
    const variableName = this._associatedVariableName;
    if (this._systemValue) {
      switch (this._systemValue) {
        case NodeMaterialSystemValues.World:
        case NodeMaterialSystemValues.WorldView:
        case NodeMaterialSystemValues.WorldViewProjection:
          return;
        case NodeMaterialSystemValues.View:
          effect.setMatrix(variableName, scene.getViewMatrix());
          break;
        case NodeMaterialSystemValues.Projection:
          effect.setMatrix(variableName, scene.getProjectionMatrix());
          break;
        case NodeMaterialSystemValues.ProjectionInverse: {
          const projectionMatrix = scene.getProjectionMatrix();
          projectionMatrix.invertToRef(TmpVectors.Matrix[0]);
          effect.setMatrix(variableName, TmpVectors.Matrix[0]);
          break;
        }
        case NodeMaterialSystemValues.ViewProjection:
          effect.setMatrix(variableName, scene.getTransformMatrix());
          break;
        case NodeMaterialSystemValues.CameraPosition:
          scene.bindEyePosition(effect, variableName, true);
          break;
        case NodeMaterialSystemValues.FogColor:
          effect.setColor3(variableName, scene.fogColor);
          break;
        case NodeMaterialSystemValues.DeltaTime:
          effect.setFloat(variableName, scene.deltaTime / 1e3);
          break;
        case NodeMaterialSystemValues.CameraParameters:
          if (scene.activeCamera) {
            effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);
          }
          break;
        case NodeMaterialSystemValues.MaterialAlpha:
          effect.setFloat(variableName, material.alpha);
          break;
      }
      return;
    }
    const value = this._valueCallback ? this._valueCallback() : this._storedValue;
    if (value === null) {
      return;
    }
    switch (this.type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        effect.setFloat(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Int:
        effect.setInt(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color3:
        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
        if (this.convertToGammaSpace) {
          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setColor3(variableName, TmpColors.Color3[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Color4:
        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
        if (this.convertToGammaSpace) {
          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        if (this.convertToLinearSpace) {
          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
        }
        effect.setDirectColor4(variableName, TmpColors.Color4[0]);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        effect.setVector2(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        effect.setVector3(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        effect.setVector4(variableName, value);
        break;
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        effect.setMatrix(variableName, value);
        break;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.isUniform || this.isSystemValue) {
      state.sharedData.inputBlocks.push(this);
    }
    this._emit(state);
  }
  _dumpPropertiesCode() {
    const variableName = this._codeVariableName;
    if (this.isAttribute) {
      return super._dumpPropertiesCode() + `${variableName}.setAsAttribute("${this.name}");
`;
    }
    if (this.isSystemValue) {
      return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});
`;
    }
    if (this.isUniform) {
      const codes = [];
      let valueString = "";
      switch (this.type) {
        case NodeMaterialBlockConnectionPointTypes.Float:
          valueString = `${this.value}`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector2:
          valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector3:
          valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Vector4:
          valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
          break;
        case NodeMaterialBlockConnectionPointTypes.Color3:
          valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Color4:
          valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;
          if (this.convertToGammaSpace) {
            valueString += ".toGammaSpace()";
          }
          if (this.convertToLinearSpace) {
            valueString += ".toLinearSpace()";
          }
          break;
        case NodeMaterialBlockConnectionPointTypes.Matrix:
          valueString = `BABYLON.Matrix.FromArray([${this.value.m.join(", ")}])`;
          break;
      }
      codes.push(`${variableName}.value = ${valueString}`);
      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
        codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);
      }
      codes.push(`${variableName}.isConstant = ${this.isConstant}`);
      codes.push("");
      return super._dumpPropertiesCode() + codes.join(";\n");
    }
    return super._dumpPropertiesCode();
  }
  dispose() {
    this.onValueChangedObservable.clear();
    super.dispose();
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.type = this.type;
    serializationObject.mode = this._mode;
    serializationObject.systemValue = this._systemValue;
    serializationObject.animationType = this._animationType;
    serializationObject.min = this.min;
    serializationObject.max = this.max;
    serializationObject.isBoolean = this.isBoolean;
    serializationObject.matrixMode = this.matrixMode;
    serializationObject.isConstant = this.isConstant;
    serializationObject.groupInInspector = this.groupInInspector;
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this._storedValue != null && this._mode === 0) {
      if (this._storedValue.asArray) {
        serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
        serializationObject.value = this._storedValue.asArray();
      } else {
        serializationObject.valueType = "number";
        serializationObject.value = this._storedValue;
      }
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._mode = serializationObject.mode;
    super._deserialize(serializationObject, scene, rootUrl);
    this._type = serializationObject.type;
    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
    this._animationType = serializationObject.animationType;
    this.min = serializationObject.min || 0;
    this.max = serializationObject.max || 0;
    this.isBoolean = !!serializationObject.isBoolean;
    this.matrixMode = serializationObject.matrixMode || 0;
    this.isConstant = !!serializationObject.isConstant;
    this.groupInInspector = serializationObject.groupInInspector || "";
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.name === "tangent" && serializationObject.mode === 1 && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
      this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
    }
    if (!serializationObject.valueType) {
      return;
    }
    if (serializationObject.valueType === "number") {
      this._storedValue = serializationObject.value;
    } else {
      const valueType = GetClass(serializationObject.valueType);
      if (valueType) {
        this._storedValue = valueType.FromArray(serializationObject.value);
      }
    }
  }
};
RegisterClass("BABYLON.InputBlock", InputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/bonesBlock.js
var BonesBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new BonesBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this.registerInput("matricesIndices", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("matricesWeights", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("matricesIndicesExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("matricesWeightsExtra", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("boneSampler");
    state._excludeVariableName("boneTextureWidth");
    state._excludeVariableName("mBones");
    state._excludeVariableName("BonesPerMesh");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([import("./bonesDeclaration-LMOTLZ2A.js"), import("./bonesVertex-SL7KLQVT.js")]);
    } else {
      await Promise.all([import("./bonesDeclaration-H2GOTDOK.js"), import("./bonesVertex-24YVNUUB.js")]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "BonesBlock";
  }
  /**
   * Gets the matrix indices input component
   */
  get matricesIndices() {
    return this._inputs[0];
  }
  /**
   * Gets the matrix weights input component
   */
  get matricesWeights() {
    return this._inputs[1];
  }
  /**
   * Gets the extra matrix indices input component
   */
  get matricesIndicesExtra() {
    return this._inputs[2];
  }
  /**
   * Gets the extra matrix weights input component
   */
  get matricesWeightsExtra() {
    return this._inputs[3];
  }
  /**
   * Gets the world input component
   */
  get world() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.matricesIndices.isConnected) {
      let matricesIndicesInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "matricesIndices" && additionalFilteringInfo(b));
      if (!matricesIndicesInput) {
        matricesIndicesInput = new InputBlock("matricesIndices");
        matricesIndicesInput.setAsAttribute("matricesIndices");
      }
      matricesIndicesInput.output.connectTo(this.matricesIndices);
    }
    if (!this.matricesWeights.isConnected) {
      let matricesWeightsInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "matricesWeights" && additionalFilteringInfo(b));
      if (!matricesWeightsInput) {
        matricesWeightsInput = new InputBlock("matricesWeights");
        matricesWeightsInput.setAsAttribute("matricesWeights");
      }
      matricesWeightsInput.output.connectTo(this.matricesWeights);
    }
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
  }
  provideFallbacks(fallbacks, mesh) {
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      fallbacks.addCPUSkinningFallback(0, mesh);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    BindBonesParameters(mesh, effect);
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!defines._areAttributesDirty || !mesh) {
      return;
    }
    PrepareDefinesForBones(mesh, defines);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.blocksWithFallbacks.push(this);
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.uniforms.push("boneTextureWidth");
    state.uniforms.push("mBones");
    state.samplers.push("boneSampler");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("bonesDeclaration", comments, {
      removeAttributes: true,
      removeUniforms: false,
      removeVaryings: true,
      removeIfDef: false
    });
    const influenceVariablename = state._getFreeVariableName("influence");
    state.compilationString += state._emitCodeFromInclude("bonesVertex", comments, {
      replaceStrings: [
        {
          search: /finalWorld=finalWorld\*influence;/,
          replace: ""
        },
        {
          search: /influence/gm,
          replace: influenceVariablename
        }
      ]
    });
    const output = this._outputs[0];
    const worldInput = this.world;
    state.compilationString += `#if NUM_BONE_INFLUENCERS>0
`;
    state.compilationString += state._declareOutput(output) + ` = ${worldInput.associatedVariableName} * ${influenceVariablename};
`;
    state.compilationString += `#else
`;
    state.compilationString += state._declareOutput(output) + ` = ${worldInput.associatedVariableName};
`;
    state.compilationString += `#endif
`;
    return this;
  }
};
RegisterClass("BABYLON.BonesBlock", BonesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/instancesBlock.js
var InstancesBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new InstancesBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this.registerInput("world0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world3", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("instanceID", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "InstancesBlock";
  }
  /**
   * Gets the first world row input component
   */
  get world0() {
    return this._inputs[0];
  }
  /**
   * Gets the second world row input component
   */
  get world1() {
    return this._inputs[1];
  }
  /**
   * Gets the third world row input component
   */
  get world2() {
    return this._inputs[2];
  }
  /**
   * Gets the forth world row input component
   */
  get world3() {
    return this._inputs[3];
  }
  /**
   * Gets the world input component
   */
  get world() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the instanceID component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get instanceID() {
    return this._outputs[1];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.world0.connectedPoint) {
      let world0Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world0" && additionalFilteringInfo(b));
      if (!world0Input) {
        world0Input = new InputBlock("world0");
        world0Input.setAsAttribute("world0");
      }
      world0Input.output.connectTo(this.world0);
    }
    if (!this.world1.connectedPoint) {
      let world1Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world1" && additionalFilteringInfo(b));
      if (!world1Input) {
        world1Input = new InputBlock("world1");
        world1Input.setAsAttribute("world1");
      }
      world1Input.output.connectTo(this.world1);
    }
    if (!this.world2.connectedPoint) {
      let world2Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world2" && additionalFilteringInfo(b));
      if (!world2Input) {
        world2Input = new InputBlock("world2");
        world2Input.setAsAttribute("world2");
      }
      world2Input.output.connectTo(this.world2);
    }
    if (!this.world3.connectedPoint) {
      let world3Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world3" && additionalFilteringInfo(b));
      if (!world3Input) {
        world3Input = new InputBlock("world3");
        world3Input.setAsAttribute("world3");
      }
      world3Input.output.connectTo(this.world3);
    }
    if (!this.world.connectedPoint) {
      let worldInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "world" && additionalFilteringInfo(b));
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    this.world.define = "!INSTANCES || THIN_INSTANCES";
  }
  prepareDefines(defines, nodeMaterial, mesh, useInstances = false, subMesh) {
    let changed = false;
    if (defines["INSTANCES"] !== useInstances) {
      defines.setValue("INSTANCES", useInstances);
      changed = true;
    }
    if (subMesh && defines["THIN_INSTANCES"] !== !!subMesh?.getRenderingMesh().hasThinInstances) {
      defines.setValue("THIN_INSTANCES", !!subMesh?.getRenderingMesh().hasThinInstances);
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const engine = state.sharedData.scene.getEngine();
    state.sharedData.blocksWithDefines.push(this);
    const output = this._outputs[0];
    const instanceID = this._outputs[1];
    const world0 = this.world0;
    const world1 = this.world1;
    const world2 = this.world2;
    const world3 = this.world3;
    let mat4 = "mat4";
    let instance = "gl_InstanceID";
    let floatCast = "float";
    if (state.shaderLanguage === 1) {
      mat4 = "mat4x4f";
      instance = "vertexInputs.instanceIndex";
      floatCast = "f32";
    }
    state.compilationString += `#ifdef INSTANCES
`;
    state.compilationString += state._declareOutput(output) + ` = ${mat4}(${world0.associatedVariableName}, ${world1.associatedVariableName}, ${world2.associatedVariableName}, ${world3.associatedVariableName});
`;
    state.compilationString += `#ifdef THIN_INSTANCES
`;
    state.compilationString += `${output.associatedVariableName} = ${this.world.associatedVariableName} * ${output.associatedVariableName};
`;
    state.compilationString += `#endif
`;
    if (engine._caps.canUseGLInstanceID) {
      state.compilationString += state._declareOutput(instanceID) + ` = ${floatCast}(${instance});
`;
    } else {
      state.compilationString += state._declareOutput(instanceID) + ` = 0.0;
`;
    }
    state.compilationString += `#else
`;
    state.compilationString += state._declareOutput(output) + ` = ${this.world.associatedVariableName};
`;
    state.compilationString += state._declareOutput(instanceID) + ` = 0.0;
`;
    state.compilationString += `#endif
`;
    return this;
  }
};
RegisterClass("BABYLON.InstancesBlock", InstancesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/morphTargetsBlock.js
var MorphTargetsBlock = class extends NodeMaterialBlock {
  /**
   * Create a new MorphTargetsBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.tangent.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("uv2", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4);
    this.registerOutput("positionOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("normalOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("tangentOutput", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("uvOutput", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("uv2Output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("colorOutput", NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MorphTargetsBlock";
  }
  /**
   * Gets the position input component
   */
  get position() {
    return this._inputs[0];
  }
  /**
   * Gets the normal input component
   */
  get normal() {
    return this._inputs[1];
  }
  /**
   * Gets the tangent input component
   */
  get tangent() {
    return this._inputs[2];
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[3];
  }
  /**
   * Gets the uv2 input component
   */
  get uv2() {
    return this._inputs[4];
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[5];
  }
  /**
   * Gets the position output component
   */
  get positionOutput() {
    return this._outputs[0];
  }
  /**
   * Gets the normal output component
   */
  get normalOutput() {
    return this._outputs[1];
  }
  /**
   * Gets the tangent output component
   */
  get tangentOutput() {
    return this._outputs[2];
  }
  /**
   * Gets the uv output component
   */
  get uvOutput() {
    return this._outputs[3];
  }
  /**
   * Gets the uv2 output component
   */
  get uv2Output() {
    return this._outputs[4];
  }
  /**
   * Gets the color output component
   */
  get colorOutput() {
    return this._outputs[5];
  }
  initialize(state) {
    state._excludeVariableName("morphTargetInfluences");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./morphTargetsVertex-GUNKLI3Y.js"),
        import("./morphTargetsVertexDeclaration-PPAKEUCX.js"),
        import("./morphTargetsVertexGlobal-MINQVA4H.js"),
        import("./morphTargetsVertexGlobalDeclaration-QFGS7FUD.js")
      ]);
    } else {
      await Promise.all([
        import("./morphTargetsVertex-7XH3TDCY.js"),
        import("./morphTargetsVertexDeclaration-4XKQPOQV.js"),
        import("./morphTargetsVertexGlobal-LOEISG5U.js"),
        import("./morphTargetsVertexGlobalDeclaration-HOB45PXA.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.position.isConnected) {
      let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "position" && additionalFilteringInfo(b));
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.normal.isConnected) {
      let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "normal" && additionalFilteringInfo(b));
      if (!normalInput) {
        normalInput = new InputBlock("normal");
        normalInput.setAsAttribute("normal");
      }
      normalInput.output.connectTo(this.normal);
    }
    if (!this.tangent.isConnected) {
      let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "tangent" && additionalFilteringInfo(b));
      if (!tangentInput) {
        tangentInput = new InputBlock("tangent");
        tangentInput.setAsAttribute("tangent");
      }
      tangentInput.output.connectTo(this.tangent);
    }
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("uv");
      }
      uvInput.output.connectTo(this.uv);
    }
    if (!this.uv2.isConnected) {
      let uv2Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "uv2" && additionalFilteringInfo(b));
      if (!uv2Input) {
        uv2Input = new InputBlock("uv2");
        uv2Input.setAsAttribute("uv2");
      }
      uv2Input.output.connectTo(this.uv2);
    }
    if (!this.color.isConnected) {
      let colorInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "color" && additionalFilteringInfo(b));
      if (!colorInput) {
        colorInput = new InputBlock("color");
        colorInput.setAsAttribute("color");
      }
      colorInput.output.connectTo(this.color);
    }
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (mesh.morphTargetManager) {
      const morphTargetManager = mesh.morphTargetManager;
      if (morphTargetManager?.isUsingTextureForTargets && (morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers) !== defines["NUM_MORPH_INFLUENCERS"]) {
        defines.markAsAttributesDirty();
      }
    }
    if (!defines._areAttributesDirty) {
      return;
    }
    PrepareDefinesForMorphTargets(mesh, defines);
  }
  bind(effect, nodeMaterial, mesh) {
    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {
      BindMorphTargetParameters(mesh, effect);
      if (mesh.morphTargetManager.isUsingTextureForTargets) {
        mesh.morphTargetManager._bind(effect);
      }
    }
  }
  replaceRepeatableContent(vertexShaderState, defines, mesh) {
    if (!mesh) {
      return;
    }
    const position = this.position;
    const normal = this.normal;
    const tangent = this.tangent;
    const uv = this.uv;
    const uv2 = this.uv2;
    const color = this.color;
    const positionOutput = this.positionOutput;
    const normalOutput = this.normalOutput;
    const tangentOutput = this.tangentOutput;
    const uvOutput = this.uvOutput;
    const uv2Output = this.uv2Output;
    const colorOutput = this.colorOutput;
    const state = vertexShaderState;
    const repeatCount = defines.NUM_MORPH_INFLUENCERS;
    const manager = mesh.morphTargetManager;
    const supportPositions = manager && manager.supportsPositions;
    const supportNormals = manager && manager.supportsNormals;
    const supportTangents = manager && manager.supportsTangents;
    const supportUVs = manager && manager.supportsUVs;
    const supportUV2s = manager && manager.supportsUV2s;
    const supportColors = manager && manager.supportsColors;
    let injectionCode = "";
    if (manager?.isUsingTextureForTargets && repeatCount > 0) {
      injectionCode += `${state._declareLocalVar("vertexID", NodeMaterialBlockConnectionPointTypes.Float)};
`;
    }
    injectionCode += `#ifdef MORPHTARGETS
`;
    const isWebGPU = state.shaderLanguage === 1;
    const uniformsPrefix = isWebGPU ? "uniforms." : "";
    if (manager?.isUsingTextureForTargets) {
      injectionCode += `for (${isWebGPU ? "var" : "int"} i = 0; i < NUM_MORPH_INFLUENCERS; i++) {
`;
      injectionCode += `if (${isWebGPU ? "f32" : "float"}(i) >= ${uniformsPrefix}morphTargetCount) { break; }
`;
      injectionCode += `vertexID = ${isWebGPU ? "f32(vertexInputs.vertexIndex" : "float(gl_VertexID"}) * ${uniformsPrefix}morphTargetTextureInfo.x;
`;
      if (supportPositions) {
        injectionCode += `#ifdef MORPHTARGETS_POSITION
`;
        injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${position.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];
`;
        injectionCode += `#endif
`;
      }
      injectionCode += `#ifdef MORPHTARGETTEXTURE_HASPOSITIONS
`;
      injectionCode += `vertexID += 1.0;
`;
      injectionCode += `#endif
`;
      if (supportNormals) {
        injectionCode += `#ifdef MORPHTARGETS_NORMAL
`;
        injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${normal.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];
`;
        injectionCode += `#endif
`;
      }
      injectionCode += `#ifdef MORPHTARGETTEXTURE_HASNORMALS
`;
      injectionCode += `vertexID += 1.0;
`;
      injectionCode += `#endif
`;
      if (supportUVs) {
        injectionCode += `#ifdef MORPHTARGETS_UV
`;
        injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${uv.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];
`;
        injectionCode += `#endif
`;
      }
      injectionCode += `#ifdef MORPHTARGETTEXTURE_HASUVS
`;
      injectionCode += `vertexID += 1.0;
`;
      injectionCode += `#endif
`;
      if (supportTangents) {
        injectionCode += `#ifdef MORPHTARGETS_TANGENT
`;
        injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(i, vertexID) - ${tangent.associatedVariableName}.xyz) * ${uniformsPrefix}morphTargetInfluences[i];
`;
        if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
          injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;
`;
        } else {
          injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;
`;
        }
        injectionCode += `#endif
`;
      }
      injectionCode += `#ifdef MORPHTARGETTEXTURE_HASTANGENTS
`;
      injectionCode += `vertexID += 1.0;
`;
      injectionCode += `#endif
`;
      if (supportUV2s) {
        injectionCode += `#ifdef MORPHTARGETS_UV2
`;
        injectionCode += `${uv2Output.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${uv2.associatedVariableName}) * morphTargetInfluences[i];
`;
        injectionCode += `#endif
`;
      }
      injectionCode += `#ifdef MORPHTARGETTEXTURE_HASUV2S
`;
      injectionCode += `vertexID += 1.0;
`;
      injectionCode += `#endif
`;
      if (supportColors) {
        injectionCode += `#ifdef MORPHTARGETS_COLOR
`;
        injectionCode += `${colorOutput.associatedVariableName} += (readVector4FromRawSampler(i, vertexID) - ${color.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];
`;
        injectionCode += `#endif
`;
      }
      injectionCode += "}\n";
    } else {
      for (let index = 0; index < repeatCount; index++) {
        if (supportPositions) {
          injectionCode += `#ifdef MORPHTARGETS_POSITION
`;
          injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];
`;
          injectionCode += `#endif
`;
        }
        if (supportNormals && defines["NORMAL"]) {
          injectionCode += `#ifdef MORPHTARGETS_NORMAL
`;
          injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];
`;
          injectionCode += `#endif
`;
        }
        if (supportUVs && defines["UV1"]) {
          injectionCode += `#ifdef MORPHTARGETS_UV
`;
          injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * ${uniformsPrefix}morphTargetInfluences[${index}];
`;
          injectionCode += `#endif
`;
        }
        if (supportTangents && defines["TANGENT"]) {
          injectionCode += `#ifdef MORPHTARGETS_TANGENT
`;
          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * ${uniformsPrefix}morphTargetInfluences[${index}];
`;
          if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
            injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;
`;
          } else {
            injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;
`;
          }
          injectionCode += `#endif
`;
        }
        if (supportUV2s && defines["UV2"]) {
          injectionCode += `#ifdef MORPHTARGETS_UV2
`;
          injectionCode += `${uv2Output.associatedVariableName}.xy += (uv2_${index} - ${uv2.associatedVariableName}.xy) * morphTargetInfluences[${index}];
`;
          injectionCode += `#endif
`;
        }
        if (supportColors && defines["VERTEXCOLOR_NME"]) {
          injectionCode += `#ifdef MORPHTARGETS_COLOR
`;
          injectionCode += `${colorOutput.associatedVariableName} += (color${index} - ${color.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];
`;
          injectionCode += `#endif
`;
        }
      }
    }
    injectionCode += `#endif
`;
    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);
    if (repeatCount > 0) {
      for (let index = 0; index < repeatCount; index++) {
        if (supportPositions) {
          state.attributes.push(VertexBuffer.PositionKind + index);
        }
        if (supportNormals && defines["NORMAL"]) {
          state.attributes.push(VertexBuffer.NormalKind + index);
        }
        if (supportTangents && defines["TANGENT"]) {
          state.attributes.push(VertexBuffer.TangentKind + index);
        }
        if (supportUVs && defines["UV1"]) {
          state.attributes.push(VertexBuffer.UVKind + "_" + index);
        }
        if (supportUV2s && defines["UV2"]) {
          state.attributes.push(VertexBuffer.UV2Kind + "_" + index);
        }
        if (supportColors && defines["VERTEXCOLOR_NME"]) {
          state.attributes.push(VertexBuffer.ColorKind + index);
        }
      }
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.repeatableContentBlocks.push(this);
    const position = this.position;
    const normal = this.normal;
    const tangent = this.tangent;
    const uv = this.uv;
    const uv2 = this.uv2;
    const color = this.color;
    const positionOutput = this.positionOutput;
    const normalOutput = this.normalOutput;
    const tangentOutput = this.tangentOutput;
    const uvOutput = this.uvOutput;
    const uv2Output = this.uv2Output;
    const colorOutput = this.colorOutput;
    const comments = `//${this.name}`;
    state.uniforms.push("morphTargetInfluences");
    state.uniforms.push("morphTargetCount");
    state.uniforms.push("morphTargetTextureInfo");
    state.uniforms.push("morphTargetTextureIndices");
    state.samplers.push("morphTargets");
    state._emitFunctionFromInclude("morphTargetsVertexGlobalDeclaration", comments);
    state._emitFunctionFromInclude("morphTargetsVertexDeclaration", comments, {
      repeatKey: "maxSimultaneousMorphTargets"
    });
    state.compilationString += `${state._declareOutput(positionOutput)} = ${position.associatedVariableName};
`;
    state.compilationString += `#ifdef NORMAL
`;
    state.compilationString += `${state._declareOutput(normalOutput)} = ${normal.associatedVariableName};
`;
    state.compilationString += `#else
`;
    state.compilationString += `${state._declareOutput(normalOutput)} = vec3(0., 0., 0.);
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef TANGENT
`;
    state.compilationString += `${state._declareOutput(tangentOutput)} = ${tangent.associatedVariableName};
`;
    state.compilationString += `#else
`;
    state.compilationString += `${state._declareOutput(tangentOutput)} = vec4(0., 0., 0., 0.);
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef UV1
`;
    state.compilationString += `${state._declareOutput(uvOutput)} = ${uv.associatedVariableName};
`;
    state.compilationString += `#else
`;
    state.compilationString += `${state._declareOutput(uvOutput)} = vec2(0., 0.);
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef UV2
`;
    state.compilationString += `${state._declareOutput(uv2Output)} = ${uv2.associatedVariableName};
`;
    state.compilationString += `#else
`;
    state.compilationString += `${state._declareOutput(uv2Output)} = vec2(0., 0.);
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef VERTEXCOLOR_NME
`;
    state.compilationString += `${state._declareOutput(colorOutput)} = ${color.associatedVariableName};
`;
    state.compilationString += `#else
`;
    state.compilationString += `${state._declareOutput(colorOutput)} = vec4(0., 0., 0., 0.);
`;
    state.compilationString += `#endif
`;
    this._repeatableContentAnchor = state._repeatableContentAnchor;
    state.compilationString += this._repeatableContentAnchor;
    return this;
  }
};
RegisterClass("BABYLON.MorphTargetsBlock", MorphTargetsBlock);

// node_modules/@babylonjs/core/Lights/pointLight.js
Node.AddNodeConstructor("Light_Type_0", (name6, scene) => {
  return () => new PointLight(name6, Vector3.Zero(), scene);
});
var PointLight = class extends ShadowLight {
  /**
   * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   * This specifies what angle the shadow will use to be created.
   *
   * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
   */
  get shadowAngle() {
    return this._shadowAngle;
  }
  /**
   * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   * This specifies what angle the shadow will use to be created.
   *
   * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
   */
  set shadowAngle(value) {
    this._shadowAngle = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the direction if it has been set.
   * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   */
  get direction() {
    return this._direction;
  }
  /**
   * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   */
  set direction(value) {
    const previousNeedCube = this.needCube();
    this._direction = value;
    if (this.needCube() !== previousNeedCube && this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.recreateShadowMap();
      }
    }
  }
  /**
   * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
   * A PointLight emits the light in every direction.
   * It can cast shadows.
   * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
   * ```javascript
   * var pointLight = new PointLight("pl", camera.position, scene);
   * ```
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The light friendly name
   * @param position The position of the point light in the scene
   * @param scene The scene the lights belongs to
   */
  constructor(name6, position, scene) {
    super(name6, scene);
    this._shadowAngle = Math.PI / 2;
    this.position = position;
  }
  /**
   * Returns the string "PointLight"
   * @returns the class name
   */
  getClassName() {
    return "PointLight";
  }
  /**
   * Returns the integer 0.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTypeID() {
    return Light.LIGHTTYPEID_POINTLIGHT;
  }
  /**
   * Specifies whether or not the shadowmap should be a cube texture.
   * @returns true if the shadowmap needs to be a cube texture.
   */
  needCube() {
    return !this.direction;
  }
  /**
   * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  getShadowDirection(faceIndex) {
    if (this.direction) {
      return super.getShadowDirection(faceIndex);
    } else {
      switch (faceIndex) {
        case 0:
          return new Vector3(1, 0, 0);
        case 1:
          return new Vector3(-1, 0, 0);
        case 2:
          return new Vector3(0, -1, 0);
        case 3:
          return new Vector3(0, 1, 0);
        case 4:
          return new Vector3(0, 0, 1);
        case 5:
          return new Vector3(0, 0, -1);
      }
    }
    return Vector3.Zero();
  }
  /**
   * Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
   * - fov = PI / 2
   * - aspect ratio : 1.0
   * - z-near and far equal to the active camera minZ and maxZ.
   * Returns the PointLight.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    const minZ = this.getDepthMinZ(activeCamera);
    const maxZ = this.getDepthMaxZ(activeCamera);
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightFalloff", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The point light
   */
  transferToEffect(effect, lightIndex) {
    const offset = this._scene.floatingOriginOffset;
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z, 0, lightIndex);
    } else {
      this._uniformBuffer.updateFloat4("vLightData", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);
    }
    this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    const offset = this._scene.floatingOriginOffset;
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z);
    } else {
      effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);
    }
    return this;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["POINTLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], PointLight.prototype, "shadowAngle", null);
RegisterClass("BABYLON.PointLight", PointLight);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/lightInformationBlock.js
var LightInformationBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new LightInformationBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("direction", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("intensity", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowBias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowNormalBias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowDepthScale", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("shadowDepthRange", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "LightInformationBlock";
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the direction output component
   */
  get direction() {
    return this._outputs[0];
  }
  /**
   * Gets the direction output component
   */
  get color() {
    return this._outputs[1];
  }
  /**
   * Gets the direction output component
   */
  get intensity() {
    return this._outputs[2];
  }
  /**
   * Gets the shadow bias output component
   */
  get shadowBias() {
    return this._outputs[3];
  }
  /**
   * Gets the shadow normal bias output component
   */
  get shadowNormalBias() {
    return this._outputs[4];
  }
  /**
   * Gets the shadow depth scale component
   */
  get shadowDepthScale() {
    return this._outputs[5];
  }
  /**
   * Gets the shadow depth range component
   */
  get shadowDepthRange() {
    return this._outputs[6];
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (this.light && this.light.isDisposed()) {
      this.light = null;
    }
    let light = this.light;
    const scene = nodeMaterial.getScene();
    if (!light && scene.lights.length) {
      light = this.light = scene.lights[0];
      this._forcePrepareDefines = true;
    }
    if (!light || !light.isEnabled) {
      effect.setFloat3(this._lightDataUniformName, 0, 0, 0);
      effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);
      return;
    }
    light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);
    effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);
    const generator = light.getShadowGenerator();
    if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {
      if (generator) {
        effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);
      } else {
        effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);
      }
    }
    if (this.shadowDepthRange) {
      if (generator && scene.activeCamera) {
        const shadowLight = light;
        effect.setFloat2(this._lightShadowExtraUniformName, shadowLight.getDepthMinZ(scene.activeCamera), shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera));
      } else {
        effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);
      }
    }
  }
  prepareDefines(defines) {
    if (!defines._areLightsDirty && !this._forcePrepareDefines) {
      return;
    }
    this._forcePrepareDefines = false;
    const light = this.light;
    defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    const direction = this.direction;
    const color = this.color;
    const intensity = this.intensity;
    const shadowBias = this.shadowBias;
    const shadowNormalBias = this.shadowNormalBias;
    const shadowDepthScale = this.shadowDepthScale;
    const shadowDepthRange = this.shadowDepthRange;
    this._lightDataUniformName = state._getFreeVariableName("lightData");
    this._lightColorUniformName = state._getFreeVariableName("lightColor");
    this._lightShadowUniformName = state._getFreeVariableName("shadowData");
    this._lightShadowExtraUniformName = state._getFreeVariableName("shadowExtraData");
    this._lightTypeDefineName = state._getFreeDefineName("LIGHTPOINTTYPE");
    const uniformAdd = state.shaderLanguage === 1 ? "uniforms." : "";
    state._emitUniformFromString(this._lightDataUniformName, NodeMaterialBlockConnectionPointTypes.Vector3);
    state._emitUniformFromString(this._lightColorUniformName, NodeMaterialBlockConnectionPointTypes.Vector4);
    state.compilationString += `#ifdef ${this._lightTypeDefineName}
`;
    state.compilationString += state._declareOutput(direction) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${uniformAdd}${this._lightDataUniformName});
`;
    state.compilationString += `#else
`;
    state.compilationString += state._declareOutput(direction) + ` = ${uniformAdd}${this._lightDataUniformName};
`;
    state.compilationString += `#endif
`;
    state.compilationString += state._declareOutput(color) + ` = ${uniformAdd}${this._lightColorUniformName}.rgb;
`;
    state.compilationString += state._declareOutput(intensity) + ` = ${uniformAdd}${this._lightColorUniformName}.a;
`;
    if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {
      state._emitUniformFromString(this._lightShadowUniformName, NodeMaterialBlockConnectionPointTypes.Vector3);
      if (shadowBias.hasEndpoints) {
        state.compilationString += state._declareOutput(shadowBias) + ` = ${uniformAdd}${this._lightShadowUniformName}.x;
`;
      }
      if (shadowNormalBias.hasEndpoints) {
        state.compilationString += state._declareOutput(shadowNormalBias) + ` = ${uniformAdd}${this._lightShadowUniformName}.y;
`;
      }
      if (shadowDepthScale.hasEndpoints) {
        state.compilationString += state._declareOutput(shadowDepthScale) + ` = ${uniformAdd}${this._lightShadowUniformName}.z;
`;
      }
    }
    if (shadowDepthRange.hasEndpoints) {
      state._emitUniformFromString(this._lightShadowExtraUniformName, NodeMaterialBlockConnectionPointTypes.Vector2);
      state.compilationString += state._declareOutput(shadowDepthRange) + ` = ${this._lightShadowUniformName};
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
  }
};
RegisterClass("BABYLON.LightInformationBlock", LightInformationBlock);

// node_modules/@babylonjs/core/Decorators/nodeDecorator.js
var PropertyTypeForEdition;
(function(PropertyTypeForEdition2) {
  PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Vector3"] = 4] = "Vector3";
  PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 5] = "List";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Color3"] = 6] = "Color3";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Color4"] = 7] = "Color4";
  PropertyTypeForEdition2[PropertyTypeForEdition2["SamplingMode"] = 8] = "SamplingMode";
  PropertyTypeForEdition2[PropertyTypeForEdition2["TextureFormat"] = 9] = "TextureFormat";
  PropertyTypeForEdition2[PropertyTypeForEdition2["TextureType"] = 10] = "TextureType";
  PropertyTypeForEdition2[PropertyTypeForEdition2["String"] = 11] = "String";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Matrix"] = 12] = "Matrix";
  PropertyTypeForEdition2[PropertyTypeForEdition2["Viewport"] = 13] = "Viewport";
})(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
function editableInPropertyPage(displayName, propertyType = 0, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options ?? {},
      className: target.getClassName()
    });
  };
}

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlockColorSpace;
(function(FragmentOutputBlockColorSpace2) {
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["NoColorSpace"] = 0] = "NoColorSpace";
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Gamma"] = 1] = "Gamma";
  FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Linear"] = 2] = "Linear";
})(FragmentOutputBlockColorSpace || (FragmentOutputBlockColorSpace = {}));
var FragmentOutputBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FragmentOutputBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true, true);
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this.useLogarithmicDepth = false;
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("glow", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets or sets the color space used for the block
   */
  get colorSpace() {
    if (this.convertToGammaSpace) {
      return FragmentOutputBlockColorSpace.Gamma;
    }
    if (this.convertToLinearSpace) {
      return FragmentOutputBlockColorSpace.Linear;
    }
    return FragmentOutputBlockColorSpace.NoColorSpace;
  }
  set colorSpace(value) {
    this.convertToGammaSpace = value === FragmentOutputBlockColorSpace.Gamma;
    this.convertToLinearSpace = value === FragmentOutputBlockColorSpace.Linear;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FragmentOutputBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("logarithmicDepthConstant");
    state._excludeVariableName("vFragmentDepth");
  }
  /**
   * Gets the rgba input component
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb input component
   */
  get rgb() {
    return this._inputs[1];
  }
  /**
   * Gets the a input component
   */
  get a() {
    return this._inputs[2];
  }
  /**
   * Gets the additionalColor input component (named glow in the UI for now)
   */
  get additionalColor() {
    return this._inputs[3];
  }
  /**
   * Gets the glow input component
   */
  get glow() {
    return this._inputs[3];
  }
  _getOutputString(state) {
    return state.shaderLanguage === 1 ? "fragmentOutputsColor" : "gl_FragColor";
  }
  prepareDefines(defines, nodeMaterial) {
    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._additionalColorDefineName, this.additionalColor.connectedPoint && nodeMaterial._useAdditionalColor, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {
      BindLogDepth(void 0, effect, mesh.getScene());
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rgba = this.rgba;
    const rgb = this.rgb;
    const a = this.a;
    const additionalColor = this.additionalColor;
    const isWebGPU = state.shaderLanguage === 1;
    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
    state.sharedData.blocksWithDefines.push(this);
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
      state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
      state.sharedData.bindableBlocks.push(this);
    }
    if (additionalColor.connectedPoint) {
      state._excludeVariableName("useAdditionalColor");
      state._emitUniformFromString("useAdditionalColor", NodeMaterialBlockConnectionPointTypes.Float);
      this._additionalColorDefineName = state._getFreeDefineName("USEADDITIONALCOLOR");
    }
    this._linearDefineName = state._getFreeDefineName("CONVERTTOLINEAR");
    this._gammaDefineName = state._getFreeDefineName("CONVERTTOGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    const outputString = this._getOutputString(state);
    if (state.shaderLanguage === 1) {
      state.compilationString += `var ${outputString} : vec4<f32>;\r
`;
    }
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    if (additionalColor.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      state.compilationString += `#ifdef ${this._additionalColorDefineName}
`;
      if (additionalColor.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${aValue});
`;
      } else {
        state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${aValue});
`;
      }
      state.compilationString += `#else
`;
    }
    if (rgba.connectedPoint) {
      if (a.isConnected) {
        state.compilationString += `${outputString} = ${vec4}(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});
`;
      } else {
        state.compilationString += `${outputString}  = ${rgba.associatedVariableName};
`;
      }
    } else if (rgb.connectedPoint) {
      let aValue = "1.0";
      if (a.connectedPoint) {
        aValue = a.associatedVariableName;
      }
      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
        state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});
`;
      } else {
        state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${aValue});
`;
      }
    } else {
      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
    }
    if (additionalColor.connectedPoint) {
      state.compilationString += `#endif
`;
    }
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${outputString}  = toLinearSpace(${outputString});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${outputString}  = toGammaSpace(${outputString});
`;
    state.compilationString += `#endif
`;
    if (state.shaderLanguage === 1) {
      state.compilationString += `#if !defined(PREPASS)\r
`;
      state.compilationString += `fragmentOutputs.color = ${outputString};\r
`;
      state.compilationString += `#endif\r
`;
    }
    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
      const fragDepth = isWebGPU ? "input.vFragmentDepth" : "vFragmentDepth";
      const uniformP = isWebGPU ? "uniforms." : "";
      const output = isWebGPU ? "fragmentOutputs.fragDepth" : "gl_FragDepthEXT";
      state.compilationString += `${output} = log2(${fragDepth}) * ${uniformP}logarithmicDepthConstant * 0.5;
`;
    }
    state.compilationString += `#if defined(PREPASS)\r
`;
    state.compilationString += `${isWebGPU ? "fragmentOutputs.fragData0" : "gl_FragData[0]"} = ${outputString};\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;
  }
};
__decorate([
  editableInPropertyPage("Use logarithmic depth", 0, "PROPERTIES", { embedded: true })
], FragmentOutputBlock.prototype, "useLogarithmicDepth", void 0);
__decorate([
  editableInPropertyPage("Color space", 5, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "No color space", value: FragmentOutputBlockColorSpace.NoColorSpace },
      { label: "Gamma", value: FragmentOutputBlockColorSpace.Gamma },
      { label: "Linear", value: FragmentOutputBlockColorSpace.Linear }
    ]
  })
], FragmentOutputBlock.prototype, "colorSpace", null);
RegisterClass("BABYLON.FragmentOutputBlock", FragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
(function(NodeMaterialModes2) {
  NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
  NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
  NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
  NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
  NodeMaterialModes2[NodeMaterialModes2["GaussianSplatting"] = 4] = "GaussianSplatting";
  NodeMaterialModes2[NodeMaterialModes2["SFE"] = 5] = "SFE";
})(NodeMaterialModes || (NodeMaterialModes = {}));

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js
var ScreenSizeBlock = class extends NodeMaterialBlock {
  /**
   * Name of the variable in the shader that holds the screen size
   */
  get associatedVariableName() {
    return this._varName;
  }
  /**
   * Creates a new ScreenSizeBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ScreenSizeBlock";
  }
  /**
   * Gets the xy component
   */
  get xy() {
    return this._outputs[0];
  }
  /**
   * Gets the x component
   */
  get x() {
    return this._outputs[1];
  }
  /**
   * Gets the y component
   */
  get y() {
    return this._outputs[2];
  }
  bind(effect) {
    const engine = this._scene.getEngine();
    effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  writeOutputs(state, varName) {
    let code = "";
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        code += `${state._declareOutput(output)} = ${varName}.${output.name};
`;
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      state.sharedData.raiseBuildError("ScreenSizeBlock must only be used in a fragment shader");
      return this;
    }
    state.sharedData.bindableBlocks.push(this);
    this._varName = state._getFreeVariableName("screenSize");
    state._emitUniformFromString(this._varName, NodeMaterialBlockConnectionPointTypes.Vector2);
    const prefix = state.shaderLanguage === 1 ? "uniforms." : "";
    state.compilationString += this.writeOutputs(state, prefix + this._varName);
    return this;
  }
};
RegisterClass("BABYLON.ScreenSizeBlock", ScreenSizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.js
var SfeModeDefine = "USE_SFE_FRAMEWORK";
var SmartFilterFragmentOutputBlock = class extends FragmentOutputBlock {
  /**
   * Create a new SmartFilterFragmentOutputBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SmartFilterFragmentOutputBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    super.initialize(state);
    if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {
      state.sharedData.raiseBuildError("SmartFilterFragmentOutputBlock should not be used outside of SFE mode.");
    }
    if (state.sharedData.nodeMaterial.shaderLanguage !== 0) {
      state.sharedData.raiseBuildError("WebGPU is not supported in SmartFilters mode.");
    }
    if (!state.sharedData.formatConfig.getUniformAnnotation) {
      state.sharedData.formatConfig.getUniformAnnotation = (name6) => {
        for (const block of state.sharedData.nodeMaterial.attachedBlocks) {
          if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name6) {
            return this._generateInputBlockAnnotation(block);
          }
          if (block instanceof ScreenSizeBlock && block.associatedVariableName === name6) {
            return this._generateScreenSizeBlockAnnotation();
          }
        }
        return "";
      };
    }
    state.sharedData.formatConfig.formatVariablename = (n) => {
      let name6 = n;
      const hasUnderscoredPrefix = name6.length > 1 && name6[1] === "_";
      if (hasUnderscoredPrefix) {
        name6 = name6.substring(2);
      }
      return name6.replace(/[^a-zA-Z]+/g, "");
    };
  }
  _generateInputBlockAnnotation(inputBlock) {
    const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;
    return `// { "default": ${JSON.stringify(value)} }
`;
  }
  _generateScreenSizeBlockAnnotation() {
    return `// { "autoBind": "outputResolution" }
`;
  }
  _getMainUvName(state) {
    const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === "postprocess_uv");
    if (!screenUv || !screenUv.isAnAncestorOf(this)) {
      return "";
    }
    return screenUv.associatedVariableName;
  }
  _getOutputString() {
    return "outColor";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const outputString = this._getOutputString();
    state._customEntryHeader += `#ifdef ${SfeModeDefine}
`;
    state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main
`;
    state._customEntryHeader += `#else
`;
    state._customEntryHeader += `void main(void) {
`;
    state._customEntryHeader += `#endif
`;
    state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);
`;
    state.compilationString += `
#ifndef ${SfeModeDefine}
`;
    state.compilationString += `gl_FragColor = ${outputString};
`;
    state.compilationString += `#else
`;
    state.compilationString += `return ${outputString};
`;
    state.compilationString += `#endif
`;
    return this;
  }
};
RegisterClass("BABYLON.SmartFilterFragmentOutputBlock", SmartFilterFragmentOutputBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/imageProcessingBlock.js
var ImageProcessingBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ImageProcessingBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.convertInputToLinearSpace = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color4);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ImageProcessingBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("exposureLinear");
    state._excludeVariableName("contrast");
    state._excludeVariableName("vInverseScreenSize");
    state._excludeVariableName("vignetteSettings1");
    state._excludeVariableName("vignetteSettings2");
    state._excludeVariableName("vCameraColorCurveNegative");
    state._excludeVariableName("vCameraColorCurveNeutral");
    state._excludeVariableName("vCameraColorCurvePositive");
    state._excludeVariableName("txColorTransform");
    state._excludeVariableName("colorTransformSettings");
    state._excludeVariableName("ditherIntensity");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./helperFunctions-MOSZRSGX.js"),
        import("./imageProcessingDeclaration-XB3NANIR.js"),
        import("./imageProcessingFunctions-MIXEEG4T.js")
      ]);
    } else {
      await Promise.all([
        import("./helperFunctions-CPXXYXMJ.js"),
        import("./imageProcessingDeclaration-722TOVCC.js"),
        import("./imageProcessingFunctions-PMUL2F24.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  isReady(mesh, nodeMaterial, defines) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    return true;
  }
  prepareDefines(defines, nodeMaterial) {
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (!nodeMaterial.imageProcessingConfiguration) {
      return;
    }
    nodeMaterial.imageProcessingConfiguration.bind(effect);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.bindableBlocks.push(this);
    state.uniforms.push("exposureLinear");
    state.uniforms.push("contrast");
    state.uniforms.push("vInverseScreenSize");
    state.uniforms.push("vignetteSettings1");
    state.uniforms.push("vignetteSettings2");
    state.uniforms.push("vCameraColorCurveNegative");
    state.uniforms.push("vCameraColorCurveNeutral");
    state.uniforms.push("vCameraColorCurvePositive");
    state.uniforms.push("txColorTransform");
    state.uniforms.push("colorTransformSettings");
    state.uniforms.push("ditherIntensity");
    const color = this.color;
    const output = this._outputs[0];
    const comments = `//${this.name}`;
    const overrideText = state.shaderLanguage === 1 ? "Vec3" : "";
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingDeclaration", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    if (color.connectedPoint?.isConnected) {
      if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
        state.compilationString += `${state._declareOutput(output)} = ${color.associatedVariableName};
`;
      } else {
        state.compilationString += `${state._declareOutput(output)} = vec4${state.fSuffix}(${color.associatedVariableName}, 1.0);
`;
      }
      state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS
`;
      if (this.convertInputToLinearSpace) {
        state.compilationString += `${output.associatedVariableName} = vec4${state.fSuffix}(toLinearSpace${overrideText}(${color.associatedVariableName}.rgb), ${color.associatedVariableName}.a);
`;
      }
      state.compilationString += `#else
`;
      state.compilationString += `#ifdef IMAGEPROCESSING
`;
      if (this.convertInputToLinearSpace) {
        state.compilationString += `${output.associatedVariableName} = vec4${state.fSuffix}(toLinearSpace${overrideText}(${color.associatedVariableName}.rgb), ${color.associatedVariableName}.a);
`;
      }
      state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});
`;
      state.compilationString += `#endif
`;
      state.compilationString += `#endif
`;
      if (this.rgb.hasEndpoints) {
        state.compilationString += state._declareOutput(this.rgb) + ` = ${this.output.associatedVariableName}.xyz;
`;
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertInputToLinearSpace = serializationObject.convertInputToLinearSpace ?? true;
  }
};
__decorate([
  editableInPropertyPage("Convert input to linear space", 0, "ADVANCED")
], ImageProcessingBlock.prototype, "convertInputToLinearSpace", void 0);
RegisterClass("BABYLON.ImageProcessingBlock", ImageProcessingBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialConnectionPointCustomObject.js
var NodeMaterialConnectionPointCustomObject = class _NodeMaterialConnectionPointCustomObject extends NodeMaterialConnectionPoint {
  /**
   * Creates a new connection point
   * @param name defines the connection point name
   * @param ownerBlock defines the block hosting this connection point
   * @param direction defines the direction of the connection point
   * @param _blockType
   * @param _blockName
   */
  constructor(name6, ownerBlock, direction, _blockType, _blockName) {
    super(name6, ownerBlock, direction);
    this._blockType = _blockType;
    this._blockName = _blockName;
    this.needDualDirectionValidation = true;
  }
  /**
   * Gets a number indicating if the current point can be connected to another point
   * @param connectionPoint defines the other connection point
   * @returns a number defining the compatibility state
   */
  checkCompatibilityState(connectionPoint) {
    return connectionPoint instanceof _NodeMaterialConnectionPointCustomObject && connectionPoint._blockName === this._blockName ? 0 : 1;
  }
  /**
   * Creates a block suitable to be used as an input for this input point.
   * If null is returned, a block based on the point type will be created.
   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
   */
  createCustomInputBlock() {
    return [new this._blockType(this._blockName), this.name];
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/TBNBlock.js
var TBNBlock = class _TBNBlock extends NodeMaterialBlock {
  /**
   * Create a new TBNBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.normal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerOutput("TBN", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("TBN", this, 1, _TBNBlock, "TBNBlock"));
    this.registerOutput("row0", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("row1", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("row2", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TBNBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("tbnNormal");
    state._excludeVariableName("tbnTangent");
    state._excludeVariableName("tbnBitangent");
    state._excludeVariableName("TBN");
  }
  /**
   * Gets the normal input component
   */
  get normal() {
    return this._inputs[0];
  }
  /**
   * Gets the tangent input component
   */
  get tangent() {
    return this._inputs[1];
  }
  /**
   * Gets the world matrix input component
   */
  get world() {
    return this._inputs[2];
  }
  /**
   * Gets the TBN output component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get TBN() {
    return this._outputs[0];
  }
  /**
   * Gets the row0 of the output matrix
   */
  get row0() {
    return this._outputs[1];
  }
  /**
   * Gets the row1 of the output matrix
   */
  get row1() {
    return this._outputs[2];
  }
  /**
   * Gets the row2 of the output matrix
   */
  get row2() {
    return this._outputs[3];
  }
  get target() {
    return NodeMaterialBlockTargets.Fragment;
  }
  set target(value) {
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    if (!this.normal.isConnected) {
      let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "normal" && additionalFilteringInfo(b));
      if (!normalInput) {
        normalInput = new InputBlock("normal");
        normalInput.setAsAttribute("normal");
      }
      normalInput.output.connectTo(this.normal);
    }
    if (!this.tangent.isConnected) {
      let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "tangent" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4 && additionalFilteringInfo(b));
      if (!tangentInput) {
        tangentInput = new InputBlock("tangent");
        tangentInput.setAsAttribute("tangent");
      }
      tangentInput.output.connectTo(this.tangent);
    }
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const normal = this.normal;
    const tangent = this.tangent;
    let normalAvailable = normal.isConnected;
    if (normal.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(normal.connectInputBlock?.name)) {
      normalAvailable = false;
    }
    let tangentAvailable = tangent.isConnected;
    if (tangent.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(tangent.connectInputBlock?.name)) {
      tangentAvailable = false;
    }
    const useTBNBlock = normalAvailable && tangentAvailable;
    defines.setValue("TBNBLOCK", useTBNBlock, true);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const normal = this.normal;
    const tangent = this.tangent;
    const world = this.world;
    const tbn = this.TBN;
    const row0 = this.row0;
    const row1 = this.row1;
    const row2 = this.row2;
    const isWebGPU = state.shaderLanguage === 1;
    const mat3 = isWebGPU ? "mat3x3f" : "mat3";
    const fSuffix = isWebGPU ? "f" : "";
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `
                // ${this.name}
                ${state._declareLocalVar("tbnNormal", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${normal.associatedVariableName}).xyz;
                ${state._declareLocalVar("tbnTangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${tangent.associatedVariableName}.xyz);
                ${state._declareLocalVar("tbnBitangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;
                ${isWebGPU ? "var" : "mat3"} ${tbn.associatedVariableName} = ${mat3}(${world.associatedVariableName}[0].xyz, ${world.associatedVariableName}[1].xyz, ${world.associatedVariableName}[2].xyz) * ${mat3}(tbnTangent, tbnBitangent, tbnNormal);
            `;
      if (row0.hasEndpoints) {
        state.compilationString += state._declareOutput(row0) + ` = vec3${fSuffix}(${tbn.associatedVariableName}[0][0], ${tbn.associatedVariableName}[0][1], ${tbn.associatedVariableName}[0][2]);
`;
      }
      if (row1.hasEndpoints) {
        state.compilationString += state._declareOutput(row1) + ` = vec3${fSuffix}(${tbn.associatedVariableName}[1[0], ${tbn.associatedVariableName}[1][1], ${tbn.associatedVariableName}[1][2]);
`;
      }
      if (row2.hasEndpoints) {
        state.compilationString += state._declareOutput(row2) + ` = vec3${fSuffix}(${tbn.associatedVariableName}[2][0], ${tbn.associatedVariableName}[2][1], ${tbn.associatedVariableName}[2][2]);
`;
      }
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
};
RegisterClass("BABYLON.TBNBlock", TBNBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/perturbNormalBlock.js
var PerturbNormalBlock = class extends NodeMaterialBlock {
  /**
   * Create a new PerturbNormalBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._tangentSpaceParameterName = "";
    this._tangentCorrectionFactorName = "";
    this._worldMatrixName = "";
    this.invertX = false;
    this.invertY = false;
    this.useParallaxOcclusion = false;
    this.useObjectSpaceNormalMap = false;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false);
    this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, false);
    this.registerInput("strength", NodeMaterialBlockConnectionPointTypes.Float, false);
    this.registerInput("viewDirection", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("parallaxScale", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("parallaxHeight", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, 0, TBNBlock, "TBNBlock"));
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("uvOffset", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PerturbNormalBlock";
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[1];
  }
  /**
   * Gets the world tangent input component
   */
  get worldTangent() {
    return this._inputs[2];
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[3];
  }
  /**
   * Gets the normal map color input component
   */
  get normalMapColor() {
    return this._inputs[4];
  }
  /**
   * Gets the strength input component
   */
  get strength() {
    return this._inputs[5];
  }
  /**
   * Gets the view direction input component
   */
  get viewDirection() {
    return this._inputs[6];
  }
  /**
   * Gets the parallax scale input component
   */
  get parallaxScale() {
    return this._inputs[7];
  }
  /**
   * Gets the parallax height input component
   */
  get parallaxHeight() {
    return this._inputs[8];
  }
  /**
   * Gets the TBN input component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get TBN() {
    return this._inputs[9];
  }
  /**
   * Gets the World input component
   */
  get world() {
    return this._inputs[10];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the uv offset output component
   */
  get uvOffset() {
    return this._outputs[1];
  }
  initialize(state) {
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./bumpFragment-XVLI665C.js"),
        import("./bumpFragmentMainFunctions-3SEYL5ZC.js"),
        import("./bumpFragmentFunctions-IONHPDY2.js")
      ]);
    } else {
      await Promise.all([
        import("./bumpFragment-B5SBRADG.js"),
        import("./bumpFragmentMainFunctions-DFYU6NWC.js"),
        import("./bumpFragmentFunctions-URHVHFBG.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  prepareDefines(defines, nodeMaterial) {
    const normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;
    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && !!normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);
    defines.setValue("BUMP", true);
    defines.setValue("PARALLAX", useParallax, true);
    defines.setValue("PARALLAX_RHS", nodeMaterial.getScene().useRightHandedSystem, true);
    defines.setValue("PARALLAXOCCLUSION", this.useParallaxOcclusion, true);
    defines.setValue("OBJECTSPACE_NORMALMAP", this.useObjectSpaceNormalMap, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if (nodeMaterial.getScene()._mirroredCameraPosition) {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1 : -1, this.invertY ? 1 : -1);
    } else {
      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1 : 1, this.invertY ? -1 : 1);
    }
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
      if (this.useObjectSpaceNormalMap && !this.world.isConnected) {
        effect.setMatrix(this._worldMatrixName, mesh.getWorldMatrix());
      }
    }
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute();
      }
      uvInput.output.connectTo(this.uv);
    }
    if (!this.strength.isConnected) {
      const strengthInput = new InputBlock("strength");
      strengthInput.value = 1;
      strengthInput.output.connectTo(this.strength);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    const uv = this.uv;
    const worldPosition = this.worldPosition;
    const worldNormal = this.worldNormal;
    const worldTangent = this.worldTangent;
    const isWebGPU = state.shaderLanguage === 1;
    const mat3 = isWebGPU ? "mat3x3f" : "mat3";
    const fSuffix = isWebGPU ? "f" : "";
    const uniformPrefix = isWebGPU ? "uniforms." : "";
    const fragmentInputsPrefix = isWebGPU ? "fragmentInputs." : "";
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._tangentSpaceParameterName = state._getFreeDefineName("tangentSpaceParameter");
    state._emitUniformFromString(this._tangentSpaceParameterName, NodeMaterialBlockConnectionPointTypes.Vector2);
    this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
    state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);
    this._worldMatrixName = state._getFreeDefineName("perturbNormalWorldMatrix");
    state._emitUniformFromString(this._worldMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);
    let normalSamplerName = null;
    if (this.normalMapColor.connectedPoint) {
      normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;
    }
    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && !!normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);
    const replaceForParallaxInfos = !this.parallaxScale.isConnectedToInputBlock ? "0.05" : this.parallaxScale.connectInputBlock.isConstant ? state._emitFloat(this.parallaxScale.connectInputBlock.value) : this.parallaxScale.associatedVariableName;
    const replaceForBumpInfos = this.strength.isConnectedToInputBlock && this.strength.connectInputBlock.isConstant ? `
#if !defined(NORMALXYSCALE)
1.0/
#endif
${state._emitFloat(this.strength.connectInputBlock.value)}` : `
#if !defined(NORMALXYSCALE)
1.0/
#endif
${this.strength.associatedVariableName}`;
    if (!isWebGPU) {
      state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    }
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const tbnVarying = { search: /varying mat3 vTBN;/g, replace: "" };
    const normalMatrixReplaceString = { search: isWebGPU ? /uniform normalMatrix: mat4x4f;/g : /uniform mat4 normalMatrix;/g, replace: "" };
    const tbn = this.TBN;
    if (tbn.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
            ${isWebGPU ? "var" : "mat3"} vTBN = ${tbn.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      state.compilationString += `${state._declareLocalVar("tbnNormal", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormal.associatedVariableName}.xyz);
`;
      state.compilationString += `${state._declareLocalVar("tbnTangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);
`;
      state.compilationString += `${state._declareLocalVar("tbnBitangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${uniformPrefix}${this._tangentCorrectionFactorName};
`;
      state.compilationString += `${isWebGPU ? "var" : "mat3"} vTBN = ${mat3}(tbnTangent, tbnBitangent, tbnNormal);
`;
    }
    let replaceStrings = [tangentReplaceString, tbnVarying, normalMatrixReplaceString];
    if (isWebGPU) {
      replaceStrings.push({ search: /varying vTBN0: vec3f;/g, replace: "" });
      replaceStrings.push({ search: /varying vTBN1: vec3f;/g, replace: "" });
      replaceStrings.push({ search: /varying vTBN2: vec3f;/g, replace: "" });
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings
    });
    const replaceString0 = isWebGPU ? "fn parallaxOcclusion(vViewDirCoT: vec3f, vNormalCoT: vec3f, texCoord: vec2f, parallaxScale:f32, bumpSampler: texture_2d<f32>, bumpSamplerSampler: sampler)" : "#define inline\nvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)";
    const searchExp0 = isWebGPU ? /fn parallaxOcclusion\(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32\)/g : /vec2 parallaxOcclusion\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\)/g;
    const replaceString1 = isWebGPU ? "fn parallaxOffset(viewDir: vec3f, heightScale: f32, height_: f32)" : "vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)";
    const searchExp1 = isWebGPU ? /fn parallaxOffset\(viewDir: vec3f,heightScale: f32\)/g : /vec2 parallaxOffset\(vec3 viewDir,float heightScale\)/g;
    state._emitFunctionFromInclude("bumpFragmentFunctions", comments, {
      replaceStrings: [
        { search: /#include<samplerFragmentDeclaration>\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\)/g, replace: "" },
        { search: /uniform sampler2D bumpSampler;/g, replace: "" },
        {
          search: searchExp0,
          replace: replaceString0
        },
        { search: searchExp1, replace: replaceString1 },
        { search: /texture.+?bumpSampler,.*?vBumpUV\)\.w/g, replace: "height_" }
      ]
    });
    const normalRead = isWebGPU ? `textureSample(${normalSamplerName}, ${normalSamplerName + `Sampler`}` : `texture2D(${normalSamplerName}`;
    const uvForPerturbNormal = !useParallax || !normalSamplerName ? this.normalMapColor.associatedVariableName : `${normalRead}, ${uv.associatedVariableName} + uvOffset).xyz`;
    const tempOutput = state._getFreeVariableName("tempOutput");
    state.compilationString += state._declareLocalVar(tempOutput, NodeMaterialBlockConnectionPointTypes.Vector3) + ` = vec3${fSuffix}(0.);
`;
    replaceStrings = [
      { search: new RegExp(`texture.+?bumpSampler${isWebGPU ? "Sampler,fragmentInputs." : ","}vBumpUV\\)`, "g"), replace: `${uvForPerturbNormal}` },
      {
        search: /#define CUSTOM_FRAGMENT_BUMP_FRAGMENT/g,
        replace: `${state._declareLocalVar("normalMatrix", NodeMaterialBlockConnectionPointTypes.Matrix)} = toNormalMatrix(${this.world.isConnected ? this.world.associatedVariableName : uniformPrefix + this._worldMatrixName});`
      },
      {
        search: new RegExp(`perturbNormal\\(TBN,texture.+?bumpSampler${isWebGPU ? "Sampler,fragmentInputs." : ","}vBumpUV\\+uvOffset\\).xyz,${uniformPrefix}vBumpInfos.y\\)`, "g"),
        replace: `perturbNormal(TBN, ${uvForPerturbNormal}, ${uniformPrefix}vBumpInfos.y)`
      },
      {
        search: /parallaxOcclusion\(invTBN\*-viewDirectionW,invTBN\*normalW,(fragmentInputs\.)?vBumpUV,(uniforms\.)?vBumpInfos.z\)/g,
        replace: `parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), ${fragmentInputsPrefix}vBumpUV, ${uniformPrefix}vBumpInfos.z, ${isWebGPU ? useParallax && this.useParallaxOcclusion ? `${normalSamplerName}, ${normalSamplerName + `Sampler`}` : "bump, bumpSampler" : useParallax && this.useParallaxOcclusion ? normalSamplerName : "bumpSampler"})`
      },
      {
        search: /parallaxOffset\(invTBN\*viewDirectionW,vBumpInfos\.z\)/g,
        replace: `parallaxOffset(invTBN * viewDirectionW, ${uniformPrefix}vBumpInfos.z, ${useParallax ? this.parallaxHeight.associatedVariableName : "0."})`
      },
      { search: isWebGPU ? /uniforms.vBumpInfos.y/g : /vBumpInfos.y/g, replace: replaceForBumpInfos },
      { search: isWebGPU ? /uniforms.vBumpInfos.z/g : /vBumpInfos.z/g, replace: replaceForParallaxInfos },
      { search: /normalW=/g, replace: tempOutput + " = " },
      isWebGPU ? {
        search: /mat3x3f\(uniforms\.normalMatrix\[0\].xyz,uniforms\.normalMatrix\[1\]\.xyz,uniforms\.normalMatrix\[2\].xyz\)\*normalW/g,
        replace: `${mat3}(normalMatrix[0].xyz, normalMatrix[1].xyz, normalMatrix[2].xyz) * ` + tempOutput
      } : {
        search: /mat3\(normalMatrix\)\*normalW/g,
        replace: `${mat3}(normalMatrix) * ` + tempOutput
      },
      { search: /normalW/g, replace: worldNormal.associatedVariableName + ".xyz" },
      { search: /viewDirectionW/g, replace: useParallax ? this.viewDirection.associatedVariableName : `vec3${fSuffix}(0.)` },
      tangentReplaceString
    ];
    if (isWebGPU) {
      replaceStrings.push({ search: /fragmentInputs.vBumpUV/g, replace: uv.associatedVariableName });
      replaceStrings.push({ search: /input.vPositionW/g, replace: worldPosition.associatedVariableName + ".xyz" });
      replaceStrings.push({ search: /uniforms.vTangentSpaceParams/g, replace: uniformPrefix + this._tangentSpaceParameterName });
      replaceStrings.push({ search: /var TBN: mat3x3f=mat3x3<f32>\(input.vTBN0,input.vTBN1,input.vTBN2\);/g, replace: `var TBN = vTBN;` });
    } else {
      replaceStrings.push({ search: /vBumpUV/g, replace: uv.associatedVariableName });
      replaceStrings.push({ search: /vPositionW/g, replace: worldPosition.associatedVariableName + ".xyz" });
      replaceStrings.push({ search: /vTangentSpaceParams/g, replace: uniformPrefix + this._tangentSpaceParameterName });
    }
    state.compilationString += state._emitCodeFromInclude("bumpFragment", comments, {
      replaceStrings
    });
    state.compilationString += state._declareOutput(this.output) + ` = vec4${fSuffix}(${tempOutput}, 0.);
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.invertX = ${this.invertX};
`;
    codeString += `${this._codeVariableName}.invertY = ${this.invertY};
`;
    codeString += `${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};
`;
    codeString += `${this._codeVariableName}.useObjectSpaceNormalMap = ${this.useObjectSpaceNormalMap};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.invertX = this.invertX;
    serializationObject.invertY = this.invertY;
    serializationObject.useParallaxOcclusion = this.useParallaxOcclusion;
    serializationObject.useObjectSpaceNormalMap = this.useObjectSpaceNormalMap;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.invertX = serializationObject.invertX;
    this.invertY = serializationObject.invertY;
    this.useParallaxOcclusion = !!serializationObject.useParallaxOcclusion;
    this.useObjectSpaceNormalMap = !!serializationObject.useObjectSpaceNormalMap;
    this.parallaxScale._isInactive = this.useParallaxOcclusion;
    this.parallaxHeight._isInactive = this.useParallaxOcclusion;
  }
};
__decorate([
  editableInPropertyPage("Invert X axis", 0, "PROPERTIES", { embedded: true, notifiers: { update: true } })
], PerturbNormalBlock.prototype, "invertX", void 0);
__decorate([
  editableInPropertyPage("Invert Y axis", 0, "PROPERTIES", { embedded: true, notifiers: { update: true } })
], PerturbNormalBlock.prototype, "invertY", void 0);
__decorate([
  editableInPropertyPage("Use parallax occlusion", 0, void 0, {
    embedded: true,
    notifiers: {
      update: true,
      callback: (_scene, block) => {
        block.parallaxScale._isInactive = block.useParallaxOcclusion;
        block.parallaxHeight._isInactive = block.useParallaxOcclusion;
        return true;
      }
    }
  })
], PerturbNormalBlock.prototype, "useParallaxOcclusion", void 0);
__decorate([
  editableInPropertyPage("Object Space Mode", 0, "PROPERTIES", { embedded: true, notifiers: { update: true } })
], PerturbNormalBlock.prototype, "useObjectSpaceNormalMap", void 0);
RegisterClass("BABYLON.PerturbNormalBlock", PerturbNormalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/discardBlock.js
var DiscardBlock = class extends NodeMaterialBlock {
  /**
   * Create a new DiscardBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("cutoff", NodeMaterialBlockConnectionPointTypes.Float, true);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DiscardBlock";
  }
  /**
   * Gets the color input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the cutoff input component
   */
  get cutoff() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    state.sharedData.hints.needAlphaTesting = true;
    if (!this.cutoff.isConnected || !this.value.isConnected) {
      return;
    }
    state.compilationString += `if (${this.value.associatedVariableName} < ${this.cutoff.associatedVariableName}) { discard; }
`;
    return this;
  }
};
RegisterClass("BABYLON.DiscardBlock", DiscardBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/frontFacingBlock.js
var FrontFacingBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new FrontFacingBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FrontFacingBlock";
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      state.sharedData.raiseBuildError("FrontFacingBlock must only be used in a fragment shader");
      return this;
    }
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary("1.0", "0.0", state.shaderLanguage === 0 ? "gl_FrontFacing" : "fragmentInputs.frontFacing")};
`;
    return this;
  }
};
RegisterClass("BABYLON.FrontFacingBlock", FrontFacingBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/derivativeBlock.js
var DerivativeBlock = class extends NodeMaterialBlock {
  /**
   * Create a new DerivativeBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerOutput("dx", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this.registerOutput("dy", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._outputs[1]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DerivativeBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the derivative output on x
   */
  get dx() {
    return this._outputs[0];
  }
  /**
   * Gets the derivative output on y
   */
  get dy() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const dx = this._outputs[0];
    const dy = this._outputs[1];
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    let dpdx = "dFdx";
    let dpdy = "dFdy";
    if (state.shaderLanguage === 1) {
      dpdx = "dpdx";
      dpdy = "dpdy";
    }
    if (dx.hasEndpoints) {
      state.compilationString += state._declareOutput(dx) + ` = ${dpdx}(${this.input.associatedVariableName});
`;
    }
    if (dy.hasEndpoints) {
      state.compilationString += state._declareOutput(dy) + ` = ${dpdy}(${this.input.associatedVariableName});
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.DerivativeBlock", DerivativeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragCoordBlock.js
var FragCoordBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new FragCoordBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FragCoordBlock";
  }
  /**
   * Gets the xy component
   */
  get xy() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component
   */
  get xyz() {
    return this._outputs[1];
  }
  /**
   * Gets the xyzw component
   */
  get xyzw() {
    return this._outputs[2];
  }
  /**
   * Gets the x component
   */
  get x() {
    return this._outputs[3];
  }
  /**
   * Gets the y component
   */
  get y() {
    return this._outputs[4];
  }
  /**
   * Gets the z component
   */
  get z() {
    return this._outputs[5];
  }
  /**
   * Gets the w component
   */
  get output() {
    return this._outputs[6];
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  writeOutputs(state) {
    let code = "";
    const coord = state.shaderLanguage === 1 ? "fragmentInputs.position" : "gl_FragCoord";
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        code += `${state._declareOutput(output)} = ${coord}.${output.name};
`;
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      state.sharedData.raiseBuildError("FragCoordBlock must only be used in a fragment shader");
      return this;
    }
    state.compilationString += this.writeOutputs(state);
    return this;
  }
};
RegisterClass("BABYLON.FragCoordBlock", FragCoordBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSpaceBlock.js
var ScreenSpaceBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ScreenSpaceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("worldViewProjection", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ScreenSpaceBlock";
  }
  /**
   * Gets the vector input
   */
  get vector() {
    return this._inputs[0];
  }
  /**
   * Gets the worldViewProjection transform input
   */
  get worldViewProjection() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the x output component
   */
  get x() {
    return this._outputs[1];
  }
  /**
   * Gets the y output component
   */
  get y() {
    return this._outputs[2];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.worldViewProjection.isConnected) {
      let worldViewProjectionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.WorldViewProjection && additionalFilteringInfo(b));
      if (!worldViewProjectionInput) {
        worldViewProjectionInput = new InputBlock("worldViewProjection");
        worldViewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.WorldViewProjection);
      }
      worldViewProjectionInput.output.connectTo(this.worldViewProjection);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const worldViewProjection = this.worldViewProjection;
    if (!vector.connectedPoint) {
      return;
    }
    const worldViewProjectionName = worldViewProjection.associatedVariableName;
    const tempVariableName = state._getFreeVariableName("screenSpaceTemp");
    switch (vector.connectedPoint.type) {
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        state.compilationString += `${state._declareLocalVar(tempVariableName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldViewProjectionName} * vec4${state.fSuffix}(${vector.associatedVariableName}, 1.0);
`;
        break;
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        state.compilationString += `${state._declareLocalVar(tempVariableName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldViewProjectionName} * ${vector.associatedVariableName};
`;
        break;
    }
    state.compilationString += `${tempVariableName} = vec4${state.fSuffix}(${tempVariableName}.xy / ${tempVariableName}.w, ${tempVariableName}.zw);`;
    state.compilationString += `${tempVariableName} = vec4${state.fSuffix}(${tempVariableName}.xy * 0.5 + vec2${state.fSuffix}(0.5, 0.5), ${tempVariableName}.zw);`;
    if (this.output.hasEndpoints) {
      state.compilationString += state._declareOutput(this.output) + ` = ${tempVariableName}.xy;
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += state._declareOutput(this.x) + ` = ${tempVariableName}.x;
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += state._declareOutput(this.y) + ` = ${tempVariableName}.y;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ScreenSpaceBlock", ScreenSpaceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/twirlBlock.js
var TwirlBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new TwirlBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("strength", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("center", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("offset", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TwirlBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the strength component
   */
  get strength() {
    return this._inputs[1];
  }
  /**
   * Gets the center component
   */
  get center() {
    return this._inputs[2];
  }
  /**
   * Gets the offset component
   */
  get offset() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the x output component
   */
  get x() {
    return this._outputs[1];
  }
  /**
   * Gets the y output component
   */
  get y() {
    return this._outputs[2];
  }
  autoConfigure() {
    if (!this.center.isConnected) {
      const centerInput = new InputBlock("center");
      centerInput.value = new Vector2(0.5, 0.5);
      centerInput.output.connectTo(this.center);
    }
    if (!this.strength.isConnected) {
      const strengthInput = new InputBlock("strength");
      strengthInput.value = 1;
      strengthInput.output.connectTo(this.strength);
    }
    if (!this.offset.isConnected) {
      const offsetInput = new InputBlock("offset");
      offsetInput.value = new Vector2(0, 0);
      offsetInput.output.connectTo(this.offset);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const tempDelta = state._getFreeVariableName("delta");
    const tempAngle = state._getFreeVariableName("angle");
    const tempX = state._getFreeVariableName("x");
    const tempY = state._getFreeVariableName("y");
    const tempResult = state._getFreeVariableName("result");
    state.compilationString += `        
            ${state._declareLocalVar(tempDelta, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};
            ${state._declareLocalVar(tempAngle, NodeMaterialBlockConnectionPointTypes.Float)} = ${this.strength.associatedVariableName} * length(${tempDelta});
            ${state._declareLocalVar(tempX, NodeMaterialBlockConnectionPointTypes.Float)} = cos(${tempAngle}) * ${tempDelta}.x - sin(${tempAngle}) * ${tempDelta}.y;
            ${state._declareLocalVar(tempY, NodeMaterialBlockConnectionPointTypes.Float)} = sin(${tempAngle}) * ${tempDelta}.x + cos(${tempAngle}) * ${tempDelta}.y;
            ${state._declareLocalVar(tempResult, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2(${tempX} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${tempY} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);
        `;
    if (this.output.hasEndpoints) {
      state.compilationString += state._declareOutput(this.output) + ` = ${tempResult};
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += state._declareOutput(this.x) + ` = ${tempResult}.x;
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += state._declareOutput(this.y) + ` = ${tempResult}.y;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.TwirlBlock", TwirlBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/heightToNormalBlock.js
var HeightToNormalBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new HeightToNormalBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.generateInWorldSpace = false;
    this.automaticNormalizationNormal = true;
    this.automaticNormalizationTangent = true;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "HeightToNormalBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the position component
   */
  get worldPosition() {
    return this._inputs[1];
  }
  /**
   * Gets the normal component
   */
  get worldNormal() {
    return this._inputs[2];
  }
  /**
   * Gets the tangent component
   */
  get worldTangent() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component
   */
  get xyz() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const isWebGPU = state.shaderLanguage === 1;
    const fPrefix = state.fSuffix;
    if (!this.generateInWorldSpace && !this.worldTangent.isConnected) {
      state.sharedData.raiseBuildError(`You must connect the 'worldTangent' input of the ${this.name} block!`);
    }
    const startCode = this.generateInWorldSpace ? "" : `
            vec3 biTangent = cross(norm, tgt);
            mat3 TBN = mat3(tgt, biTangent, norm);
            `;
    const endCode = this.generateInWorldSpace ? "" : `
            result = TBN * result;
            result = result * vec3(0.5) + vec3(0.5);
            `;
    let heightToNormal = `
            vec4 heightToNormal(float height, vec3 position, vec3 tangent, vec3 normal) {
                vec3 tgt = ${this.automaticNormalizationTangent ? "normalize(tangent);" : "tangent;"}
                vec3 norm = ${this.automaticNormalizationNormal ? "normalize(normal);" : "normal;"}
                ${startCode}
                vec3 worlddX = dFdx(position);
                vec3 worlddY = dFdy(position);
                vec3 crossX = cross(norm, worlddX);
                vec3 crossY = cross(worlddY, norm);
                float d = abs(dot(crossY, worlddX));
                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));
                inToNormal.y *= -1.0;
                vec3 result = normalize((d * norm) - inToNormal);
                ${endCode}
                return vec4(result, 0.);
            }`;
    if (isWebGPU) {
      heightToNormal = state._babylonSLtoWGSL(heightToNormal);
    } else {
      state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    }
    state._emitFunction("heightToNormal", heightToNormal, "// heightToNormal");
    state.compilationString += state._declareOutput(output) + ` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${this.worldTangent.isConnected ? this.worldTangent.associatedVariableName : `vec3${fPrefix}(0.)`}.xyz, ${this.worldNormal.associatedVariableName});
`;
    if (this.xyz.hasEndpoints) {
      state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;
`;
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};
`;
    codeString += `${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};
`;
    codeString += `${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.generateInWorldSpace = this.generateInWorldSpace;
    serializationObject.automaticNormalizationNormal = this.automaticNormalizationNormal;
    serializationObject.automaticNormalizationTangent = this.automaticNormalizationTangent;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.generateInWorldSpace = serializationObject.generateInWorldSpace;
    this.automaticNormalizationNormal = serializationObject.automaticNormalizationNormal;
    this.automaticNormalizationTangent = serializationObject.automaticNormalizationTangent;
  }
};
__decorate([
  editableInPropertyPage("Generate in world space instead of tangent space", 0, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "generateInWorldSpace", void 0);
__decorate([
  editableInPropertyPage("Force normalization for the worldNormal input", 0, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "automaticNormalizationNormal", void 0);
__decorate([
  editableInPropertyPage("Force normalization for the worldTangent input", 0, "PROPERTIES", { notifiers: { update: true } })
], HeightToNormalBlock.prototype, "automaticNormalizationTangent", void 0);
RegisterClass("BABYLON.HeightToNormalBlock", HeightToNormalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragDepthBlock.js
var FragDepthBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FragDepthBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("depth", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("worldPos", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("viewProjection", NodeMaterialBlockConnectionPointTypes.Matrix, true);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FragDepthBlock";
  }
  /**
   * Gets the depth input component
   */
  get depth() {
    return this._inputs[0];
  }
  /**
   * Gets the worldPos input component
   */
  get worldPos() {
    return this._inputs[1];
  }
  /**
   * Gets the viewProjection input component
   */
  get viewProjection() {
    return this._inputs[2];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const fragDepth = state.shaderLanguage === 0 ? "gl_FragDepth" : "fragmentOutputs.fragDepth";
    if (this.depth.isConnected) {
      state.compilationString += `${fragDepth} = ${this.depth.associatedVariableName};
`;
    } else if (this.worldPos.isConnected && this.viewProjection.isConnected) {
      state.compilationString += `
                ${state._declareLocalVar("p", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.viewProjection.associatedVariableName} * ${this.worldPos.associatedVariableName};
                ${state._declareLocalVar("v", NodeMaterialBlockConnectionPointTypes.Float)} = p.z / p.w;
                #ifndef IS_NDC_HALF_ZRANGE
                    v = v * 0.5 + 0.5;
                #endif
                ${fragDepth} = v;
    
            `;
    } else {
      Logger.Warn("FragDepthBlock: either the depth input or both the worldPos and viewProjection inputs must be connected!");
    }
    return this;
  }
};
RegisterClass("BABYLON.FragDepthBlock", FragDepthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/shadowMapBlock.js
var ShadowMapBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ShadowMapBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
    this.registerInput("viewProjection", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("depth", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ShadowMapBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("vPositionWSM");
    state._excludeVariableName("lightDataSM");
    state._excludeVariableName("biasAndScaleSM");
    state._excludeVariableName("depthValuesSM");
    state._excludeVariableName("clipPos");
    state._excludeVariableName("worldPos");
    state._excludeVariableName("zSM");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./shadowMapVertexMetric-B36YDKTU.js"),
        import("./packingFunctions-BGKH2WPT.js"),
        import("./shadowMapFragment-42SQKGO5.js")
      ]);
    } else {
      await Promise.all([
        import("./shadowMapVertexMetric-CIALVGNI.js"),
        import("./packingFunctions-4F36DV4R.js"),
        import("./shadowMapFragment-VC6I4B2O.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the view x projection input component
   */
  get viewProjection() {
    return this._inputs[1];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[2];
  }
  /**
   * Gets the depth output component
   */
  get depth() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    const isWebGPU = state.shaderLanguage === 1;
    state._emitUniformFromString("biasAndScaleSM", NodeMaterialBlockConnectionPointTypes.Vector3);
    state._emitUniformFromString("lightDataSM", NodeMaterialBlockConnectionPointTypes.Vector3);
    state._emitUniformFromString("depthValuesSM", NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emitFunctionFromInclude("packingFunctions", comments);
    state.compilationString += `${state._declareLocalVar("worldPos", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.worldPosition.associatedVariableName};
`;
    state.compilationString += `${state._declareLocalVar("vPositionWSM", NodeMaterialBlockConnectionPointTypes.Vector3)};
`;
    state.compilationString += `${state._declareLocalVar("vDepthMetricSM", NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;
`;
    state.compilationString += `${state._declareLocalVar("zSM", NodeMaterialBlockConnectionPointTypes.Float)};
`;
    if (this.worldNormal.isConnected) {
      state.compilationString += `${state._declareLocalVar("vNormalW", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;
`;
      state.compilationString += state._emitCodeFromInclude("shadowMapVertexNormalBias", comments);
    }
    state.compilationString += `${state._declareLocalVar("clipPos", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.viewProjection.associatedVariableName} * worldPos;
`;
    state.compilationString += state._emitCodeFromInclude("shadowMapVertexMetric", comments, {
      replaceStrings: [
        {
          search: /gl_Position/g,
          replace: "clipPos"
        },
        {
          search: /vertexOutputs.position/g,
          replace: "clipPos"
        },
        {
          search: /vertexOutputs\.vDepthMetricSM/g,
          replace: "vDepthMetricSM"
        }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("shadowMapFragment", comments, {
      replaceStrings: [
        {
          search: /return;/g,
          replace: ""
        },
        {
          search: /fragmentInputs\.vDepthMetricSM/g,
          replace: "vDepthMetricSM"
        }
      ]
    });
    const output = isWebGPU ? "fragmentOutputs.fragDepth" : "gl_FragDepth";
    state.compilationString += `
            #if SM_DEPTHTEXTURE == 1
                #ifdef IS_NDC_HALF_ZRANGE
                    ${output} = (clipPos.z / clipPos.w);
                #else
                    ${output} = (clipPos.z / clipPos.w) * 0.5 + 0.5;
                #endif
            #endif
        `;
    state.compilationString += `${state._declareOutput(this.depth)} = vec3${state.fSuffix}(depthSM, 1., 1.);
`;
    return this;
  }
};
RegisterClass("BABYLON.ShadowMapBlock", ShadowMapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/prePassOutputBlock.js
var PrePassOutputBlock = class extends NodeMaterialBlock {
  /**
   * Create a new PrePassOutputBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true);
    this.registerInput("viewDepth", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("screenDepth", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("localPosition", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("viewNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("reflectivity", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("velocity", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("velocityLinear", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.inputs[2].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this.inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this.inputs[4].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this.inputs[5].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this.inputs[6].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this.inputs[7].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this.inputs[8].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PrePassOutputBlock";
  }
  /**
   * Gets the view depth component
   */
  get viewDepth() {
    return this._inputs[0];
  }
  /**
   * Gets the screen depth component
   */
  get screenDepth() {
    return this._inputs[1];
  }
  /**
   * Gets the world position component
   */
  get worldPosition() {
    return this._inputs[2];
  }
  /**
   * Gets the position in local space component
   */
  get localPosition() {
    return this._inputs[3];
  }
  /**
   * Gets the view normal component
   */
  get viewNormal() {
    return this._inputs[4];
  }
  /**
   * Gets the world normal component
   */
  get worldNormal() {
    return this._inputs[5];
  }
  /**
   * Gets the reflectivity component
   */
  get reflectivity() {
    return this._inputs[6];
  }
  /**
   * Gets the velocity component
   */
  get velocity() {
    return this._inputs[7];
  }
  /**
   * Gets the linear velocity component
   */
  get velocityLinear() {
    return this._inputs[8];
  }
  _getFragData(isWebGPU, index) {
    return isWebGPU ? `fragmentOutputs.fragData${index}` : `gl_FragData[${index}]`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const worldPosition = this.worldPosition;
    const localPosition = this.localPosition;
    const viewNormal = this.viewNormal;
    const worldNormal = this.worldNormal;
    const viewDepth = this.viewDepth;
    const reflectivity = this.reflectivity;
    const screenDepth = this.screenDepth;
    const velocity = this.velocity;
    const velocityLinear = this.velocityLinear;
    state.sharedData.blocksWithDefines.push(this);
    const comments = `//${this.name}`;
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const isWebGPU = state.shaderLanguage === 1;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += `#if defined(PREPASS)\r
`;
    state.compilationString += isWebGPU ? `var fragData: array<vec4<f32>, SCENE_MRT_COUNT>;\r
` : `vec4 fragData[SCENE_MRT_COUNT];\r
`;
    state.compilationString += `#ifdef PREPASS_DEPTH\r
`;
    if (viewDepth.connectedPoint) {
      state.compilationString += ` fragData[PREPASS_DEPTH_INDEX] = ${vec4}(${viewDepth.associatedVariableName}, 0.0, 0.0, 1.0);\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_DEPTH_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_SCREENSPACE_DEPTH\r
`;
    if (screenDepth.connectedPoint) {
      state.compilationString += ` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(${screenDepth.associatedVariableName}, 0.0, 0.0, 1.0);\r
`;
    } else {
      state.compilationString += ` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_POSITION\r
`;
    if (worldPosition.connectedPoint) {
      state.compilationString += `fragData[PREPASS_POSITION_INDEX] = ${vec4}(${worldPosition.associatedVariableName}.rgb, ${worldPosition.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? worldPosition.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_POSITION_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_LOCAL_POSITION\r
`;
    if (localPosition.connectedPoint) {
      state.compilationString += ` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(${localPosition.associatedVariableName}.rgb, ${localPosition.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? localPosition.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_NORMAL\r
`;
    if (viewNormal.connectedPoint) {
      state.compilationString += ` fragData[PREPASS_NORMAL_INDEX] = ${vec4}(${viewNormal.associatedVariableName}.rgb, ${viewNormal.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? viewNormal.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_NORMAL_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_WORLD_NORMAL\r
`;
    if (worldNormal.connectedPoint) {
      state.compilationString += ` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(${worldNormal.associatedVariableName}.rgb, ${worldNormal.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? worldNormal.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_REFLECTIVITY\r
`;
    if (reflectivity.connectedPoint) {
      state.compilationString += ` fragData[PREPASS_REFLECTIVITY_INDEX] = ${vec4}(${reflectivity.associatedVariableName}.rgb, ${reflectivity.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? reflectivity.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_REFLECTIVITY_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_VELOCITY\r
`;
    if (velocity.connectedPoint) {
      state.compilationString += ` fragData[PREPASS_VELOCITY_INDEX] = ${vec4}(${velocity.associatedVariableName}.rgb, ${velocity.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? velocity.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_VELOCITY_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#ifdef PREPASS_VELOCITY_LINEAR\r
`;
    if (velocityLinear.connectedPoint) {
      state.compilationString += ` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${vec4}(${velocityLinear.associatedVariableName}.rgb, ${velocityLinear.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? velocityLinear.associatedVariableName + ".a" : "1.0"});\r
`;
    } else {
      state.compilationString += ` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\r
`;
    }
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 1\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 1)} = fragData[1];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 2\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 2)} = fragData[2];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 3\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 3)} = fragData[3];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 4\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 4)} = fragData[4];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 5\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 5)} = fragData[5];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 6\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 6)} = fragData[6];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#if SCENE_MRT_COUNT > 7\r
`;
    state.compilationString += `${this._getFragData(isWebGPU, 7)} = fragData[7];\r
`;
    state.compilationString += `#endif\r
`;
    state.compilationString += `#endif\r
`;
    return this;
  }
};
RegisterClass("BABYLON.PrePassOutputBlock", PrePassOutputBlock);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture = class _RawTexture extends Texture {
  /**
   * Instantiates a new RawTexture.
   * Raw texture can help creating a texture directly from an array of data.
   * This can be super useful if you either get the data from an uncompressed source or
   * if you wish to create your texture pixel by pixel.
   * @param data define the array of data to use to create the texture (null to create an empty texture)
   * @param width define the width of the texture
   * @param height define the height of the texture
   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps define whether mip maps should be generated or not
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.
   */
  constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer, waitDataToBeReady) {
    super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
    this.format = format;
    if (!this._engine) {
      return;
    }
    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
      samplingMode = 1;
    }
    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
      samplingMode = 1;
    }
    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._waitingForData = !!waitDataToBeReady && !data;
  }
  /**
   * Updates the texture underlying data.
   * @param data Define the new data of the texture
   */
  update(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
    this._waitingForData = false;
  }
  /**
   * Clones the texture.
   * @returns the cloned texture
   */
  clone() {
    if (!this._texture) {
      return super.clone();
    }
    const rawTexture = new _RawTexture(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);
    rawTexture._texture = this._texture;
    this._texture.incrementReferences();
    return rawTexture;
  }
  isReady() {
    return super.isReady() && !this._waitingForData;
  }
  /**
   * Creates a luminance texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance texture
   */
  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a luminance alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance alpha texture
   */
  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates an alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the alpha texture
   */
  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a RGB texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGB alpha texture
   */
  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false, waitDataToBeReady = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer, waitDataToBeReady);
  }
  /**
   * Creates a RGBA storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
  }
  /**
   * Creates a R texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  }
  /**
   * Creates a R storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState = class {
  constructor() {
    this.supportUniformBuffers = false;
    this.attributes = [];
    this.uniforms = [];
    this.constants = [];
    this.samplers = [];
    this.functions = {};
    this.extensions = {};
    this.prePassOutput = {};
    this.counters = {};
    this._terminalBlocks = /* @__PURE__ */ new Set();
    this._attributeDeclaration = "";
    this._uniformDeclaration = "";
    this._constantDeclaration = "";
    this._samplerDeclaration = "";
    this._varyingTransfer = "";
    this._injectAtEnd = "";
    this._injectAtTop = "";
    this._customEntryHeader = "";
    this._repeatableContentAnchorIndex = 0;
    this._builtCompilationString = "";
    this.compilationString = "";
  }
  /**
   * Gets the current shader language to use
   */
  get shaderLanguage() {
    return this.sharedData.nodeMaterial.shaderLanguage;
  }
  /** Gets suffix to add behind type casting */
  get fSuffix() {
    return this.shaderLanguage === 1 ? "f" : "";
  }
  /**
   * Returns the processed, compiled shader code
   * @param defines defines to use for the shader processing
   * @returns the raw shader code used by the engine
   */
  async getProcessedShaderAsync(defines) {
    if (!this._builtCompilationString) {
      Logger.Error("getProcessedShaderAsync: Shader not built yet.");
      return "";
    }
    const engine = this.sharedData.nodeMaterial.getScene().getEngine();
    const options = {
      defines: defines.split("\n"),
      indexParameters: void 0,
      isFragment: this.target === NodeMaterialBlockTargets.Fragment,
      shouldUseHighPrecisionShader: engine._shouldUseHighPrecisionShader,
      processor: engine._getShaderProcessor(this.shaderLanguage),
      supportsUniformBuffers: engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this.shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this.shaderLanguage),
      version: (engine.version * 100).toString(),
      platformName: engine.shaderPlatformName,
      processingContext: null,
      isNDCHalfZRange: engine.isNDCHalfZRange,
      useReverseDepthBuffer: engine.useReverseDepthBuffer
    };
    if (!engine.isWebGPU && engine.version > 1) {
      options.processor = new WebGLShaderProcessor();
    }
    return await new Promise((resolve) => {
      Process(this._builtCompilationString, options, (migratedCode, _) => {
        resolve(migratedCode);
      }, engine);
    });
  }
  /**
   * Finalize the compilation strings
   * @param state defines the current compilation state
   */
  finalize(state) {
    const emitComments = state.sharedData.emitComments;
    const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
    let entryPointString = `
${emitComments ? "//Entry point\n" : ""}`;
    if (this._customEntryHeader) {
      entryPointString += this._customEntryHeader;
    } else if (this.shaderLanguage === 1) {
      if (isFragmentMode) {
        entryPointString += `@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
${this.sharedData.varyingInitializationsFragment}`;
      } else {
        entryPointString += `@vertex
fn main(input: VertexInputs) -> FragmentInputs{
`;
      }
    } else {
      entryPointString += `void main(void) {
`;
    }
    this.compilationString = entryPointString + this.compilationString;
    if (this._constantDeclaration) {
      this.compilationString = `
${emitComments ? "//Constants\n" : ""}${this._constantDeclaration}
${this.compilationString}`;
    }
    let functionCode = "";
    for (const functionName in this.functions) {
      functionCode += this.functions[functionName] + `
`;
    }
    this.compilationString = `
${functionCode}
${this.compilationString}`;
    if (!isFragmentMode && this._varyingTransfer) {
      this.compilationString = `${this.compilationString}
${this._varyingTransfer}`;
    }
    if (this._injectAtEnd) {
      this.compilationString = `${this.compilationString}
${this._injectAtEnd}`;
    }
    this.compilationString = `${this.compilationString}
}`;
    if (this.sharedData.varyingDeclaration) {
      this.compilationString = `
${emitComments ? "//Varyings\n" : ""}${isFragmentMode ? this.sharedData.varyingDeclarationFragment : this.sharedData.varyingDeclaration}
${this.compilationString}`;
    }
    if (this._samplerDeclaration) {
      this.compilationString = `
${emitComments ? "//Samplers\n" : ""}${this._samplerDeclaration}
${this.compilationString}`;
    }
    if (this._uniformDeclaration) {
      this.compilationString = `
${emitComments ? "//Uniforms\n" : ""}${this._uniformDeclaration}
${this.compilationString}`;
    }
    if (this._attributeDeclaration && !isFragmentMode) {
      this.compilationString = `
${emitComments ? "//Attributes\n" : ""}${this._attributeDeclaration}
${this.compilationString}`;
    }
    if (this.shaderLanguage !== 1) {
      this.compilationString = "precision highp float;\n" + this.compilationString;
      this.compilationString = "#if defined(WEBGL2) || defined(WEBGPU)\nprecision highp sampler2DArray;\n#endif\n" + this.compilationString;
      if (isFragmentMode) {
        this.compilationString = "#if defined(PREPASS)\r\n#extension GL_EXT_draw_buffers : require\r\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r\nhighp vec4 gl_FragColor;\r\n#endif\r\n" + this.compilationString;
      }
      for (const extensionName in this.extensions) {
        const extension = this.extensions[extensionName];
        this.compilationString = `
${extension}
${this.compilationString}`;
      }
    }
    if (this._injectAtTop) {
      this.compilationString = `${this._injectAtTop}
${this.compilationString}`;
    }
    this._builtCompilationString = this.compilationString;
  }
  /** @internal */
  get _repeatableContentAnchor() {
    return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;
  }
  /**
   * @internal
   */
  _getFreeVariableName(prefix) {
    prefix = this.sharedData.formatConfig.formatVariablename(prefix);
    if (this.sharedData.variableNames[prefix] === void 0) {
      this.sharedData.variableNames[prefix] = 0;
      if (prefix === "output" || prefix === "texture") {
        return prefix + this.sharedData.variableNames[prefix];
      }
      return prefix;
    } else {
      this.sharedData.variableNames[prefix]++;
    }
    return prefix + this.sharedData.variableNames[prefix];
  }
  /**
   * @internal
   */
  _getFreeDefineName(prefix) {
    if (this.sharedData.defineNames[prefix] === void 0) {
      this.sharedData.defineNames[prefix] = 0;
    } else {
      this.sharedData.defineNames[prefix]++;
    }
    return prefix + this.sharedData.defineNames[prefix];
  }
  /**
   * @internal
   */
  _excludeVariableName(name6) {
    this.sharedData.variableNames[name6] = 0;
  }
  /**
   * @internal
   */
  _emit2DSampler(name6, define = "", force = false, annotation, unsignedSampler, precision) {
    if (this.samplers.indexOf(name6) < 0 || force) {
      if (define) {
        this._samplerDeclaration += `#if ${define}
`;
      }
      if (this.shaderLanguage === 1) {
        const unsignedSamplerPrefix = unsignedSampler ? "u" : "f";
        this._samplerDeclaration += `var ${name6 + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name6}: texture_2d<${unsignedSamplerPrefix}32>;
`;
      } else {
        const unsignedSamplerPrefix = unsignedSampler ? "u" : "";
        const precisionDecl = precision ?? "";
        this._samplerDeclaration += `uniform ${precisionDecl} ${unsignedSamplerPrefix}sampler2D ${name6}; ${annotation ? annotation : ""}
`;
      }
      if (define) {
        this._samplerDeclaration += `#endif
`;
      }
      if (!force) {
        this.samplers.push(name6);
      }
    }
  }
  /**
   * @internal
   */
  _emitCubeSampler(name6, define = "", force = false) {
    if (this.samplers.indexOf(name6) < 0 || force) {
      if (define) {
        this._samplerDeclaration += `#if ${define}
`;
      }
      if (this.shaderLanguage === 1) {
        this._samplerDeclaration += `var ${name6 + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name6}: texture_cube<f32>;
`;
      } else {
        this._samplerDeclaration += `uniform samplerCube ${name6};
`;
      }
      if (define) {
        this._samplerDeclaration += `#endif
`;
      }
      if (!force) {
        this.samplers.push(name6);
      }
    }
  }
  /**
   * @internal
   */
  _emit2DArraySampler(name6) {
    if (this.samplers.indexOf(name6) < 0) {
      if (this.shaderLanguage === 1) {
        this._samplerDeclaration += `var ${name6 + `Sampler`}: sampler;
`;
        this._samplerDeclaration += `var ${name6}: texture_2d_array<f32>;
`;
      } else {
        this._samplerDeclaration += `uniform sampler2DArray ${name6};
`;
      }
      this.samplers.push(name6);
    }
  }
  /**
   * @internal
   */
  _getGLType(type) {
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return "mat4";
    }
    return "";
  }
  /**
   * @internal
   */
  _getShaderType(type) {
    const isWGSL = this.shaderLanguage === 1;
    switch (type) {
      case NodeMaterialBlockConnectionPointTypes.Float:
        return isWGSL ? "f32" : "float";
      case NodeMaterialBlockConnectionPointTypes.Int:
        return isWGSL ? "i32" : "int";
      case NodeMaterialBlockConnectionPointTypes.Vector2:
        return isWGSL ? "vec2f" : "vec2";
      case NodeMaterialBlockConnectionPointTypes.Color3:
      case NodeMaterialBlockConnectionPointTypes.Vector3:
        return isWGSL ? "vec3f" : "vec3";
      case NodeMaterialBlockConnectionPointTypes.Color4:
      case NodeMaterialBlockConnectionPointTypes.Vector4:
        return isWGSL ? "vec4f" : "vec4";
      case NodeMaterialBlockConnectionPointTypes.Matrix:
        return isWGSL ? "mat4x4f" : "mat4";
    }
    return "";
  }
  /**
   * @internal
   */
  _emitExtension(name6, extension, define = "") {
    if (this.extensions[name6]) {
      return;
    }
    if (define) {
      extension = `#if ${define}
${extension}
#endif`;
    }
    this.extensions[name6] = extension;
  }
  /**
   * @internal
   */
  _emitFunction(name6, code, comments) {
    if (this.functions[name6]) {
      return;
    }
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    this.functions[name6] = code;
  }
  /**
   * @internal
   */
  _emitCodeFromInclude(includeName, comments, options) {
    const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
    if (options && options.repeatKey) {
      return `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
    }
    let code = store[includeName] + "\n";
    if (this.sharedData.emitComments) {
      code = comments + `
` + code;
    }
    if (!options) {
      return code;
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        code = code.replace(replaceString.search, replaceString.replace);
      }
    }
    return code;
  }
  /**
   * @internal
   */
  _emitFunctionFromInclude(includeName, comments, options, storeKey = "") {
    const key = includeName + storeKey;
    if (this.functions[key]) {
      return;
    }
    const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
      if (options && options.repeatKey) {
        this.functions[key] = `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
      } else {
        this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? "(" + options?.substitutionVars + ")" : ""}
`;
      }
      if (this.sharedData.emitComments) {
        this.functions[key] = comments + `
` + this.functions[key];
      }
      return;
    }
    this.functions[key] = store[includeName];
    if (this.sharedData.emitComments) {
      this.functions[key] = comments + `
` + this.functions[key];
    }
    if (options.removeIfDef) {
      this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
      this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
    }
    if (options.removeAttributes) {
      this.functions[key] = this.functions[key].replace(/\s*?attribute .+?;/g, "\n");
    }
    if (options.removeUniforms) {
      this.functions[key] = this.functions[key].replace(/\s*?uniform .*?;/g, "\n");
    }
    if (options.removeVaryings) {
      this.functions[key] = this.functions[key].replace(/\s*?(varying|in) .+?;/g, "\n");
    }
    if (options.replaceStrings) {
      for (let index = 0; index < options.replaceStrings.length; index++) {
        const replaceString = options.replaceStrings[index];
        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
      }
    }
  }
  /**
   * @internal
   */
  _registerTempVariable(name6) {
    if (this.sharedData.temps.indexOf(name6) !== -1) {
      return false;
    }
    this.sharedData.temps.push(name6);
    return true;
  }
  _emitDefineStart(define, notDefine = false) {
    let code = "";
    if (define) {
      if (define.startsWith("defined(")) {
        code = `#if ${define}
`;
      } else {
        code = `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
    }
    return code;
  }
  _emitDefineEnd(define) {
    return define ? `#endif
` : "";
  }
  /**
   * @internal
   */
  _emitVaryingFromString(name6, type, define = "", notDefine = false) {
    if (this.sharedData.varyings.indexOf(name6) !== -1) {
      return false;
    }
    this.sharedData.varyings.push(name6);
    const shaderType = this._getShaderType(type);
    const emitCode = (forFragment = false) => {
      let code = this._emitDefineStart(define, notDefine);
      if (this.shaderLanguage === 1) {
        switch (shaderType) {
          case "i32":
          case "f32":
          case "vec2f":
          case "vec3f":
          case "vec4f":
            code += `varying ${name6}: ${shaderType};
`;
            if (forFragment) {
              code += `var<private> ${name6}: ${shaderType};
`;
              this.sharedData.varyingInitializationsFragment += this._emitDefineStart(define, notDefine) + `${name6} = fragmentInputs.${name6};
` + this._emitDefineEnd(define);
            }
            break;
          case "mat4x4f":
            code += `varying ${name6}_r0: vec4f;
`;
            code += `varying ${name6}_r1: vec4f;
`;
            code += `varying ${name6}_r2: vec4f;
`;
            code += `varying ${name6}_r3: vec4f;
`;
            if (forFragment) {
              code += `var<private> ${name6}: mat4x4f;
`;
              this.sharedData.varyingInitializationsFragment += this._emitDefineStart(define, notDefine) + `${name6} = mat4x4f(fragmentInputs.${name6}_r0, fragmentInputs.${name6}_r1, fragmentInputs.${name6}_r2, fragmentInputs.${name6}_r3);
` + this._emitDefineEnd(define);
            }
            break;
          default:
            code += `varying ${name6}: ${shaderType};
`;
            break;
        }
      } else {
        code += `varying ${shaderType} ${name6};
`;
      }
      code += this._emitDefineEnd(define);
      return code;
    };
    if (this.shaderLanguage === 1) {
      this.sharedData.varyingDeclaration += emitCode(false);
      this.sharedData.varyingDeclarationFragment += emitCode(true);
    } else {
      const code = emitCode();
      this.sharedData.varyingDeclaration += code;
      this.sharedData.varyingDeclarationFragment += code;
    }
    return true;
  }
  /**
   * @internal
   */
  _getVaryingName(name6) {
    if (this.shaderLanguage === 1) {
      return (this.target !== NodeMaterialBlockTargets.Fragment ? "vertexOutputs." : "fragmentInputs.") + name6;
    }
    return name6;
  }
  /**
   * @internal
   */
  _emitUniformFromString(name6, type, define = "", notDefine = false) {
    if (this.uniforms.indexOf(name6) !== -1) {
      return;
    }
    this.uniforms.push(name6);
    if (define) {
      if (define.startsWith("defined(")) {
        this._uniformDeclaration += `#if ${define}
`;
      } else {
        this._uniformDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
    }
    if (this.sharedData.formatConfig.getUniformAnnotation) {
      this._uniformDeclaration += this.sharedData.formatConfig.getUniformAnnotation(name6);
    }
    const shaderType = this._getShaderType(type);
    if (this.shaderLanguage === 1) {
      this._uniformDeclaration += `uniform ${name6}: ${shaderType};
`;
    } else {
      this._uniformDeclaration += `uniform ${shaderType} ${name6};
`;
    }
    if (define) {
      this._uniformDeclaration += `#endif
`;
    }
  }
  /**
   * @internal
   */
  _generateTernary(trueStatement, falseStatement, condition) {
    if (this.shaderLanguage === 1) {
      return `select(${falseStatement}, ${trueStatement}, ${condition})`;
    }
    return `(${condition}) ? ${trueStatement} : ${falseStatement}`;
  }
  /**
   * @internal
   */
  _emitFloat(value) {
    if (value.toString() === value.toFixed(0)) {
      return `${value}.0`;
    }
    return value.toString();
  }
  /**
   * @internal
   */
  _declareOutput(output, isConst) {
    return this._declareLocalVar(output.associatedVariableName, output.type, isConst);
  }
  /**
   * @internal
   */
  _declareLocalVar(name6, type, isConst, isVarPrivate) {
    if (this.shaderLanguage === 1) {
      return `${isConst ? "const" : "var" + (isVarPrivate ? "<private>" : "")} ${name6}: ${this._getShaderType(type)}`;
    } else {
      return `${isConst ? "const " : ""}${this._getShaderType(type)} ${name6}`;
    }
  }
  /**
   * @internal
   */
  _samplerCubeFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSample";
    }
    return "textureCube";
  }
  /**
   * @internal
   */
  _samplerFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSample";
    }
    return "texture2D";
  }
  /**
   * @internal
   */
  _samplerLODFunc() {
    if (this.shaderLanguage === 1) {
      return "textureSampleLevel";
    }
    return "texture2DLodEXT";
  }
  _toLinearSpace(output) {
    if (this.shaderLanguage === 1) {
      if (output.type === NodeMaterialBlockConnectionPointTypes.Color3 || output.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
        return `toLinearSpaceVec3(${output.associatedVariableName})`;
      }
      return `toLinearSpace(${output.associatedVariableName})`;
    }
    return `toLinearSpace(${output.associatedVariableName})`;
  }
  /**
   * @internal
   */
  _generateTextureSample(uv, samplerName) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
    }
    return `${this._samplerFunc()}(${samplerName}, ${uv})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleLOD(uv, samplerName, lod) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerLODFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
    }
    return `${this._samplerLODFunc()}(${samplerName}, ${uv}, ${lod})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleCube(uv, samplerName) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
    }
    return `${this._samplerCubeFunc()}(${samplerName}, ${uv})`;
  }
  /**
   * @internal
   */
  _generateTextureSampleCubeLOD(uv, samplerName, lod) {
    if (this.shaderLanguage === 1) {
      return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
    }
    return `${this._samplerCubeFunc()}(${samplerName}, ${uv}, ${lod})`;
  }
  _convertVariableDeclarationToWGSL(type, dest, source) {
    return source.replace(new RegExp(`(${type})\\s+(\\w+)`, "g"), `var $2: ${dest}`);
  }
  _convertVariableConstructorsToWGSL(type, dest, source) {
    return source.replace(new RegExp(`(${type})\\(`, "g"), ` ${dest}(`);
  }
  _convertOutParametersToWGSL(source) {
    return source.replace(new RegExp(`out\\s+var\\s+(\\w+)\\s*:\\s*(\\w+)`, "g"), `$1: ptr<function, $2>`);
  }
  _convertTernaryOperandsToWGSL(source) {
    return source.replace(new RegExp(`\\[(.*?)\\?(.*?):(.*)\\]`, "g"), (match, condition, trueCase, falseCase) => `select(${falseCase}, ${trueCase}, ${condition})`);
  }
  _convertModOperatorsToWGSL(source) {
    return source.replace(new RegExp(`mod\\((.+?),\\s*(.+?)\\)`, "g"), (match, left, right) => `((${left})%(${right}))`);
  }
  _convertConstToWGSL(source) {
    return source.replace(new RegExp(`const var`, "g"), `const`);
  }
  _convertInnerFunctionsToWGSL(source) {
    return source.replace(new RegExp(`inversesqrt`, "g"), `inverseSqrt`);
  }
  _convertFunctionsToWGSL(source) {
    const regex = /var\s+(\w+)\s*:\s*(\w+)\((.*)\)/g;
    let match;
    while ((match = regex.exec(source)) !== null) {
      const funcName = match[1];
      const funcType = match[2];
      const params = match[3];
      const formattedParams = params.replace(/var\s/g, "");
      source = source.replace(match[0], `fn ${funcName}(${formattedParams}) -> ${funcType}`);
    }
    return source;
  }
  _babylonSLtoWGSL(code) {
    code = this._convertVariableDeclarationToWGSL("void", "voidnull", code);
    code = this._convertVariableDeclarationToWGSL("bool", "bool", code);
    code = this._convertVariableDeclarationToWGSL("int", "i32", code);
    code = this._convertVariableDeclarationToWGSL("uint", "u32", code);
    code = this._convertVariableDeclarationToWGSL("float", "f32", code);
    code = this._convertVariableDeclarationToWGSL("vec2", "vec2f", code);
    code = this._convertVariableDeclarationToWGSL("vec3", "vec3f", code);
    code = this._convertVariableDeclarationToWGSL("vec4", "vec4f", code);
    code = this._convertVariableDeclarationToWGSL("mat2", "mat2x2f", code);
    code = this._convertVariableDeclarationToWGSL("mat3", "mat3x3f", code);
    code = this._convertVariableDeclarationToWGSL("mat4", "mat4x4f", code);
    code = this._convertVariableConstructorsToWGSL("float", "f32", code);
    code = this._convertVariableConstructorsToWGSL("vec2", "vec2f", code);
    code = this._convertVariableConstructorsToWGSL("vec3", "vec3f", code);
    code = this._convertVariableConstructorsToWGSL("vec4", "vec4f", code);
    code = this._convertVariableConstructorsToWGSL("mat2", "mat2x2f", code);
    code = this._convertVariableConstructorsToWGSL("mat3", "mat3x3f", code);
    code = this._convertVariableConstructorsToWGSL("mat4", "mat4x4f", code);
    code = this._convertTernaryOperandsToWGSL(code);
    code = this._convertModOperatorsToWGSL(code);
    code = this._convertConstToWGSL(code);
    code = this._convertInnerFunctionsToWGSL(code);
    code = this._convertOutParametersToWGSL(code);
    code = code.replace(/\[\*\]/g, "*");
    code = this._convertFunctionsToWGSL(code);
    code = code.replace(/\s->\svoidnull/g, "");
    code = code.replace(/dFdx/g, "dpdx");
    code = code.replace(/dFdy/g, "dpdy");
    return code;
  }
  _convertTernaryOperandsToGLSL(source) {
    return source.replace(new RegExp(`\\[(.+?)\\?(.+?):(.+)\\]`, "g"), (match, condition, trueCase, falseCase) => `${condition} ? ${trueCase} : ${falseCase}`);
  }
  _babylonSLtoGLSL(code) {
    code = code.replace(/\[\*\]/g, "");
    code = this._convertTernaryOperandsToGLSL(code);
    return code;
  }
};

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData = class {
  /** Creates a new shared data */
  constructor() {
    this.temps = [];
    this.varyings = [];
    this.varyingDeclaration = "";
    this.varyingDeclarationFragment = "";
    this.varyingInitializationsFragment = "";
    this.inputBlocks = [];
    this.textureBlocks = [];
    this.bindableBlocks = [];
    this.forcedBindableBlocks = [];
    this.blocksWithFallbacks = [];
    this.blocksWithDefines = [];
    this.repeatableContentBlocks = [];
    this.dynamicUniformBlocks = [];
    this.blockingBlocks = [];
    this.animatedInputs = [];
    this.formatConfig = {
      getUniformAnnotation: null,
      formatVariablename: (name6) => name6.replace(/[^a-zA-Z_]+/g, "")
    };
    this.variableNames = {};
    this.defineNames = {};
    this.hints = {
      needWorldViewMatrix: false,
      needWorldViewProjectionMatrix: false,
      needAlphaBlending: false,
      needAlphaTesting: false
    };
    this.checks = {
      emitVertex: false,
      emitFragment: false,
      notConnectedNonOptionalInputs: new Array(),
      customErrors: new Array()
    };
    this.allowEmptyVertexProgram = false;
    this.variableNames["position"] = 0;
    this.variableNames["normal"] = 0;
    this.variableNames["tangent"] = 0;
    this.variableNames["uv"] = 0;
    this.variableNames["uv2"] = 0;
    this.variableNames["uv3"] = 0;
    this.variableNames["uv4"] = 0;
    this.variableNames["uv5"] = 0;
    this.variableNames["uv6"] = 0;
    this.variableNames["color"] = 0;
    this.variableNames["matricesIndices"] = 0;
    this.variableNames["matricesWeights"] = 0;
    this.variableNames["matricesIndicesExtra"] = 0;
    this.variableNames["matricesWeightsExtra"] = 0;
    this.variableNames["diffuseBase"] = 0;
    this.variableNames["specularBase"] = 0;
    this.variableNames["worldPos"] = 0;
    this.variableNames["shadow"] = 0;
    this.variableNames["view"] = 0;
    this.variableNames["vTBN"] = 0;
    this.defineNames["MAINUV0"] = 0;
    this.defineNames["MAINUV1"] = 0;
    this.defineNames["MAINUV2"] = 0;
    this.defineNames["MAINUV3"] = 0;
    this.defineNames["MAINUV4"] = 0;
    this.defineNames["MAINUV5"] = 0;
    this.defineNames["MAINUV6"] = 0;
    this.defineNames["MAINUV7"] = 0;
  }
  /**
   * Push a new error to the build state, avoiding exceptions that can break the build process
   * @param message defines the error message to push
   */
  raiseBuildError(message) {
    if (this.checks.customErrors.indexOf(message) !== -1) {
      this.checks.customErrors.push(message);
    }
  }
  /**
   * Emits console errors and exceptions if there is a failing check
   * @returns true if all checks pass
   */
  emitErrors() {
    let errorMessage = "";
    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
      errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.\n";
    }
    if (!this.checks.emitFragment) {
      errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.\n";
    }
    for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {
      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
    }
    for (const customError of this.checks.customErrors) {
      errorMessage += customError + "\n";
    }
    if (errorMessage) {
      errorMessage = "Node material build failed: \n" + errorMessage;
      Logger.Error(errorMessage);
      this.nodeMaterial.onBuildErrorObservable.notifyObservers(errorMessage);
      return false;
    }
    return true;
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock = class extends NodeMaterialBlock {
  /**
   * Boolean indicating if the transformation is made for a direction vector and not a position vector
   * If set to true the complementW value will be set to 0 else it will be set to 1
   */
  get transformAsDirection() {
    return this.complementW === 0;
  }
  set transformAsDirection(value) {
    this.complementW = value ? 0 : 1;
  }
  /**
   * Creates a new TransformBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.complementW = 1;
    this.complementZ = 0;
    this.target = NodeMaterialBlockTargets.Vertex;
    this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].onConnectionObservable.add((other) => {
      if (other.ownerBlock.isInput) {
        const otherAsInput = other.ownerBlock;
        if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
          this.complementW = 0;
        }
      }
    });
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TransformBlock";
  }
  /**
   * Gets the vector input
   */
  get vector() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz output component
   */
  get xyz() {
    return this._outputs[1];
  }
  /**
   * Gets the matrix transform input
   */
  get transform() {
    return this._inputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const vector = this.vector;
    const transform = this.transform;
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    if (vector.connectedPoint) {
      if (this.complementW === 0 || this.transformAsDirection) {
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.sharedData.blocksWithDefines.push(this);
        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);
        if (state.shaderLanguage === 1) {
          state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);
`;
        } else {
          state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});
`;
        }
        state.compilationString += `#ifdef NONUNIFORMSCALING
`;
        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));
`;
        state.compilationString += `#endif
`;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});
`;
            break;
        }
      } else {
        const transformName = transform.associatedVariableName;
        switch (vector.connectedPoint.type) {
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});
`;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
          case NodeMaterialBlockConnectionPointTypes.Color3:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
            break;
          default:
            state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};
`;
            break;
        }
      }
      if (this.xyz.hasEndpoints) {
        state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;
`;
      }
    }
    return this;
  }
  /**
   * Update defines for shader compilation
   * @param defines defines the material defines to update
   * @param nodeMaterial defines the node material requesting the update
   * @param mesh defines the mesh to be rendered
   */
  prepareDefines(defines, nodeMaterial, mesh) {
    if (mesh && mesh.nonUniformScaling) {
      defines.setValue("NONUNIFORMSCALING", true);
    }
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.complementZ = this.complementZ;
    serializationObject.complementW = this.complementW;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
    this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};
`;
    codeString += `${this._codeVariableName}.complementW = ${this.complementW};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Transform as direction", 0, void 0, { embedded: true })
], TransformBlock.prototype, "transformAsDirection", null);
RegisterClass("BABYLON.TransformBlock", TransformBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock = class extends NodeMaterialBlock {
  /**
   * The name of the sampler to read the screen texture from.
   */
  get samplerName() {
    return this._samplerName;
  }
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
  }
  /**
   * Create a new CurrentScreenBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this._samplerName = "textureSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CurrentScreenBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName(this.samplerName);
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  prepareDefines(defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _getMainUvName(state) {
    return "vMain" + this.uv.associatedVariableName;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, NodeMaterialBlockConnectionPointTypes.Vector2);
      }
    }
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      const textureReadFunc2 = state.shaderLanguage === 0 ? `texture2D(${this.samplerName},` : `textureSampleLevel(${this.samplerName}, ${this.samplerName + `Sampler`},`;
      const complement = state.shaderLanguage === 0 ? "" : ", 0";
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc2} ${uvInput.associatedVariableName}${complement});
`;
      return;
    }
    const textureReadFunc = state.shaderLanguage === 0 ? `texture2D(${this.samplerName},` : `textureSample(${this.samplerName}, ${this.samplerName + `Sampler`},`;
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName});
`;
      return;
    }
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _emitUvAndSampler(state) {
    state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emit2DSampler(this.samplerName);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
      state.sharedData.blockingBlocks.push(this);
    }
    if (state.sharedData.textureBlocks.indexOf(this) < 0) {
      state.sharedData.textureBlocks.push(this);
    }
    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
      state.sharedData.blocksWithDefines.push(this);
    }
    this._mainUVName = this._getMainUvName(state);
    this._emitUvAndSampler(state);
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.CurrentScreenBlock", CurrentScreenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleTextureBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._samplerName = "diffuseSampler";
    this.convertToGammaSpace = false;
    this.convertToLinearSpace = false;
    this._isUnique = false;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleTextureBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("diffuseSampler");
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "particle_uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("particle_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  prepareDefines(defines) {
    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  _writeOutput(state, output, swizzle) {
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
    state.compilationString += `#ifdef ${this._linearDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
    state.compilationString += `#ifdef ${this._gammaDefineName}
`;
    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
    state.compilationString += `#endif
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    state._emit2DSampler(this._samplerName);
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(this.uv.associatedVariableName, this._samplerName)};
`;
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
RegisterClass("BABYLON.ParticleTextureBlock", ParticleTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleRampGradientBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleRampGradientBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the rampColor output component
   */
  get rampColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("remapRanges");
    state._excludeVariableName("rampSampler");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("alpha");
    state._excludeVariableName("remappedColorIndex");
    state._excludeVariableName("rampColor");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state._emit2DSampler("rampSampler", "RAMPGRADIENT");
    state._emitVaryingFromString("remapRanges", NodeMaterialBlockConnectionPointTypes.Vector4, "RAMPGRADIENT");
    const varyingString = state.shaderLanguage === 0 ? "" : "fragmentInputs.";
    state.compilationString += `
            #ifdef RAMPGRADIENT
                ${state._declareLocalVar("baseColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.color.associatedVariableName};
                ${state._declareLocalVar("alpha", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.color.associatedVariableName}.a;

                ${state._declareLocalVar("remappedColorIndex", NodeMaterialBlockConnectionPointTypes.Float)} = clamp((alpha - ${varyingString}remapRanges.x) / ${varyingString}remapRanges.y, 0.0, 1.0);

                ${state._declareLocalVar("rampColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample("vec2(1.0 - remappedColorIndex, 0.)", "rampSampler")};

                // Remapped alpha
                ${state._declareOutput(this.rampColor)} = vec4${state.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${varyingString}remapRanges.z) / ${varyingString}remapRanges.w, 0.0, 1.0));
            #else
                ${state._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleRampGradientBlock", ParticleRampGradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ParticleBlendMultiplyBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ParticleBlendMultiplyBlock";
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the alphaTexture input component
   */
  get alphaTexture() {
    return this._inputs[1];
  }
  /**
   * Gets the alphaColor input component
   */
  get alphaColor() {
    return this._inputs[2];
  }
  /**
   * Gets the blendColor output component
   */
  get blendColor() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("sourceAlpha");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    state.compilationString += `
            #ifdef BLENDMULTIPLYMODE
                ${state._declareOutput(this.blendColor)};
                ${state._declareLocalVar("sourceAlpha", NodeMaterialBlockConnectionPointTypes.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName} = vec4${state.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);
            #else
                ${state._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};
            #endif
        `;
    return this;
  }
};
RegisterClass("BABYLON.ParticleBlendMultiplyBlock", ParticleBlendMultiplyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock = class extends NodeMaterialBlock {
  /**
   * Create a new VectorMergerBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.xSwizzle = "x";
    this.ySwizzle = "y";
    this.zSwizzle = "z";
    this.wSwizzle = "w";
    this.registerInput("xyzw ", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("zw ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VectorMergerBlock";
  }
  /**
   * Gets the xyzw component (input)
   */
  get xyzwIn() {
    return this._inputs[0];
  }
  /**
   * Gets the xyz component (input)
   */
  get xyzIn() {
    return this._inputs[1];
  }
  /**
   * Gets the xy component (input)
   */
  get xyIn() {
    return this._inputs[2];
  }
  /**
   * Gets the zw component (input)
   */
  get zwIn() {
    return this._inputs[3];
  }
  /**
   * Gets the x component (input)
   */
  get x() {
    return this._inputs[4];
  }
  /**
   * Gets the y component (input)
   */
  get y() {
    return this._inputs[5];
  }
  /**
   * Gets the z component (input)
   */
  get z() {
    return this._inputs[6];
  }
  /**
   * Gets the w component (input)
   */
  get w() {
    return this._inputs[7];
  }
  /**
   * Gets the xyzw component (output)
   */
  get xyzw() {
    return this._outputs[0];
  }
  /**
   * Gets the xyz component (output)
   */
  get xyzOut() {
    return this._outputs[1];
  }
  /**
   * Gets the xy component (output)
   */
  get xyOut() {
    return this._outputs[2];
  }
  /**
   * Gets the zw component (output)
   */
  get zwOut() {
    return this._outputs[3];
  }
  /**
   * Gets the xy component (output)
   * @deprecated Please use xyOut instead.
   */
  get xy() {
    return this.xyOut;
  }
  /**
   * Gets the xyz component (output)
   * @deprecated Please use xyzOut instead.
   */
  get xyz() {
    return this.xyzOut;
  }
  _inputRename(name6) {
    if (name6 === "xyzw ") {
      return "xyzwIn";
    }
    if (name6 === "xyz ") {
      return "xyzIn";
    }
    if (name6 === "xy ") {
      return "xyIn";
    }
    if (name6 === "zw ") {
      return "zwIn";
    }
    return name6;
  }
  _buildSwizzle(len) {
    const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;
    return "." + swizzle.substring(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const xInput = this.x;
    const yInput = this.y;
    const zInput = this.z;
    const wInput = this.w;
    const xyInput = this.xyIn;
    const zwInput = this.zwIn;
    const xyzInput = this.xyzIn;
    const xyzwInput = this.xyzwIn;
    const v4Output = this._outputs[0];
    const v3Output = this._outputs[1];
    const v2Output = this._outputs[2];
    const v2CompOutput = this._outputs[3];
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);
    if (xyzwInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v4Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyzInput.isConnected) {
      if (v4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
    } else if (xyInput.isConnected) {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    } else {
      if (v4Output.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
        } else {
          state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
        }
      }
      if (v3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
      if (v2Output.hasEndpoints) {
        state.compilationString += state._declareOutput(v2Output) + ` = ${vec2}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"})${this._buildSwizzle(2)};
`;
      }
      if (v2CompOutput.hasEndpoints) {
        if (zwInput.isConnected) {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
        } else {
          state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
        }
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.xSwizzle = this.xSwizzle;
    serializationObject.ySwizzle = this.ySwizzle;
    serializationObject.zSwizzle = this.zSwizzle;
    serializationObject.wSwizzle = this.wSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.xSwizzle = serializationObject.xSwizzle ?? "x";
    this.ySwizzle = serializationObject.ySwizzle ?? "y";
    this.zSwizzle = serializationObject.zSwizzle ?? "z";
    this.wSwizzle = serializationObject.wSwizzle ?? "w";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";
`;
    codeString += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";
`;
    codeString += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";
`;
    codeString += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";
`;
    return codeString;
  }
};
RegisterClass("BABYLON.VectorMergerBlock", VectorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new RemapBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.sourceRange = new Vector2(-1, 1);
    this.targetRange = new Vector2(0, 1);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RemapBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the source min input component
   */
  get sourceMin() {
    return this._inputs[1];
  }
  /**
   * Gets the source max input component
   */
  get sourceMax() {
    return this._inputs[2];
  }
  /**
   * Gets the target min input component
   */
  get targetMin() {
    return this._inputs[3];
  }
  /**
   * Gets the target max input component
   */
  get targetMax() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
    const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
    const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
    const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
    state.compilationString += state._declareOutput(output) + ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});
`;
    codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.sourceRange = this.sourceRange.asArray();
    serializationObject.targetRange = this.targetRange.asArray();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
    this.targetRange = Vector2.FromArray(serializationObject.targetRange);
  }
};
__decorate([
  editableInPropertyPage(
    "From",
    3
    /* PropertyTypeForEdition.Vector2 */
  )
], RemapBlock.prototype, "sourceRange", void 0);
__decorate([
  editableInPropertyPage(
    "To",
    3
    /* PropertyTypeForEdition.Vector2 */
  )
], RemapBlock.prototype, "targetRange", void 0);
RegisterClass("BABYLON.RemapBlock", RemapBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/baseMathBlock.js
var BaseMathBlock = class extends NodeMaterialBlock {
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this.output._typeConnectionSource = this.left;
    this._linkConnectionTypes(0, 1, true);
    this.left.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this.right.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._connectionObservers = [
      this.left.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),
      this.right.onTypeChangedObservable.add(() => this._updateInputOutputTypes())
    ];
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _updateInputOutputTypes() {
    this.output._typeConnectionSource = this.left;
    if (this.left.isConnected && this.right.isConnected) {
      if (this.left.type === NodeMaterialBlockConnectionPointTypes.Int || this.left.type === NodeMaterialBlockConnectionPointTypes.Float && this.right.type !== NodeMaterialBlockConnectionPointTypes.Int) {
        this.output._typeConnectionSource = this.right;
      }
    } else if (this.left.isConnected !== this.right.isConnected) {
      this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;
    }
    if (this.left.isConnected || this.right.isConnected) {
      for (const [first, second] of [
        [this.left, this.right],
        [this.right, this.left]
      ]) {
        first.acceptedConnectionPointTypes = [NodeMaterialBlockConnectionPointTypes.Int, NodeMaterialBlockConnectionPointTypes.Float];
        if (second.isConnected) {
          first.acceptedConnectionPointTypes.push(second.type);
          if (second.type === NodeMaterialBlockConnectionPointTypes.Int || second.type === NodeMaterialBlockConnectionPointTypes.Float) {
            first.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockConnectionPointTypes.Matrix);
          }
        }
      }
    }
  }
  /**
   * Release resources
   */
  dispose() {
    super.dispose();
    for (const observer of this._connectionObservers) {
      observer.remove();
    }
    this._connectionObservers.length = 0;
  }
};

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock = class extends BaseMathBlock {
  /**
   * Creates a new MultiplyBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MultiplyBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.MultiplyBlock", MultiplyBlock);

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem = class _BaseParticleSystem {
  /**
   * The amount of time the particle system is running (depends of the overall update speed).
   */
  get targetStopDuration() {
    return this._targetStopDuration;
  }
  set targetStopDuration(value) {
    if (this._targetStopDuration === value) {
      return;
    }
    this._targetStopDuration = value;
  }
  /**
   * Returns true if the particle system was generated by a node particle system set
   */
  get isNodeGenerated() {
    return false;
  }
  /**
   * Gets or sets a texture used to add random noise to particle positions
   */
  get noiseTexture() {
    return this._noiseTexture;
  }
  set noiseTexture(value) {
    if (this._noiseTexture === value) {
      return;
    }
    this._noiseTexture = value;
    this._reset();
  }
  /** @internal */
  get _isAnimationSheetEnabled() {
    return this._animationSheetEnabled;
  }
  set _isAnimationSheetEnabled(value) {
    if (this._animationSheetEnabled === value) {
      return;
    }
    this._animationSheetEnabled = value;
  }
  /**
   * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
   */
  get isAnimationSheetEnabled() {
    return this._isAnimationSheetEnabled;
  }
  set isAnimationSheetEnabled(value) {
    if (this._isAnimationSheetEnabled == value) {
      return;
    }
    this._isAnimationSheetEnabled = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.
   */
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(value) {
    this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
  }
  /**
   * Get hosting scene
   * @returns the scene
   */
  getScene() {
    return this._scene;
  }
  _hasTargetStopDurationDependantGradient() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  }
  _setEngineBasedOnBlendMode(blendMode) {
    switch (blendMode) {
      case _BaseParticleSystem.BLENDMODE_MULTIPLYADD:
        return;
      case _BaseParticleSystem.BLENDMODE_ADD:
        blendMode = 1;
        break;
      case _BaseParticleSystem.BLENDMODE_ONEONE:
        blendMode = 6;
        break;
      case _BaseParticleSystem.BLENDMODE_STANDARD:
        blendMode = 2;
        break;
      case _BaseParticleSystem.BLENDMODE_MULTIPLY:
        blendMode = 4;
        break;
      case _BaseParticleSystem.BLENDMODE_SUBTRACT:
        blendMode = 3;
        break;
      default:
        break;
    }
    this._engine.setAlphaMode(blendMode);
  }
  /**
   * Gets the current list of drag gradients.
   * You must use addDragGradient and removeDragGradient to update this list
   * @returns the list of drag gradients
   */
  getDragGradients() {
    return this._dragGradients;
  }
  /**
   * Gets the current list of limit velocity gradients.
   * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list
   * @returns the list of limit velocity gradients
   */
  getLimitVelocityGradients() {
    return this._limitVelocityGradients;
  }
  /**
   * Gets the current list of color gradients.
   * You must use addColorGradient and removeColorGradient to update this list
   * @returns the list of color gradients
   */
  getColorGradients() {
    return this._colorGradients;
  }
  /**
   * Gets the current list of size gradients.
   * You must use addSizeGradient and removeSizeGradient to update this list
   * @returns the list of size gradients
   */
  getSizeGradients() {
    return this._sizeGradients;
  }
  /**
   * Gets the current list of color remap gradients.
   * You must use addColorRemapGradient and removeColorRemapGradient to update this list
   * @returns the list of color remap gradients
   */
  getColorRemapGradients() {
    return this._colorRemapGradients;
  }
  /**
   * Gets the current list of alpha remap gradients.
   * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list
   * @returns the list of alpha remap gradients
   */
  getAlphaRemapGradients() {
    return this._alphaRemapGradients;
  }
  /**
   * Gets the current list of life time gradients.
   * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list
   * @returns the list of life time gradients
   */
  getLifeTimeGradients() {
    return this._lifeTimeGradients;
  }
  /**
   * Gets the current list of angular speed gradients.
   * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list
   * @returns the list of angular speed gradients
   */
  getAngularSpeedGradients() {
    return this._angularSpeedGradients;
  }
  /**
   * Gets the current list of velocity gradients.
   * You must use addVelocityGradient and removeVelocityGradient to update this list
   * @returns the list of velocity gradients
   */
  getVelocityGradients() {
    return this._velocityGradients;
  }
  /**
   * Gets the current list of start size gradients.
   * You must use addStartSizeGradient and removeStartSizeGradient to update this list
   * @returns the list of start size gradients
   */
  getStartSizeGradients() {
    return this._startSizeGradients;
  }
  /**
   * Gets the current list of emit rate gradients.
   * You must use addEmitRateGradient and removeEmitRateGradient to update this list
   * @returns the list of emit rate gradients
   */
  getEmitRateGradients() {
    return this._emitRateGradients;
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction1() {
    if (this.particleEmitterType.direction1) {
      return this.particleEmitterType.direction1;
    }
    return Vector3.Zero();
  }
  set direction1(value) {
    if (this.particleEmitterType.direction1) {
      this.particleEmitterType.direction1 = value;
    }
  }
  /**
   * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get direction2() {
    if (this.particleEmitterType.direction2) {
      return this.particleEmitterType.direction2;
    }
    return Vector3.Zero();
  }
  set direction2(value) {
    if (this.particleEmitterType.direction2) {
      this.particleEmitterType.direction2 = value;
    }
  }
  /**
   * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get minEmitBox() {
    if (this.particleEmitterType.minEmitBox) {
      return this.particleEmitterType.minEmitBox;
    }
    return Vector3.Zero();
  }
  set minEmitBox(value) {
    if (this.particleEmitterType.minEmitBox) {
      this.particleEmitterType.minEmitBox = value;
    }
  }
  /**
   * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
   * This only works when particleEmitterTyps is a BoxParticleEmitter
   */
  get maxEmitBox() {
    if (this.particleEmitterType.maxEmitBox) {
      return this.particleEmitterType.maxEmitBox;
    }
    return Vector3.Zero();
  }
  set maxEmitBox(value) {
    if (this.particleEmitterType.maxEmitBox) {
      this.particleEmitterType.maxEmitBox = value;
    }
  }
  /**
   * Gets or sets the billboard mode to use when isBillboardBased = true.
   * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._reset();
  }
  /**
   * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
   */
  get isBillboardBased() {
    return this._isBillboardBased;
  }
  set isBillboardBased(value) {
    if (this._isBillboardBased === value) {
      return;
    }
    this._isBillboardBased = value;
    this._reset();
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  }
  /** @internal */
  _reset() {
  }
  /**
   * @internal
   */
  _removeGradientAndTexture(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    let index = 0;
    for (const valueGradient of gradients) {
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  }
  /**
   * Instantiates a particle system.
   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
   * @param name The name of the particle system
   */
  constructor(name6) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this._targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this.applyFog = false;
    this._wasDispatched = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = _BaseParticleSystem.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this._animationSheetEnabled = false;
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this._useLogarithmicDepth = false;
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name6;
    this.name = name6;
  }
  /**
   * Creates a Point Emitter for the particle system (emits directly from the emitter position)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   */
  createPointEmitter(direction1, direction2) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
   * @param radius The radius of the hemisphere to emit from
   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createHemisphericEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
   * @param radius The radius of the sphere to emit from
   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
   */
  createSphereEmitter(radius = 1, radiusRange = 1) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the sphere to emit from
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
   */
  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
   * @param radius The radius of the emission cylinder
   * @param height The height of the emission cylinder
   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
   * @param directionRandomizer How much to randomize the particle direction [0-1]
   */
  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
   * @param radius The radius of the cylinder to emit from
   * @param height The height of the emission cylinder
   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
   */
  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
   * @param radius The radius of the cone to emit from
   * @param angle The base angle of the cone
   */
  createConeEmitter(radius = 1, angle = Math.PI / 4) {
    throw new Error("Method not implemented.");
  }
  createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
    throw new Error("Method not implemented.");
  }
  /**
   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
   */
  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
    throw new Error("Method not implemented.");
  }
};
BaseParticleSystem.BLENDMODE_ONEONE = 0;
BaseParticleSystem.BLENDMODE_STANDARD = 1;
BaseParticleSystem.BLENDMODE_ADD = 2;
BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;
BaseParticleSystem.BLENDMODE_SUBTRACT = -1;
RegisterClass("BABYLON.BaseParticleSystem", BaseParticleSystem);

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ColorSplitterBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ColorSplitterBlock";
  }
  /**
   * Gets the rgba component (input)
   */
  get rgba() {
    return this._inputs[0];
  }
  /**
   * Gets the rgb component (input)
   */
  get rgbIn() {
    return this._inputs[1];
  }
  /**
   * Gets the rgb component (output)
   */
  get rgbOut() {
    return this._outputs[0];
  }
  /**
   * Gets the r component (output)
   */
  get r() {
    return this._outputs[1];
  }
  /**
   * Gets the g component (output)
   */
  get g() {
    return this._outputs[2];
  }
  /**
   * Gets the b component (output)
   */
  get b() {
    return this._outputs[3];
  }
  /**
   * Gets the a component (output)
   */
  get a() {
    return this._outputs[4];
  }
  _inputRename(name6) {
    if (name6 === "rgb ") {
      return "rgbIn";
    }
    return name6;
  }
  _outputRename(name6) {
    if (name6 === "rgb") {
      return "rgbOut";
    }
    return name6;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.rgba.isConnected ? this.rgba : this.rgbIn;
    if (!input.isConnected) {
      return;
    }
    const rgbOutput = this._outputs[0];
    const rOutput = this._outputs[1];
    const gOutput = this._outputs[2];
    const bOutput = this._outputs[3];
    const aOutput = this._outputs[4];
    if (rgbOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(rgbOutput) + ` = ${input.associatedVariableName}.rgb;
`;
    }
    if (rOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(rOutput) + ` = ${input.associatedVariableName}.r;
`;
    }
    if (gOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(gOutput) + ` = ${input.associatedVariableName}.g;
`;
    }
    if (bOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(bOutput) + ` = ${input.associatedVariableName}.b;
`;
    }
    if (aOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(aOutput) + ` = ${input.associatedVariableName}.a;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ColorSplitterBlock", ColorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
  }
  _beforeClear() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = class _ProceduralTexture extends Texture {
  /**
   * Gets the shader language type used to generate vertex and fragment source code.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Instantiates a new procedural texture.
   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
   * This is the base class of any Procedural texture and contains most of the shareable code.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures
   * @param name  Define the name of the texture
   * @param size Define the size of the texture to create
   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:
   *  * object: \{ fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ fragmentSource: "fragment shader code string" \}, the string contains the shader code
   *  * string: the string contains a name "XXX" to lookup in Effect.ShadersStore["XXXFragmentShader"]
   * @param scene Define the scene the texture belongs to
   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
   * @param generateMipMaps Define if the texture should creates mip maps or not
   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
   * @param textureType The FBO internal texture type
   */
  constructor(name6, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
    super(null, scene, !generateMipMaps);
    this.isEnabled = true;
    this.autoClear = true;
    this.onGeneratedObservable = new Observable();
    this.onBeforeGenerationObservable = new Observable();
    this.nodeMaterialSource = null;
    this.defines = "";
    this._textures = {};
    this._currentRefreshId = -1;
    this._frameId = -1;
    this._refreshRate = 1;
    this._vertexBuffers = {};
    this._uniforms = new Array();
    this._samplers = new Array();
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors4 = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._matrices = {};
    this._fallbackTextureUsed = false;
    this._cachedDefines = null;
    this._contentUpdateId = -1;
    this._rtWrapper = null;
    if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {
      this._options = fallbackTexture;
      this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;
    } else {
      this._options = {};
      this._fallbackTexture = fallbackTexture;
    }
    this._shaderLanguage = this._options.shaderLanguage ?? 0;
    scene = this.getScene() || EngineStore.LastCreatedScene;
    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(this);
    this._fullEngine = scene.getEngine();
    this.name = name6;
    this.isRenderTarget = true;
    this._size = size;
    this._textureType = textureType;
    this._generateMipMaps = generateMipMaps;
    this._drawWrapper = new DrawWrapper(this._fullEngine);
    this.setFragment(fragment);
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
    this._texture = rtWrapper.texture;
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  _createRtWrapper(isCube, size, generateMipMaps, textureType) {
    if (isCube) {
      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      this.setFloat("face", 0);
    } else {
      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      if (this._rtWrapper.is3D) {
        this.setFloat("layer", 0);
        this.setInt("layerNum", 0);
      }
    }
    return this._rtWrapper;
  }
  /**
   * The effect that is created when initializing the post process.
   * @returns The created effect corresponding the postprocess.
   */
  getEffect() {
    return this._drawWrapper.effect;
  }
  /**
   * @internal
   */
  _setEffect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Gets texture content (Use this function wisely as reading from a texture can be slow)
   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)
   */
  getContent() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    if (this._contentData) {
      this._contentData.then((buffer) => {
        this._contentData = this.readPixels(0, 0, buffer);
        this._contentUpdateId = this._frameId;
      });
    } else {
      this._contentData = this.readPixels(0, 0);
      this._contentUpdateId = this._frameId;
    }
    return this._contentData;
  }
  _createIndexBuffer() {
    const engine = this._fullEngine;
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  }
  /**
   * Resets the texture in order to recreate its associated resources.
   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code
   */
  reset() {
    this._drawWrapper.effect?.dispose();
    this._drawWrapper.effect = null;
    this._cachedDefines = null;
  }
  _getDefines() {
    return this.defines;
  }
  /**
   * Executes a function when the texture will be ready to be drawn.
   * @param func The callback to be used.
   */
  executeWhenReady(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    const effect = this.getEffect();
    if (effect) {
      effect.executeWhenCompiled(() => {
        func(this);
      });
    }
  }
  /**
   * Is the texture ready to be used ? (rendered at least once)
   * @returns true if ready, otherwise, false.
   */
  isReady() {
    const engine = this._fullEngine;
    if (this.nodeMaterialSource) {
      return this._drawWrapper.effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    if (!this._texture) {
      return false;
    }
    const defines = this._getDefines();
    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
      return true;
    }
    const shaders = {
      vertex: "procedural",
      fragmentElement: this._fragment.fragmentElement,
      fragmentSource: this._fragment.fragmentSource,
      fragment: typeof this._fragment === "string" ? this._fragment : void 0
    };
    if (this._cachedDefines !== defines) {
      this._cachedDefines = defines;
      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
        this._rtWrapper?.dispose();
        this._rtWrapper = this._texture = null;
        if (this._fallbackTexture) {
          this._texture = this._fallbackTexture._texture;
          if (this._texture) {
            this._texture.incrementReferences();
          }
        }
        this._fallbackTextureUsed = true;
      }, void 0, this._shaderLanguage, async () => {
        if (this._options.extraInitializationsAsync) {
          if (this.shaderLanguage === 1) {
            await Promise.all([import("./procedural.vertex-CI6Z2BNC.js"), this._options.extraInitializationsAsync()]);
          } else {
            await Promise.all([import("./procedural.vertex-ELJR66D7.js"), this._options.extraInitializationsAsync()]);
          }
        } else {
          if (this.shaderLanguage === 1) {
            await import("./procedural.vertex-CI6Z2BNC.js");
          } else {
            await import("./procedural.vertex-ELJR66D7.js");
          }
        }
      });
    }
    return this._drawWrapper.effect.isReady();
  }
  /**
   * Resets the refresh counter of the texture and start bak from scratch.
   * Could be useful to regenerate the texture if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  /**
   * Set the fragment shader to use in order to render the texture.
   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
   */
  setFragment(fragment) {
    this._fragment = fragment;
  }
  /**
   * Define the refresh rate of the texture or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  /** @internal */
  _shouldRender() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  /**
   * Get the size the texture is rendering at.
   * @returns the size (on cube texture it is always squared)
   */
  getRenderSize() {
    return this._size;
  }
  /**
   * Resize the texture to new value.
   * @param size Define the new size the texture should have
   * @param generateMipMaps Define whether the new texture should create mip maps
   */
  resize(size, generateMipMaps) {
    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
      return;
    }
    const isCube = this._texture.isCube;
    this._rtWrapper.dispose();
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
    this._texture = rtWrapper.texture;
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  }
  _checkUniform(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader program used to render.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setTexture(name6, texture) {
    if (this._samplers.indexOf(name6) === -1) {
      this._samplers.push(name6);
    }
    this._textures[name6] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloat(name6, value) {
    this._checkUniform(name6);
    this._floats[name6] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setInt(name6, value) {
    this._checkUniform(name6);
    this._ints[name6] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloats(name6, value) {
    this._checkUniform(name6);
    this._floatsArrays[name6] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor3(name6, value) {
    this._checkUniform(name6);
    this._colors3[name6] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor4(name6, value) {
    this._checkUniform(name6);
    this._colors4[name6] = value;
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector2(name6, value) {
    this._checkUniform(name6);
    this._vectors2[name6] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector3(name6, value) {
    this._checkUniform(name6);
    this._vectors3[name6] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector4(name6, value) {
    this._checkUniform(name6);
    this._vectors4[name6] = value;
    return this;
  }
  /**
   * Set a mat4 in the shader from a MAtrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setMatrix(name6, value) {
    this._checkUniform(name6);
    this._matrices[name6] = value;
    return this;
  }
  /**
   * Render the texture to its associated render target.
   * @param useCameraPostProcess Define if camera post process should be applied to the texture
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(useCameraPostProcess) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this._fullEngine;
    engine.enableEffect(this._drawWrapper);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (const name6 in this._textures) {
        this._drawWrapper.effect.setTexture(name6, this._textures[name6]);
      }
      for (const name6 in this._ints) {
        this._drawWrapper.effect.setInt(name6, this._ints[name6]);
      }
      for (const name6 in this._floats) {
        this._drawWrapper.effect.setFloat(name6, this._floats[name6]);
      }
      for (const name6 in this._floatsArrays) {
        this._drawWrapper.effect.setArray(name6, this._floatsArrays[name6]);
      }
      for (const name6 in this._colors3) {
        this._drawWrapper.effect.setColor3(name6, this._colors3[name6]);
      }
      for (const name6 in this._colors4) {
        const color = this._colors4[name6];
        this._drawWrapper.effect.setFloat4(name6, color.r, color.g, color.b, color.a);
      }
      for (const name6 in this._vectors2) {
        this._drawWrapper.effect.setVector2(name6, this._vectors2[name6]);
      }
      for (const name6 in this._vectors3) {
        this._drawWrapper.effect.setVector3(name6, this._vectors3[name6]);
      }
      for (const name6 in this._vectors4) {
        this._drawWrapper.effect.setVector4(name6, this._vectors4[name6]);
      }
      for (const name6 in this._matrices) {
        this._drawWrapper.effect.setMatrix(name6, this._matrices[name6]);
      }
    }
    if (!this._texture || !this._rtWrapper) {
      return;
    }
    engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);
    const viewPort = engine.currentViewport;
    if (this.isCube) {
      for (let face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        this._drawWrapper.effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, true);
      }
    } else {
      let numLayers = 1;
      if (this._rtWrapper.is3D) {
        numLayers = this._rtWrapper.depth;
      } else if (this._rtWrapper.is2DArray) {
        numLayers = this._rtWrapper.layers;
      }
      for (let layer = 0; layer < numLayers; layer++) {
        engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true, 0, layer);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {
          this._drawWrapper.effect?.setFloat("layer", numLayers !== 1 ? layer / (numLayers - 1) : 0);
          this._drawWrapper.effect?.setInt("layerNum", layer);
          for (const name6 in this._textures) {
            this._drawWrapper.effect.setTexture(name6, this._textures[name6]);
          }
        }
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);
      }
    }
    if (viewPort) {
      engine.setViewport(viewPort);
    }
    if (this.isCube) {
      engine.generateMipMapsForCubemap(this._texture, true);
    }
    engine._debugPopGroup?.(1);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  }
  /**
   * Clone the texture.
   * @returns the cloned texture
   */
  clone() {
    const textureSize = this.getSize();
    const newTexture = new _ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    super.dispose();
  }
};
__decorate([
  serialize()
], ProceduralTexture.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "autoClear", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_generateMipMaps", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_size", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "refreshRate", null);
RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations;
(function(TrigonometryBlockOperations2) {
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
  TrigonometryBlockOperations2[TrigonometryBlockOperations2["Set"] = 18] = "Set";
})(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
var TrigonometryBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new TrigonometryBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.operation = TrigonometryBlockOperations.Cos;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TrigonometryBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    let operation = "";
    switch (this.operation) {
      case TrigonometryBlockOperations.Cos: {
        operation = "cos";
        break;
      }
      case TrigonometryBlockOperations.Sin: {
        operation = "sin";
        break;
      }
      case TrigonometryBlockOperations.Abs: {
        operation = "abs";
        break;
      }
      case TrigonometryBlockOperations.Exp: {
        operation = "exp";
        break;
      }
      case TrigonometryBlockOperations.Exp2: {
        operation = "exp2";
        break;
      }
      case TrigonometryBlockOperations.Round: {
        operation = "round";
        break;
      }
      case TrigonometryBlockOperations.Floor: {
        operation = "floor";
        break;
      }
      case TrigonometryBlockOperations.Ceiling: {
        operation = "ceil";
        break;
      }
      case TrigonometryBlockOperations.Sqrt: {
        operation = "sqrt";
        break;
      }
      case TrigonometryBlockOperations.Log: {
        operation = "log";
        break;
      }
      case TrigonometryBlockOperations.Tan: {
        operation = "tan";
        break;
      }
      case TrigonometryBlockOperations.ArcTan: {
        operation = "atan";
        break;
      }
      case TrigonometryBlockOperations.ArcCos: {
        operation = "acos";
        break;
      }
      case TrigonometryBlockOperations.ArcSin: {
        operation = "asin";
        break;
      }
      case TrigonometryBlockOperations.Fract: {
        operation = "fract";
        break;
      }
      case TrigonometryBlockOperations.Sign: {
        operation = "sign";
        break;
      }
      case TrigonometryBlockOperations.Radians: {
        operation = "radians";
        break;
      }
      case TrigonometryBlockOperations.Degrees: {
        operation = "degrees";
        break;
      }
      case TrigonometryBlockOperations.Set: {
        operation = "";
        break;
      }
    }
    state.compilationString += state._declareOutput(output) + ` = ${operation}(${this.input.associatedVariableName});
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.operation = this.operation;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.operation = serializationObject.operation;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Operation", 5, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "Cos", value: TrigonometryBlockOperations.Cos },
      { label: "Sin", value: TrigonometryBlockOperations.Sin },
      { label: "Abs", value: TrigonometryBlockOperations.Abs },
      { label: "Exp", value: TrigonometryBlockOperations.Exp },
      { label: "Exp2", value: TrigonometryBlockOperations.Exp2 },
      { label: "Round", value: TrigonometryBlockOperations.Round },
      { label: "Floor", value: TrigonometryBlockOperations.Floor },
      { label: "Ceiling", value: TrigonometryBlockOperations.Ceiling },
      { label: "Sqrt", value: TrigonometryBlockOperations.Sqrt },
      { label: "Log", value: TrigonometryBlockOperations.Log },
      { label: "Tan", value: TrigonometryBlockOperations.Tan },
      { label: "ArcTan", value: TrigonometryBlockOperations.ArcTan },
      { label: "ArcCos", value: TrigonometryBlockOperations.ArcCos },
      { label: "ArcSin", value: TrigonometryBlockOperations.ArcSin },
      { label: "Fract", value: TrigonometryBlockOperations.Fract },
      { label: "Sign", value: TrigonometryBlockOperations.Sign },
      { label: "Radians", value: TrigonometryBlockOperations.Radians },
      { label: "Degrees", value: TrigonometryBlockOperations.Degrees },
      { label: "Set", value: TrigonometryBlockOperations.Set }
    ]
  })
], TrigonometryBlock.prototype, "operation", void 0);
RegisterClass("BABYLON.TrigonometryBlock", TrigonometryBlock);

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var NodeMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
};
var NodeMaterialDefines = class extends ImageProcessingDefinesMixin(NodeMaterialDefinesBase) {
  /**
   * Creates a new NodeMaterialDefines
   */
  constructor() {
    super();
    this.NORMAL = false;
    this.TANGENT = false;
    this.VERTEXCOLOR_NME = false;
    this.PREPASS = false;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_WORLD_NORMAL = false;
    this.PREPASS_WORLD_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_LOCAL_POSITION = false;
    this.PREPASS_LOCAL_POSITION_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_SCREENSPACE_DEPTH = false;
    this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_POSITION = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.MORPHTARGETS_UV2 = false;
    this.MORPHTARGETS_COLOR = false;
    this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
    this.MORPHTARGETTEXTURE_HASNORMALS = false;
    this.MORPHTARGETTEXTURE_HASTANGENTS = false;
    this.MORPHTARGETTEXTURE_HASUVS = false;
    this.MORPHTARGETTEXTURE_HASUV2S = false;
    this.MORPHTARGETTEXTURE_HASCOLORS = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.BUMPDIRECTUV = 0;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.AREALIGHTSUPPORTED = true;
    this.AREALIGHTNOROUGHTNESS = true;
    this.rebuild();
  }
  /**
   * Set the value of a specific key
   * @param name defines the name of the key to set
   * @param value defines the value to set
   * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing
   */
  setValue(name6, value, markAsUnprocessedIfDirty = false) {
    if (this[name6] === void 0) {
      this._keys.push(name6);
    }
    if (markAsUnprocessedIfDirty && this[name6] !== value) {
      this.markAsUnprocessed();
    }
    this[name6] = value;
  }
};
var NodeMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
};
var NodeMaterial = class _NodeMaterial extends NodeMaterialBase {
  /**
   * Checks if a block is a texture block
   * @param block The block to check
   * @returns True if the block is a texture block
   */
  static _BlockIsTextureBlock(block) {
    return block.getClassName() === "TextureBlock" || block.getClassName() === "ReflectionTextureBaseBlock" || block.getClassName() === "ReflectionTextureBlock" || block.getClassName() === "ReflectionBlock" || block.getClassName() === "RefractionBlock" || block.getClassName() === "CurrentScreenBlock" || block.getClassName() === "SmartFilterTextureBlock" || block.getClassName() === "ParticleTextureBlock" || block.getClassName() === "ImageSourceBlock" || block.getClassName() === "TriPlanarBlock" || block.getClassName() === "BiPlanarBlock" || block.getClassName() === "PrePassTextureBlock";
  }
  /** Gets whether the node material is currently building */
  get buildIsInProgress() {
    return this._buildIsInProgress;
  }
  set _glowModeEnabled(value) {
    this._useAdditionalColor = value;
  }
  /** Get the inspector from bundle or global
   * @returns the global NME
   */
  _getGlobalNodeMaterialEditor() {
    if (typeof NODEEDITOR !== "undefined") {
      return NODEEDITOR;
    }
    if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
      return BABYLON;
    }
    return void 0;
  }
  /** Gets or sets the active shader language */
  get shaderLanguage() {
    return this._options?.shaderLanguage || _NodeMaterial.DefaultShaderLanguage;
  }
  set shaderLanguage(value) {
    this._options.shaderLanguage = value;
  }
  /** Gets or sets options to control the node material overall behavior */
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
  }
  /**
   * Gets or sets the mode property
   */
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
  }
  /** Gets or sets the unique identifier used to identified the effect associated with the material */
  get buildId() {
    return this._buildId;
  }
  set buildId(value) {
    this._buildId = value;
  }
  /**
   * Create a new node based material
   * @param name defines the material name
   * @param scene defines the hosting scene
   * @param options defines creation option
   */
  constructor(name6, scene, options = {}) {
    super(name6, scene || EngineStore.LastCreatedScene);
    this._buildId = _NodeMaterial._BuildIdGenerator++;
    this._buildWasSuccessful = false;
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._optimizers = new Array();
    this._animationFrame = -1;
    this._buildIsInProgress = false;
    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();
    this._useAdditionalColor = false;
    this.editorData = null;
    this.ignoreAlpha = false;
    this.maxSimultaneousLights = 4;
    this.onBuildObservable = new Observable();
    this.onBuildErrorObservable = new Observable();
    this._vertexOutputNodes = new Array();
    this._fragmentOutputNodes = new Array();
    this.attachedBlocks = [];
    this._mode = NodeMaterialModes.Material;
    this.forceAlphaBlending = false;
    if (!_NodeMaterial.UseNativeShaderLanguageOfEngine && options && options.shaderLanguage === 1 && !this.getScene().getEngine().isWebGPU) {
      throw new Error("WebGPU shader language is only supported with WebGPU engine");
    }
    this._options = {
      emitComments: false,
      shaderLanguage: _NodeMaterial.DefaultShaderLanguage,
      ...options
    };
    if (_NodeMaterial.UseNativeShaderLanguageOfEngine) {
      this._options.shaderLanguage = this.getScene().getEngine().isWebGPU ? 1 : 0;
    }
    this._attachImageProcessingConfiguration(null);
  }
  /**
   * Gets the current class name of the material e.g. "NodeMaterial"
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterial";
  }
  /**
   * Get a block by its name
   * @param name defines the name of the block to retrieve
   * @returns the required block or null if not found
   */
  getBlockByName(name6) {
    let result = null;
    for (const block of this.attachedBlocks) {
      if (block.name === name6) {
        if (!result) {
          result = block;
        } else {
          Tools.Warn("More than one block was found with the name `" + name6 + "`");
          return result;
        }
      }
    }
    return result;
  }
  /**
   * Get a block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required block or null if not found
   */
  getBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Get an input block using a predicate
   * @param predicate defines the predicate used to find the good candidate
   * @returns the required input block or null if not found
   */
  getInputBlockByPredicate(predicate) {
    for (const block of this.attachedBlocks) {
      if (block.isInput && predicate(block)) {
        return block;
      }
    }
    return null;
  }
  /**
   * Gets the list of input blocks attached to this material
   * @returns an array of InputBlocks
   */
  getInputBlocks() {
    const blocks = [];
    for (const block of this.attachedBlocks) {
      if (block.isInput) {
        blocks.push(block);
      }
    }
    return blocks;
  }
  /**
   * Adds a new optimizer to the list of optimizers
   * @param optimizer defines the optimizers to add
   * @returns the current material
   */
  registerOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index > -1) {
      return;
    }
    this._optimizers.push(optimizer);
    return this;
  }
  /**
   * Remove an optimizer from the list of optimizers
   * @param optimizer defines the optimizers to remove
   * @returns the current material
   */
  unregisterOptimizer(optimizer) {
    const index = this._optimizers.indexOf(optimizer);
    if (index === -1) {
      return;
    }
    this._optimizers.splice(index, 1);
    return this;
  }
  /**
   * Add a new block to the list of output nodes
   * @param node defines the node to add
   * @returns the current material
   */
  addOutputNode(node) {
    if (node.target === null) {
      throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._addVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._addFragmentOutputNode(node);
    }
    return this;
  }
  /**
   * Remove a block from the list of root nodes
   * @param node defines the node to remove
   * @returns the current material
   */
  removeOutputNode(node) {
    if (node.target === null) {
      return this;
    }
    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
      this._removeVertexOutputNode(node);
    }
    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
      this._removeFragmentOutputNode(node);
    }
    return this;
  }
  _addVertexOutputNode(node) {
    if (this._vertexOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Vertex;
    this._vertexOutputNodes.push(node);
    return this;
  }
  _removeVertexOutputNode(node) {
    const index = this._vertexOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._vertexOutputNodes.splice(index, 1);
    return this;
  }
  _addFragmentOutputNode(node) {
    if (this._fragmentOutputNodes.indexOf(node) !== -1) {
      return;
    }
    node.target = NodeMaterialBlockTargets.Fragment;
    this._fragmentOutputNodes.push(node);
    return this;
  }
  _removeFragmentOutputNode(node) {
    const index = this._fragmentOutputNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this._fragmentOutputNodes.splice(index, 1);
    return this;
  }
  get _supportGlowLayer() {
    if (this._fragmentOutputNodes.length === 0) {
      return false;
    }
    if (this._fragmentOutputNodes.some((f) => f.additionalColor && f.additionalColor.isConnected)) {
      return true;
    }
    return false;
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    if (this.ignoreAlpha) {
      return false;
    }
    return this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._sharedData && this._sharedData.hints.needAlphaTesting;
  }
  _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
      nodesToProcessForOtherBuildState.push(block);
    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
      nodesToProcessForOtherBuildState.push(block);
    }
    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);
  }
  _attachBlock(node) {
    if (this.attachedBlocks.indexOf(node) === -1) {
      if (node.isUnique) {
        const className = node.getClassName();
        for (const other of this.attachedBlocks) {
          if (other.getClassName() === className) {
            this._sharedData.raiseBuildError(`Cannot have multiple blocks of type ${className} in the same NodeMaterial`);
            return;
          }
        }
      }
      this.attachedBlocks.push(node);
    }
  }
  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
    node.initialize(state);
    if (autoConfigure) {
      node.autoConfigure(this);
    }
    node._preparationId = this._buildId;
    this._attachBlock(node);
    for (const input of node.inputs) {
      input.associatedVariableName = "";
      const connectedPoint = input.connectedPoint;
      if (connectedPoint && !connectedPoint._preventBubbleUp) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    }
    if (node.isLoop) {
      const loopBlock = node;
      if (loopBlock.loopID.hasEndpoints) {
        for (const endpoint of loopBlock.loopID.endpoints) {
          const block = endpoint.ownerBlock;
          if (block.outputs.length !== 0) {
            continue;
          }
          state._terminalBlocks.add(block);
          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
        }
      }
    } else if (node.isTeleportOut) {
      const teleport = node;
      if (teleport.entryPoint) {
        this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);
      }
    }
    for (const output of node.outputs) {
      output.associatedVariableName = "";
    }
  }
  _resetDualBlocks(node, id) {
    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
      node.buildId = id;
    }
    for (const input of node.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint && !connectedPoint._preventBubbleUp) {
        const block = connectedPoint.ownerBlock;
        if (block !== node) {
          this._resetDualBlocks(block, id);
        }
      }
    }
    if (node.isTeleportOut) {
      const teleportOut = node;
      if (teleportOut.entryPoint) {
        this._resetDualBlocks(teleportOut.entryPoint, id);
      }
    } else if (node.isLoop) {
      const loopBlock = node;
      if (loopBlock.loopID.hasEndpoints) {
        for (const endpoint of loopBlock.loopID.endpoints) {
          const block = endpoint.ownerBlock;
          if (block.outputs.length !== 0) {
            continue;
          }
          this._resetDualBlocks(block, id);
        }
      }
    }
  }
  /**
   * Remove a block from the current node material
   * @param block defines the block to remove
   */
  removeBlock(block) {
    const attachedBlockIndex = this.attachedBlocks.indexOf(block);
    if (attachedBlockIndex > -1) {
      this.attachedBlocks.splice(attachedBlockIndex, 1);
    }
    if (block.isFinalMerger) {
      this.removeOutputNode(block);
    }
  }
  /**
   * Build the material and generates the inner effect
   * @param verbose defines if the build should log activity
   * @param updateBuildId defines if the internal build Id should be updated (default is true)
   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)
   */
  build(verbose = false, updateBuildId = true, autoConfigure = false) {
    if (this._buildIsInProgress) {
      Logger.Warn("Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.");
      return;
    }
    this._buildIsInProgress = true;
    if (!this._vertexCompilationState && !autoConfigure) {
      autoConfigure = true;
    }
    this._buildWasSuccessful = false;
    const engine = this.getScene().getEngine();
    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle || this._mode === NodeMaterialModes.SFE;
    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
      this.onBuildErrorObservable.notifyObservers("You must define at least one vertexOutputNode");
      this._buildIsInProgress = false;
      return;
    }
    if (this._fragmentOutputNodes.length === 0) {
      this.onBuildErrorObservable.notifyObservers("You must define at least one fragmentOutputNode");
      this._buildIsInProgress = false;
      return;
    }
    this._vertexCompilationState = new NodeMaterialBuildState();
    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
    this._fragmentCompilationState = new NodeMaterialBuildState();
    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
    const needToPurgeList = this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive).length > 1;
    let fragmentOutputNodes = this._fragmentOutputNodes;
    if (needToPurgeList) {
      fragmentOutputNodes = this._fragmentOutputNodes.filter((n) => !n._isFinalOutputAndActive);
      fragmentOutputNodes.push(this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive && n._hasPrecedence)[0]);
    }
    this._sharedData = new NodeMaterialBuildStateSharedData();
    this._sharedData.nodeMaterial = this;
    this._sharedData.fragmentOutputNodes = fragmentOutputNodes;
    this._vertexCompilationState.sharedData = this._sharedData;
    this._fragmentCompilationState.sharedData = this._sharedData;
    this._sharedData.buildId = this._buildId;
    this._sharedData.emitComments = this._options.emitComments;
    this._sharedData.verbose = verbose;
    this._sharedData.scene = this.getScene();
    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
    const vertexNodes = [];
    const fragmentNodes = [];
    for (const vertexOutputNode of this._vertexOutputNodes) {
      vertexNodes.push(vertexOutputNode);
      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);
    }
    for (const fragmentOutputNode of fragmentOutputNodes) {
      fragmentNodes.push(fragmentOutputNode);
      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);
    }
    let waitingNodeCount = 0;
    for (const node of this.attachedBlocks) {
      if (!node.codeIsReady) {
        waitingNodeCount++;
        node.onCodeIsReadyObservable.addOnce(() => {
          waitingNodeCount--;
          if (waitingNodeCount === 0) {
            this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
          }
        });
      }
    }
    if (waitingNodeCount !== 0) {
      return;
    }
    this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
  }
  _finishBuildProcess(verbose = false, updateBuildId = true, vertexNodes, fragmentNodes) {
    this.optimize();
    for (const vertexOutputNode of vertexNodes) {
      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
    }
    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
    this._fragmentCompilationState._vertexState = this._vertexCompilationState;
    for (const fragmentOutputNode of fragmentNodes) {
      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
    }
    for (const fragmentOutputNode of fragmentNodes) {
      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
    }
    this._vertexCompilationState.finalize(this._vertexCompilationState);
    this._fragmentCompilationState.finalize(this._fragmentCompilationState);
    if (updateBuildId) {
      this._buildId = _NodeMaterial._BuildIdGenerator++;
    }
    if (verbose) {
      Logger.Log("Vertex shader:");
      Logger.Log(this._vertexCompilationState.compilationString);
      Logger.Log("Fragment shader:");
      Logger.Log(this._fragmentCompilationState.compilationString);
    }
    const noError = this._sharedData.emitErrors();
    this._buildIsInProgress = false;
    if (noError) {
      this._buildWasSuccessful = true;
      this.onBuildObservable.notifyObservers(this);
    }
    const meshes = this.getScene().meshes;
    for (const mesh of meshes) {
      if (!mesh.subMeshes) {
        continue;
      }
      for (const subMesh of mesh.subMeshes) {
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.materialDefines) {
          continue;
        }
        const defines = subMesh.materialDefines;
        defines.markAllAsDirty();
        defines.reset();
      }
    }
    if (this.prePassTextureInputs.length) {
      this.getScene().enablePrePassRenderer();
    }
    const prePassRenderer = this.getScene().prePassRenderer;
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  }
  /**
   * Runs an optimization phase to try to improve the shader code
   */
  optimize() {
    for (const optimizer of this._optimizers) {
      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
    }
  }
  _prepareDefinesForAttributes(mesh, defines) {
    const oldNormal = defines["NORMAL"];
    const oldTangent = defines["TANGENT"];
    const oldColor = defines["VERTEXCOLOR_NME"];
    defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
    defines["VERTEXCOLOR_NME"] = hasVertexColors;
    let uvChanged = false;
    for (let i = 1; i <= 6; ++i) {
      const oldUV = defines["UV" + i];
      defines["UV" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`);
      uvChanged = uvChanged || defines["UV" + i] !== oldUV;
    }
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(this.getScene(), defines, !oit);
    MaterialHelperGeometryRendering.PrepareDefines(this.getScene().getEngine().currentRenderPassId, mesh, defines);
    if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || oldColor !== defines["VERTEXCOLOR_NME"] || uvChanged) {
      defines.markAsAttributesDirty();
    }
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return true;
  }
  /**
   * Outputs written to the prepass
   */
  get prePassTextureOutputs() {
    const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === "PrePassOutputBlock");
    const result = [4];
    if (!prePassOutputBlock) {
      return result;
    }
    if (this.prePassTextureInputs.length) {
      return result;
    }
    if (prePassOutputBlock.viewDepth.isConnected) {
      result.push(5);
    }
    if (prePassOutputBlock.screenDepth.isConnected) {
      result.push(10);
    }
    if (prePassOutputBlock.viewNormal.isConnected) {
      result.push(6);
    }
    if (prePassOutputBlock.worldNormal.isConnected) {
      result.push(8);
    }
    if (prePassOutputBlock.worldPosition.isConnected) {
      result.push(1);
    }
    if (prePassOutputBlock.localPosition.isConnected) {
      result.push(9);
    }
    if (prePassOutputBlock.reflectivity.isConnected) {
      result.push(3);
    }
    if (prePassOutputBlock.velocity.isConnected) {
      result.push(2);
    }
    if (prePassOutputBlock.velocityLinear.isConnected) {
      result.push(11);
    }
    return result;
  }
  /**
   * Gets the list of prepass texture required
   */
  get prePassTextureInputs() {
    const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === "PrePassTextureBlock");
    const result = [];
    for (const block of prePassTextureBlocks) {
      if (block.position.isConnected && !result.includes(1)) {
        result.push(1);
      }
      if (block.localPosition.isConnected && !result.includes(9)) {
        result.push(9);
      }
      if (block.depth.isConnected && !result.includes(5)) {
        result.push(5);
      }
      if (block.screenDepth.isConnected && !result.includes(10)) {
        result.push(10);
      }
      if (block.normal.isConnected && !result.includes(6)) {
        result.push(6);
      }
      if (block.worldNormal.isConnected && !result.includes(8)) {
        result.push(8);
      }
    }
    return result;
  }
  /**
   * Sets the required values to the prepass renderer.
   * @param prePassRenderer defines the prepass renderer to set
   * @returns true if the pre pass is needed
   */
  setPrePassRenderer(prePassRenderer) {
    const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);
    if (prePassRenderer && prePassTexturesRequired.length > 1) {
      let cfg = prePassRenderer.getEffectConfiguration("nodeMaterial");
      if (!cfg) {
        cfg = prePassRenderer.addEffectConfiguration({
          enabled: true,
          needsImageProcessing: false,
          name: "nodeMaterial",
          texturesRequired: []
        });
      }
      for (const prePassTexture of prePassTexturesRequired) {
        if (!cfg.texturesRequired.includes(prePassTexture)) {
          cfg.texturesRequired.push(prePassTexture);
        }
      }
      cfg.enabled = true;
    }
    return prePassTexturesRequired.length > 1;
  }
  /**
   * Create a post process from the material
   * @param camera The camera to apply the render pass to.
   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType Type of textures used when performing the post process. (default: 0)
   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
   * @returns the post process created
   */
  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    if (this.mode !== NodeMaterialModes.PostProcess && this.mode !== NodeMaterialModes.SFE) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
  }
  /**
   * Create the post process effect from the material
   * @param postProcess The post process to create the effect for
   */
  createEffectForPostProcess(postProcess) {
    this._createEffectForPostProcess(postProcess);
  }
  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
    let tempName = this.name + this._buildId;
    const defines = new NodeMaterialDefines();
    let buildId = this._buildId;
    this._processDefines(defines);
    const vertexCode = this._sharedData.checks.emitVertex ? this._vertexCompilationState._builtCompilationString : void 0;
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, vertexCode, this.shaderLanguage);
    if (!postProcess) {
      postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, vertexCode ? tempName : "postprocess", { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat, this.shaderLanguage);
    } else {
      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
    }
    postProcess.nodeMaterialSource = this;
    postProcess.onApplyObservable.add((effect) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result = this._processDefines(defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName));
      }
      this._checkInternals(effect);
    });
    return postProcess;
  }
  /**
   * Create a new procedural texture based on this node material
   * @param size defines the size of the texture
   * @param scene defines the hosting scene
   * @returns the new procedural texture attached to this node material
   */
  createProceduralTexture(size, scene) {
    if (this.mode !== NodeMaterialModes.ProceduralTexture) {
      Logger.Log("Incompatible material mode");
      return null;
    }
    let tempName = this.name + this._buildId;
    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
    const defines = new NodeMaterialDefines();
    const result = this._processDefines(defines);
    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
    let effect = this.getScene().getEngine().createEffect({
      vertexElement: tempName,
      fragmentElement: tempName
    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result?.fallbacks, void 0, void 0, void 0, this.shaderLanguage);
    proceduralTexture.nodeMaterialSource = this;
    proceduralTexture._setEffect(effect);
    let buildId = this._buildId;
    const refreshEffect = () => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "VertexShader"];
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      const result2 = this._processDefines(defines);
      if (result2) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
        TimingTools.SetImmediate(() => {
          effect = this.getScene().getEngine().createEffect({
            vertexElement: tempName,
            fragmentElement: tempName
          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result2?.fallbacks, void 0);
          proceduralTexture._setEffect(effect);
        });
      }
      this._checkInternals(effect);
    };
    proceduralTexture.onBeforeGenerationObservable.add(() => {
      refreshEffect();
    });
    this.onBuildObservable.add(() => {
      refreshEffect();
    });
    return proceduralTexture;
  }
  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, particleSystemDefinesJoined = "") {
    let tempName = this.name + this._buildId + "_" + blendMode;
    if (!defines) {
      defines = new NodeMaterialDefines();
    }
    let buildId = this._buildId;
    const particleSystemDefines = [];
    let join = particleSystemDefinesJoined;
    if (!effect) {
      const result = this._processDefines(defines);
      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
      particleSystem.fillDefines(particleSystemDefines, blendMode, false);
      join = particleSystemDefines.join("\n");
      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem, this.shaderLanguage);
      particleSystem.setCustomEffect(effect, blendMode);
    }
    effect.onBindObservable.add((effect2) => {
      if (buildId !== this._buildId) {
        delete Effect.ShadersStore[tempName + "PixelShader"];
        tempName = this.name + this._buildId + "_" + blendMode;
        defines.markAllAsDirty();
        buildId = this._buildId;
      }
      particleSystemDefines.length = 0;
      particleSystem.fillDefines(particleSystemDefines, blendMode, false);
      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
      if (particleSystemDefinesJoinedCurrent !== join) {
        defines.markAllAsDirty();
        join = particleSystemDefinesJoinedCurrent;
      }
      const result = this._processDefines(defines);
      if (result) {
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
        effect2 = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem);
        particleSystem.setCustomEffect(effect2, blendMode);
        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, particleSystemDefinesJoined);
        return;
      }
      this._checkInternals(effect2);
    });
  }
  _checkInternals(effect) {
    if (this._sharedData.animatedInputs) {
      const scene = this.getScene();
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    for (const block of this._sharedData.bindableBlocks) {
      block.bind(effect, this);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmit(effect, this.getScene(), this);
    }
  }
  /**
   * Create the effect to be used as the custom effect for a particle system
   * @param particleSystem Particle system to create the effect for
   * @param onCompiled defines a function to call when the effect creation is successful
   * @param onError defines a function to call when the effect creation has failed
   */
  createEffectForParticles(particleSystem, onCompiled, onError) {
    if (this.mode !== NodeMaterialModes.Particle) {
      Logger.Log("Incompatible material mode");
      return;
    }
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
  }
  /**
   * Use this material as the shadow depth wrapper of a target material
   * @param targetMaterial defines the target material
   */
  createAsShadowDepthWrapper(targetMaterial) {
    if (this.mode !== NodeMaterialModes.Material) {
      Logger.Log("Incompatible material mode");
      return;
    }
    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());
  }
  _processDefines(defines, mesh, useInstances = false, subMesh) {
    let result = null;
    const scene = this.getScene();
    if (PrepareDefinesForCamera(scene, defines)) {
      defines.markAsMiscDirty();
    }
    for (const b of this._sharedData.blocksWithDefines) {
      b.initializeDefines(defines);
    }
    for (const b of this._sharedData.blocksWithDefines) {
      b.prepareDefines(defines, this, mesh, useInstances, subMesh);
    }
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
      for (const b of this._sharedData.repeatableContentBlocks) {
        b.replaceRepeatableContent(this._vertexCompilationState, defines, mesh);
      }
      const uniformBuffers = [];
      for (const b of this._sharedData.dynamicUniformBlocks) {
        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);
      }
      const mergedUniforms = this._vertexCompilationState.uniforms;
      for (const u of this._fragmentCompilationState.uniforms) {
        const index = mergedUniforms.indexOf(u);
        if (index === -1) {
          mergedUniforms.push(u);
        }
      }
      const mergedSamplers = this._vertexCompilationState.samplers;
      for (const s of this._fragmentCompilationState.samplers) {
        const index = mergedSamplers.indexOf(s);
        if (index === -1) {
          mergedSamplers.push(s);
        }
      }
      const fallbacks = new EffectFallbacks();
      for (const b of this._sharedData.blocksWithFallbacks) {
        b.provideFallbacks(fallbacks, mesh);
      }
      result = {
        lightDisposed,
        uniformBuffers,
        mergedUniforms,
        mergedSamplers,
        fallbacks
      };
    }
    return result;
  }
  /**
   * Get if the submesh is ready to be used and all its information available.
   * Child classes can use it to update shaders
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._buildWasSuccessful) {
      return false;
    }
    const scene = this.getScene();
    if (this._sharedData.animatedInputs) {
      const frameId = scene.getFrameId();
      if (this._animationFrame !== frameId) {
        for (const input of this._sharedData.animatedInputs) {
          input.animate(scene);
        }
        this._animationFrame = frameId;
      }
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines || typeof subMesh.materialDefines === "string") {
      subMesh.materialDefines = new NodeMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    this._prepareDefinesForAttributes(mesh, defines);
    if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {
      return false;
    }
    const result = this._processDefines(defines, mesh, useInstances, subMesh);
    if (result) {
      const previousEffect = subMesh.effect;
      const join = defines.toString();
      let effect = engine.createEffect({
        vertex: "nodeMaterial" + this._buildId,
        fragment: "nodeMaterial" + this._buildId,
        vertexSource: this._vertexCompilationState.compilationString,
        fragmentSource: this._fragmentCompilationState.compilationString
      }, {
        attributes: this._vertexCompilationState.attributes,
        uniformsNames: result.mergedUniforms,
        uniformBuffersNames: result.uniformBuffers,
        samplers: result.mergedSamplers,
        defines: join,
        fallbacks: result.fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        multiTarget: defines.PREPASS,
        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
        shaderLanguage: this.shaderLanguage
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (result.lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (defines["AREALIGHTUSED"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Get a string representing the shaders built by the current node graph
   */
  get compiledShaders() {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    return `// Vertex shader
${this._vertexCompilationState.compilationString}

// Fragment shader
${this._fragmentCompilationState.compilationString}`;
  }
  /**
   * Get a string representing the fragment shader used by the engine for the current node graph
   * @internal
   */
  async _getProcessedFragmentAsync() {
    if (!this._buildWasSuccessful) {
      this.build();
    }
    const defines = new NodeMaterialDefines();
    this._processDefines(defines);
    let processingDefines = defines.toString();
    if (this.mode === NodeMaterialModes.SFE) {
      processingDefines += `#define ${SfeModeDefine}
`;
    }
    return await this._fragmentCompilationState.getProcessedShaderAsync(processingDefines);
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   */
  bindOnlyWorldMatrix(world) {
    const scene = this.getScene();
    if (!this._activeEffect) {
      return;
    }
    const hints = this._sharedData.hints;
    if (hints.needWorldViewMatrix) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
    }
    if (hints.needWorldViewProjectionMatrix) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
    }
    for (const inputBlock of this._sharedData.inputBlocks) {
      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    const sharedData = this._sharedData;
    if (mustRebind) {
      for (const block of sharedData.bindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
      for (const inputBlock of sharedData.inputBlocks) {
        inputBlock._transmit(effect, scene, this);
      }
    } else if (!this.isFrozen) {
      for (const block of sharedData.forcedBindableBlocks) {
        block.bind(effect, this, mesh, subMesh);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._sharedData) {
      activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture));
    }
    return activeTextures;
  }
  /**
   * Gets the list of texture blocks
   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!
   * @returns an array of texture blocks
   */
  getTextureBlocks() {
    if (!this._sharedData) {
      return [];
    }
    return this._sharedData.textureBlocks;
  }
  /**
   * Gets the list of all texture blocks
   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks
   * @returns
   */
  getAllTextureBlocks() {
    const textureBlocks = [];
    for (const block of this.attachedBlocks) {
      if (_NodeMaterial._BlockIsTextureBlock(block)) {
        textureBlocks.push(block);
      }
    }
    return textureBlocks;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (!this._sharedData) {
      return false;
    }
    for (const t of this._sharedData.textureBlocks) {
      if (t.texture === texture) {
        return true;
      }
    }
    return false;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      for (const texture of this.getTextureBlocks().filter((tb) => tb.texture).map((tb) => tb.texture)) {
        texture.dispose();
      }
    }
    for (const block of this.attachedBlocks) {
      block.dispose();
    }
    this.attachedBlocks.length = 0;
    this._sharedData = null;
    this._vertexCompilationState = null;
    this._fragmentCompilationState = null;
    this.onBuildObservable.clear();
    this.onBuildErrorObservable.clear();
    if (this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
      this._imageProcessingObserver = null;
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /** Creates the node editor window.
   * @param additionalConfig Define the configuration of the editor
   */
  _createNodeEditor(additionalConfig) {
    const nodeEditorConfig = {
      nodeMaterial: this,
      ...additionalConfig
    };
    this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);
  }
  /**
   * Launch the node material editor
   * @param config Define the configuration of the editor
   * @returns a promise fulfilled when the node editor is visible
   */
  async edit(config) {
    return await new Promise((resolve) => {
      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
      if (typeof this.BJSNODEMATERIALEDITOR == "undefined") {
        const editorUrl = config && config.editorURL ? config.editorURL : _NodeMaterial.EditorURL;
        Tools.LoadBabylonScript(editorUrl, () => {
          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
          this._createNodeEditor(config?.nodeEditorConfig);
          resolve();
        });
      } else {
        this._createNodeEditor(config?.nodeEditorConfig);
        resolve();
      }
    });
  }
  /**
   * Clear the current material
   */
  clear() {
    this._vertexOutputNodes.length = 0;
    this._fragmentOutputNodes.length = 0;
    this.attachedBlocks.length = 0;
    this._buildIsInProgress = false;
  }
  /**
   * Clear the current material and set it to a default state
   */
  setToDefault() {
    this.clear();
    this.editorData = null;
    const positionInput = new InputBlock("Position");
    positionInput.setAsAttribute("position");
    const worldInput = new InputBlock("World");
    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
    const worldPos = new TransformBlock("WorldPos");
    positionInput.connectTo(worldPos);
    worldInput.connectTo(worldPos);
    const viewProjectionInput = new InputBlock("ViewProjection");
    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);
    const worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
    worldPos.connectTo(worldPosdMultipliedByViewProjection);
    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
    const pixelColor = new InputBlock("color");
    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    pixelColor.connectTo(fragmentOutput);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Material;
  }
  /**
   * Clear the current material and set it to a default state for post process
   */
  setToDefaultPostProcess() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const scale = new InputBlock("Scale");
    scale.visibleInInspector = true;
    scale.value = new Vector2(1, 1);
    const uv0 = new RemapBlock("uv0");
    position.connectTo(uv0);
    const uv = new MultiplyBlock("UV scale");
    uv0.connectTo(uv);
    scale.connectTo(uv);
    const currentScreen = new CurrentScreenBlock("CurrentScreen");
    uv.connectTo(currentScreen);
    const textureUrl = Tools.GetAssetUrl("https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png");
    currentScreen.texture = new Texture(textureUrl, this.getScene());
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    currentScreen.connectTo(fragmentOutput, { output: "rgba" });
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.PostProcess;
  }
  /**
   * Clear the current material and set it to a default state for procedural texture
   */
  setToDefaultProceduralTexture() {
    this.clear();
    this.editorData = null;
    const position = new InputBlock("Position");
    position.setAsAttribute("position2d");
    const const1 = new InputBlock("Constant1");
    const1.isConstant = true;
    const1.value = 1;
    const vmerger = new VectorMergerBlock("Position3D");
    position.connectTo(vmerger);
    const1.connectTo(vmerger, { input: "w" });
    const vertexOutput = new VertexOutputBlock("VertexOutput");
    vmerger.connectTo(vertexOutput);
    const time = new InputBlock("Time");
    time.value = 0;
    time.min = 0;
    time.max = 0;
    time.isBoolean = false;
    time.matrixMode = 0;
    time.animationType = AnimatedInputBlockTypes.Time;
    time.isConstant = false;
    const color = new InputBlock("Color3");
    color.value = new Color3(1, 1, 1);
    color.isConstant = false;
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    const vectorMerger = new VectorMergerBlock("VectorMerger");
    vectorMerger.visibleInInspector = false;
    const cos = new TrigonometryBlock("Cos");
    cos.operation = TrigonometryBlockOperations.Cos;
    position.connectTo(vectorMerger);
    time.output.connectTo(cos.input);
    cos.output.connectTo(vectorMerger.z);
    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
    this.addOutputNode(vertexOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.ProceduralTexture;
  }
  /**
   * Clear the current material and set it to a default state for particle
   */
  setToDefaultParticle() {
    this.clear();
    this.editorData = null;
    const uv = new InputBlock("uv");
    uv.setAsAttribute("particle_uv");
    const texture = new ParticleTextureBlock("ParticleTexture");
    uv.connectTo(texture);
    const color = new InputBlock("Color");
    color.setAsAttribute("particle_color");
    const multiply = new MultiplyBlock("Texture * Color");
    texture.connectTo(multiply);
    color.connectTo(multiply);
    const rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
    multiply.connectTo(rampGradient);
    const cSplitter = new ColorSplitterBlock("ColorSplitter");
    color.connectTo(cSplitter);
    const blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
    rampGradient.connectTo(blendMultiply);
    texture.connectTo(blendMultiply, { output: "a" });
    cSplitter.connectTo(blendMultiply, { output: "a" });
    const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
    blendMultiply.connectTo(fragmentOutput);
    this.addOutputNode(fragmentOutput);
    this._mode = NodeMaterialModes.Particle;
  }
  /**
   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead
   * @param url defines the url to load from
   * @param rootUrl defines the root URL for nested url in the node material
   * @returns a promise that will fulfil when the material is fully loaded
   */
  async loadAsync(url, rootUrl = "") {
    return await _NodeMaterial.ParseFromFileAsync("", url, this.getScene(), rootUrl, true, this);
  }
  _gatherBlocks(rootNode, list) {
    if (list.indexOf(rootNode) !== -1) {
      return;
    }
    list.push(rootNode);
    for (const input of rootNode.inputs) {
      const connectedPoint = input.connectedPoint;
      if (connectedPoint) {
        const block = connectedPoint.ownerBlock;
        if (block !== rootNode) {
          this._gatherBlocks(block, list);
        }
      }
    }
    if (rootNode.isTeleportOut) {
      const block = rootNode;
      if (block.entryPoint) {
        this._gatherBlocks(block.entryPoint, list);
      }
    }
  }
  /**
   * Generate a string containing the code declaration required to create an equivalent of this material
   * @returns a string
   */
  generateCode() {
    let alreadyDumped = [];
    const vertexBlocks = [];
    const uniqueNames = ["const", "var", "let"];
    for (const outputNode of this._vertexOutputNodes) {
      this._gatherBlocks(outputNode, vertexBlocks);
    }
    const fragmentBlocks = [];
    for (const outputNode of this._fragmentOutputNodes) {
      this._gatherBlocks(outputNode, fragmentBlocks);
    }
    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name || "node material"}");
`;
    codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};
`;
    for (const node of vertexBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    for (const node of fragmentBlocks) {
      if (node.isInput && alreadyDumped.indexOf(node) === -1) {
        codeString += node._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    alreadyDumped = [];
    codeString += "\n// Connections\n";
    for (const node of this._vertexOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += node._dumpCodeForOutputConnections(alreadyDumped);
    }
    codeString += "\n// Output nodes\n";
    for (const node of this._vertexOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    for (const node of this._fragmentOutputNodes) {
      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
    }
    codeString += `nodeMaterial.build();
`;
    return codeString;
  }
  /**
   * Serializes this material in a JSON representation
   * @param selectedBlocks defines an optional list of blocks to serialize
   * @returns the serialized material object
   */
  serialize(selectedBlocks) {
    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
    let blocks = [];
    if (selectedBlocks) {
      blocks = selectedBlocks;
    } else {
      serializationObject.customType = "BABYLON.NodeMaterial";
      serializationObject.outputNodes = [];
      for (const outputNode of this._vertexOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        serializationObject.outputNodes.push(outputNode.uniqueId);
      }
      for (const outputNode of this._fragmentOutputNodes) {
        this._gatherBlocks(outputNode, blocks);
        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
          serializationObject.outputNodes.push(outputNode.uniqueId);
        }
      }
    }
    serializationObject.blocks = [];
    for (const block of blocks) {
      serializationObject.blocks.push(block.serialize());
    }
    if (!selectedBlocks) {
      for (const block of this.attachedBlocks) {
        if (blocks.indexOf(block) !== -1) {
          continue;
        }
        serializationObject.blocks.push(block.serialize());
      }
    }
    serializationObject.uniqueId = this.uniqueId;
    return serializationObject;
  }
  _restoreConnections(block, source, map) {
    for (const outputPoint of block.outputs) {
      for (const candidate of source.blocks) {
        const target = map[candidate.id];
        if (!target) {
          continue;
        }
        for (const input of candidate.inputs) {
          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
            const inputPoint = target.getInputByName(input.inputName);
            if (!inputPoint || inputPoint.isConnected) {
              continue;
            }
            outputPoint.connectTo(inputPoint, true);
            this._restoreConnections(target, source, map);
            continue;
          }
        }
      }
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   * @param urlRewriter defines a function used to rewrite urls
   */
  parseSerializedObject(source, rootUrl = "", merge = false, urlRewriter) {
    if (!merge) {
      this.clear();
    }
    const map = {};
    for (const parsedBlock of source.blocks) {
      const blockType = GetClass(parsedBlock.customType);
      if (blockType) {
        const block = new blockType();
        block._deserialize(parsedBlock, this.getScene(), rootUrl, urlRewriter);
        map[parsedBlock.id] = block;
        this.attachedBlocks.push(block);
      }
    }
    for (const block of this.attachedBlocks) {
      if (block.isTeleportOut) {
        const teleportOut = block;
        const id = teleportOut._tempEntryPointUniqueId;
        if (id) {
          const source2 = map[id];
          source2.attachToEndpoint(teleportOut);
        }
      }
    }
    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
      const parsedBlock = source.blocks[blockIndex];
      const block = map[parsedBlock.id];
      if (!block) {
        continue;
      }
      if (block.inputs.length && !merge) {
        continue;
      }
      this._restoreConnections(block, source, map);
    }
    if (source.outputNodes) {
      for (const outputNodeId of source.outputNodes) {
        this.addOutputNode(map[outputNodeId]);
      }
    }
    if (source.locations || source.editorData && source.editorData.locations) {
      const locations = source.locations || source.editorData.locations;
      for (const location of locations) {
        if (map[location.blockId]) {
          location.blockId = map[location.blockId].uniqueId;
        }
      }
      if (merge && this.editorData && this.editorData.locations) {
        locations.concat(this.editorData.locations);
      }
      if (source.locations) {
        this.editorData = {
          locations
        };
      } else {
        this.editorData = source.editorData;
        this.editorData.locations = locations;
      }
      const blockMap = {};
      for (const key in map) {
        blockMap[key] = map[key].uniqueId;
      }
      this.editorData.map = blockMap;
    }
    Material.ParseAlphaMode(source, this);
    if (!merge) {
      this._mode = source.mode ?? NodeMaterialModes.Material;
    }
  }
  /**
   * Clear the current graph and load a new one from a serialization object
   * @param source defines the JSON representation of the material
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param merge defines whether or not the source must be merged or replace the current content
   * @deprecated Please use the parseSerializedObject method instead
   */
  loadFromSerialization(source, rootUrl = "", merge = false) {
    SerializationHelper.ParseProperties(source, this, this.getScene(), rootUrl);
    this.parseSerializedObject(source, rootUrl, merge);
  }
  /**
   * Makes a duplicate of the current material.
   * @param name defines the name to use for the new material
   * @param shareEffect defines if the clone material should share the same effect (default is false)
   * @returns the cloned material
   */
  clone(name6, shareEffect = false) {
    const serializationObject = this.serialize();
    const clone = SerializationHelper.Clone(() => new _NodeMaterial(name6, this.getScene(), this.options), this);
    clone.id = name6;
    clone.name = name6;
    clone.parseSerializedObject(serializationObject);
    clone._buildId = this._buildId;
    clone.build(false, !shareEffect);
    return clone;
  }
  /**
   * Awaits for all the material textures to be ready before resolving the returned promise.
   * @returns A promise that resolves when the textures are ready.
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  whenTexturesReadyAsync() {
    const textureReadyPromises = [];
    const activeTextures = this.getActiveTextures();
    for (const texture of activeTextures) {
      const internalTexture = texture.getInternalTexture();
      if (internalTexture && !internalTexture.isReady) {
        textureReadyPromises.push(new Promise((textureResolve, textureReject) => {
          internalTexture.onLoadedObservable.addOnce(() => {
            textureResolve();
          });
          internalTexture.onErrorObservable.addOnce((e) => {
            textureReject(e);
          });
        }));
      }
    }
    return Promise.all(textureReadyPromises);
  }
  /**
   * Creates a node material from parsed material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param shaderLanguage defines the language to use (GLSL by default)
   * @returns a new node material
   */
  static Parse(source, scene, rootUrl = "", shaderLanguage = 0) {
    const nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(source.name, scene, { shaderLanguage }), source, scene, rootUrl);
    nodeMaterial.parseSerializedObject(source, rootUrl);
    nodeMaterial.build();
    return nodeMaterial;
  }
  /**
   * Creates a node material from a snippet saved in a remote file
   * @param name defines the name of the material to create
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL for nested url in the node material
   * @param skipBuild defines whether to build the node material
   * @param targetMaterial defines a material to use instead of creating a new one
   * @param urlRewriter defines a function used to rewrite urls
   * @param options defines options to be used with the node material
   * @returns a promise that will resolve to the new node material
   */
  static async ParseFromFileAsync(name6, url, scene, rootUrl = "", skipBuild = false, targetMaterial, urlRewriter, options) {
    const material = targetMaterial ?? new _NodeMaterial(name6, scene, options);
    const data = await scene._loadFileAsync(url);
    const serializationObject = JSON.parse(data);
    material.parseSerializedObject(serializationObject, rootUrl, void 0, urlRewriter);
    if (!skipBuild) {
      material.build();
    }
    return material;
  }
  /**
   * Creates a node material from a snippet saved by the node material editor
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @param nodeMaterial defines a node material to update (instead of creating a new one)
   * @param skipBuild defines whether to build the node material
   * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)
   * @param urlRewriter defines a function used to rewrite urls
   * @param options defines options to be used with the node material
   * @returns a promise that will resolve to the new node material
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = "", nodeMaterial, skipBuild = false, waitForTextureReadyness = false, urlRewriter, options) {
    if (snippetId === "_BLANK") {
      return Promise.resolve(_NodeMaterial.CreateDefault("blank", scene));
    }
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.nodeMaterial);
            if (!nodeMaterial) {
              nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(snippetId, scene, options), serializationObject, scene, rootUrl);
              nodeMaterial.uniqueId = scene.getUniqueId();
            }
            nodeMaterial.parseSerializedObject(serializationObject, void 0, void 0, urlRewriter);
            nodeMaterial.snippetId = snippetId;
            nodeMaterial.sideOrientation = null;
            try {
              if (!skipBuild) {
                nodeMaterial.build();
              }
            } catch (err) {
              reject(err);
            }
            if (waitForTextureReadyness) {
              nodeMaterial.whenTexturesReadyAsync().then(() => {
                resolve(nodeMaterial);
              }).catch((err) => {
                reject(err);
              });
            } else {
              resolve(nodeMaterial);
            }
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
  /**
   * Creates a new node material set to default basic configuration
   * @param name defines the name of the material
   * @param scene defines the hosting scene
   * @returns a new NodeMaterial
   */
  static CreateDefault(name6, scene) {
    const newMaterial = new _NodeMaterial(name6, scene);
    newMaterial.setToDefault();
    newMaterial.build();
    return newMaterial;
  }
};
NodeMaterial._BuildIdGenerator = 0;
NodeMaterial.EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeEditor/babylon.nodeEditor.js`;
NodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
NodeMaterial.IgnoreTexturesAtLoadTime = false;
NodeMaterial.AllowSerializationOfRenderTargetTextures = false;
NodeMaterial.DefaultShaderLanguage = 0;
NodeMaterial.UseNativeShaderLanguageOfEngine = false;
__decorate([
  serialize()
], NodeMaterial.prototype, "ignoreAlpha", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("mode")
], NodeMaterial.prototype, "_mode", void 0);
__decorate([
  serialize("comment")
], NodeMaterial.prototype, "comment", void 0);
__decorate([
  serialize()
], NodeMaterial.prototype, "forceAlphaBlending", void 0);
RegisterClass("BABYLON.NodeMaterial", NodeMaterial);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/imageSourceBlock.js
var ImageSourceBlock = class _ImageSourceBlock extends NodeMaterialBlock {
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    return this._texture;
  }
  set texture(texture) {
    if (this._texture === texture) {
      return;
    }
    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get samplerName() {
    return this._samplerName;
  }
  /**
   * Creates a new ImageSourceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("source", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, 1, _ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("dimensions", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  bind(effect, _nodeMaterial) {
    if (!this.texture) {
      return;
    }
    effect.setTexture(this._samplerName, this.texture);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ImageSourceBlock";
  }
  /**
   * Gets the output component
   */
  get source() {
    return this._outputs[0];
  }
  /**
   * Gets the dimension component
   */
  get dimensions() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      this._samplerName = state._getFreeVariableName(this.name);
      state.sharedData.blockingBlocks.push(this);
      state.sharedData.textureBlocks.push(this);
      state.sharedData.bindableBlocks.push(this);
    }
    if (this.dimensions.isConnected) {
      let affect = "";
      if (state.shaderLanguage === 1) {
        affect = `vec2f(textureDimensions(${this._samplerName}, 0).xy)`;
      } else {
        affect = `vec2(textureSize(${this._samplerName}, 0).xy)`;
      }
      state.compilationString += `${state._declareOutput(this.dimensions)} = ${affect};
`;
    }
    if (this._texture?._texture?.is2DArray) {
      state._emit2DArraySampler(this._samplerName);
    } else {
      state._emit2DSampler(this._samplerName);
    }
    return this;
  }
  _dumpPropertiesCode(ignoreTexture = false) {
    let codeString = super._dumpPropertiesCode();
    if (!this.texture || ignoreTexture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`;
    return codeString;
  }
  serialize(ignoreTexture = false) {
    const serializationObject = super.serialize();
    if (!ignoreTexture && this.texture && (NodeMaterial.AllowSerializationOfRenderTargetTextures || !this.texture.isRenderTarget) && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl, urlRewriter) {
    super._deserialize(serializationObject, scene, rootUrl, urlRewriter);
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {
      if (serializationObject.texture.url !== void 0) {
        if (serializationObject.texture.url.indexOf("data:") === 0) {
          rootUrl = "";
        } else if (urlRewriter) {
          serializationObject.texture.url = urlRewriter(serializationObject.texture.url);
          serializationObject.texture.name = serializationObject.texture.url;
        }
      }
      if (serializationObject.texture.base64String || serializationObject.texture.url !== void 0) {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
  }
};
RegisterClass("BABYLON.ImageSourceBlock", ImageSourceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/ambientOcclusionBlock.js
var AmbientOcclusionBlock = class extends NodeMaterialBlock {
  /**
   * Create a new AmbientOcclusionBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.radius = 1e-4;
    this.area = 75e-4;
    this.fallOff = 1e-6;
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, 0, ImageSourceBlock, "ImageSourceBlock"));
    this.registerInput("screenSize", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("occlusion", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "AmbientOcclusionBlock";
  }
  /**
   * Gets the source component
   */
  get source() {
    return this._inputs[0];
  }
  /**
   * Gets the screenSize component
   */
  get screenSize() {
    return this._inputs[1];
  }
  /**
   * Gets the occlusion output
   */
  get occlusion() {
    return this._outputs[0];
  }
  bind(effect) {
    if (!this._randomTexture) {
      this._createRandomTexture(effect.getEngine());
    }
    effect.setTexture(this._randomSamplerName, this._randomTexture);
  }
  _createRandomTexture(engine) {
    const size = 512;
    const data = new Uint8Array(size * size * 4);
    for (let index = 0; index < data.length; ) {
      data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
      data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
      data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
      data[index++] = 255;
    }
    const texture = RawTexture.CreateRGBATexture(data, size, size, engine, false, false, 2);
    texture.name = "SSAORandomTexture";
    texture.wrapU = Texture.WRAP_ADDRESSMODE;
    texture.wrapV = Texture.WRAP_ADDRESSMODE;
    this._randomTexture = texture;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.source.connectedPoint) {
      return this;
    }
    state.sharedData.bindableBlocks.push(this);
    const depthSource = this.source.connectedPoint.ownerBlock;
    const occlusion = this._outputs[0];
    const screenSize = this.screenSize;
    let functionString;
    if (state.shaderLanguage === 1) {
      functionString = `fn normalFromDepth(depth: f32, coords: vec2f, radius: f32) -> vec3f {
                let offset1: vec2f = vec2f(0.0, radius);
                let offset2: vec2f = vec2f(radius, 0.0);

                let depth1: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset1, 0.0).r;
                let depth2: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset2, 0.0).r;

                let p1: vec3f = vec3f(offset1, depth1 - depth);
                let p2: vec3f = vec3f(offset2, depth2 - depth);

                var normal: vec3f = cross(p1, p2);
                normal.z = -normal.z;

                return normalize(normal);
            }
            `;
    } else {
      functionString = `vec3 normalFromDepth(float depth, vec2 coords, float radius) {
                vec2 offset1 = vec2(0.0, radius);
                vec2 offset2 = vec2(radius, 0.0);

                float depth1 = textureLod(${depthSource.samplerName}, coords + offset1, 0.0).r;
                float depth2 = textureLod(${depthSource.samplerName}, coords + offset2, 0.0).r;

                vec3 p1 = vec3(offset1, depth1 - depth);
                vec3 p2 = vec3(offset2, depth2 - depth);

                vec3 normal = cross(p1, p2);
                normal.z = -normal.z;

                return normalize(normal);
            }
            `;
    }
    state._emitFunction("normalFromDepth", functionString, "// normalFromDepth function");
    this._randomSamplerName = state._getFreeVariableName("randomSampler");
    state._emit2DSampler(this._randomSamplerName);
    if (state.shaderLanguage === 1) {
      functionString = `
            const sampleSphere: array<vec3f, 16> = array<vec3f, 16>(
                vec3f( 0.5381,  0.1856, -0.4319),
                vec3f( 0.1379,  0.2486,  0.4430),
                vec3f( 0.3371,  0.5679, -0.0057),
                vec3f(-0.6999, -0.0451, -0.0019),
                vec3f( 0.0689, -0.1598, -0.8547),
                vec3f( 0.0560,  0.0069, -0.1843),
                vec3f(-0.0146,  0.1402,  0.0762),
                vec3f( 0.0100, -0.1924, -0.0344),
                vec3f(-0.3577, -0.5301, -0.4358),
                vec3f(-0.3169,  0.1063,  0.0158),
                vec3f( 0.0103, -0.5869,  0.0046),
                vec3f(-0.0897, -0.4940,  0.3287),
                vec3f( 0.7119, -0.0154, -0.0918),
                vec3f(-0.0533,  0.0596, -0.5411),
                vec3f( 0.0352, -0.0631,  0.5460),
                vec3f(-0.4776,  0.2847, -0.0271)
            );

            fn computeOcclusion(screenSize: vec2f) -> f32 {
                let uv: vec2f = fragmentInputs.position.xy / screenSize;
                let random: vec3f = normalize(textureSampleLevel(${this._randomSamplerName}, ${this._randomSamplerName}Sampler, uv * 4.0, 0.0).rgb);
                let depth: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, uv, 0.0).r;
                let position: vec3f = vec3f(uv, depth);
                let normal: vec3f = normalFromDepth(depth, uv, ${this.radius}f);

                let radiusDepth: f32 = ${this.radius}f / depth;
                var occlusion: f32 = 0.0;

                var ray: vec3f;
                var hemiRay: vec3f;
                var occlusionDepth: f32;
                var difference: f32;

                for (var i: i32 = 0; i < 16; i++)
                {
                    ray = radiusDepth * reflect(sampleSphere[i], random);
                    hemiRay = position + sign(dot(ray, normal)) * ray;

                    occlusionDepth = textureSample(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, clamp(hemiRay.xy, vec2f(0.001, 0.001), vec2f(0.999, 0.999))).r;
                    difference = depth - occlusionDepth;

                    occlusion += step(${this.fallOff}f, difference) * (1.0 - smoothstep(${this.fallOff}f, ${this.area}f, difference));
                }

                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);
            }
            `;
    } else {
      functionString = `
            const vec3 sampleSphere[16] = vec3[](
                vec3( 0.5381,  0.1856, -0.4319),
                vec3( 0.1379,  0.2486,  0.4430),
                vec3( 0.3371,  0.5679, -0.0057),
                vec3(-0.6999, -0.0451, -0.0019),
                vec3( 0.0689, -0.1598, -0.8547),
                vec3( 0.0560,  0.0069, -0.1843),
                vec3(-0.0146,  0.1402,  0.0762),
                vec3( 0.0100, -0.1924, -0.0344),
                vec3(-0.3577, -0.5301, -0.4358),
                vec3(-0.3169,  0.1063,  0.0158),
                vec3( 0.0103, -0.5869,  0.0046),
                vec3(-0.0897, -0.4940,  0.3287),
                vec3( 0.7119, -0.0154, -0.0918),
                vec3(-0.0533,  0.0596, -0.5411),
                vec3( 0.0352, -0.0631,  0.5460),
                vec3(-0.4776,  0.2847, -0.0271)
            );

            float computeOcclusion(vec2 screenSize) {
                vec2 uv = gl_FragCoord.xy / screenSize;
                vec3 random = normalize(textureLod(${this._randomSamplerName}, uv * 4., 0.0).rgb);
                float depth = textureLod(${depthSource.samplerName}, uv, 0.0).r;              
                vec3 position = vec3(uv, depth);
                vec3 normal = normalFromDepth(depth, uv, ${this.radius} );

                float radiusDepth = ${this.radius} / depth;
                float occlusion = 0.0;

                vec3 ray;
                vec3 hemiRay;
                float occlusionDepth;
                float difference;

                for (int i = 0; i < 16; i++)
                {
                    ray = radiusDepth * reflect(sampleSphere[i], random);
                    hemiRay = position + sign(dot(ray, normal)) * ray;

                    occlusionDepth = texture2D(${depthSource.samplerName}, clamp(hemiRay.xy, vec2(0.001, 0.001), vec2(0.999, 0.999))).r;
                    difference = depth - occlusionDepth;

                    occlusion += step(${this.fallOff}, difference) * (1.0 - smoothstep(${this.fallOff}, ${this.area}, difference));
                }

                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);
            }
            `;
    }
    state._emitFunction("computeOcclusion", functionString, "// computeOcclusion function");
    state.compilationString += state._declareOutput(occlusion) + ` = computeOcclusion(${screenSize.associatedVariableName});`;
    return this;
  }
  dispose() {
    if (this._randomTexture) {
      this._randomTexture.dispose();
      this._randomTexture = null;
    }
    super.dispose();
  }
};
__decorate([
  editableInPropertyPage("radius", 1, "ADVANCED", {
    min: 1e-4
  })
], AmbientOcclusionBlock.prototype, "radius", void 0);
__decorate([
  editableInPropertyPage("area", 1, "ADVANCED", {
    min: 0
  })
], AmbientOcclusionBlock.prototype, "area", void 0);
__decorate([
  editableInPropertyPage("fallOff", 1, "ADVANCED", {
    min: 0
  })
], AmbientOcclusionBlock.prototype, "fallOff", void 0);
RegisterClass("BABYLON.AmbientOcclusionBlock", AmbientOcclusionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/fogBlock.js
var FogBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FogBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment, false);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("fogColor", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.input.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this.fogColor.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FogBlock";
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the view input component
   */
  get view() {
    return this._inputs[1];
  }
  /**
   * Gets the color input component
   */
  get input() {
    return this._inputs[2];
  }
  /**
   * Gets the fog color input component
   */
  get fogColor() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  initialize(state) {
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await import("./fogFragmentDeclaration-ZLLHMU6Y.js");
    } else {
      await import("./fogFragmentDeclaration-LQY26APA.js");
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
    if (!this.fogColor.isConnected) {
      let fogColorInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.FogColor && additionalFilteringInfo(b));
      if (!fogColorInput) {
        fogColorInput = new InputBlock("fogColor", void 0, NodeMaterialBlockConnectionPointTypes.Color3);
        fogColorInput.setAsSystemValue(NodeMaterialSystemValues.FogColor);
      }
      fogColorInput.output.connectTo(this.fogColor);
    }
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    defines.setValue("FOG", nodeMaterial.fogEnabled && GetFogState(mesh, scene));
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    effect.setFloat4(this._fogParameters, scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
      let replaceStrings = [];
      let prefix1 = "";
      let prefix2 = "";
      if (state.shaderLanguage === 1) {
        replaceStrings = [
          { search: /fn CalcFogFactor\(\)/, replace: "fn CalcFogFactor(vFogDistance: vec3f, vFogInfos: vec4f)" },
          { search: /uniforms.vFogInfos/g, replace: "vFogInfos" },
          { search: /fragmentInputs.vFogDistance/g, replace: "vFogDistance" }
        ];
        prefix1 = "fragmentInputs.";
        prefix2 = "uniforms.";
      } else {
        replaceStrings = [{ search: /float CalcFogFactor\(\)/, replace: "float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)" }];
      }
      state._emitFunctionFromInclude("fogFragmentDeclaration", `//${this.name}`, {
        removeUniforms: true,
        removeVaryings: true,
        removeIfDef: false,
        replaceStrings
      });
      const tempFogVariablename = state._getFreeVariableName("fog");
      const color = this.input;
      const fogColor = this.fogColor;
      this._fogParameters = state._getFreeVariableName("fogParameters");
      const output = this._outputs[0];
      state._emitUniformFromString(this._fogParameters, NodeMaterialBlockConnectionPointTypes.Vector4);
      state.compilationString += `#ifdef FOG
`;
      state.compilationString += `${state._declareLocalVar(tempFogVariablename, NodeMaterialBlockConnectionPointTypes.Float)} = CalcFogFactor(${prefix1}${this._fogDistanceName}, ${prefix2}${this._fogParameters});
`;
      state.compilationString += state._declareOutput(output) + ` = ${tempFogVariablename} * ${color.associatedVariableName}.rgb + (1.0 - ${tempFogVariablename}) * ${fogColor.associatedVariableName}.rgb;
`;
      state.compilationString += `#else
${state._declareOutput(output)} =  ${color.associatedVariableName}.rgb;
`;
      state.compilationString += `#endif
`;
    } else {
      const worldPos = this.worldPosition;
      const view = this.view;
      this._fogDistanceName = state._getFreeVariableName("vFogDistance");
      state._emitVaryingFromString(this._fogDistanceName, NodeMaterialBlockConnectionPointTypes.Vector3);
      const prefix = state.shaderLanguage === 1 ? "vertexOutputs." : "";
      state.compilationString += `${prefix}${this._fogDistanceName} = (${view.associatedVariableName} * ${worldPos.associatedVariableName}).xyz;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.FogBlock", FogBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/lightBlock.js
var LightBlock = class extends NodeMaterialBlock {
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    if (that.worldPosition.isConnected) {
      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;
      Logger.Error("The worldPosition input must not be connected to be able to switch!");
      return false;
    }
    that._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  /**
   * Create a new LightBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this._lightId = 0;
    this.generateOnlyFragmentCode = false;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("glossiness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("glossPower", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("diffuseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("specularColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, true);
    this.registerOutput("diffuseOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularOutput", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "LightBlock";
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[1];
  }
  /**
   * Gets the camera (or eye) position component
   */
  get cameraPosition() {
    return this._inputs[2];
  }
  /**
   * Gets the glossiness component
   */
  get glossiness() {
    return this._inputs[3];
  }
  /**
   * Gets the glossiness power component
   */
  get glossPower() {
    return this._inputs[4];
  }
  /**
   * Gets the diffuse color component
   */
  get diffuseColor() {
    return this._inputs[5];
  }
  /**
   * Gets the specular color component
   */
  get specularColor() {
    return this._inputs[6];
  }
  /**
   * Gets the view matrix component
   */
  get view() {
    return this._inputs[7];
  }
  /**
   * Gets the diffuse output component
   */
  get diffuseOutput() {
    return this._outputs[0];
  }
  /**
   * Gets the specular output component
   */
  get specularOutput() {
    return this._outputs[1];
  }
  /**
   * Gets the shadow output component
   */
  get shadow() {
    return this._outputs[2];
  }
  initialize(state) {
    this._initShaderSourceAsync(state.shaderLanguage);
    state._excludeVariableName("vViewDepth");
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./lightFragment-4Q5WSWNF.js"),
        import("./lightUboDeclaration-Z45CSO64.js"),
        import("./lightVxUboDeclaration-K5NIOSC5.js"),
        import("./helperFunctions-MOSZRSGX.js"),
        import("./lightsFragmentFunctions-CQWVVVRS.js"),
        import("./shadowsFragmentFunctions-VRQ5DL7N.js"),
        import("./shadowsVertex-XJH4XQ4M.js")
      ]);
    } else {
      await Promise.all([
        import("./lightFragmentDeclaration-333377TP.js"),
        import("./lightFragment-LUEZAPQG.js"),
        import("./lightUboDeclaration-ZQLW2FFI.js"),
        import("./lightVxUboDeclaration-2DGLOHW2.js"),
        import("./lightVxFragmentDeclaration-ZBNBASNV.js"),
        import("./helperFunctions-CPXXYXMJ.js"),
        import("./lightsFragmentFunctions-W2FHMSE5.js"),
        import("./shadowsFragmentFunctions-RQCBMNAS.js"),
        import("./shadowsVertex-75HKRQKQ.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh || !defines._areLightsDirty) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
    } else {
      const state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  }
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
    state.samplers.push("areaLightsLTC1Sampler");
    state.samplers.push("areaLightsLTC2Sampler");
    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      const onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList, defines["IESLIGHTTEXTURE" + lightIndex], defines["CLUSTLIGHT" + lightIndex]);
    }
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      BindLight(this.light, this._lightId, scene, effect, true);
    }
  }
  _injectVertexCode(state) {
    const worldPos = this.worldPosition;
    const comments = `//${this.name}`;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    const worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {
      state.compilationString += (state.shaderLanguage === 1 ? "vertexOutputs." : "") + `${worldPosVaryingName} = ${worldPos.associatedVariableName};
`;
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += `${state._declareLocalVar("worldPos", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldPos.associatedVariableName};
`;
      if (this.view.isConnected) {
        state.compilationString += `${state._declareLocalVar("view", NodeMaterialBlockConnectionPointTypes.Matrix)} = ${this.view.associatedVariableName};
`;
        state._emitVaryingFromString("vViewDepth", NodeMaterialBlockConnectionPointTypes.Float);
        state.compilationString += (state.shaderLanguage === 1 ? "vertexOutputs." : "") + `vViewDepth = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;
`;
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  }
  _injectUBODeclaration(state) {
    const comments = `//${this.name}`;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? "varying," : void 0
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const isWGSL = state.shaderLanguage === 1;
    const addF = isWGSL ? "f" : "";
    const comments = `//${this.name}`;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (this.generateOnlyFragmentCode) {
      state.sharedData.dynamicUniformBlocks.push(this);
    }
    const accessor = isWGSL ? "fragmentInputs." : "";
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    const worldPos = this.worldPosition;
    let worldPosVariableName = worldPos.associatedVariableName;
    if (this.generateOnlyFragmentCode) {
      worldPosVariableName = state._getFreeVariableName("globalWorldPos");
      state._emitFunction("light_globalworldpos", `${state._declareLocalVar(worldPosVariableName, NodeMaterialBlockConnectionPointTypes.Vector3, false, true)};
`, comments);
      state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;
`;
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: `worldPos,${worldPos.associatedVariableName}`
      });
    } else {
      worldPosVariableName = accessor + "v_" + worldPosVariableName + ".xyz";
    }
    state._emitFunctionFromInclude("helperFunctions", comments);
    let replaceString = { search: /vPositionW/g, replace: worldPosVariableName };
    if (isWGSL) {
      replaceString = { search: /fragmentInputs\.vPositionW/g, replace: worldPosVariableName };
    }
    state._emitFunctionFromInclude("lightsFragmentFunctions", comments, {
      replaceStrings: [replaceString]
    });
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments, {
      replaceStrings: [replaceString]
    });
    this._injectUBODeclaration(state);
    if (this._lightId === 0) {
      if (state._registerTempVariable("viewDirectionW")) {
        state.compilationString += `${state._declareLocalVar("viewDirectionW", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});
`;
      }
      if (this.generateOnlyFragmentCode && this.view.isConnected) {
        state.compilationString += `${state._declareLocalVar("vViewDepth", NodeMaterialBlockConnectionPointTypes.Float)} = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;
`;
      }
      state.compilationString += isWGSL ? `var info: lightingInfo;
` : `lightingInfo info;
`;
      state.compilationString += `${state._declareLocalVar("shadow", NodeMaterialBlockConnectionPointTypes.Float)} = 1.;
`;
      state.compilationString += `${state._declareLocalVar("aggShadow", NodeMaterialBlockConnectionPointTypes.Float)} = 0.;
`;
      state.compilationString += `${state._declareLocalVar("numLights", NodeMaterialBlockConnectionPointTypes.Float)} = 0.;
`;
      state.compilationString += `${state._declareLocalVar("glossiness", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : "1.0"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : "1024.0"};
`;
      state.compilationString += `${state._declareLocalVar("diffuseBase", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3${addF}(0., 0., 0.);
`;
      state.compilationString += `${state._declareLocalVar("specularBase", NodeMaterialBlockConnectionPointTypes.Vector3)}  = vec3${addF}(0., 0., 0.);
`;
      state.compilationString += `${state._declareLocalVar("normalW", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;
`;
    }
    if (this.light) {
      let replaceString2 = [{ search: /vPositionW/g, replace: worldPosVariableName + ".xyz" }];
      if (isWGSL) {
        replaceString2 = [
          { search: /fragmentInputs\.vPositionW/g, replace: worldPosVariableName + ".xyz" },
          { search: /uniforms\.vReflectivityColor/g, replace: "vReflectivityColor" }
        ];
      }
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }, ...replaceString2]
      });
    } else {
      let substitutionVars = `vPositionW,${worldPosVariableName}.xyz`;
      if (isWGSL) {
        substitutionVars = `fragmentInputs.vPositionW,${worldPosVariableName}.xyz`;
        if (this.generateOnlyFragmentCode) {
          substitutionVars += `,fragmentInputs.vViewDepth,vViewDepth`;
        }
      }
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars
      });
    }
    if (this._lightId === 0) {
      state.compilationString += `aggShadow = aggShadow / numLights;
`;
    }
    const diffuseOutput = this.diffuseOutput;
    const specularOutput = this.specularOutput;
    state.compilationString += state._declareOutput(diffuseOutput) + ` = diffuseBase${this.diffuseColor.isConnected ? " * " + this.diffuseColor.associatedVariableName : ""};
`;
    if (specularOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(specularOutput) + ` = specularBase${this.specularColor.isConnected ? " * " + this.specularColor.associatedVariableName : ""};
`;
    }
    if (this.shadow.hasEndpoints) {
      state.compilationString += state._declareOutput(this.shadow) + ` = aggShadow;
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Generate only fragment code", 0, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], LightBlock.prototype, "generateOnlyFragmentCode", void 0);
RegisterClass("BABYLON.LightBlock", LightBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/textureBlock.js
var TextureBlock = class _TextureBlock extends NodeMaterialBlock {
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    if (this.source.isConnected) {
      return (this.source.connectedPoint?.ownerBlock).texture;
    }
    return this._texture;
  }
  set texture(texture) {
    if (this._texture === texture) {
      return;
    }
    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  static _IsPrePassTextureBlock(block) {
    return block?.getClassName() === "PrePassTextureBlock";
  }
  get _isSourcePrePass() {
    return _TextureBlock._IsPrePassTextureBlock(this._imageSource);
  }
  /**
   * Gets the sampler name associated with this texture
   */
  get samplerName() {
    if (this._imageSource) {
      if (!_TextureBlock._IsPrePassTextureBlock(this._imageSource)) {
        return this._imageSource.samplerName;
      }
      if (this.source.connectedPoint) {
        return this._imageSource.getSamplerName(this.source.connectedPoint);
      }
    }
    return this._samplerName;
  }
  /**
   * Gets a boolean indicating that this block is linked to an ImageSourceBlock
   */
  get hasImageSource() {
    return this.source.isConnected;
  }
  /**
   * Gets or sets a boolean indicating if content needs to be converted to gamma space
   */
  set convertToGammaSpace(value) {
    if (value === this._convertToGammaSpace) {
      return;
    }
    this._convertToGammaSpace = value;
    if (this.texture) {
      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;
      scene?.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToGammaSpace() {
    return this._convertToGammaSpace;
  }
  /**
   * Gets or sets a boolean indicating if content needs to be converted to linear space
   */
  set convertToLinearSpace(value) {
    if (value === this._convertToLinearSpace) {
      return;
    }
    this._convertToLinearSpace = value;
    if (this.texture) {
      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;
      scene?.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToLinearSpace() {
    return this._convertToLinearSpace;
  }
  /**
   * Create a new TextureBlock
   * @param name defines the block name
   * @param fragmentOnly
   */
  constructor(name6, fragmentOnly = false) {
    super(name6, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this._convertToGammaSpace = false;
    this._convertToLinearSpace = false;
    this.disableLevelMultiplication = false;
    this._fragmentOnly = fragmentOnly;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, 0, ImageSourceBlock, "ImageSourceBlock"));
    this.registerInput("layer", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("lod", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("level", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = !fragmentOnly;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TextureBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the source input component
   */
  get source() {
    return this._inputs[1];
  }
  /**
   * Gets the layer input component
   */
  get layer() {
    return this._inputs[2];
  }
  /**
   * Gets the LOD input component
   */
  get lod() {
    return this._inputs[3];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Gets the level output component
   */
  get level() {
    return this._outputs[6];
  }
  _isTiedToFragment(input) {
    if (input.target === NodeMaterialBlockTargets.Fragment) {
      return true;
    }
    if (input.target === NodeMaterialBlockTargets.Vertex) {
      return false;
    }
    if (input.target === NodeMaterialBlockTargets.Neutral || input.target === NodeMaterialBlockTargets.VertexAndFragment) {
      const parentBlock = input.ownerBlock;
      if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {
        return true;
      }
      for (const input2 of parentBlock.inputs) {
        if (!input2.isConnected) {
          continue;
        }
        if (this._isTiedToFragment(input2.connectedPoint)) {
          return true;
        }
      }
    }
    return false;
  }
  _getEffectiveTarget() {
    if (this._fragmentOnly) {
      return NodeMaterialBlockTargets.Fragment;
    }
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this._isTiedToFragment(this.uv.connectedPoint)) {
      return NodeMaterialBlockTargets.Fragment;
    }
    return NodeMaterialBlockTargets.VertexAndFragment;
  }
  get target() {
    return this._getEffectiveTarget();
  }
  set target(value) {
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      if (material.mode === NodeMaterialModes.PostProcess) {
        const uvInput = material.getBlockByPredicate((b) => b.name === "uv" && additionalFilteringInfo(b));
        if (uvInput) {
          uvInput.connectTo(this);
        }
      } else if (material.mode !== NodeMaterialModes.ProceduralTexture) {
        const attributeName = material.mode === NodeMaterialModes.Particle ? "particle_uv" : "uv";
        let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName && additionalFilteringInfo(b));
        if (!uvInput) {
          uvInput = new InputBlock("uv");
          uvInput.setAsAttribute(attributeName);
        }
        uvInput.output.connectTo(this.uv);
      }
    }
  }
  initializeDefines(defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    if (this._mainUVDefineName !== void 0) {
      defines.setValue(this._mainUVDefineName, false, true);
    }
  }
  prepareDefines(defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    if (!this.texture || !this.texture.getTextureMatrix) {
      if (this._isMixed) {
        defines.setValue(this._defineName, false, true);
        defines.setValue(this._mainUVDefineName, true, true);
      }
      return;
    }
    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;
    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;
    defines.setValue(this._linearDefineName, toGamma, true);
    defines.setValue(this._gammaDefineName, toLinear, true);
    if (this._isMixed) {
      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {
        defines.setValue(this._defineName, true);
        if (defines[this._mainUVDefineName] == void 0) {
          defines.setValue(this._mainUVDefineName, false, true);
        }
      } else {
        defines.setValue(this._defineName, false, true);
        defines.setValue(this._mainUVDefineName, true, true);
      }
    }
  }
  isReady() {
    if (this._isSourcePrePass) {
      return true;
    }
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect) {
    if (this._isSourcePrePass) {
      effect.setFloat(this._textureInfoName, 1);
    }
    if (!this.texture) {
      return;
    }
    if (this._isMixed) {
      effect.setFloat(this._textureInfoName, this.texture.level);
      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());
    }
    if (!this._imageSource) {
      effect.setTexture(this._samplerName, this.texture);
    }
  }
  get _isMixed() {
    return this.target !== NodeMaterialBlockTargets.Fragment;
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    this._defineName = state._getFreeDefineName("UVTRANSFORM");
    this._mainUVDefineName = "VMAIN" + uvInput.declarationVariableName.toUpperCase();
    this._mainUVName = "vMain" + uvInput.declarationVariableName;
    this._transformedUVName = state._getFreeVariableName("transformedUV");
    this._textureTransformName = state._getFreeVariableName("textureTransform");
    this._textureInfoName = state._getFreeVariableName("textureInfoName");
    this.level.associatedVariableName = this._textureInfoName;
    state._emitVaryingFromString(this._transformedUVName, NodeMaterialBlockConnectionPointTypes.Vector2, this._defineName);
    state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, this._mainUVDefineName);
    state._emitUniformFromString(this._textureTransformName, NodeMaterialBlockConnectionPointTypes.Matrix, this._defineName);
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);
    state.compilationString += `#ifdef ${this._defineName}
`;
    state.compilationString += `${state._getVaryingName(this._transformedUVName)} = ${vec2}(${this._textureTransformName} * ${vec4}(${uvInput.associatedVariableName}.xy, 1.0, 0.0));
`;
    state.compilationString += `#elif defined(${this._mainUVDefineName})
`;
    let automaticPrefix = "";
    if (state.shaderLanguage === 1) {
      if (uvInput.isConnectedToInputBlock && uvInput.associatedVariableName.indexOf("vertexInputs.") === -1) {
        automaticPrefix = "vertexInputs.";
      }
    }
    state.compilationString += `${state._getVaryingName(this._mainUVName)} = ${automaticPrefix}${uvInput.associatedVariableName}.xy;
`;
    state.compilationString += `#endif
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name, true);
      }
    }
  }
  _getUVW(uvName) {
    let coords = uvName;
    const is2DArrayTexture = this._texture?._texture?.is2DArray ?? false;
    const is3D = this._texture?._texture?.is3D ?? false;
    if (is2DArrayTexture) {
      const layerValue = this.layer.isConnected ? this.layer.associatedVariableName : "0";
      coords = `vec3(${uvName}, ${layerValue})`;
    } else if (is3D) {
      const layerValue = this.layer.isConnected ? this.layer.associatedVariableName : "0";
      coords = `vec3(${uvName}, ${layerValue})`;
    }
    return coords;
  }
  _samplerFunc(state) {
    if (state.shaderLanguage === 1) {
      return state.target === NodeMaterialBlockTargets.Vertex ? "textureSampleLevel" : "textureSample";
    }
    return this.lod.isConnected ? "texture2DLodEXT" : "texture2D";
  }
  get _samplerLodSuffix() {
    return this.lod.isConnected ? `, ${this.lod.associatedVariableName}` : "";
  }
  _generateTextureSample(uv, state) {
    if (state.shaderLanguage === 1) {
      const isVertex = state.target === NodeMaterialBlockTargets.Vertex;
      return `${this._samplerFunc(state)}(${this.samplerName},${this.samplerName + `Sampler`}, ${this._getUVW(uv)}${this._samplerLodSuffix}${isVertex ? ", 0" : ""})`;
    }
    return `${this._samplerFunc(state)}(${this.samplerName}, ${this._getUVW(uv)}${this._samplerLodSuffix})`;
  }
  _generateTextureLookup(state) {
    state.compilationString += `#ifdef ${this._defineName}
`;
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(state._getVaryingName(this._transformedUVName), state)};
`;
    state.compilationString += `#elif defined(${this._mainUVDefineName})
`;
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(this._mainUVName ? state._getVaryingName(this._mainUVName) : this.uv.associatedVariableName, state)}${this._samplerLodSuffix};
`;
    state.compilationString += `#endif
`;
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      this._generateTextureLookup(state);
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(uvInput.associatedVariableName, state)}${this._samplerLodSuffix};
`;
      return;
    }
    this._generateTextureLookup(state);
  }
  _generateConversionCode(state, output, swizzle) {
    if (swizzle !== "a") {
      if (!this.texture || !this.texture.gammaSpace) {
        state.compilationString += `#ifdef ${this._linearDefineName}
                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
                    #endif
                `;
      }
      state.compilationString += `#ifdef ${this._gammaDefineName}
                ${output.associatedVariableName} = ${state._toLinearSpace(output)};
                #endif
            `;
    }
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      this._generateConversionCode(state, output, swizzle);
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      this._generateConversionCode(state, output, swizzle);
      return;
    }
    let complement = "";
    if (!this.disableLevelMultiplication) {
      complement = ` * ${(state.shaderLanguage === 1 ? "uniforms." : "") + this._textureInfoName}`;
    }
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle}${complement};
`;
    this._generateConversionCode(state, output, swizzle);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.source.isConnected) {
      this._imageSource = this.source.connectedPoint.ownerBlock;
    } else {
      this._imageSource = null;
    }
    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment) {
      this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
      this._linearDefineName = state._getFreeDefineName("ISLINEAR");
      this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    }
    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {
      if (!this._imageSource) {
        const varName = state._getFreeVariableName(this.name);
        this._samplerName = varName + "Texture";
        if (this._texture?._texture?.is2DArray) {
          state._emit2DArraySampler(this._samplerName);
        } else {
          state._emit2DSampler(this._samplerName);
        }
      }
      state.sharedData.blockingBlocks.push(this);
      state.sharedData.textureBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    if (this._isMixed && !this._imageSource) {
      if (this._texture?._texture?.is2DArray) {
        state._emit2DArraySampler(this._samplerName);
      } else {
        state._emit2DSampler(this._samplerName);
      }
    }
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    if (this._isMixed) {
      state._emitUniformFromString(this._textureInfoName, NodeMaterialBlockConnectionPointTypes.Float);
    }
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};
`;
    if (!this.texture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.fragmentOnly = this._fragmentOnly;
    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;
    if (!this.hasImageSource && this.texture && (NodeMaterial.AllowSerializationOfRenderTargetTextures || !this.texture.isRenderTarget) && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl, urlRewriter) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this._fragmentOnly = !!serializationObject.fragmentOnly;
    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {
      if (serializationObject.texture.url !== void 0) {
        if (serializationObject.texture.url.indexOf("data:") === 0) {
          rootUrl = "";
        } else if (urlRewriter) {
          serializationObject.texture.url = urlRewriter(serializationObject.texture.url);
          serializationObject.texture.name = serializationObject.texture.url;
        }
      }
      if (serializationObject.texture.base64String || serializationObject.texture.url !== void 0) {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
  }
};
RegisterClass("BABYLON.TextureBlock", TextureBlock);

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var DefaultLodScale = 0.8;
var CubeTexture = class _CubeTexture extends BaseTexture {
  /**
   * Gets or sets the size of the bounding box associated with the cube texture
   * When defined, the cubemap will switch to local mode
   * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
   * @example https://www.babylonjs-playground.com/#RNASML
   */
  set boundingBoxSize(value) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
      return;
    }
    this._boundingBoxSize = value;
    const scene = this.getScene();
    if (scene) {
      scene.markAllMaterialsAsDirty(1);
    }
  }
  /**
   * Returns the bounding box size
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode
   */
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  /**
   * Sets texture matrix rotation angle around Y axis in radians.
   */
  set rotationY(value) {
    this._rotationY = value;
    this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
  }
  /**
   * Gets texture matrix rotation angle around Y axis radians.
   */
  get rotationY() {
    return this._rotationY;
  }
  /**
   * Are mip maps generated for this texture or not.
   */
  get noMipmap() {
    return this._noMipmap;
  }
  /**
   * Gets the forced extension (if any)
   */
  get forcedExtension() {
    return this._forcedExtension;
  }
  /**
   * Creates a cube texture from an array of image urls
   * @param files defines an array of image urls
   * @param scene defines the hosting scene
   * @param noMipmap specifies if mip maps are not used
   * @returns a cube texture
   */
  static CreateFromImages(files, scene, noMipmap) {
    let rootUrlKey = "";
    for (const url of files) {
      rootUrlKey += url;
    }
    return new _CubeTexture(rootUrlKey, scene, null, noMipmap, files);
  }
  /**
   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
   * @param url defines the url of the prefiltered texture
   * @param scene defines the scene the texture is attached to
   * @param forcedExtension defines the extension of the file if different from the url
   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
   * @returns the prefiltered texture
   */
  static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {
    const oldValue = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    const result = new _CubeTexture(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
    scene.useDelayedTextureLoading = oldValue;
    return result;
  }
  /**
   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
   * as prefiltered data.
   * @param rootUrl defines the url of the texture or the root name of the six images
   * @param sceneOrEngine defines the scene or engine the texture is attached to
   * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture
   * @param noMipmap defines if mipmaps should be created or not
   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
   * @param onLoad defines a callback triggered at the end of the file load if no errors occurred
   * @param onError defines a callback triggered in case of error during load
   * @param format defines the internal format to use for the texture once loaded
   * @param prefiltered defines whether or not the texture is created from prefiltered data
   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
   * @param loaderOptions options to be passed to the loader
   * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)
   * @returns the cube texture
   */
  constructor(rootUrl, sceneOrEngine, extensionsOrOptions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = DefaultLodScale, lodOffset = 0, loaderOptions, useSRGBBuffer) {
    super(sceneOrEngine);
    this.onLoadObservable = new Observable();
    this.boundingBoxPosition = Vector3.Zero();
    this._rotationY = 0;
    this._files = null;
    this._forcedExtension = null;
    this._extensions = null;
    this._textureMatrixRefraction = new Matrix();
    this._buffer = null;
    this.name = rootUrl;
    this.url = rootUrl;
    this._noMipmap = noMipmap;
    this.hasAlpha = false;
    this.isCube = true;
    this._textureMatrix = Matrix.Identity();
    this.coordinatesMode = Texture.CUBIC_MODE;
    let extensions = null;
    let buffer = null;
    if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {
      extensions = extensionsOrOptions.extensions ?? null;
      this._noMipmap = extensionsOrOptions.noMipmap ?? false;
      files = extensionsOrOptions.files ?? null;
      buffer = extensionsOrOptions.buffer ?? null;
      this._format = extensionsOrOptions.format ?? 5;
      prefiltered = extensionsOrOptions.prefiltered ?? false;
      forcedExtension = extensionsOrOptions.forcedExtension ?? null;
      this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;
      this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;
      this._lodOffset = extensionsOrOptions.lodOffset ?? 0;
      this._loaderOptions = extensionsOrOptions.loaderOptions;
      this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;
      onLoad = extensionsOrOptions.onLoad ?? null;
      onError = extensionsOrOptions.onError ?? null;
    } else {
      this._noMipmap = noMipmap;
      this._format = format;
      this._createPolynomials = createPolynomials;
      extensions = extensionsOrOptions;
      this._loaderOptions = loaderOptions;
      this._useSRGBBuffer = useSRGBBuffer;
      this._lodScale = lodScale;
      this._lodOffset = lodOffset;
    }
    if (!rootUrl && !files) {
      return;
    }
    this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);
  }
  /**
   * Get the current class name of the texture useful for serialization or dynamic coding.
   * @returns "CubeTexture"
   */
  getClassName() {
    return "CubeTexture";
  }
  /**
   * Update the url (and optional buffer) of this texture if url was null during construction.
   * @param url the url of the texture
   * @param forcedExtension defines the extension to use
   * @param onLoad callback called when the texture is loaded  (defaults to null)
   * @param prefiltered Defines whether the updated texture is prefiltered or not
   * @param onError callback called if there was an error during the loading process (defaults to null)
   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
   * @param delayLoad defines if the texture should be loaded now (false by default)
   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
   * @param buffer the buffer to use instead of loading from the url
   */
  updateURL(url, forcedExtension = null, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null, buffer = null) {
    if (!this.name || this.name.startsWith("data:")) {
      this.name = url;
    }
    this.url = url;
    if (forcedExtension) {
      this._forcedExtension = forcedExtension;
    }
    const lastDot = url.lastIndexOf(".");
    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    const isDDS = extension.indexOf(".dds") === 0;
    const isEnv = extension.indexOf(".env") === 0;
    const isBasis = extension.indexOf(".basis") === 0;
    if (isEnv) {
      this.gammaSpace = false;
      this._prefiltered = false;
      this.anisotropicFilteringLevel = 1;
    } else {
      this._prefiltered = prefiltered;
      if (prefiltered) {
        this.gammaSpace = false;
        this.anisotropicFilteringLevel = 1;
      }
    }
    if (files) {
      this._files = files;
    } else {
      if (!isBasis && !isEnv && !isDDS && !extensions) {
        extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
      }
      this._files = this._files || [];
      this._files.length = 0;
      if (extensions) {
        for (let index = 0; index < extensions.length; index++) {
          this._files.push(url + extensions[index]);
        }
        this._extensions = extensions;
      }
    }
    this._buffer = buffer;
    if (delayLoad) {
      this.delayLoadState = 4;
      this._delayedOnLoad = onLoad;
      this._delayedOnError = onError;
    } else {
      this._loadTexture(onLoad, onError);
    }
  }
  /**
   * Delays loading of the cube texture
   * @param forcedExtension defines the extension to use
   */
  delayLoad(forcedExtension) {
    if (this.delayLoadState !== 4) {
      return;
    }
    if (forcedExtension) {
      this._forcedExtension = forcedExtension;
    }
    this.delayLoadState = 1;
    this._loadTexture(this._delayedOnLoad, this._delayedOnError);
  }
  /**
   * Returns the reflection texture matrix
   * @returns the reflection texture matrix
   */
  getReflectionTextureMatrix() {
    return this._textureMatrix;
  }
  /**
   * Sets the reflection texture matrix
   * @param value Reflection texture matrix
   */
  setReflectionTextureMatrix(value) {
    if (value.updateFlag === this._textureMatrix.updateFlag) {
      return;
    }
    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
      this.getScene()?.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
    }
    this._textureMatrix = value;
    if (!this.getScene()?.useRightHandedSystem) {
      return;
    }
    const scale = TmpVectors.Vector3[0];
    const quat = TmpVectors.Quaternion[0];
    const trans = TmpVectors.Vector3[1];
    this._textureMatrix.decompose(scale, quat, trans);
    quat.z *= -1;
    quat.w *= -1;
    Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);
  }
  /**
   * Gets a suitable rotate/transform matrix when the texture is used for refraction.
   * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
   * @returns The refraction matrix
   */
  getRefractionTextureMatrix() {
    return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;
  }
  _loadTexture(onLoad = null, onError = null) {
    const scene = this.getScene();
    const oldTexture = this._texture;
    this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
    const onLoadProcessing = () => {
      this.onLoadObservable.notifyObservers(this);
      if (oldTexture) {
        oldTexture.dispose();
        this.getScene()?.markAllMaterialsAsDirty(1);
      }
      if (onLoad) {
        onLoad();
      }
    };
    const errorHandler = (message, exception) => {
      this._loadingError = true;
      this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      Texture.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this._texture) {
      if (this._prefiltered) {
        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
      } else {
        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer);
      }
      this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));
    } else {
      if (this._texture.isReady) {
        Tools.SetImmediate(() => onLoadProcessing());
      } else {
        this._texture.onLoadedObservable.add(() => onLoadProcessing());
      }
    }
  }
  /**
   * Parses text to create a cube texture
   * @param parsedTexture define the serialized text to read from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root url of the cube texture
   * @returns a cube texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => {
      let prefiltered = false;
      if (parsedTexture.prefiltered) {
        prefiltered = parsedTexture.prefiltered;
      }
      return new _CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
    }, parsedTexture, scene);
    if (parsedTexture.boundingBoxPosition) {
      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
    }
    if (parsedTexture.boundingBoxSize) {
      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
    }
    if (parsedTexture.animations) {
      for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
        const parsedAnimation = parsedTexture.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          texture.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
    }
    return texture;
  }
  /**
   * Makes a clone, or deep copy, of the cube texture
   * @returns a new cube texture
   */
  clone() {
    let uniqueId = 0;
    const newCubeTexture = SerializationHelper.Clone(() => {
      const cubeTexture = new _CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
      uniqueId = cubeTexture.uniqueId;
      return cubeTexture;
    }, this);
    newCubeTexture.uniqueId = uniqueId;
    return newCubeTexture;
  }
};
__decorate([
  serialize()
], CubeTexture.prototype, "url", void 0);
__decorate([
  serializeAsVector3()
], CubeTexture.prototype, "boundingBoxPosition", void 0);
__decorate([
  serializeAsVector3()
], CubeTexture.prototype, "boundingBoxSize", null);
__decorate([
  serialize("rotationY")
], CubeTexture.prototype, "rotationY", null);
__decorate([
  serialize("files")
], CubeTexture.prototype, "_files", void 0);
__decorate([
  serialize("forcedExtension")
], CubeTexture.prototype, "_forcedExtension", void 0);
__decorate([
  serialize("extensions")
], CubeTexture.prototype, "_extensions", void 0);
__decorate([
  serializeAsMatrix("textureMatrix")
], CubeTexture.prototype, "_textureMatrix", void 0);
__decorate([
  serializeAsMatrix("textureMatrixRefraction")
], CubeTexture.prototype, "_textureMatrixRefraction", void 0);
Texture._CubeTextureParser = CubeTexture.Parse;
RegisterClass("BABYLON.CubeTexture", CubeTexture);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.js
var ReflectionTextureBaseBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    return this._texture;
  }
  set texture(texture) {
    if (this._texture === texture) {
      return;
    }
    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    return that._onGenerateOnlyFragmentCodeChanged();
  }
  _onGenerateOnlyFragmentCodeChanged() {
    this._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
  }
  /**
   * Create a new ReflectionTextureBaseBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this.generateOnlyFragmentCode = false;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReflectionTextureBaseBlock";
  }
  _getTexture() {
    return this.texture;
  }
  initialize(state) {
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await import("./reflectionFunction-YFSN2BNX.js");
    } else {
      await import("./reflectionFunction-O7M7RMLU.js");
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  /**
   * Auto configure the node based on the existing material
   * @param material defines the material to configure
   * @param additionalFilteringInfo defines additional info to be used when filtering inputs (we might want to skip some non relevant blocks)
   */
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.position.isConnected) {
      let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "position" && additionalFilteringInfo(b));
      if (!positionInput) {
        positionInput = new InputBlock("position");
        positionInput.setAsAttribute();
      }
      positionInput.output.connectTo(this.position);
    }
    if (!this.world.isConnected) {
      let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));
      if (!worldInput) {
        worldInput = new InputBlock("world");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
      }
      worldInput.output.connectTo(this.world);
    }
    if (this.view && !this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    const texture = this._getTexture();
    if (!texture || !texture.getTextureMatrix) {
      return;
    }
    defines.setValue(this._define3DName, texture.isCube, true);
    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);
    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);
    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);
    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);
    defines.setValue("INVERTCUBICMAP", texture.coordinatesMode === 6, true);
    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);
    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);
    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);
    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);
    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);
    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);
  }
  isReady() {
    const texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh, _subMesh) {
    const texture = this._getTexture();
    if (!mesh || !texture) {
      return;
    }
    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());
    if (texture.isCube) {
      effect.setTexture(this._cubeSamplerName, texture);
    } else {
      effect.setTexture(this._2DSamplerName, texture);
    }
    if (texture.boundingBoxSize) {
      const cubeTexture = texture;
      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);
      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);
    }
  }
  /**
   * Gets the code to inject in the vertex shader
   * @param state current state of the node material building
   * @returns the shader code
   */
  handleVertexSide(state) {
    if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {
      return "";
    }
    const isWebGPU = state.shaderLanguage === 1;
    this._define3DName = state._getFreeDefineName("REFLECTIONMAP_3D");
    this._defineCubicName = state._getFreeDefineName("REFLECTIONMAP_CUBIC");
    this._defineSphericalName = state._getFreeDefineName("REFLECTIONMAP_SPHERICAL");
    this._definePlanarName = state._getFreeDefineName("REFLECTIONMAP_PLANAR");
    this._defineProjectionName = state._getFreeDefineName("REFLECTIONMAP_PROJECTION");
    this._defineExplicitName = state._getFreeDefineName("REFLECTIONMAP_EXPLICIT");
    this._defineEquirectangularName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR");
    this._defineLocalCubicName = state._getFreeDefineName("USE_LOCAL_REFLECTIONMAP_CUBIC");
    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
    this._defineEquirectangularFixedName = state._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
    this._defineSkyboxName = state._getFreeDefineName("REFLECTIONMAP_SKYBOX");
    this._defineOppositeZ = state._getFreeDefineName("REFLECTIONMAP_OPPOSITEZ");
    this._reflectionMatrixName = state._getFreeVariableName("reflectionMatrix");
    state._emitUniformFromString(this._reflectionMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);
    let code = "";
    this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName("worldPosition");
    const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : "v_" + this.worldPosition.associatedVariableName;
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {
      if (this.generateOnlyFragmentCode) {
        code += `${state._declareLocalVar(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.worldPosition.associatedVariableName};
`;
      } else {
        code += `${isWebGPU ? "vertexOutputs." : ""}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};
`;
      }
    }
    this._positionUVWName = state._getFreeVariableName("positionUVW");
    this._directionWname = state._getFreeVariableName("directionW");
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, NodeMaterialBlockConnectionPointTypes.Vector3, this._defineSkyboxName)) {
      code += `#ifdef ${this._defineSkyboxName}
`;
      if (this.generateOnlyFragmentCode) {
        code += `${state._declareLocalVar(this._positionUVWName, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.position.associatedVariableName}.xyz;
`;
      } else {
        code += `${isWebGPU ? "vertexOutputs." : ""}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;
`;
      }
      code += `#endif
`;
    }
    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._directionWname, NodeMaterialBlockConnectionPointTypes.Vector3, `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {
      code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})
`;
      if (this.generateOnlyFragmentCode) {
        code += `${state._declareLocalVar(this._directionWname, NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(vec3${state.fSuffix}(${this.world.associatedVariableName} * vec4${state.fSuffix}(${this.position.associatedVariableName}.xyz, 0.0)));
`;
      } else {
        code += `${isWebGPU ? "vertexOutputs." : ""}${this._directionWname} = normalize(vec3${state.fSuffix}(${this.world.associatedVariableName} * vec4${state.fSuffix}(${this.position.associatedVariableName}.xyz, 0.0)));
`;
      }
      code += `#endif
`;
    }
    return code;
  }
  /**
   * Handles the inits for the fragment code path
   * @param state node material build state
   */
  handleFragmentSideInits(state) {
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    state._samplerDeclaration += `#ifdef ${this._define3DName}
`;
    state._emitCubeSampler(this._cubeSamplerName, "", true);
    state._samplerDeclaration += `#else
`;
    state._emit2DSampler(this._2DSamplerName, "", true);
    state._samplerDeclaration += `#endif
`;
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("reflectionFunction", comments, {
      replaceStrings: [
        { search: /vec3 computeReflectionCoords/g, replace: "void DUMMYFUNC" },
        { search: /fn computeReflectionCoords\(worldPos: vec4f,worldNormal: vec3f\)->vec3f/g, replace: "fn DUMMYFUNC()" }
      ]
    });
    this._reflectionColorName = state._getFreeVariableName("reflectionColor");
    this._reflectionVectorName = state._getFreeVariableName("reflectionUVW");
    this._reflectionCoordsName = state._getFreeVariableName("reflectionCoords");
    this._reflectionPositionName = state._getFreeVariableName("vReflectionPosition");
    state._emitUniformFromString(this._reflectionPositionName, NodeMaterialBlockConnectionPointTypes.Vector3);
    this._reflectionSizeName = state._getFreeVariableName("vReflectionPosition");
    state._emitUniformFromString(this._reflectionSizeName, NodeMaterialBlockConnectionPointTypes.Vector3);
  }
  /**
   * Generates the reflection coords code for the fragment code path
   * @param state defines the build state
   * @param worldNormalVarName name of the world normal variable
   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block
   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates
   * @param doNotEmitInvertZ if true, does not emit the invertZ code
   * @returns the shader code
   */
  handleFragmentSideCodeReflectionCoords(state, worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {
    const isWebGPU = state.shaderLanguage === 1;
    const reflectionMatrix = (isWebGPU ? "uniforms." : "") + this._reflectionMatrixName;
    const direction = `normalize(${this._directionWname})`;
    const positionUVW = `${this._positionUVWName}`;
    const vEyePosition = `${this.cameraPosition.associatedVariableName}`;
    const view = `${this.view.associatedVariableName}`;
    const fragmentInputsPrefix = isWebGPU ? "fragmentInputs." : "";
    if (!worldPos) {
      worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `${fragmentInputsPrefix}v_${this.worldPosition.associatedVariableName}`;
    }
    worldNormalVarName += ".xyz";
    let code = `
            #ifdef ${this._defineMirroredEquirectangularFixedName}
               ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});
            #endif

            #ifdef ${this._defineEquirectangularFixedName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});
            #endif

            #ifdef ${this._defineEquirectangularName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineSphericalName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});
            #endif

            #ifdef ${this._definePlanarName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineCubicName}
                #ifdef ${this._defineLocalCubicName}
                    ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});
                #else
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});
                #endif
            #endif

            #ifdef ${this._defineProjectionName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineSkyboxName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});
            #endif

            #ifdef ${this._defineExplicitName}
                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3(0, 0, 0);
            #endif
`;
    if (!doNotEmitInvertZ) {
      code += `#ifdef ${this._defineOppositeZ}
                ${this._reflectionVectorName}.z *= -1.0;
            #endif
`;
    }
    if (!onlyReflectionVector) {
      code += `
                #ifdef ${this._define3DName}
                    ${state._declareLocalVar(this._reflectionCoordsName, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._reflectionVectorName};
                #else
                    ${state._declareLocalVar(this._reflectionCoordsName, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this._reflectionVectorName}.xy;
                    #ifdef ${this._defineProjectionName}
                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;
                    #endif
                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;
                #endif
`;
    }
    return code;
  }
  /**
   * Generates the reflection color code for the fragment code path
   * @param state defines the build state
   * @param lodVarName name of the lod variable
   * @param swizzleLookupTexture swizzle to use for the final color variable
   * @returns the shader code
   */
  handleFragmentSideCodeReflectionColor(state, lodVarName, swizzleLookupTexture = ".rgb") {
    let colorType = NodeMaterialBlockConnectionPointTypes.Vector4;
    if (swizzleLookupTexture.length === 3) {
      colorType = NodeMaterialBlockConnectionPointTypes.Vector3;
    }
    let code = `${state._declareLocalVar(this._reflectionColorName, colorType)};
            #ifdef ${this._define3DName}
`;
    if (lodVarName) {
      code += `${this._reflectionColorName} = ${state._generateTextureSampleCubeLOD(this._reflectionVectorName, this._cubeSamplerName, lodVarName)}${swizzleLookupTexture};
`;
    } else {
      code += `${this._reflectionColorName} = ${state._generateTextureSampleCube(this._reflectionVectorName, this._cubeSamplerName)}${swizzleLookupTexture};
`;
    }
    code += `
            #else
`;
    if (lodVarName) {
      code += `${this._reflectionColorName} =${state._generateTextureSampleLOD(this._reflectionCoordsName, this._2DSamplerName, lodVarName)}${swizzleLookupTexture};
`;
    } else {
      code += `${this._reflectionColorName} = ${state._generateTextureSample(this._reflectionCoordsName, this._2DSamplerName)}${swizzleLookupTexture};
`;
    }
    code += `#endif
`;
    return code;
  }
  /**
   * Generates the code corresponding to the connected output points
   * @param state node material build state
   * @param varName name of the variable to output
   * @returns the shader code
   */
  writeOutputs(state, varName) {
    let code = "";
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      for (const output of this._outputs) {
        if (output.hasEndpoints) {
          code += `${state._declareOutput(output)} = ${varName}.${output.name};
`;
        }
      }
    }
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (!this.texture) {
      return codeString;
    }
    if (this.texture.isCube) {
      const forcedExtension = this.texture.forcedExtension;
      codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '"' + forcedExtension + '"' : "null"});
`;
    } else {
      codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null);
`;
    }
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Generate only fragment code", 0, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], ReflectionTextureBaseBlock.prototype, "generateOnlyFragmentCode", void 0);
RegisterClass("BABYLON.ReflectionTextureBaseBlock", ReflectionTextureBaseBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/reflectionTextureBlock.js
var ReflectionTextureBlock = class extends ReflectionTextureBaseBlock {
  _onGenerateOnlyFragmentCodeChanged() {
    if (this.position.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      Logger.Error("The position input must not be connected to be able to switch!");
      return false;
    }
    if (this.worldPosition.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      Logger.Error("The worldPosition input must not be connected to be able to switch!");
      return false;
    }
    this._setTarget();
    return true;
  }
  _setTarget() {
    super._setTarget();
    this.getInputByName("position").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  /**
   * Create a new ReflectionTextureBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReflectionTextureBlock";
  }
  /**
   * Gets the world position input component
   */
  get position() {
    return this._inputs[0];
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[1];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[2];
  }
  /**
   * Gets the world input component
   */
  get world() {
    return this._inputs[3];
  }
  /**
   * Gets the camera (or eye) position component
   */
  get cameraPosition() {
    return this._inputs[4];
  }
  /**
   * Gets the view input component
   */
  get view() {
    return this._inputs[5];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    super.autoConfigure(material);
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.texture) {
      state.compilationString += this.writeOutputs(state, `vec4${state.fSuffix}(0.)`);
      return this;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state.compilationString += this.handleVertexSide(state);
      return this;
    }
    if (this.generateOnlyFragmentCode) {
      state.compilationString += this.handleVertexSide(state);
    }
    this.handleFragmentSideInits(state);
    const normalWUnit = state._getFreeVariableName("normalWUnit");
    state.compilationString += `${state._declareLocalVar(normalWUnit, NodeMaterialBlockConnectionPointTypes.Vector4)} = normalize(${this.worldNormal.associatedVariableName});
`;
    state.compilationString += this.handleFragmentSideCodeReflectionCoords(state, normalWUnit);
    state.compilationString += this.handleFragmentSideCodeReflectionColor(state, void 0, "");
    state.compilationString += this.writeOutputs(state, this._reflectionColorName);
    return this;
  }
};
RegisterClass("BABYLON.ReflectionTextureBlock", ReflectionTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/sceneDepthBlock.js
var SceneDepthBlock = class extends NodeMaterialBlock {
  /**
   * Create a new SceneDepthBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this.useNonLinearDepth = false;
    this.storeCameraSpaceZ = false;
    this.force32itsFloat = false;
    this._isUnique = true;
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
    this.registerOutput("depth", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[0]._prioritizeVertex = false;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SceneDepthBlock";
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[0];
  }
  /**
   * Gets the depth output component
   */
  get depth() {
    return this._outputs[0];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("textureSampler");
  }
  get target() {
    if (!this.uv.isConnected) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    if (this.uv.sourceBlock.isInput) {
      return NodeMaterialBlockTargets.VertexAndFragment;
    }
    return NodeMaterialBlockTargets.Fragment;
  }
  _getTexture(scene) {
    const depthRenderer = scene.enableDepthRenderer(void 0, this.useNonLinearDepth, this.force32itsFloat, void 0, this.storeCameraSpaceZ);
    return depthRenderer.getDepthMap();
  }
  bind(effect, nodeMaterial) {
    const texture = this._getTexture(nodeMaterial.getScene());
    effect.setTexture(this._samplerName, texture);
  }
  _injectVertexCode(state) {
    const uvInput = this.uv;
    if (uvInput.connectedPoint.ownerBlock.isInput) {
      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
      if (!uvInputOwnerBlock.isAttribute) {
        state._emitUniformFromString(uvInput.associatedVariableName, uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? NodeMaterialBlockConnectionPointTypes.Vector3 : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? NodeMaterialBlockConnectionPointTypes.Vector4 : NodeMaterialBlockConnectionPointTypes.Vector2);
      }
    }
    this._mainUVName = "vMain" + uvInput.associatedVariableName;
    state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);
    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;
`;
    if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
      return;
    }
    this._writeTextureRead(state, true);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, "r", true);
      }
    }
  }
  _writeTextureRead(state, vertexMode = false) {
    const uvInput = this.uv;
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      const textureReadFunc2 = state.shaderLanguage === 0 ? `texture2D(${this._samplerName},` : `textureSampleLevel(${this._samplerName}, ${this._samplerName + `Sampler`},`;
      const complement = state.shaderLanguage === 0 ? "" : ", 0";
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)}=  ${textureReadFunc2} ${uvInput.associatedVariableName}.xy${complement});
`;
      return;
    }
    const textureReadFunc = state.shaderLanguage === 0 ? `texture2D(${this._samplerName},` : `textureSample(${this._samplerName}, ${this._samplerName + `Sampler`},`;
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName}.xy);
`;
      return;
    }
    state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});
`;
  }
  _writeOutput(state, output, swizzle, vertexMode = false) {
    if (vertexMode) {
      if (state.target === NodeMaterialBlockTargets.Fragment) {
        return;
      }
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
      state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
      return;
    }
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._samplerName = state._getFreeVariableName(this.name + "Sampler");
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    if (state.sharedData.bindableBlocks.indexOf(this) < 0) {
      state.sharedData.bindableBlocks.push(this);
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      state._emit2DSampler(this._samplerName);
      this._injectVertexCode(state);
      return;
    }
    if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
      return;
    }
    state._emit2DSampler(this._samplerName);
    this._writeTextureRead(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        this._writeOutput(state, output, "r");
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.useNonLinearDepth = this.useNonLinearDepth;
    serializationObject.storeCameraSpaceZ = this.storeCameraSpaceZ;
    serializationObject.force32itsFloat = this.force32itsFloat;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.useNonLinearDepth = serializationObject.useNonLinearDepth;
    this.storeCameraSpaceZ = !!serializationObject.storeCameraSpaceZ;
    this.force32itsFloat = serializationObject.force32itsFloat;
  }
};
__decorate([
  editableInPropertyPage("Use non linear depth", 0, "ADVANCED", {
    embedded: true,
    notifiers: {
      activatePreviewCommand: true,
      callback: (scene, block) => {
        const sceneDepthBlock = block;
        let retVal = false;
        if (sceneDepthBlock.useNonLinearDepth) {
          sceneDepthBlock.storeCameraSpaceZ = false;
          retVal = true;
        }
        if (scene) {
          scene.disableDepthRenderer();
        }
        return retVal;
      }
    }
  })
], SceneDepthBlock.prototype, "useNonLinearDepth", void 0);
__decorate([
  editableInPropertyPage("Store Camera space Z", 0, "ADVANCED", {
    notifiers: {
      activatePreviewCommand: true,
      callback: (scene, block) => {
        const sceneDepthBlock = block;
        let retVal = false;
        if (sceneDepthBlock.storeCameraSpaceZ) {
          sceneDepthBlock.useNonLinearDepth = false;
          retVal = true;
        }
        if (scene) {
          scene.disableDepthRenderer();
        }
        return retVal;
      }
    }
  })
], SceneDepthBlock.prototype, "storeCameraSpaceZ", void 0);
__decorate([
  editableInPropertyPage("Force 32 bits float", 0, "ADVANCED", {
    notifiers: { activatePreviewCommand: true, callback: (scene) => scene?.disableDepthRenderer() }
  })
], SceneDepthBlock.prototype, "force32itsFloat", void 0);
RegisterClass("BABYLON.SceneDepthBlock", SceneDepthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/depthSourceBlock.js
var DepthSourceBlock = class extends ImageSourceBlock {
  /**
   * Creates a new DepthSourceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    return this._texture;
  }
  set texture(texture) {
  }
  bind(effect, nodeMaterial) {
    const scene = nodeMaterial.getScene();
    const renderer = scene.enableDepthRenderer();
    this._texture = renderer.getDepthMap();
    super.bind(effect, nodeMaterial);
  }
  isReady() {
    return true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DepthSourceBlock";
  }
  _dumpPropertiesCode() {
    return super._dumpPropertiesCode(true);
  }
  serialize() {
    return super.serialize(true);
  }
};
RegisterClass("BABYLON.DepthSourceBlock", DepthSourceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/clipPlanesBlock.js
var ClipPlanesBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ClipPlanesBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment, true);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ClipPlanesBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("vClipPlane");
    state._excludeVariableName("fClipDistance");
    state._excludeVariableName("vClipPlane2");
    state._excludeVariableName("fClipDistance2");
    state._excludeVariableName("vClipPlane3");
    state._excludeVariableName("fClipDistance3");
    state._excludeVariableName("vClipPlane4");
    state._excludeVariableName("fClipDistance4");
    state._excludeVariableName("vClipPlane5");
    state._excludeVariableName("fClipDistance5");
    state._excludeVariableName("vClipPlane6");
    state._excludeVariableName("fClipDistance6");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([
        import("./clipPlaneFragment-VTLNRIZX.js"),
        import("./clipPlaneFragmentDeclaration-7JGDZAUB.js"),
        import("./clipPlaneVertex-HWXX5A27.js"),
        import("./clipPlaneVertexDeclaration-4MU5JGCR.js")
      ]);
    } else {
      await Promise.all([
        import("./clipPlaneFragment-VWLNWFNS.js"),
        import("./clipPlaneFragmentDeclaration-VMXDMBRJ.js"),
        import("./clipPlaneVertex-JZVO3DYB.js"),
        import("./clipPlaneVertexDeclaration-JO5QR7J6.js")
      ]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  /**
   * Gets the worldPosition input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  get target() {
    return NodeMaterialBlockTargets.VertexAndFragment;
  }
  set target(value) {
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    const useClipPlane1 = nodeMaterial.clipPlane ?? scene.clipPlane ? true : false;
    const useClipPlane2 = nodeMaterial.clipPlane2 ?? scene.clipPlane2 ? true : false;
    const useClipPlane3 = nodeMaterial.clipPlane3 ?? scene.clipPlane3 ? true : false;
    const useClipPlane4 = nodeMaterial.clipPlane4 ?? scene.clipPlane4 ? true : false;
    const useClipPlane5 = nodeMaterial.clipPlane5 ?? scene.clipPlane5 ? true : false;
    const useClipPlane6 = nodeMaterial.clipPlane6 ?? scene.clipPlane6 ? true : false;
    defines.setValue("CLIPPLANE", useClipPlane1, true);
    defines.setValue("CLIPPLANE2", useClipPlane2, true);
    defines.setValue("CLIPPLANE3", useClipPlane3, true);
    defines.setValue("CLIPPLANE4", useClipPlane4, true);
    defines.setValue("CLIPPLANE5", useClipPlane5, true);
    defines.setValue("CLIPPLANE6", useClipPlane6, true);
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    BindClipPlane(effect, nodeMaterial, scene);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      const worldPos = this.worldPosition;
      state._emitFunctionFromInclude("clipPlaneVertexDeclaration", comments, {
        replaceStrings: [{ search: /uniform vec4 vClipPlane\d*;/g, replace: "" }]
      });
      state.compilationString += state._emitCodeFromInclude("clipPlaneVertex", comments, {
        replaceStrings: [{ search: /worldPos/g, replace: worldPos.associatedVariableName }]
      });
      state._emitUniformFromString("vClipPlane", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClipPlane2", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClipPlane3", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClipPlane4", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClipPlane5", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClipPlane6", NodeMaterialBlockConnectionPointTypes.Vector4);
      return;
    }
    state.sharedData.bindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state._emitFunctionFromInclude("clipPlaneFragmentDeclaration", comments);
    state.compilationString += state._emitCodeFromInclude("clipPlaneFragment", comments);
    return this;
  }
};
RegisterClass("BABYLON.ClipPlanesBlock", ClipPlanesBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/smartFilterTextureBlock.js
var SmartFilterTextureBlock = class extends CurrentScreenBlock {
  /**
   * Gets the sampler name associated with this texture
   */
  get samplerName() {
    if (this.source.connectedPoint) {
      return this.source.connectedPoint.ownerBlock.samplerName;
    }
    return this._samplerName;
  }
  /**
   * Gets or sets the texture associated with this block
   */
  get texture() {
    if (this.source.connectedPoint) {
      return this.source.connectedPoint.ownerBlock.texture;
    }
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
  }
  /**
   * Create a new SmartFilterTextureBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
    this._firstInit = true;
    this.isMainInput = false;
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, 0, ImageSourceBlock, "ImageSourceBlock"));
  }
  /**
   * Gets the source input component
   */
  get source() {
    return this._inputs[1];
  }
  /**
   * Gets a boolean indicating that this block is linked to an ImageSourceBlock
   */
  get hasImageSource() {
    return this.source.isConnected;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SmartFilterTextureBlock";
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    if (this._firstInit) {
      this._samplerName = state._getFreeVariableName(this.name);
      this._firstInit = false;
    }
  }
  _getMainUvName(state) {
    const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === "postprocess_uv");
    if (!screenUv || !screenUv.isAnAncestorOf(this)) {
      state.sharedData.raiseBuildError("SmartFilterTextureBlock: 'postprocess_uv' attribute from ScreenUVBlock is required.");
      return "";
    }
    return screenUv.associatedVariableName;
  }
  _emitUvAndSampler(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, SfeModeDefine, true);
      if (!this.hasImageSource) {
        const annotation = this.isMainInput ? "// main" : void 0;
        state._emit2DSampler(this._samplerName, void 0, void 0, annotation);
      }
    }
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.uv.isConnected) {
      let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "postprocess_uv" && additionalFilteringInfo(b));
      if (!uvInput) {
        uvInput = new InputBlock("uv");
        uvInput.setAsAttribute("postprocess_uv");
      }
      uvInput.output.connectTo(this.uv);
    }
  }
  _postBuildBlock() {
    this._firstInit = true;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.isMainInput = this.isMainInput;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.isMainInput = serializationObject.isMainInput;
  }
};
RegisterClass("BABYLON.SmartFilterTextureBlock", SmartFilterTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/prePassTextureBlock.js
var PrePassTextureBlock = class extends NodeMaterialBlock {
  /**
   * The texture associated with the node is the prepass texture
   */
  get texture() {
    return null;
  }
  set texture(value) {
    return;
  }
  /**
   * Creates a new PrePassTextureBlock
   * @param name defines the block name
   * @param target defines the target of that block (VertexAndFragment by default)
   */
  constructor(name6, target = NodeMaterialBlockTargets.VertexAndFragment) {
    super(name6, target, false);
    this.registerOutput("position", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("position", this, 1, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("localPosition", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("localPosition", this, 1, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("depth", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("depth", this, 1, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("screenDepth", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("screenDepth", this, 1, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("normal", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("normal", this, 1, ImageSourceBlock, "ImageSourceBlock"));
    this.registerOutput("worldNormal", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("worldNormal", this, 1, ImageSourceBlock, "ImageSourceBlock"));
  }
  /**
   * Returns the sampler name associated with the node connection point
   * @param output defines the connection point to get the associated sampler name
   * @returns
   */
  getSamplerName(output) {
    if (output === this._outputs[0]) {
      return this._positionSamplerName;
    }
    if (output === this._outputs[1]) {
      return this._localPositionSamplerName;
    }
    if (output === this._outputs[2]) {
      return this._depthSamplerName;
    }
    if (output === this._outputs[3]) {
      return this._screenSpaceDepthSamplerName;
    }
    if (output === this._outputs[4]) {
      return this._normalSamplerName;
    }
    if (output === this._outputs[5]) {
      return this._worldNormalSamplerName;
    }
    return "";
  }
  /**
   * Gets the position texture
   */
  get position() {
    return this._outputs[0];
  }
  /**
   * Gets the local position texture
   */
  get localPosition() {
    return this._outputs[1];
  }
  /**
   * Gets the depth texture
   */
  get depth() {
    return this._outputs[2];
  }
  /**
   * Gets the screen depth texture
   */
  get screenDepth() {
    return this._outputs[3];
  }
  /**
   * Gets the normal texture
   */
  get normal() {
    return this._outputs[4];
  }
  /**
   * Gets the world normal texture
   */
  get worldNormal() {
    return this._outputs[5];
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get positionSamplerName() {
    return this._positionSamplerName;
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get localPositionSamplerName() {
    return this._localPositionSamplerName;
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get normalSamplerName() {
    return this._normalSamplerName;
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get worldNormalSamplerName() {
    return this._worldNormalSamplerName;
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get depthSamplerName() {
    return this._depthSamplerName;
  }
  /**
   * Gets the sampler name associated with this image source
   */
  get linearDepthSamplerName() {
    return this._screenSpaceDepthSamplerName;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PrePassTextureBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    this._positionSamplerName = "prepassPositionSampler";
    this._depthSamplerName = "prepassDepthSampler";
    this._normalSamplerName = "prepassNormalSampler";
    this._worldNormalSamplerName = "prepassWorldNormalSampler";
    this._localPositionSamplerName = "prepassLocalPositionSampler";
    this._screenSpaceDepthSamplerName = "prepassScreenSpaceDepthSampler";
    state.sharedData.variableNames.prepassPositionSampler = 0;
    state.sharedData.variableNames.prepassDepthSampler = 0;
    state.sharedData.variableNames.prepassNormalSampler = 0;
    state.sharedData.variableNames.prepassWorldNormalSampler = 0;
    state.sharedData.variableNames.prepassLocalPositionSampler = 0;
    state.sharedData.variableNames.prepassScreenSpaceDepthSampler = 0;
    state.sharedData.textureBlocks.push(this);
    state.sharedData.bindableBlocks.push(this);
    if (this.position.isConnected) {
      state._emit2DSampler(this._positionSamplerName);
    }
    if (this.depth.isConnected) {
      state._emit2DSampler(this._depthSamplerName);
    }
    if (this.normal.isConnected) {
      state._emit2DSampler(this._normalSamplerName);
    }
    if (this.worldNormal.isConnected) {
      state._emit2DSampler(this._worldNormalSamplerName);
    }
    if (this.localPosition.isConnected) {
      state._emit2DSampler(this._localPositionSamplerName);
    }
    if (this.screenDepth.isConnected) {
      state._emit2DSampler(this._screenSpaceDepthSamplerName);
    }
    return this;
  }
  bind(effect, nodeMaterial) {
    const scene = nodeMaterial.getScene();
    const prePassRenderer = scene.enablePrePassRenderer();
    if (!prePassRenderer) {
      return;
    }
    const sceneRT = prePassRenderer.defaultRT;
    if (!sceneRT.textures) {
      return;
    }
    if (this.position.isConnected) {
      effect.setTexture(this._positionSamplerName, sceneRT.textures[prePassRenderer.getIndex(1)]);
    }
    if (this.localPosition.isConnected) {
      effect.setTexture(this._localPositionSamplerName, sceneRT.textures[prePassRenderer.getIndex(9)]);
    }
    if (this.depth.isConnected) {
      effect.setTexture(this._depthSamplerName, sceneRT.textures[prePassRenderer.getIndex(5)]);
    }
    if (this.screenDepth.isConnected) {
      effect.setTexture(this._screenSpaceDepthSamplerName, sceneRT.textures[prePassRenderer.getIndex(10)]);
    }
    if (this.normal.isConnected) {
      effect.setTexture(this._normalSamplerName, sceneRT.textures[prePassRenderer.getIndex(6)]);
    }
    if (this.worldNormal.isConnected) {
      effect.setTexture(this._worldNormalSamplerName, sceneRT.textures[prePassRenderer.getIndex(8)]);
    }
  }
};
RegisterClass("BABYLON.PrePassTextureBlock", PrePassTextureBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Teleport/teleportInBlock.js
var NodeMaterialTeleportInBlock = class extends NodeMaterialBlock {
  /** Gets the list of attached endpoints */
  get endpoints() {
    return this._endpoints;
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    const input = this._inputs[0];
    if (input.isConnected) {
      const block = input.connectedPoint.ownerBlock;
      if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return block.target;
      }
      if (input.connectedPoint.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return input.connectedPoint.target;
      }
    }
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  /**
   * Create a new NodeMaterialTeleportInBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this._endpoints = [];
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialTeleportInBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * @returns a boolean indicating that this connection will be used in the fragment shader
   */
  isConnectedInFragmentShader() {
    return this.endpoints.some((e) => e.output.isConnectedInFragmentShader);
  }
  /**
   * Checks if the input is connected to a uniform input block
   */
  get isConnectedToUniform() {
    return this.input.isConnected && this.input.connectedPoint.ownerBlock.isInput && this.input.connectedPoint.ownerBlock.isUniform;
  }
  _dumpCode(uniqueNames, alreadyDumped) {
    let codeString = super._dumpCode(uniqueNames, alreadyDumped);
    for (const endpoint of this.endpoints) {
      if (alreadyDumped.indexOf(endpoint) === -1) {
        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    return codeString;
  }
  /**
   * Checks if the current block is an ancestor of a given block
   * @param block defines the potential descendant block to check
   * @returns true if block is a descendant
   */
  isAnAncestorOf(block) {
    for (const endpoint of this.endpoints) {
      if (endpoint === block) {
        return true;
      }
      if (endpoint.isAnAncestorOf(block)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Add an enpoint to this block
   * @param endpoint define the endpoint to attach to
   */
  attachToEndpoint(endpoint) {
    endpoint.detach();
    this._endpoints.push(endpoint);
    endpoint._entryPoint = this;
    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];
    endpoint._tempEntryPointUniqueId = null;
    endpoint.name = "> " + this.name;
    this._outputs = this._endpoints.map((e) => e.output);
  }
  /**
   * Remove enpoint from this block
   * @param endpoint define the endpoint to remove
   */
  detachFromEndpoint(endpoint) {
    const index = this._endpoints.indexOf(endpoint);
    if (index !== -1) {
      this._endpoints.splice(index, 1);
      endpoint._outputs[0]._typeConnectionSource = null;
      endpoint._entryPoint = null;
      this._outputs = this._endpoints.map((e) => e.output);
    }
  }
  /**
   * Release resources
   */
  dispose() {
    super.dispose();
    for (const endpoint of this._endpoints) {
      this.detachFromEndpoint(endpoint);
    }
    this._endpoints = [];
  }
};
RegisterClass("BABYLON.NodeMaterialTeleportInBlock", NodeMaterialTeleportInBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/Teleport/teleportOutBlock.js
var NodeMaterialTeleportOutBlock = class extends NodeMaterialBlock {
  /**
   * Create a new TeleportOutBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this._entryPoint = null;
    this._tempEntryPointUniqueId = null;
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
  }
  /**
   * Gets the entry point
   */
  get entryPoint() {
    return this._entryPoint;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialTeleportOutBlock";
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    return this._entryPoint ? this._entryPoint.target : this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  /** Detach from entry point */
  detach() {
    if (!this._entryPoint) {
      return;
    }
    this._entryPoint.detachFromEndpoint(this);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.entryPoint) {
      return;
    }
    if (this.entryPoint.isConnectedToUniform) {
      this.output.associatedVariableName = this.entryPoint.input.associatedVariableName;
      return;
    }
    state.compilationString += state._declareOutput(this.output) + ` = ${this.entryPoint.input.associatedVariableName};
`;
  }
  /**
   * Clone the current block to a new identical block
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a copy of the current block
   */
  clone(scene, rootUrl = "") {
    const clone = super.clone(scene, rootUrl);
    if (this.entryPoint) {
      this.entryPoint.attachToEndpoint(clone);
    }
    return clone;
  }
  _customBuildStep(state, activeBlocks) {
    if (this.entryPoint) {
      this.entryPoint.build(state, activeBlocks);
    }
  }
  _dumpCode(uniqueNames, alreadyDumped) {
    let codeString = "";
    if (this.entryPoint) {
      if (alreadyDumped.indexOf(this.entryPoint) === -1) {
        codeString += this.entryPoint._dumpCode(uniqueNames, alreadyDumped);
      }
    }
    return codeString + super._dumpCode(uniqueNames, alreadyDumped);
  }
  _dumpCodeForOutputConnections(alreadyDumped) {
    let codeString = super._dumpCodeForOutputConnections(alreadyDumped);
    if (this.entryPoint) {
      codeString += this.entryPoint._dumpCodeForOutputConnections(alreadyDumped);
    }
    return codeString;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.entryPoint) {
      codeString += `${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});
`;
    }
    return codeString;
  }
  /**
   * Serializes this block in a JSON representation
   * @returns the serialized block object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.entryPoint = this.entryPoint?.uniqueId ?? "";
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this._tempEntryPointUniqueId = serializationObject.entryPoint;
  }
};
RegisterClass("BABYLON.NodeMaterialTeleportOutBlock", NodeMaterialTeleportOutBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/addBlock.js
var AddBlock = class extends BaseMathBlock {
  /**
   * Creates a new AddBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "AddBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} + ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.AddBlock", AddBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/scaleBlock.js
var ScaleBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ScaleBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("factor", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ScaleBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the factor input component
   */
  get factor() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName} * ${this.factor.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.ScaleBlock", ScaleBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/clampBlock.js
var ClampBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ClampBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.minimum = 0;
    this.maximum = 1;
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ClampBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const cast = state.shaderLanguage === 1 ? state._getShaderType(this.value.type) : "";
    state.compilationString += state._declareOutput(output) + ` = clamp(${this.value.associatedVariableName}, ${cast}(${this._writeFloat(this.minimum)}), ${cast}(${this._writeFloat(this.maximum)}));
`;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.minimum = ${this.minimum};
`;
    codeString += `${this._codeVariableName}.maximum = ${this.maximum};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.minimum = this.minimum;
    serializationObject.maximum = this.maximum;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.minimum = serializationObject.minimum;
    this.maximum = serializationObject.maximum;
  }
};
__decorate([
  editableInPropertyPage("Minimum", 1, void 0, { embedded: true })
], ClampBlock.prototype, "minimum", void 0);
__decorate([
  editableInPropertyPage("Maximum", 1, void 0, { embedded: true })
], ClampBlock.prototype, "maximum", void 0);
RegisterClass("BABYLON.ClampBlock", ClampBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/crossBlock.js
var CrossBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new CrossBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CrossBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = cross(${this.left.associatedVariableName}.xyz, ${this.right.associatedVariableName}.xyz);
`;
    return this;
  }
};
RegisterClass("BABYLON.CrossBlock", CrossBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/customBlock.js
var CustomBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the options for this custom block
   */
  get options() {
    return this._options;
  }
  set options(options) {
    this._deserializeOptions(options);
  }
  /**
   * Creates a new CustomBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CustomBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    let code = this._code;
    let functionName = this._options.functionName;
    for (const input of this._inputs) {
      const rexp = new RegExp("\\{TYPE_" + input.name + "\\}", "gm");
      const type = state._getGLType(input.type);
      code = code.replace(rexp, type);
      functionName = functionName.replace(rexp, type);
    }
    for (const output of this._outputs) {
      const rexp = new RegExp("\\{TYPE_" + output.name + "\\}", "gm");
      const type = state._getGLType(output.type);
      code = code.replace(rexp, type);
      functionName = functionName.replace(rexp, type);
    }
    state._emitFunction(functionName, code, "");
    for (const output of this._outputs) {
      state.compilationString += state._declareOutput(output) + ";\n";
    }
    state.compilationString += functionName + "(";
    let hasInput = false;
    for (let i = 0; i < this._inputs.length; i++) {
      const input = this._inputs[i];
      if (i > 0) {
        state.compilationString += ", ";
      }
      if (this._inputSamplers && this._inputSamplers.indexOf(input.name) !== -1) {
        state.compilationString += input.connectedPoint?.ownerBlock?.samplerName ?? input.associatedVariableName;
      } else {
        state.compilationString += input.associatedVariableName;
      }
      hasInput = true;
    }
    for (let i = 0; i < this._outputs.length; i++) {
      const output = this._outputs[i];
      if (i > 0 || hasInput) {
        state.compilationString += ", ";
      }
      state.compilationString += output.associatedVariableName;
    }
    state.compilationString += ");\n";
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.options = ${JSON.stringify(this._options)};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.options = this._options;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    this._deserializeOptions(serializationObject.options);
    super._deserialize(serializationObject, scene, rootUrl);
  }
  _deserializeOptions(options) {
    this._options = options;
    this._code = options.code.join("\n") + "\n";
    this.name = this.name || options.name;
    this.target = NodeMaterialBlockTargets[options.target];
    if (options.inParameters) {
      for (let i = 0; i < options.inParameters.length; i++) {
        const input = options.inParameters[i];
        const type = NodeMaterialBlockConnectionPointTypes[input.type];
        if (input.type === "sampler2D" || input.type === "samplerCube" || input.type === "sampler2DArray") {
          this._inputSamplers = this._inputSamplers || [];
          this._inputSamplers.push(input.name);
          this.registerInput(input.name, NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(input.name, this, 0, ImageSourceBlock, "ImageSourceBlock"));
        } else {
          this.registerInput(input.name, type);
        }
        Object.defineProperty(this, input.name, {
          get: function() {
            return this._inputs[i];
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (options.outParameters) {
      for (let i = 0; i < options.outParameters.length; i++) {
        const output = options.outParameters[i];
        this.registerOutput(output.name, NodeMaterialBlockConnectionPointTypes[output.type]);
        Object.defineProperty(this, output.name, {
          get: function() {
            return this._outputs[i];
          },
          enumerable: true,
          configurable: true
        });
        if (output.type === "BasedOnInput") {
          this._outputs[i]._typeConnectionSource = this._findInputByName(output.typeFromInput)[0];
        }
      }
    }
    if (options.inLinkedConnectionTypes) {
      for (const connection of options.inLinkedConnectionTypes) {
        this._linkConnectionTypes(this._findInputByName(connection.input1)[1], this._findInputByName(connection.input2)[1]);
      }
    }
  }
  _findInputByName(name6) {
    if (!name6) {
      return null;
    }
    for (let i = 0; i < this._inputs.length; i++) {
      if (this._inputs[i].name === name6) {
        return [this._inputs[i], i];
      }
    }
    return null;
  }
};
RegisterClass("BABYLON.CustomBlock", CustomBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/dotBlock.js
var DotBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new DotBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DotBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = dot(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.DotBlock", DotBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalizeBlock.js
var NormalizeBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new NormalizeBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NormalizeBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input = this._inputs[0];
    state.compilationString += state._declareOutput(output) + ` = normalize(${input.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.NormalizeBlock", NormalizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorMergerBlock.js
var ColorMergerBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ColorMergerBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.rSwizzle = "r";
    this.gSwizzle = "g";
    this.bSwizzle = "b";
    this.aSwizzle = "a";
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerInput("r", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("g", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("b", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ColorMergerBlock";
  }
  /**
   * Gets the rgb component (input)
   */
  get rgbIn() {
    return this._inputs[0];
  }
  /**
   * Gets the r component (input)
   */
  get r() {
    return this._inputs[1];
  }
  /**
   * Gets the g component (input)
   */
  get g() {
    return this._inputs[2];
  }
  /**
   * Gets the b component (input)
   */
  get b() {
    return this._inputs[3];
  }
  /**
   * Gets the a component (input)
   */
  get a() {
    return this._inputs[4];
  }
  /**
   * Gets the rgba component (output)
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb component (output)
   */
  get rgbOut() {
    return this._outputs[1];
  }
  /**
   * Gets the rgb component (output)
   * @deprecated Please use rgbOut instead.
   */
  get rgb() {
    return this.rgbOut;
  }
  _inputRename(name6) {
    if (name6 === "rgb ") {
      return "rgbIn";
    }
    return name6;
  }
  _outputRename(name6) {
    if (name6 === "rgb") {
      return "rgbOut";
    }
    return name6;
  }
  _buildSwizzle(len) {
    const swizzle = this.rSwizzle + this.gSwizzle + this.bSwizzle + this.aSwizzle;
    return "." + swizzle.substring(0, len);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rInput = this.r;
    const gInput = this.g;
    const bInput = this.b;
    const aInput = this.a;
    const rgbInput = this.rgbIn;
    const color4Output = this._outputs[0];
    const color3Output = this._outputs[1];
    const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    if (rgbInput.isConnected) {
      if (color4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(color4Output) + ` = ${vec4}(${rgbInput.associatedVariableName}, ${aInput.isConnected ? this._writeVariable(aInput) : "0.0"})${this._buildSwizzle(4)};
`;
      }
      if (color3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(color3Output) + ` = ${rgbInput.associatedVariableName}${this._buildSwizzle(3)};
`;
      }
    } else {
      if (color4Output.hasEndpoints) {
        state.compilationString += state._declareOutput(color4Output) + ` = ${vec4}(${rInput.isConnected ? this._writeVariable(rInput) : "0.0"}, ${gInput.isConnected ? this._writeVariable(gInput) : "0.0"}, ${bInput.isConnected ? this._writeVariable(bInput) : "0.0"}, ${aInput.isConnected ? this._writeVariable(aInput) : "0.0"})${this._buildSwizzle(4)};
`;
      }
      if (color3Output.hasEndpoints) {
        state.compilationString += state._declareOutput(color3Output) + ` = ${vec3}(${rInput.isConnected ? this._writeVariable(rInput) : "0.0"}, ${gInput.isConnected ? this._writeVariable(gInput) : "0.0"}, ${bInput.isConnected ? this._writeVariable(bInput) : "0.0"})${this._buildSwizzle(3)};
`;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.rSwizzle = this.rSwizzle;
    serializationObject.gSwizzle = this.gSwizzle;
    serializationObject.bSwizzle = this.bSwizzle;
    serializationObject.aSwizzle = this.aSwizzle;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.rSwizzle = serializationObject.rSwizzle ?? "r";
    this.gSwizzle = serializationObject.gSwizzle ?? "g";
    this.bSwizzle = serializationObject.bSwizzle ?? "b";
    this.aSwizzle = serializationObject.aSwizzle ?? "a";
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.rSwizzle = "${this.rSwizzle}";
`;
    codeString += `${this._codeVariableName}.gSwizzle = "${this.gSwizzle}";
`;
    codeString += `${this._codeVariableName}.bSwizzle = "${this.bSwizzle}";
`;
    codeString += `${this._codeVariableName}.aSwizzle = "${this.aSwizzle}";
`;
    return codeString;
  }
};
RegisterClass("BABYLON.ColorMergerBlock", ColorMergerBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorSplitterBlock.js
var VectorSplitterBlock = class extends NodeMaterialBlock {
  /**
   * Create a new VectorSplitterBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
    this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("z", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("w", NodeMaterialBlockConnectionPointTypes.Float);
    this.inputsAreExclusive = true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VectorSplitterBlock";
  }
  /**
   * Gets the xyzw component (input)
   */
  get xyzw() {
    return this._inputs[0];
  }
  /**
   * Gets the xyz component (input)
   */
  get xyzIn() {
    return this._inputs[1];
  }
  /**
   * Gets the xy component (input)
   */
  get xyIn() {
    return this._inputs[2];
  }
  /**
   * Gets the xyz component (output)
   */
  get xyzOut() {
    return this._outputs[0];
  }
  /**
   * Gets the xy component (output)
   */
  get xyOut() {
    return this._outputs[1];
  }
  /**
   * Gets the zw component (output)
   */
  get zw() {
    return this._outputs[2];
  }
  /**
   * Gets the x component (output)
   */
  get x() {
    return this._outputs[3];
  }
  /**
   * Gets the y component (output)
   */
  get y() {
    return this._outputs[4];
  }
  /**
   * Gets the z component (output)
   */
  get z() {
    return this._outputs[5];
  }
  /**
   * Gets the w component (output)
   */
  get w() {
    return this._outputs[6];
  }
  _inputRename(name6) {
    switch (name6) {
      case "xy ":
        return "xyIn";
      case "xyz ":
        return "xyzIn";
      default:
        return name6;
    }
  }
  _outputRename(name6) {
    switch (name6) {
      case "xy":
        return "xyOut";
      case "xyz":
        return "xyzOut";
      default:
        return name6;
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this.xyzw.isConnected ? this.xyzw : this.xyzIn.isConnected ? this.xyzIn : this.xyIn;
    const xyzOutput = this._outputs[0];
    const xyOutput = this._outputs[1];
    const zwOutput = this._outputs[2];
    const xOutput = this._outputs[3];
    const yOutput = this._outputs[4];
    const zOutput = this._outputs[5];
    const wOutput = this._outputs[6];
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    if (xyzOutput.hasEndpoints) {
      if (input === this.xyIn) {
        state.compilationString += state._declareOutput(xyzOutput) + ` = ${vec3}(${input.associatedVariableName}, 0.0);
`;
      } else {
        state.compilationString += state._declareOutput(xyzOutput) + ` = ${input.associatedVariableName}.xyz;
`;
      }
    }
    if (zwOutput.hasEndpoints && this.xyzw.isConnected) {
      state.compilationString += state._declareOutput(zwOutput) + ` = ${this.xyzw.associatedVariableName}.zw;
`;
    }
    if (xyOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(xyOutput) + ` = ${input.associatedVariableName}.xy;
`;
    }
    if (xOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(xOutput) + ` = ${input.associatedVariableName}.x;
`;
    }
    if (yOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(yOutput) + ` = ${input.associatedVariableName}.y;
`;
    }
    if (zOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(zOutput) + ` = ${input.associatedVariableName}.z;
`;
    }
    if (wOutput.hasEndpoints) {
      state.compilationString += state._declareOutput(wOutput) + ` = ${input.associatedVariableName}.w;
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VectorSplitterBlock", VectorSplitterBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/lerpBlock.js
var LerpBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new LerpBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(1, 2, true);
    this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "LerpBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the gradient operand input component
   */
  get gradient() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.LerpBlock", LerpBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/divideBlock.js
var DivideBlock = class extends BaseMathBlock {
  /**
   * Creates a new DivideBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DivideBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} / ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.DivideBlock", DivideBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/subtractBlock.js
var SubtractBlock = class extends BaseMathBlock {
  /**
   * Creates a new SubtractBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SubtractBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} - ${this.right.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.SubtractBlock", SubtractBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/stepBlock.js
var StepBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new StepBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("edge", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "StepBlock";
  }
  /**
   * Gets the value operand input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the edge operand input component
   */
  get edge() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = step(${this.edge.associatedVariableName}, ${this.value.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.StepBlock", StepBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/oneMinusBlock.js
var OneMinusBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new OneMinusBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._outputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "OneMinusBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = 1. - ${this.input.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.OneMinusBlock", OneMinusBlock);
RegisterClass("BABYLON.OppositeBlock", OneMinusBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/viewDirectionBlock.js
var ViewDirectionBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ViewDirectionBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ViewDirectionBlock";
  }
  /**
   * Gets the world position component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the camera position component
   */
  get cameraPosition() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);
`;
    return this;
  }
};
RegisterClass("BABYLON.ViewDirectionBlock", ViewDirectionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/fresnelBlock.js
var FresnelBlock = class extends NodeMaterialBlock {
  /**
   * Create a new FresnelBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("viewDirection", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("bias", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("power", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("fresnel", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "FresnelBlock";
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[0];
  }
  /**
   * Gets the view direction input component
   */
  get viewDirection() {
    return this._inputs[1];
  }
  /**
   * Gets the bias input component
   */
  get bias() {
    return this._inputs[2];
  }
  /**
   * Gets the camera (or eye) position component
   */
  get power() {
    return this._inputs[3];
  }
  /**
   * Gets the fresnel output component
   */
  get fresnel() {
    return this._outputs[0];
  }
  autoConfigure(material) {
    if (!this.viewDirection.isConnected) {
      const viewDirectionInput = new ViewDirectionBlock("View direction");
      viewDirectionInput.output.connectTo(this.viewDirection);
      viewDirectionInput.autoConfigure(material);
    }
    if (!this.bias.isConnected) {
      const biasInput = new InputBlock("bias");
      biasInput.value = 0;
      biasInput.output.connectTo(this.bias);
    }
    if (!this.power.isConnected) {
      const powerInput = new InputBlock("power");
      powerInput.value = 1;
      powerInput.output.connectTo(this.power);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("fresnelFunction", comments, { removeIfDef: true });
    state.compilationString += state._declareOutput(this.fresnel) + ` = computeFresnelTerm(${this.viewDirection.associatedVariableName}.xyz, ${this.worldNormal.associatedVariableName}.xyz, ${this.bias.associatedVariableName}, ${this.power.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.FresnelBlock", FresnelBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/maxBlock.js
var MaxBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MaxBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MaxBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = max(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.MaxBlock", MaxBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/minBlock.js
var MinBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MinBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MinBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = min(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.MinBlock", MinBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/distanceBlock.js
var DistanceBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new DistanceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DistanceBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = length(${this.left.associatedVariableName} - ${this.right.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.DistanceBlock", DistanceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/lengthBlock.js
var LengthBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new LengthBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "LengthBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = length(${this.value.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.LengthBlock", LengthBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/negateBlock.js
var NegateBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new NegateBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NegateBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = -1.0 * ${this.value.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.NegateBlock", NegateBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/powBlock.js
var PowBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new PowBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("power", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PowBlock";
  }
  /**
   * Gets the value operand input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the power operand input component
   */
  get power() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = pow(max(${this.value.associatedVariableName}, 0.), ${this.power.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.PowBlock", PowBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/randomNumberBlock.js
var RandomNumberBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new RandomNumberBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RandomNumberBlock";
  }
  /**
   * Gets the seed input component
   */
  get seed() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state.compilationString += state._declareOutput(output) + ` = getRand(${this.seed.associatedVariableName}.xy);
`;
    return this;
  }
};
RegisterClass("BABYLON.RandomNumberBlock", RandomNumberBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/arcTan2Block.js
var ArcTan2Block = class extends NodeMaterialBlock {
  /**
   * Creates a new ArcTan2Block
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ArcTan2Block";
  }
  /**
   * Gets the x operand input component
   */
  get x() {
    return this._inputs[0];
  }
  /**
   * Gets the y operand input component
   */
  get y() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const func = state.shaderLanguage === 1 ? "atan2" : "atan";
    state.compilationString += state._declareOutput(output) + ` = ${func}(${this.x.associatedVariableName}, ${this.y.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.ArcTan2Block", ArcTan2Block);

// node_modules/@babylonjs/core/Materials/Node/Blocks/smoothStepBlock.js
var SmoothStepBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new SmoothStepBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("edge0", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("edge1", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SmoothStepBlock";
  }
  /**
   * Gets the value operand input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the first edge operand input component
   */
  get edge0() {
    return this._inputs[1];
  }
  /**
   * Gets the second edge operand input component
   */
  get edge1() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const cast = state._getShaderType(this.value.type);
    state.compilationString += state._declareOutput(output) + ` = smoothstep(${cast}(${this.edge0.associatedVariableName}), ${cast}(${this.edge1.associatedVariableName}), ${this.value.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.SmoothStepBlock", SmoothStepBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/reciprocalBlock.js
var ReciprocalBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ReciprocalBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReciprocalBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    if (this.input.type === NodeMaterialBlockConnectionPointTypes.Matrix) {
      state.compilationString += state._declareOutput(output) + ` = inverse(${this.input.associatedVariableName});
`;
    } else {
      state.compilationString += state._declareOutput(output) + ` = 1. / ${this.input.associatedVariableName};
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ReciprocalBlock", ReciprocalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/replaceColorBlock.js
var ReplaceColorBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ReplaceColorBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("reference", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("distance", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("replacement", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(0, 3);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReplaceColorBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the reference input component
   */
  get reference() {
    return this._inputs[1];
  }
  /**
   * Gets the distance input component
   */
  get distance() {
    return this._inputs[2];
  }
  /**
   * Gets the replacement input component
   */
  get replacement() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + `;
`;
    state.compilationString += `if (length(${this.value.associatedVariableName} - ${this.reference.associatedVariableName}) < ${this.distance.associatedVariableName}) {
`;
    state.compilationString += `${output.associatedVariableName} = ${this.replacement.associatedVariableName};
`;
    state.compilationString += `} else {
`;
    state.compilationString += `${output.associatedVariableName} = ${this.value.associatedVariableName};
`;
    state.compilationString += `}
`;
    return this;
  }
};
RegisterClass("BABYLON.ReplaceColorBlock", ReplaceColorBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/posterizeBlock.js
var PosterizeBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new PosterizeBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("steps", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PosterizeBlock";
  }
  /**
   * Gets the value input component
   */
  get value() {
    return this._inputs[0];
  }
  /**
   * Gets the steps input component
   */
  get steps() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = floor(${this.value.associatedVariableName} / (1.0 / ${this.steps.associatedVariableName})) * (1.0 / ${this.steps.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.PosterizeBlock", PosterizeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/waveBlock.js
var WaveBlockKind;
(function(WaveBlockKind2) {
  WaveBlockKind2[WaveBlockKind2["SawTooth"] = 0] = "SawTooth";
  WaveBlockKind2[WaveBlockKind2["Square"] = 1] = "Square";
  WaveBlockKind2[WaveBlockKind2["Triangle"] = 2] = "Triangle";
})(WaveBlockKind || (WaveBlockKind = {}));
var WaveBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new WaveBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.kind = 0;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "WaveBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    switch (this.kind) {
      case 0: {
        state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName});
`;
        break;
      }
      case 1: {
        state.compilationString += state._declareOutput(output) + ` = 1.0 - 2.0 * round(fract(${this.input.associatedVariableName}));
`;
        break;
      }
      case 2: {
        state.compilationString += state._declareOutput(output) + ` = 2.0 * abs(2.0 * (${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName}))) - 1.0;
`;
        break;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.kind = this.kind;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.kind = serializationObject.kind;
  }
};
__decorate([
  editableInPropertyPage("Kind", 5, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      {
        label: "SawTooth",
        value: 0
        /* WaveBlockKind.SawTooth */
      },
      {
        label: "Square",
        value: 1
        /* WaveBlockKind.Square */
      },
      {
        label: "Triangle",
        value: 2
        /* WaveBlockKind.Triangle */
      }
    ]
  })
], WaveBlock.prototype, "kind", void 0);
RegisterClass("BABYLON.WaveBlock", WaveBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/gradientBlock.js
var GradientBlockColorStep = class {
  /**
   * Gets value indicating which step this color is associated with (between 0 and 1)
   */
  get step() {
    return this._step;
  }
  /**
   * Sets a value indicating which step this color is associated with (between 0 and 1)
   */
  set step(val) {
    this._step = val;
  }
  /**
   * Gets the color associated with this step
   */
  get color() {
    return this._color;
  }
  /**
   * Sets the color associated with this step
   */
  set color(val) {
    this._color = val;
  }
  /**
   * Creates a new GradientBlockColorStep
   * @param step defines a value indicating which step this color is associated with (between 0 and 1)
   * @param color defines the color associated with this step
   */
  constructor(step, color) {
    this.step = step;
    this.color = color;
  }
};
var GradientBlock = class extends NodeMaterialBlock {
  /** calls observable when the value is changed*/
  colorStepsUpdated() {
    this.onValueChangedObservable.notifyObservers(this);
  }
  /**
   * Creates a new GradientBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.colorSteps = [new GradientBlockColorStep(0, Color3.Black()), new GradientBlockColorStep(1, Color3.White())];
    this.onValueChangedObservable = new Observable();
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Float | NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GradientBlock";
  }
  /**
   * Gets the gradient input component
   */
  get gradient() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _writeColorConstant(index, vec3) {
    const step = this.colorSteps[index];
    return `${vec3}(${step.color.r}, ${step.color.g}, ${step.color.b})`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    if (!this.colorSteps.length || !this.gradient.connectedPoint) {
      state.compilationString += state._declareOutput(output) + ` = ${vec3}(0., 0., 0.);
`;
      return;
    }
    const tempColor = state._getFreeVariableName("gradientTempColor");
    const tempPosition = state._getFreeVariableName("gradientTempPosition");
    state.compilationString += `${state._declareLocalVar(tempColor, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._writeColorConstant(0, vec3)};
`;
    state.compilationString += `${state._declareLocalVar(tempPosition, NodeMaterialBlockConnectionPointTypes.Float)};
`;
    let gradientSource = this.gradient.associatedVariableName;
    if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {
      gradientSource += ".x";
    }
    for (let index = 1; index < this.colorSteps.length; index++) {
      const step = this.colorSteps[index];
      const previousStep = this.colorSteps[index - 1];
      state.compilationString += `${tempPosition} = clamp((${gradientSource} - ${state._emitFloat(previousStep.step)}) / (${state._emitFloat(step.step)} -  ${state._emitFloat(previousStep.step)}), 0.0, 1.0) * step(${state._emitFloat(index)}, ${state._emitFloat(this.colorSteps.length - 1)});
`;
      state.compilationString += `${tempColor} = mix(${tempColor}, ${this._writeColorConstant(index, vec3)}, ${tempPosition});
`;
    }
    state.compilationString += state._declareOutput(output) + ` = ${tempColor};
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.colorSteps = [];
    for (const step of this.colorSteps) {
      serializationObject.colorSteps.push({
        step: step.step,
        color: {
          r: step.color.r,
          g: step.color.g,
          b: step.color.b
        }
      });
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.colorSteps.length = 0;
    for (const step of serializationObject.colorSteps) {
      this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));
    }
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.colorSteps = [];
`;
    for (const colorStep of this.colorSteps) {
      codeString += `${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${colorStep.step}, new BABYLON.Color3(${colorStep.color.r}, ${colorStep.color.g}, ${colorStep.color.b})));
`;
    }
    return codeString;
  }
};
RegisterClass("BABYLON.GradientBlock", GradientBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/nLerpBlock.js
var NLerpBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new NLerpBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._linkConnectionTypes(1, 2, true);
    this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NLerpBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the gradient operand input component
   */
  get gradient() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = normalize(mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName}));
`;
    return this;
  }
};
RegisterClass("BABYLON.NLerpBlock", NLerpBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/worleyNoise3DBlock.js
var WorleyNoise3DBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new WorleyNoise3DBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.manhattanDistance = false;
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("jitter", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "WorleyNoise3DBlock";
  }
  /**
   * Gets the seed input component
   */
  get seed() {
    return this._inputs[0];
  }
  /**
   * Gets the jitter input component
   */
  get jitter() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the x component
   */
  get x() {
    return this._outputs[1];
  }
  /**
   * Gets the y component
   */
  get y() {
    return this._outputs[2];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this.output.hasEndpoints && !this.x.hasEndpoints && !this.y.hasEndpoints) {
      return;
    }
    let functionString = `vec3 permute(vec3 x){
`;
    functionString += `    return mod((34.0 * x + 1.0) * x, 289.0);
`;
    functionString += `}

`;
    functionString += `vec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance){
`;
    functionString += `    return [manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z)];
`;
    functionString += `}

`;
    functionString += `vec2 worley(vec3 P, float jitter, bool manhattanDistance){
`;
    functionString += `    float K = 0.142857142857; // 1/7
`;
    functionString += `    float Ko = 0.428571428571; // 1/2-K/2
`;
    functionString += `    float  K2 = 0.020408163265306; // 1/(7*7)
`;
    functionString += `    float Kz = 0.166666666667; // 1/6
`;
    functionString += `    float Kzo = 0.416666666667; // 1/2-1/6*2
`;
    functionString += `
`;
    functionString += `    vec3 Pi = mod(floor(P), 289.0);
`;
    functionString += `    vec3 Pf = fract(P) - 0.5;
`;
    functionString += `
`;
    functionString += `    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
`;
    functionString += `    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
`;
    functionString += `    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
`;
    functionString += `
`;
    functionString += `    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));
`;
    functionString += `    vec3 p1 = permute(p + Pi.y - 1.0);
`;
    functionString += `    vec3 p2 = permute(p + Pi.y);
`;
    functionString += `    vec3 p3 = permute(p + Pi.y + 1.0);
`;
    functionString += `
`;
    functionString += `    vec3 p11 = permute(p1 + Pi.z - 1.0);
`;
    functionString += `    vec3 p12 = permute(p1 + Pi.z);
`;
    functionString += `    vec3 p13 = permute(p1 + Pi.z + 1.0);
`;
    functionString += `
`;
    functionString += `    vec3 p21 = permute(p2 + Pi.z - 1.0);
`;
    functionString += `    vec3 p22 = permute(p2 + Pi.z);
`;
    functionString += `    vec3 p23 = permute(p2 + Pi.z + 1.0);
`;
    functionString += `
`;
    functionString += `    vec3 p31 = permute(p3 + Pi.z - 1.0);
`;
    functionString += `    vec3 p32 = permute(p3 + Pi.z);
`;
    functionString += `    vec3 p33 = permute(p3 + Pi.z + 1.0);
`;
    functionString += `
`;
    functionString += `    vec3 ox11 = fract(p11*K) - Ko;
`;
    functionString += `    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed
`;
    functionString += `
`;
    functionString += `    vec3 ox12 = fract(p12*K) - Ko;
`;
    functionString += `    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz12 = floor(p12*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox13 = fract(p13*K) - Ko;
`;
    functionString += `    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz13 = floor(p13*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox21 = fract(p21*K) - Ko;
`;
    functionString += `    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz21 = floor(p21*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox22 = fract(p22*K) - Ko;
`;
    functionString += `    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz22 = floor(p22*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox23 = fract(p23*K) - Ko;
`;
    functionString += `    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz23 = floor(p23*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox31 = fract(p31*K) - Ko;
`;
    functionString += `    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz31 = floor(p31*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox32 = fract(p32*K) - Ko;
`;
    functionString += `    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz32 = floor(p32*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 ox33 = fract(p33*K) - Ko;
`;
    functionString += `    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
`;
    functionString += `    vec3 oz33 = floor(p33*K2)*Kz - Kzo;
`;
    functionString += `
`;
    functionString += `    vec3 dx11 = Pfx + jitter*ox11;
`;
    functionString += `    vec3 dy11 = Pfy.x + jitter*oy11;
`;
    functionString += `    vec3 dz11 = Pfz.x + jitter*oz11;
`;
    functionString += `
`;
    functionString += `    vec3 dx12 = Pfx + jitter*ox12;
`;
    functionString += `    vec3 dy12 = Pfy.x + jitter*oy12;
`;
    functionString += `    vec3 dz12 = Pfz.y + jitter*oz12;
`;
    functionString += `
`;
    functionString += `    vec3 dx13 = Pfx + jitter*ox13;
`;
    functionString += `    vec3 dy13 = Pfy.x + jitter*oy13;
`;
    functionString += `    vec3 dz13 = Pfz.z + jitter*oz13;
`;
    functionString += `
`;
    functionString += `    vec3 dx21 = Pfx + jitter*ox21;
`;
    functionString += `    vec3 dy21 = Pfy.y + jitter*oy21;
`;
    functionString += `    vec3 dz21 = Pfz.x + jitter*oz21;
`;
    functionString += `
`;
    functionString += `    vec3 dx22 = Pfx + jitter*ox22;
`;
    functionString += `    vec3 dy22 = Pfy.y + jitter*oy22;
`;
    functionString += `    vec3 dz22 = Pfz.y + jitter*oz22;
`;
    functionString += `
`;
    functionString += `    vec3 dx23 = Pfx + jitter*ox23;
`;
    functionString += `    vec3 dy23 = Pfy.y + jitter*oy23;
`;
    functionString += `    vec3 dz23 = Pfz.z + jitter*oz23;
`;
    functionString += `
`;
    functionString += `    vec3 dx31 = Pfx + jitter*ox31;
`;
    functionString += `    vec3 dy31 = Pfy.z + jitter*oy31;
`;
    functionString += `    vec3 dz31 = Pfz.x + jitter*oz31;
`;
    functionString += `
`;
    functionString += `    vec3 dx32 = Pfx + jitter*ox32;
`;
    functionString += `    vec3 dy32 = Pfy.z + jitter*oy32;
`;
    functionString += `    vec3 dz32 = Pfz.y + jitter*oz32;
`;
    functionString += `
`;
    functionString += `    vec3 dx33 = Pfx + jitter*ox33;
`;
    functionString += `    vec3 dy33 = Pfy.z + jitter*oy33;
`;
    functionString += `    vec3 dz33 = Pfz.z + jitter*oz33;
`;
    functionString += `
`;
    functionString += `    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);
`;
    functionString += `    vec3 d12 = dist(dx12, dy12, dz12, manhattanDistance);
`;
    functionString += `    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);
`;
    functionString += `    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);
`;
    functionString += `    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);
`;
    functionString += `    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);
`;
    functionString += `    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);
`;
    functionString += `    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);
`;
    functionString += `    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);
`;
    functionString += `
`;
    functionString += `    vec3 d1a = min(d11, d12);
`;
    functionString += `    d12 = max(d11, d12);
`;
    functionString += `    d11 = min(d1a, d13); // Smallest now not in d12 or d13
`;
    functionString += `    d13 = max(d1a, d13);
`;
    functionString += `    d12 = min(d12, d13); // 2nd smallest now not in d13
`;
    functionString += `    vec3 d2a = min(d21, d22);
`;
    functionString += `    d22 = max(d21, d22);
`;
    functionString += `    d21 = min(d2a, d23); // Smallest now not in d22 or d23
`;
    functionString += `    d23 = max(d2a, d23);
`;
    functionString += `    d22 = min(d22, d23); // 2nd smallest now not in d23
`;
    functionString += `    vec3 d3a = min(d31, d32);
`;
    functionString += `    d32 = max(d31, d32);
`;
    functionString += `    d31 = min(d3a, d33); // Smallest now not in d32 or d33
`;
    functionString += `    d33 = max(d3a, d33);
`;
    functionString += `    d32 = min(d32, d33); // 2nd smallest now not in d33
`;
    functionString += `    vec3 da = min(d11, d21);
`;
    functionString += `    d21 = max(d11, d21);
`;
    functionString += `    d11 = min(da, d31); // Smallest now in d11
`;
    functionString += `    d31 = max(da, d31); // 2nd smallest now not in d31
`;
    functionString += `    if (d11.x >= d11.y) { vec2 temp = d11.yx; d11.x = temp.x; d11.y = temp.y; }
`;
    functionString += `    if (d11.x >= d11.z) { vec2 temp = d11.zx; d11.x = temp.x; d11.z = temp.y; }
`;
    functionString += `    d12 = min(d12, d21); // 2nd smallest now not in d21
`;
    functionString += `    d12 = min(d12, d22); // nor in d22
`;
    functionString += `    d12 = min(d12, d31); // nor in d31
`;
    functionString += `    d12 = min(d12, d32); // nor in d32
`;
    functionString += `    vec2 temp2 = min(d11.yz, d12.xy); // nor in d12.yz
`;
    functionString += `    d11.y = temp2.x;
`;
    functionString += `    d11.z = temp2.y;
`;
    functionString += `    d11.y = min(d11.y, d12.z); // Only two more to go
`;
    functionString += `    d11.y = min(d11.y, d11.z); // Done! (Phew!)
`;
    functionString += `    return sqrt(d11.xy); // F1, F2
`;
    functionString += `}

`;
    if (state.shaderLanguage === 1) {
      functionString = state._babylonSLtoWGSL(functionString);
    } else {
      functionString = state._babylonSLtoGLSL(functionString);
    }
    state._emitFunction("worley3D", functionString, "// Worley3D");
    const tempVariable = state._getFreeVariableName("worleyTemp");
    state.compilationString += `${state._declareLocalVar(tempVariable, NodeMaterialBlockConnectionPointTypes.Vector2)} = worley(${this.seed.associatedVariableName}, ${this.jitter.associatedVariableName}, ${this.manhattanDistance});
`;
    if (this.output.hasEndpoints) {
      state.compilationString += state._declareOutput(this.output) + ` = ${tempVariable};
`;
    }
    if (this.x.hasEndpoints) {
      state.compilationString += state._declareOutput(this.x) + ` = ${tempVariable}.x;
`;
    }
    if (this.y.hasEndpoints) {
      state.compilationString += state._declareOutput(this.y) + ` = ${tempVariable}.y;
`;
    }
    return this;
  }
  /**
   * Exposes the properties to the UI?
   * @returns - boolean indicating if the block has properties or not
   */
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.manhattanDistance = ${this.manhattanDistance};
`;
    return codeString;
  }
  /**
   * Exposes the properties to the Serialize?
   * @returns - a serialized object
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.manhattanDistance = this.manhattanDistance;
    return serializationObject;
  }
  /**
   * Exposes the properties to the deserialize?
   * @param serializationObject
   * @param scene
   * @param rootUrl
   */
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.manhattanDistance = serializationObject.manhattanDistance;
  }
};
__decorate([
  editableInPropertyPage("Use Manhattan Distance", 0, "PROPERTIES", { embedded: true, notifiers: { update: false } })
], WorleyNoise3DBlock.prototype, "manhattanDistance", void 0);
RegisterClass("BABYLON.WorleyNoise3DBlock", WorleyNoise3DBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/simplexPerlin3DBlock.js
var SimplexPerlin3DBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new SimplexPerlin3DBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SimplexPerlin3DBlock";
  }
  /**
   * Gets the seed operand input component
   */
  get seed() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    let functionString = `const float SKEWFACTOR = 1.0/3.0;
`;
    functionString += `const float UNSKEWFACTOR = 1.0/6.0;
`;
    functionString += `const float SIMPLEX_CORNER_POS = 0.5;
`;
    functionString += `const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;
`;
    functionString += `float SimplexPerlin3D( vec3 source ){
`;
    functionString += `    vec3 P = source;
`;
    functionString += `    P.x = [P.x == 0. && P.y == 0. && P.z == 0. ? 0.00001 : P.x];
`;
    functionString += `    P *= SIMPLEX_TETRAHADRON_HEIGHT;
`;
    functionString += `    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );`;
    functionString += `    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );
`;
    functionString += `    vec3 g = step(x0.yzx, x0.xyz);
`;
    functionString += `    vec3 l = 1.0 - g;
`;
    functionString += `    vec3 Pi_1 = min( g.xyz, l.zxy );
`;
    functionString += `    vec3 Pi_2 = max( g.xyz, l.zxy );
`;
    functionString += `    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;
`;
    functionString += `    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;
`;
    functionString += `    vec3 x3 = x0 - SIMPLEX_CORNER_POS;
`;
    functionString += `    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );
`;
    functionString += `    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );
`;
    functionString += `    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );
`;
    functionString += `    Pi = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;
`;
    functionString += `    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );
`;
    functionString += `    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;
`;
    functionString += `    Pt *= Pt;
`;
    functionString += `    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );
`;
    functionString += `    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );
`;
    functionString += `    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );
`;
    functionString += `    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );
`;
    functionString += `    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );
`;
    functionString += `    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );
`;
    functionString += `    Pi_1 = [( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods];
`;
    functionString += `    Pi_2 = [( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods];
`;
    functionString += `    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;
`;
    functionString += `    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;
`;
    functionString += `    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;
`;
    functionString += `    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );
`;
    functionString += `    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;
`;
    functionString += `    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;
`;
    functionString += `    kernel_weights = max(0.5 - kernel_weights, vec4(0.));
`;
    functionString += `    kernel_weights = kernel_weights*kernel_weights*kernel_weights;
`;
    functionString += `    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;
`;
    functionString += `}
`;
    if (state.shaderLanguage === 1) {
      functionString = state._babylonSLtoWGSL(functionString);
    } else {
      functionString = state._babylonSLtoGLSL(functionString);
    }
    state._emitFunction("SimplexPerlin3D", functionString, "// SimplexPerlin3D");
    state.compilationString += state._declareOutput(this._outputs[0]) + ` = SimplexPerlin3D(${this.seed.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.SimplexPerlin3DBlock", SimplexPerlin3DBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/normalBlendBlock.js
var NormalBlendBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new NormalBlendBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("normalMap0", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normalMap1", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NormalBlendBlock";
  }
  /**
   * Gets the first input component
   */
  get normalMap0() {
    return this._inputs[0];
  }
  /**
   * Gets the second input component
   */
  get normalMap1() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input0 = this._inputs[0];
    const input1 = this._inputs[1];
    const stepR = state._getFreeVariableName("stepR");
    const stepG = state._getFreeVariableName("stepG");
    state.compilationString += `${state._declareLocalVar(stepR, NodeMaterialBlockConnectionPointTypes.Float)} = step(0.5, ${input0.associatedVariableName}.r);
`;
    state.compilationString += `${state._declareLocalVar(stepG, NodeMaterialBlockConnectionPointTypes.Float)} = step(0.5, ${input0.associatedVariableName}.g);
`;
    state.compilationString += state._declareOutput(output) + `;
`;
    state.compilationString += `${output.associatedVariableName}.r = (1.0 - ${stepR}) * ${input0.associatedVariableName}.r * ${input1.associatedVariableName}.r * 2.0 + ${stepR} * (1.0 - (1.0 - ${input0.associatedVariableName}.r) * (1.0 - ${input1.associatedVariableName}.r) * 2.0);
`;
    state.compilationString += `${output.associatedVariableName}.g = (1.0 - ${stepG}) * ${input0.associatedVariableName}.g * ${input1.associatedVariableName}.g * 2.0 + ${stepG} * (1.0 - (1.0 - ${input0.associatedVariableName}.g) * (1.0 - ${input1.associatedVariableName}.g) * 2.0);
`;
    state.compilationString += `${output.associatedVariableName}.b = ${input0.associatedVariableName}.b * ${input1.associatedVariableName}.b;
`;
    return this;
  }
};
RegisterClass("BABYLON.NormalBlendBlock", NormalBlendBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/rotate2dBlock.js
var Rotate2dBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new Rotate2dBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("angle", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector2);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "Rotate2dBlock";
  }
  /**
   * Gets the input vector
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the input angle
   */
  get angle() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.angle.isConnected) {
      const angleInput = new InputBlock("angle");
      angleInput.value = 0;
      angleInput.output.connectTo(this.angle);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const angle = this.angle;
    const input = this.input;
    state.compilationString += state._declareOutput(output) + ` = vec2(cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.x - sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.y, sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.x + cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.y);
`;
    return this;
  }
};
RegisterClass("BABYLON.Rotate2dBlock", Rotate2dBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/reflectBlock.js
var ReflectBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ReflectBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReflectBlock";
  }
  /**
   * Gets the incident component
   */
  get incident() {
    return this._inputs[0];
  }
  /**
   * Gets the normal component
   */
  get normal() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = reflect(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz);
`;
    return this;
  }
};
RegisterClass("BABYLON.ReflectBlock", ReflectBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/refractBlock.js
var RefractBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new RefractBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("incident", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("ior", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector3);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RefractBlock";
  }
  /**
   * Gets the incident component
   */
  get incident() {
    return this._inputs[0];
  }
  /**
   * Gets the normal component
   */
  get normal() {
    return this._inputs[1];
  }
  /**
   * Gets the index of refraction component
   */
  get ior() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    state.compilationString += state._declareOutput(output) + ` = refract(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz, ${this.ior.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.RefractBlock", RefractBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/desaturateBlock.js
var DesaturateBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new DesaturateBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerInput("level", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "DesaturateBlock";
  }
  /**
   * Gets the color operand input component
   */
  get color() {
    return this._inputs[0];
  }
  /**
   * Gets the level operand input component
   */
  get level() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const color = this.color;
    const colorName = color.associatedVariableName;
    const tempMin = state._getFreeVariableName("colorMin");
    const tempMax = state._getFreeVariableName("colorMax");
    const tempMerge = state._getFreeVariableName("colorMerge");
    state.compilationString += `${state._declareLocalVar(tempMin, NodeMaterialBlockConnectionPointTypes.Float)} = min(min(${colorName}.x, ${colorName}.y), ${colorName}.z);
`;
    state.compilationString += `${state._declareLocalVar(tempMax, NodeMaterialBlockConnectionPointTypes.Float)} = max(max(${colorName}.x, ${colorName}.y), ${colorName}.z);
`;
    state.compilationString += `${state._declareLocalVar(tempMerge, NodeMaterialBlockConnectionPointTypes.Float)} = 0.5 * (${tempMin} + ${tempMax});
`;
    state.compilationString += state._declareOutput(output) + ` = mix(${colorName}, ${state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3)}(${tempMerge}, ${tempMerge}, ${tempMerge}), ${this.level.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.DesaturateBlock", DesaturateBlock);

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
var _environmentFuzzBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAF9UlEQVR4nGWVy64eVxGF16X27u7/HMcyuZGYAINwmTBigngBXoc34El4B0ZMGDJjFCExQUIKiRKZYBITHdvn/L1rF4P+c+yEUqmH9WmtrrWLkdB4C1/91h/9yn947D8+8CfdlBeGGAMtqwNd6K7VWAJrw9qwLtw2nDaernh6wKuHPD3S1Vs6vaPT97W9r/Wx1seKUWj7Uzz6vX79T//wF/Gbx/7rw/jsFB/39nlrX7q99LKrp5bJZXAtrqW1uJIncbNOXafBU+o0tZW28got0AJ3KACsE4OfYvmzfvDMb/+4//Td9snD9rfr9vHWnyz9361/1fpNLLde0mt5pTZ7a9pCm32SrqQTfZI3aqNXHAwvcAB4BPwnk/oMEcqX8eaz1t9cHjxs7133f5z6p2v/Ylme9eWmLbexjlhnrPBirz3WxWv30rw0L/Yi96PpDrcDcPMEfq+qvQCfsFF1blcv2js3vb2xLNd9O/XT1p8u/Vlfnvd+25bResXC6BFLj2WJpUdv7uEe0exGByPoOAC//BH+cgNqUjfkU4mOEetde+O2vf+y8br71Nva+9q/XpYXvZ97z9ardUXrra3RerQWrUU4myLk4AzYiADwJ+NRQ41i7MSNEBIcM5YR1+f21rnlXcPWtbVYW1/a7dL21mZvbK211lv01lpEtIi0MxTmFGzMAABAN6gF1CTPxI1gkXa5Z5xGPNrbfo6xB/bQubW9nXvkHtXDPfqIJd2bI+1mpZjmNK17QFuxDzhBJued8Fy0KLvcp7fpNzJuM3JE7daIWGKMqAylW0bLiHQ0e1ppTXEK8Qrwkzv8fUIua6oG553wQpRIme7lbfpBxm3GnoEMZ+wZlYGMlu6pNh1pT3nqALCEugCeAB2ohKqYk9hZd4JFS5ThDm/lB9N305nGtKfnNKZiqk23qZhySZOcYhHFewXfI54UMCBDOYlU3TMkSaYWaCtdwXu5yprOKUxrqk9FyUWXNKXiBfCNgucGboGAUBwUJzFYO3G+MCwFtdAn6K6UZZSyXCXBAUVdGCoS5IVxAcQNujAHKCiLLHJqDtWZh1GHV0Et8EYNqOABTUhglKJoyKBBgSwCBC6Ajz7Azz+GiJbwhFTkZCXnEM6EJcuHDmmlztCkBE2IkMGAAhQoSCBBvgYA0G6xN4DgLE5IU5iqZA1hJ8zDqCY2qktJHfEnZSpIk6bE++kEXwHUEBMCmBBBFzE5UzNZuyBRshlSSF0aEg6MaDHIgyFCPAqvA/YdIjTgQ3WBLNZkpWoQPnRIUljdGiIkHd9jumgeO0ESEI97cNTPJj6Z4ISOZh1JUSVLwiAs7pRp02aTypRUhwIzjvhfPCKF1wH/BTqwA5pQlnYyipgs6dDBQVncZatZaZUlsUxZYVq0jyfm8kNeBzz/Gu0ETrjABAURAoTJOVVJpDAoM3ZOc5olfmMK42CYMrRTAr6tIK6QiSA84VtIIEosslSTNYUkUxyS5aEDQ6tMmQ7YDMOmjziYx8E56oPEl8DdDgM2/BLeIJVw9CRSTClZg97ZrDl0BF6m49V0GTIZQL4CvNuxFj47w4ASmqUkAalYU+DBoIbK8hAG506aZTLonWFG0IMa1AAHXlegW9wFGuAJG97hhFkqiuCxUZyqSSWR5GCZHKxB7nSwDcZADHiACQ4eJ/Oot9+BvsaLQD2Hby9RUEEs1cUlcdKpmWKSQ2VyqAY56J0RiEEPOqHxXYv2W4yJuANWxBkBOKEGFcwyjlhMYdLJSjLJpA8FAxqMwXZRQA0wgdQ94Hcf4nqDFnQhBDcY5YJUIqSSpnxpRqone6ol+2Af7Il2MJJxnN/8lgIA8yWQUKItaBMRsGEdDIrQoYNTnGSyBqdZQSY16IEYaANOOKn/A+htXH+OdgLOiB1BBOEGCz5ejmO6JpGEeexVJTmohJNORqIlnVDyO4CvvsT2AGm0BVEHo0IMHeEooeQipzDFY5eSNcigLgwoGYlIKHF/ky9Z+xD/WrCfoQUuRCGAKBhlwIBRQvmSuykkMYHkqx7EAPK+/wdqEbWmfB0bfwAAAABJRU5ErkJggg==";
var InstanceNumber = 0;
var loadBRDFTexture = (scene, textureData, textureProperty, textureName) => {
  if (!scene[textureProperty]) {
    const useDelayedTextureLoading = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    const previousState = scene._blockEntityCollection;
    scene._blockEntityCollection = false;
    const texture = Texture.CreateFromBase64String(textureData, textureName + InstanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
    scene._blockEntityCollection = previousState;
    const texturesCache = scene.getEngine().getLoadedTexturesCache();
    const index = texturesCache.indexOf(texture.getInternalTexture());
    if (index !== -1) {
      texturesCache.splice(index, 1);
    }
    texture.isRGBD = true;
    texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    scene[textureProperty] = texture;
    scene.useDelayedTextureLoading = useDelayedTextureLoading;
    RGBDTextureTools.ExpandRGBDTexture(texture);
    const observer = scene.getEngine().onContextRestoredObservable.add(() => {
      texture.isRGBD = true;
      const oo = scene.onBeforeRenderObservable.add(() => {
        if (texture.isReady()) {
          scene.onBeforeRenderObservable.remove(oo);
          RGBDTextureTools.ExpandRGBDTexture(texture);
        }
      });
    });
    scene.onDisposeObservable.add(() => {
      scene.getEngine().onContextRestoredObservable.remove(observer);
    });
  }
  return scene[textureProperty];
};
var GetEnvironmentBRDFTexture = (scene) => {
  return loadBRDFTexture(scene, _environmentBRDFBase64Texture, "environmentBRDFTexture", "EnvironmentBRDFTexture");
};
var GetEnvironmentFuzzBRDFTexture = (scene) => {
  return loadBRDFTexture(scene, _environmentFuzzBRDFBase64Texture, "environmentFuzzBRDFTexture", "EnvironmentFuzzBRDFTexture");
};
var BRDFTextureTools = {
  /**
   * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
   * @param scene defines the hosting scene
   * @returns the environment BRDF texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  GetEnvironmentBRDFTexture,
  /**
   * Gets a default environment fuzz BRDF texture
   * @param scene defines the hosting scene
   * @returns the environment fuzz BRDF texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  GetEnvironmentFuzzBRDFTexture
};

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.BRDF_V_HEIGHT_CORRELATED = false;
    this.MS_BRDF_ENERGY_CONSERVATION = false;
    this.SPHERICAL_HARMONICS = false;
    this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
    this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
    this.LEGACY_SPECULAR_ENERGY_CONSERVATION = false;
    this.BASE_DIFFUSE_MODEL = 0;
    this.DIELECTRIC_SPECULAR_MODEL = 0;
    this.CONDUCTOR_SPECULAR_MODEL = 0;
  }
};
var PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
    this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this._mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
    this.mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
    this._useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
    this.useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
    this._baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
    this.baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
    this._dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
    this.dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
    this._conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
    this.conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
    this._enable(true);
  }
  prepareDefines(defines) {
    defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
    defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
    defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
    defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
    defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;
    defines.LEGACY_SPECULAR_ENERGY_CONSERVATION = this._useLegacySpecularEnergyConservation;
    defines.BASE_DIFFUSE_MODEL = this._baseDiffuseModel;
    defines.DIELECTRIC_SPECULAR_MODEL = this._dielectricSpecularModel;
    defines.CONDUCTOR_SPECULAR_MODEL = this._conductorSpecularModel;
  }
  getClassName() {
    return "PBRBRDFConfiguration";
  }
};
PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL = 0;
PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL = 0;
PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL = 0;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "mixIblRadianceWithIrradiance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useLegacySpecularEnergyConservation", void 0);
__decorate([
  serialize("baseDiffuseModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "baseDiffuseModel", void 0);
__decorate([
  serialize("dielectricSpecularModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "dielectricSpecularModel", void 0);
__decorate([
  serialize("conductorSpecularModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "conductorSpecularModel", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.CLEARCOAT = false;
    this.CLEARCOAT_DEFAULTIOR = false;
    this.CLEARCOAT_TEXTURE = false;
    this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
    this.CLEARCOAT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.CLEARCOAT_BUMP = false;
    this.CLEARCOAT_BUMPDIRECTUV = 0;
    this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    this.CLEARCOAT_REMAP_F0 = false;
    this.CLEARCOAT_TINT = false;
    this.CLEARCOAT_TINT_TEXTURE = false;
    this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TINT_GAMMATEXTURE = false;
  }
};
var PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.roughness = 0;
    this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._remapF0OnInterfaceChange = true;
    this.remapF0OnInterfaceChange = true;
    this._bumpTexture = null;
    this.bumpTexture = null;
    this._isTintEnabled = false;
    this.isTintEnabled = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.tintThickness = 1;
    this._tintTexture = null;
    this.tintTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    const disableBumpMap = this._material._disableBumpMap;
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
          if (!this._tintTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.CLEARCOAT = true;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
          } else {
            defines.CLEARCOAT_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
          } else {
            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          }
          if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
            PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
          } else {
            defines.CLEARCOAT_BUMP = false;
          }
          defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
          if (this._isTintEnabled) {
            defines.CLEARCOAT_TINT = true;
            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
              defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
            } else {
              defines.CLEARCOAT_TINT_TEXTURE = false;
            }
          } else {
            defines.CLEARCOAT_TINT = false;
            defines.CLEARCOAT_TINT_TEXTURE = false;
          }
        }
      }
    } else {
      defines.CLEARCOAT = false;
      defines.CLEARCOAT_TEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
      defines.CLEARCOAT_BUMP = false;
      defines.CLEARCOAT_TINT = false;
      defines.CLEARCOAT_TINT_TEXTURE = false;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.CLEARCOAT_DEFAULTIOR = false;
      defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
      defines.CLEARCOAT_BUMPDIRECTUV = 0;
      defines.CLEARCOAT_REMAP_F0 = false;
      defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const disableBumpMap = this._material._disableBumpMap;
    const invertNormalMapX = this._material._invertNormalMapX;
    const invertNormalMapY = this._material._invertNormalMapY;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
        }
        if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
        }
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
        uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
        BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
        if (scene._mirroredCameraPosition) {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
        } else {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
        }
      }
      if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
        BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
      }
      uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
      const a = 1 - this._indexOfRefraction;
      const b = 1 + this._indexOfRefraction;
      const f0 = Math.pow(-a / b, 2);
      const eta = 1 / this._indexOfRefraction;
      uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
      if (this._isTintEnabled) {
        uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
        uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatSampler", this._texture);
      }
      if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
        uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
      }
      if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._tintTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._tintTexture) {
      activeTextures.push(this._tintTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      animatables.push(this._bumpTexture);
    }
    if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
      animatables.push(this._tintTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._textureRoughness?.dispose();
      this._bumpTexture?.dispose();
      this._tintTexture?.dispose();
    }
  }
  getClassName() {
    return "PBRClearCoatConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.CLEARCOAT_BUMP) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
    }
    if (defines.CLEARCOAT_TINT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
    }
    if (defines.CLEARCOAT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vClearCoatParams", size: 2, type: "vec2" },
        { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
        { name: "vClearCoatInfos", size: 4, type: "vec4" },
        { name: "clearCoatMatrix", size: 16, type: "mat4" },
        { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
        { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
        { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatTintParams", size: 4, type: "vec4" },
        { name: "clearCoatColorAtDistance", size: 1, type: "float" },
        { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
        { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
__decorate([
  serializeAsColor3()
], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.IRIDESCENCE = false;
    this.IRIDESCENCE_TEXTURE = false;
    this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
    this.IRIDESCENCE_THICKNESS_TEXTURE = false;
    this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
  }
};
var PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
    this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
    this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.IRIDESCENCE = true;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
          } else {
            defines.IRIDESCENCE_TEXTURE = false;
          }
          if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
          } else {
            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          }
        }
      }
    } else {
      defines.IRIDESCENCE = false;
      defines.IRIDESCENCE_TEXTURE = false;
      defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
      defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
      defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.updateFloat4("vIridescenceInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._thicknessTexture?.coordinatesIndex ?? 0, this._thicknessTexture?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
        }
        if (this._thicknessTexture) {
          BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
        }
      }
      uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceSampler", this._texture);
      }
      if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._thicknessTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._thicknessTexture?.dispose();
    }
  }
  getClassName() {
    return "PBRIridescenceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.IRIDESCENCE) {
      fallbacks.addFallback(currentRank++, "IRIDESCENCE");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vIridescenceParams", size: 4, type: "vec4" },
        { name: "vIridescenceInfos", size: 4, type: "vec4" },
        { name: "iridescenceMatrix", size: 16, type: "mat4" },
        { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "texture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.ANISOTROPIC = false;
    this.ANISOTROPIC_TEXTURE = false;
    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
    this.ANISOTROPIC_LEGACY = false;
    this.MAINUV1 = false;
  }
};
var PBRAnisotropicConfiguration = class extends MaterialPluginBase {
  /**
   * Sets the anisotropy direction as an angle.
   */
  set angle(value) {
    this.direction.x = Math.cos(value);
    this.direction.y = Math.sin(value);
  }
  /**
   * Gets the anisotropy angle value in radians.
   * @returns the anisotropy angle value in radians.
   */
  get angle() {
    return Math.atan2(this.direction.y, this.direction.x);
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.direction = new Vector2(1, 0);
    this._texture = null;
    this.texture = null;
    this._legacy = false;
    this.legacy = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
    if (this._isEnabled) {
      defines.ANISOTROPIC = this._isEnabled;
      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
          } else {
            defines.ANISOTROPIC_TEXTURE = false;
          }
        }
      }
      if (defines._areMiscDirty) {
        defines.ANISOTROPIC_LEGACY = this._legacy;
      }
    } else {
      defines.ANISOTROPIC = false;
      defines.ANISOTROPIC_TEXTURE = false;
      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
      defines.ANISOTROPIC_LEGACY = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
        BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
      }
      uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.setTexture("anisotropySampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._texture) {
        this._texture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRAnisotropicConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.ANISOTROPIC) {
      fallbacks.addFallback(currentRank++, "ANISOTROPIC");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("anisotropySampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vAnisotropy", size: 3, type: "vec3" },
        { name: "vAnisotropyInfos", size: 2, type: "vec2" },
        { name: "anisotropyMatrix", size: 16, type: "mat4" }
      ]
    };
  }
  /**
   * Parses a anisotropy Configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    super.parse(source, scene, rootUrl);
    if (source.legacy === void 0) {
      this.legacy = true;
    }
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsVector2()
], PBRAnisotropicConfiguration.prototype, "direction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRAnisotropicConfiguration.prototype, "legacy", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SHEEN = false;
    this.SHEEN_TEXTURE = false;
    this.SHEEN_GAMMATEXTURE = false;
    this.SHEEN_TEXTURE_ROUGHNESS = false;
    this.SHEEN_TEXTUREDIRECTUV = 0;
    this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.SHEEN_LINKWITHALBEDO = false;
    this.SHEEN_ROUGHNESS = false;
    this.SHEEN_ALBEDOSCALING = false;
    this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
  }
};
var PBRSheenConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this._linkSheenWithAlbedo = false;
    this.linkSheenWithAlbedo = false;
    this.intensity = 1;
    this.color = Color3.White();
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._roughness = null;
    this.roughness = null;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._albedoScaling = false;
    this.albedoScaling = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.SheenTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.SHEEN = true;
      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
      defines.SHEEN_ROUGHNESS = this._roughness !== null;
      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
            defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
          } else {
            defines.SHEEN_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
          } else {
            defines.SHEEN_TEXTURE_ROUGHNESS = false;
          }
        }
      }
    } else {
      defines.SHEEN = false;
      defines.SHEEN_TEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS = false;
      defines.SHEEN_LINKWITHALBEDO = false;
      defines.SHEEN_ROUGHNESS = false;
      defines.SHEEN_ALBEDOSCALING = false;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.SHEEN_GAMMATEXTURE = false;
      defines.SHEEN_TEXTUREDIRECTUV = 0;
      defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "sheen");
        }
        if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
        }
      }
      uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
      if (this._roughness !== null) {
        uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenSampler", this._texture);
      }
      if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._textureRoughness?.dispose();
    }
  }
  getClassName() {
    return "PBRSheenConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SHEEN) {
      fallbacks.addFallback(currentRank++, "SHEEN");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("sheenSampler", "sheenRoughnessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vSheenColor", size: 4, type: "vec4" },
        { name: "vSheenRoughness", size: 1, type: "float" },
        { name: "vSheenInfos", size: 4, type: "vec4" },
        { name: "sheenMatrix", size: 16, type: "mat4" },
        { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
__decorate([
  serialize()
], PBRSheenConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsColor3()
], PBRSheenConfiguration.prototype, "color", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "roughness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "albedoScaling", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SUBSURFACE = false;
    this.SS_REFRACTION = false;
    this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_TRANSLUCENCY = false;
    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_SCATTERING = false;
    this.SS_DISPERSION = false;
    this.SS_THICKNESSANDMASK_TEXTURE = false;
    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
    this.SS_HAS_THICKNESS = false;
    this.SS_REFRACTIONINTENSITY_TEXTURE = false;
    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
    this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
    this.SS_REFRACTIONMAP_3D = false;
    this.SS_REFRACTIONMAP_OPPOSITEZ = false;
    this.SS_LODINREFRACTIONALPHA = false;
    this.SS_GAMMAREFRACTION = false;
    this.SS_RGBDREFRACTION = false;
    this.SS_LINEARSPECULARREFRACTION = false;
    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
    this.SS_ALBEDOFORREFRACTIONTINT = false;
    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.SS_USE_THICKNESS_AS_DEPTH = false;
    this.SS_USE_GLTF_TEXTURES = false;
    this.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
    this.SS_TRANSLUCENCY_LEGACY = false;
  }
};
var PBRSubSurfaceConfiguration = class _PBRSubSurfaceConfiguration extends MaterialPluginBase {
  /**
   * Diffusion profile for subsurface scattering.
   * Useful for better scattering in the skins or foliages.
   */
  get scatteringDiffusionProfile() {
    if (!this._scene.subSurfaceConfiguration) {
      return null;
    }
    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
  }
  set scatteringDiffusionProfile(c) {
    if (!this._scene.enableSubSurfaceForPrePass()) {
      return;
    }
    if (c) {
      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
    }
  }
  /**
   * Index of refraction of the material's volume.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This ONLY impacts refraction. If not provided or given a non-valid value,
   * the volume will use the same IOR as the surface.
   */
  get volumeIndexOfRefraction() {
    if (this._volumeIndexOfRefraction >= 1) {
      return this._volumeIndexOfRefraction;
    }
    return this._indexOfRefraction;
  }
  set volumeIndexOfRefraction(value) {
    if (value >= 1) {
      this._volumeIndexOfRefraction = value;
    } else {
      this._volumeIndexOfRefraction = -1;
    }
  }
  /**
   * Keeping for backward compatibility... Should not be used anymore. It has been replaced by
   * the property with the correct spelling.
   * @see legacyTranslucency
   */
  get legacyTransluceny() {
    return this.legacyTranslucency;
  }
  set legacyTransluceny(value) {
    this.legacyTranslucency = value;
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markScenePrePassDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
    this._internalMarkScenePrePassDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
    this._isRefractionEnabled = false;
    this.isRefractionEnabled = false;
    this._isTranslucencyEnabled = false;
    this.isTranslucencyEnabled = false;
    this._isDispersionEnabled = false;
    this.isDispersionEnabled = false;
    this._isScatteringEnabled = false;
    this.isScatteringEnabled = false;
    this._scatteringDiffusionProfileIndex = 0;
    this.refractionIntensity = 1;
    this.translucencyIntensity = 1;
    this.useAlbedoToTintRefraction = false;
    this.useAlbedoToTintTranslucency = false;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._refractionTexture = null;
    this.refractionTexture = null;
    this._indexOfRefraction = 1.5;
    this.indexOfRefraction = 1.5;
    this._volumeIndexOfRefraction = -1;
    this._invertRefractionY = false;
    this.invertRefractionY = false;
    this._linkRefractionWithTransparency = false;
    this.linkRefractionWithTransparency = false;
    this.minimumThickness = 0;
    this.maximumThickness = 1;
    this.useThicknessAsDepth = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.dispersion = 0;
    this.diffusionDistance = Color3.White();
    this._useMaskFromThicknessTexture = false;
    this.useMaskFromThicknessTexture = false;
    this._refractionIntensityTexture = null;
    this.refractionIntensityTexture = null;
    this._translucencyIntensityTexture = null;
    this.translucencyIntensityTexture = null;
    this.translucencyColor = null;
    this._translucencyColorTexture = null;
    this.translucencyColorTexture = null;
    this._useGltfStyleTextures = true;
    this.useGltfStyleTextures = true;
    this.applyAlbedoAfterSubSurface = _PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;
    this.legacyTranslucency = _PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY;
    this._scene = material.getScene();
    this.registerForExtraEvents = true;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
          if (!this._refractionIntensityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
          if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
          if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const refractionTexture = this._getRefractionTexture(scene);
        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
          if (!refractionTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      defines.SUBSURFACE = false;
      defines.SS_DISPERSION = false;
      defines.SS_TRANSLUCENCY = false;
      defines.SS_SCATTERING = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
      defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
      return;
    }
    if (defines._areTexturesDirty) {
      defines.SUBSURFACE = true;
      defines.SS_DISPERSION = this._isDispersionEnabled;
      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_TRANSLUCENCY_LEGACY = this.legacyTranslucency;
      defines.SS_SCATTERING = this._isScatteringEnabled;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = this.applyAlbedoAfterSubSurface;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, "SS_TRANSLUCENCYCOLOR_TEXTURE");
            defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;
          }
        }
      }
      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;
      if (this._isRefractionEnabled) {
        if (scene.texturesEnabled) {
          const refractionTexture = this._getRefractionTexture(scene);
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            defines.SS_REFRACTION = true;
            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
          }
        }
      }
      if (this._isTranslucencyEnabled) {
        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
      }
    }
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine defines the engine the material belongs to.
   * @param subMesh the submesh to bind data for
   */
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    if (this.maximumThickness === 0 && this.minimumThickness === 0) {
      uniformBuffer.updateFloat2("vThicknessParam", 0, 0);
    } else {
      subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
      const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
      uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const realTimeFiltering = this._material.realTimeFiltering;
    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
    const refractionTexture = this._getRefractionTexture(scene);
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
        BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
        BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);
        BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, "translucencyColor");
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
        BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
        let depth = 1;
        if (!refractionTexture.isCube) {
          if (refractionTexture.depth) {
            depth = refractionTexture.depth;
          }
        }
        const width = refractionTexture.getSize().width;
        const refractionIor = this.volumeIndexOfRefraction;
        uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
        uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
        if (realTimeFiltering) {
          uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Math.log2(width));
        }
        if (refractionTexture.boundingBoxSize) {
          const cubeTexture = refractionTexture;
          uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
          uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
        }
      }
      if (this._isScatteringEnabled) {
        uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
      }
      uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
      uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
      uniformBuffer.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0);
      uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
      uniformBuffer.updateFloat("dispersion", this.dispersion);
    }
    if (scene.texturesEnabled) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.setTexture("translucencyColorSampler", this._translucencyColorTexture);
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        if (lodBasedMicrosurface) {
          uniformBuffer.setTexture("refractionSampler", refractionTexture);
        } else {
          uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
        }
      }
    }
  }
  /**
   * Returns the texture used for refraction or null if none is used.
   * @param scene defines the scene the material belongs to.
   * @returns - Refraction texture if present.  If no refraction texture and refraction
   * is linked with transparency, returns environment texture.  Otherwise, returns null.
   */
  _getRefractionTexture(scene) {
    if (this._refractionTexture) {
      return this._refractionTexture;
    }
    if (this._isRefractionEnabled) {
      return scene.environmentTexture;
    }
    return null;
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get disableAlphaBlending() {
    return this._isRefractionEnabled && this._linkRefractionWithTransparency;
  }
  /**
   * Fills the list of render target textures.
   * @param renderTargets the list of render targets to update
   */
  fillRenderTargetTextures(renderTargets) {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      renderTargets.push(this._refractionTexture);
    }
  }
  hasTexture(texture) {
    if (this._thicknessTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    if (this._refractionIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyColorTexture === texture) {
      return true;
    }
    return false;
  }
  hasRenderTargetTextures() {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    if (this._refractionIntensityTexture) {
      activeTextures.push(this._refractionIntensityTexture);
    }
    if (this._translucencyColorTexture) {
      activeTextures.push(this._translucencyColorTexture);
    }
    if (this._translucencyIntensityTexture) {
      activeTextures.push(this._translucencyIntensityTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      animatables.push(this._refractionTexture);
    }
    if (this._refractionIntensityTexture && this._refractionIntensityTexture.animations && this._refractionIntensityTexture.animations.length > 0) {
      animatables.push(this._refractionIntensityTexture);
    }
    if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {
      animatables.push(this._translucencyColorTexture);
    }
    if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {
      animatables.push(this._translucencyIntensityTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._thicknessTexture) {
        this._thicknessTexture.dispose();
      }
      if (this._refractionTexture) {
        this._refractionTexture.dispose();
      }
      if (this._refractionIntensityTexture) {
        this._refractionIntensityTexture.dispose();
      }
      if (this._translucencyColorTexture) {
        this._translucencyColorTexture.dispose();
      }
      if (this._translucencyIntensityTexture) {
        this._translucencyIntensityTexture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRSubSurfaceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SS_SCATTERING) {
      fallbacks.addFallback(currentRank++, "SS_SCATTERING");
    }
    if (defines.SS_TRANSLUCENCY) {
      fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
        { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
        { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
        { name: "vRefractionInfos", size: 4, type: "vec4" },
        { name: "refractionMatrix", size: 16, type: "mat4" },
        { name: "vThicknessInfos", size: 2, type: "vec2" },
        { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
        { name: "thicknessMatrix", size: 16, type: "mat4" },
        { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
        { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
        { name: "vThicknessParam", size: 2, type: "vec2" },
        { name: "vDiffusionDistance", size: 3, type: "vec3" },
        { name: "vTintColor", size: 4, type: "vec4" },
        { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
        { name: "vRefractionPosition", size: 3, type: "vec3" },
        { name: "vRefractionSize", size: 3, type: "vec3" },
        { name: "scatteringDiffusionProfile", size: 1, type: "float" },
        { name: "dispersion", size: 1, type: "float" },
        { name: "vTranslucencyColor", size: 4, type: "vec4" },
        { name: "vTranslucencyColorInfos", size: 2, type: "vec2" },
        { name: "translucencyColorMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE = false;
PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY = false;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markScenePrePassDirty")
], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "translucencyColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyColorTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "applyAlbedoAfterSubSurface", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "legacyTranslucency", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters2 = { effect: null, subMesh: null };
var PBRMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
};
var PBRMaterialDefines = class extends ImageProcessingDefinesMixin(PBRMaterialDefinesBase) {
  /**
   * Initializes the PBR Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.PBR = true;
    this.NUM_SAMPLES = "0";
    this.REALTIME_FILTERING = false;
    this.IBL_CDF_FILTERING = false;
    this.ALBEDO = false;
    this.GAMMAALBEDO = false;
    this.ALBEDODIRECTUV = 0;
    this.VERTEXCOLOR = false;
    this.BASE_WEIGHT = false;
    this.BASE_WEIGHTDIRECTUV = 0;
    this.BASE_DIFFUSE_ROUGHNESS = false;
    this.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.AMBIENTINGRAYSCALE = false;
    this.OPACITY = false;
    this.VERTEXALPHA = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHABLEND = false;
    this.ALPHAFROMALBEDO = false;
    this.ALPHATESTVALUE = "0.5";
    this.SPECULAROVERALPHA = false;
    this.RADIANCEOVERALPHA = false;
    this.ALPHAFRESNEL = false;
    this.LINEARALPHAFRESNEL = false;
    this.PREMULTIPLYALPHA = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.GAMMAEMISSIVE = false;
    this.REFLECTIVITY = false;
    this.REFLECTIVITY_GAMMA = false;
    this.REFLECTIVITYDIRECTUV = 0;
    this.SPECULARTERM = false;
    this.MICROSURFACEFROMREFLECTIVITYMAP = false;
    this.MICROSURFACEAUTOMATIC = false;
    this.LODBASEDMICROSFURACE = false;
    this.MICROSURFACEMAP = false;
    this.MICROSURFACEMAPDIRECTUV = 0;
    this.METALLICWORKFLOW = false;
    this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    this.METALLNESSSTOREINMETALMAPBLUE = false;
    this.AOSTOREINMETALMAPRED = false;
    this.METALLIC_REFLECTANCE = false;
    this.METALLIC_REFLECTANCE_GAMMA = false;
    this.METALLIC_REFLECTANCEDIRECTUV = 0;
    this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
    this.REFLECTANCE = false;
    this.REFLECTANCE_GAMMA = false;
    this.REFLECTANCEDIRECTUV = 0;
    this.ENVIRONMENTBRDF = false;
    this.ENVIRONMENTBRDF_RGBD = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.NORMALXYSCALE = true;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.GAMMALIGHTMAP = false;
    this.RGBDLIGHTMAP = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.USESPHERICALFROMREFLECTIONMAP = false;
    this.USEIRRADIANCEMAP = false;
    this.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
    this.USESPHERICALINVERTEX = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.LINEARSPECULARREFLECTION = false;
    this.RADIANCEOCCLUSION = false;
    this.HORIZONOCCLUSION = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.PREPASS = false;
    this.PREPASS_COLOR = false;
    this.PREPASS_COLOR_INDEX = -1;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO = false;
    this.PREPASS_ALBEDO_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_SCREENSPACE_DEPTH = false;
    this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
    this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
    this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_WORLD_NORMAL = false;
    this.PREPASS_WORLD_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_LOCAL_POSITION = false;
    this.PREPASS_LOCAL_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_VELOCITY_LINEAR = false;
    this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.NONUNIFORMSCALING = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_POSITION = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.MORPHTARGETS_UV2 = false;
    this.MORPHTARGETS_COLOR = false;
    this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
    this.MORPHTARGETTEXTURE_HASNORMALS = false;
    this.MORPHTARGETTEXTURE_HASTANGENTS = false;
    this.MORPHTARGETTEXTURE_HASUVS = false;
    this.MORPHTARGETTEXTURE_HASUV2S = false;
    this.MORPHTARGETTEXTURE_HASCOLORS = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.USEPHYSICALLIGHTFALLOFF = false;
    this.USEGLTFLIGHTFALLOFF = false;
    this.TWOSIDEDLIGHTING = false;
    this.MIRRORED = false;
    this.SHADOWFLOAT = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LOGARITHMICDEPTH = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.AREALIGHTSUPPORTED = true;
    this.FORCENORMALFORWARD = false;
    this.SPECULARAA = false;
    this.UNLIT = false;
    this.DECAL_AFTER_DETAIL = false;
    this.DEBUGMODE = 0;
    this.USE_VERTEX_PULLING = false;
    this.CLUSTLIGHT_SLICES = 0;
    this.CLUSTLIGHT_BATCH = 0;
    this.rebuild();
  }
  /**
   * Resets the PBR Material defines.
   */
  reset() {
    super.reset();
    this.ALPHATESTVALUE = "0.5";
    this.PBR = true;
    this.NORMALXYSCALE = true;
  }
};
var PBRBaseMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
};
var PBRBaseMaterial = class _PBRBaseMaterial extends PBRBaseMaterialBase {
  /**
   * Enables realtime filtering on the texture.
   */
  get realTimeFiltering() {
    return this._realTimeFiltering;
  }
  set realTimeFiltering(b) {
    this._realTimeFiltering = b;
    this.markAsDirty(1);
  }
  /**
   * Quality switch for realtime filtering
   */
  get realTimeFilteringQuality() {
    return this._realTimeFilteringQuality;
  }
  set realTimeFilteringQuality(n) {
    this._realTimeFilteringQuality = n;
    this.markAsDirty(1);
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name6, scene, forceGLSL = false) {
    super(name6, scene, void 0, forceGLSL || _PBRBaseMaterial.ForceGLSL);
    this._directIntensity = 1;
    this._emissiveIntensity = 1;
    this._environmentIntensity = 1;
    this._specularIntensity = 1;
    this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
    this._disableBumpMap = false;
    this._albedoTexture = null;
    this._baseWeightTexture = null;
    this._baseDiffuseRoughnessTexture = null;
    this._ambientTexture = null;
    this._ambientTextureStrength = 1;
    this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._reflectivityTexture = null;
    this._metallicTexture = null;
    this._metallic = null;
    this._roughness = null;
    this._metallicF0Factor = 1;
    this._metallicReflectanceColor = Color3.White();
    this._useOnlyMetallicFromMetallicReflectanceTexture = false;
    this._metallicReflectanceTexture = null;
    this._reflectanceTexture = null;
    this._microSurfaceTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._ambientColor = new Color3(0, 0, 0);
    this._albedoColor = new Color3(1, 1, 1);
    this._baseWeight = 1;
    this._baseDiffuseRoughness = null;
    this._reflectivityColor = new Color3(1, 1, 1);
    this._reflectionColor = new Color3(1, 1, 1);
    this._emissiveColor = new Color3(0, 0, 0);
    this._microSurface = 0.9;
    this._useLightmapAsShadowmap = false;
    this._useHorizonOcclusion = true;
    this._useRadianceOcclusion = true;
    this._useAlphaFromAlbedoTexture = false;
    this._useSpecularOverAlpha = true;
    this._useMicroSurfaceFromReflectivityMapAlpha = false;
    this._useRoughnessFromMetallicTextureAlpha = true;
    this._useRoughnessFromMetallicTextureGreen = false;
    this._useMetallnessFromMetallicTextureBlue = false;
    this._useAmbientOcclusionFromMetallicTextureRed = false;
    this._useAmbientInGrayScale = false;
    this._useAutoMicroSurfaceFromReflectivityMap = false;
    this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
    this._useRadianceOverAlpha = true;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this._parallaxScaleBias = 0.05;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._alphaCutOff = 0.4;
    this._useAlphaFresnel = false;
    this._useLinearAlphaFresnel = false;
    this._environmentBRDFTexture = null;
    this._forceIrradianceInFragment = false;
    this._realTimeFiltering = false;
    this._realTimeFilteringQuality = 8;
    this._forceNormalForward = false;
    this._enableSpecularAntiAliasing = false;
    this._renderTargets = new SmartArray(16);
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._unlit = false;
    this._applyDecalMapAfterDetailMap = false;
    this._debugMode = 0;
    this._shadersLoaded = false;
    this._breakShaderLoadedCheck = false;
    this.debugMode = 0;
    this.debugLimit = -1;
    this.debugFactor = 1;
    this._cacheHasRenderTargetTextures = false;
    this.brdf = new PBRBRDFConfiguration(this);
    this.clearCoat = new PBRClearCoatConfiguration(this);
    this.iridescence = new PBRIridescenceConfiguration(this);
    this.anisotropy = new PBRAnisotropicConfiguration(this);
    this.sheen = new PBRSheenConfiguration(this);
    this.subSurface = new PBRSubSurfaceConfiguration(this);
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
    this.prePassConfiguration = new PrePassConfiguration();
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * @returns the name of the material class.
   */
  getClassName() {
    return "PBRBaseMaterial";
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get _disableAlphaBlending() {
    return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || this.subSurface?.disableAlphaBlending;
  }
  /**
   * @returns whether or not this material should be rendered in alpha blend mode.
   */
  needAlphaBlending() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsBlend;
    }
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
  }
  /**
   * @returns whether or not this material should be rendered in alpha test mode.
   */
  needAlphaTesting() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsTest;
    }
    if (this.subSurface?.disableAlphaBlending) {
      return false;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
  }
  /**
   * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
   */
  _shouldUseAlphaFromAlbedoTexture() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
  }
  /**
   * @returns whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
  }
  /**
   * @returns the texture used for the alpha test.
   */
  getAlphaTestTexture() {
    return this._albedoTexture;
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param mesh - BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
   * @param useInstances - Specifies that instances should be used.
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(4, this._eventInfo);
      subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._albedoTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          if (!this._baseWeightTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          if (!this._baseDiffuseRoughnessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (reflectionTexture.irradianceTexture) {
            if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else {
            if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {
              return false;
            }
          }
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            if (!this._metallicTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else if (this._reflectivityTexture) {
            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._metallicReflectanceTexture) {
            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._reflectanceTexture) {
            if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._microSurfaceTexture) {
            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
      }
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (defines["AREALIGHTUSED"] || defines["CLUSTLIGHT_BATCH"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    const previousEffect = subMesh.effect;
    const lightDisposed = defines._areLightsDisposed;
    let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);
    let forceWasNotReadyPreviously = false;
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        defines.markAsUnprocessed();
        forceWasNotReadyPreviously = this.isFrozen;
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines, this._materialContext);
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Specifies if the material uses metallic roughness workflow.
   * @returns boolean specifying if the material uses metallic roughness workflow.
   */
  isMetallicWorkflow() {
    if (this._metallic != null || this._roughness != null || this._metallicTexture) {
      return true;
    }
    return false;
  }
  _prepareEffect(mesh, renderingMesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null) {
    this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    const scene = this.getScene();
    const engine = scene.getEngine();
    const fallbacks = new EffectFallbacks();
    let fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAX_RHS) {
      fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    if (defines.BUMP) {
      fallbacks.addFallback(fallbackRank++, "BUMP");
    }
    fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.LIGHTMAP) {
      fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.AMBIENT) {
      fallbacks.addFallback(fallbackRank++, "AMBIENT");
    }
    if (defines.EMISSIVE) {
      fallbacks.addFallback(fallbackRank++, "EMISSIVE");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    const attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    for (let i = 1; i <= 6; ++i) {
      if (defines["UV" + i]) {
        attribs.push(`uv${i === 1 ? "" : i}`);
      }
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    PrepareAttributesForInstances(attribs, defines);
    PrepareAttributesForMorphTargets(attribs, mesh, defines);
    PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    let shaderName = "pbr";
    const uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "vAmbientColor",
      "vAlbedoColor",
      "baseWeight",
      "baseDiffuseRoughness",
      "vReflectivityColor",
      "vMetallicReflectanceFactors",
      "vEmissiveColor",
      "visibility",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "vAlbedoInfos",
      "vBaseWeightInfos",
      "vBaseDiffuseRoughnessInfos",
      "vAmbientInfos",
      "vOpacityInfos",
      "vEmissiveInfos",
      "vReflectivityInfos",
      "vMetallicReflectanceInfos",
      "vReflectanceInfos",
      "vMicroSurfaceSamplerInfos",
      "vBumpInfos",
      "vLightmapInfos",
      "mBones",
      "albedoMatrix",
      "baseWeightMatrix",
      "baseDiffuseRoughnessMatrix",
      "ambientMatrix",
      "opacityMatrix",
      "emissiveMatrix",
      "reflectivityMatrix",
      "normalMatrix",
      "microSurfaceSamplerMatrix",
      "bumpMatrix",
      "lightmapMatrix",
      "metallicReflectanceMatrix",
      "reflectanceMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices",
      "cameraInfo"
    ];
    const samplers = [
      "albedoSampler",
      "baseWeightSampler",
      "baseDiffuseRoughnessSampler",
      "reflectivitySampler",
      "ambientSampler",
      "emissiveSampler",
      "bumpSampler",
      "lightmapSampler",
      "opacitySampler",
      "microSurfaceSampler",
      "environmentBrdfSampler",
      "boneSampler",
      "metallicReflectanceSampler",
      "reflectanceSampler",
      "morphTargets",
      "oitDepthSampler",
      "oitFrontColorSampler",
      "areaLightsLTC1Sampler",
      "areaLightsLTC2Sampler"
    ];
    PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);
    const uniformBuffers = ["Material", "Scene", "Mesh"];
    const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
    this._eventInfo.fallbacks = fallbacks;
    this._eventInfo.fallbackRank = fallbackRank;
    this._eventInfo.defines = defines;
    this._eventInfo.uniforms = uniforms;
    this._eventInfo.attributes = attribs;
    this._eventInfo.samplers = samplers;
    this._eventInfo.uniformBuffersNames = uniformBuffers;
    this._eventInfo.customCode = void 0;
    this._eventInfo.mesh = mesh;
    this._eventInfo.indexParameters = indexParameters;
    this._callbackPluginEventGeneric(128, this._eventInfo);
    MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(samplers);
    AddClipPlaneUniforms(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    const csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    const join = defines.toString();
    const effect = engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters,
      processFinalCode: csnrOptions.processFinalCode,
      processCodeAfterIncludes: this._eventInfo.customCode,
      multiTarget: defines.PREPASS,
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
        if (this.shaderLanguage === 1) {
          await Promise.all([import("./pbr.vertex-OP6KEIZH.js"), import("./pbr.fragment-LEO4CZSS.js")]);
        } else {
          await Promise.all([import("./pbr.vertex-SPBYPWVL.js"), import("./pbr.fragment-QHW7PKPG.js")]);
        }
        this._shadersLoaded = true;
      }
    }, engine);
    this._eventInfo.customCode = void 0;
    return effect;
  }
  _prepareDefines(mesh, renderingMesh, defines, useInstances = null, useClipPlane = null) {
    const useThinInstances = renderingMesh.hasThinInstances;
    const scene = this.getScene();
    const engine = scene.getEngine();
    PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    PrepareDefinesForOIT(scene, defines, oit);
    MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
    defines.METALLICWORKFLOW = this.isMetallicWorkflow();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.ALBEDODIRECTUV = 0;
        defines.BASE_WEIGHTDIRECTUV = 0;
        defines.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.REFLECTIVITYDIRECTUV = 0;
        defines.MICROSURFACEMAPDIRECTUV = 0;
        defines.METALLIC_REFLECTANCEDIRECTUV = 0;
        defines.REFLECTANCEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (engine.getCaps().textureLOD) {
          defines.LODBASEDMICROSFURACE = true;
        }
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
        } else {
          defines.ALBEDO = false;
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          PrepareDefinesForMergedUV(this._baseWeightTexture, defines, "BASE_WEIGHT");
        } else {
          defines.BASE_WEIGHT = false;
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          PrepareDefinesForMergedUV(this._baseDiffuseRoughnessTexture, defines, "BASE_DIFFUSE_ROUGHNESS");
        } else {
          defines.BASE_DIFFUSE_ROUGHNESS = false;
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
        } else {
          defines.OPACITY = false;
        }
        const reflectionTexture = this._getReflectionTexture();
        const useSHInFragment = this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8 || this._baseDiffuseRoughnessTexture != null;
        PrepareDefinesForIBL(scene, reflectionTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
        } else {
          defines.EMISSIVE = false;
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
            defines.REFLECTIVITY_GAMMA = false;
          } else if (this._reflectivityTexture) {
            PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
            defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
          } else {
            defines.REFLECTIVITY = false;
          }
          if (this._metallicReflectanceTexture || this._reflectanceTexture) {
            defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;
            if (this._metallicReflectanceTexture) {
              PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
              defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
            } else {
              defines.METALLIC_REFLECTANCE = false;
            }
            if (this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
              PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
              defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
            } else {
              defines.REFLECTANCE = false;
            }
          } else {
            defines.METALLIC_REFLECTANCE = false;
            defines.REFLECTANCE = false;
          }
          if (this._microSurfaceTexture) {
            PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
          } else {
            defines.MICROSURFACEMAP = false;
          }
        } else {
          defines.REFLECTIVITY = false;
          defines.MICROSURFACEMAP = false;
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
          defines.OBJECTSPACE_NORMALMAP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._shouldUseAlphaFromAlbedoTexture()) {
          defines.ALPHAFROMALBEDO = true;
        } else {
          defines.ALPHAFROMALBEDO = false;
        }
      }
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.MIRRORED = !!scene._mirroredCameraPosition;
      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if (defines._areMiscDirty) {
      PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, renderingMesh, this._isVertexOutputInvariant);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
  }
  /**
   * Force shader compilation
   * @param mesh - Define the mesh we want to force the compilation for
   * @param onCompiled - Define a callback triggered when the compilation completes
   * @param options - Define the options used to create the compilation
   */
  forceCompilation(mesh, onCompiled, options) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    this._callbackPluginEventGeneric(4, this._eventInfo);
    const checkReady = () => {
      if (this._breakShaderLoadedCheck) {
        return;
      }
      const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
      const effect = this._prepareEffect(mesh, mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane);
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
      if (effect.isReady()) {
        if (onCompiled) {
          onCompiled(this);
        }
      } else {
        effect.onCompileObservable.add(() => {
          if (onCompiled) {
            onCompiled(this);
          }
        });
      }
    };
    checkReady();
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("vAlbedoInfos", 2);
    ubo.addUniform("vBaseWeightInfos", 2);
    ubo.addUniform("vBaseDiffuseRoughnessInfos", 2);
    ubo.addUniform("vAmbientInfos", 4);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vReflectivityInfos", 3);
    ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("albedoMatrix", 16);
    ubo.addUniform("baseWeightMatrix", 16);
    ubo.addUniform("baseDiffuseRoughnessMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("reflectivityMatrix", 16);
    ubo.addUniform("microSurfaceSamplerMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("vAlbedoColor", 4);
    ubo.addUniform("baseWeight", 1);
    ubo.addUniform("baseDiffuseRoughness", 1);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vReflectivityColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vAmbientColor", 3);
    ubo.addUniform("vDebugMode", 2);
    ubo.addUniform("vMetallicReflectanceFactors", 4);
    ubo.addUniform("vMetallicReflectanceInfos", 2);
    ubo.addUniform("metallicReflectanceMatrix", 16);
    ubo.addUniform("vReflectanceInfos", 2);
    ubo.addUniform("reflectanceMatrix", 16);
    ubo.addUniform("cameraInfo", 4);
    PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh data.
   * @param world - The world matrix.
   * @param mesh - The BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const engine = scene.getEngine();
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
    const camera = scene.activeCamera;
    if (camera) {
      this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
    } else {
      this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    let reflectionTexture = null;
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      reflectionTexture = this._getReflectionTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
        if (scene.texturesEnabled) {
          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
            BindTextureMatrix(this._albedoTexture, ubo, "albedo");
          }
          if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
            ubo.updateFloat2("vBaseWeightInfos", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);
            BindTextureMatrix(this._baseWeightTexture, ubo, "baseWeight");
          }
          if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
            ubo.updateFloat2("vBaseDiffuseRoughnessInfos", this._baseDiffuseRoughnessTexture.coordinatesIndex, this._baseDiffuseRoughnessTexture.level);
            BindTextureMatrix(this._baseDiffuseRoughnessTexture, ubo, "baseDiffuseRoughness");
          }
          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
            ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
            BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (MaterialFlags.SpecularTextureEnabled) {
            if (this._metallicTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
              BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
            } else if (this._reflectivityTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
              BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
            }
            if (this._metallicReflectanceTexture) {
              ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
              BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
            }
            if (this._reflectanceTexture && defines.REFLECTANCE) {
              ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
              BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
            }
            if (this._microSurfaceTexture) {
              ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
              BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
            BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          BindIBLParameters(scene, defines, ubo, this._reflectionColor, reflectionTexture, this.realTimeFiltering, true, true, true, true, true);
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.METALLICWORKFLOW) {
          TmpColors.Color4[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
          TmpColors.Color4[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
          const ior = this.subSurface?._indexOfRefraction ?? 1.5;
          const outsideIOR = 1;
          TmpColors.Color4[0].b = ior;
          const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
          TmpColors.Color4[0].a = f0;
          ubo.updateDirectColor4("vReflectivityColor", TmpColors.Color4[0]);
          ubo.updateColor4("vMetallicReflectanceFactors", this._metallicReflectanceColor, this._metallicF0Factor);
        } else {
          ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
        }
        ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
        if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
        } else {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
        }
        ubo.updateFloat("baseWeight", this._baseWeight);
        ubo.updateFloat("baseDiffuseRoughness", this._baseDiffuseRoughness || 0);
        this._lightingInfos.x = this._directIntensity;
        this._lightingInfos.y = this._emissiveIntensity;
        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = this._specularIntensity;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
        scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
        ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
      }
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          ubo.setTexture("albedoSampler", this._albedoTexture);
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          ubo.setTexture("baseWeightSampler", this._baseWeightTexture);
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          ubo.setTexture("baseDiffuseRoughnessSampler", this._baseDiffuseRoughnessTexture);
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          ubo.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          ubo.setTexture("opacitySampler", this._opacityTexture);
        }
        BindIBLSamplers(scene, defines, ubo, reflectionTexture, this.realTimeFiltering);
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          ubo.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          ubo.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            ubo.setTexture("reflectivitySampler", this._metallicTexture);
          } else if (this._reflectivityTexture) {
            ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
          }
          if (this._metallicReflectanceTexture) {
            ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
          }
          if (this._reflectanceTexture && defines.REFLECTANCE) {
            ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
          }
          if (this._microSurfaceTexture) {
            ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
          }
        }
        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          ubo.setTexture("bumpSampler", this._bumpTexture);
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      BindClipPlane(this._activeEffect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS || defines["CLUSTLIGHT_BATCH"]) {
        this.bindView(effect);
      }
      BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        BindMorphTargetParameters(mesh, this._activeEffect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      BindLogDepth(defines, this._activeEffect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
    ubo.update();
  }
  /**
   * Returns the animatable textures.
   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
      results.push(this._albedoTexture);
    }
    if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {
      results.push(this._baseWeightTexture);
    }
    if (this._baseDiffuseRoughnessTexture && this._baseDiffuseRoughnessTexture.animations && this._baseDiffuseRoughnessTexture.animations.length > 0) {
      results.push(this._baseDiffuseRoughnessTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
      results.push(this._metallicTexture);
    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
      results.push(this._reflectivityTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
      results.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
      results.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
      results.push(this._microSurfaceTexture);
    }
    return results;
  }
  /**
   * Returns the texture used for reflections.
   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
   */
  _getReflectionTexture() {
    if (this._reflectionTexture) {
      return this._reflectionTexture;
    }
    return this.getScene().environmentTexture;
  }
  /**
   * Returns an array of the actively used textures.
   * @returns - Array of BaseTextures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._albedoTexture) {
      activeTextures.push(this._albedoTexture);
    }
    if (this._baseWeightTexture) {
      activeTextures.push(this._baseWeightTexture);
    }
    if (this._baseDiffuseRoughnessTexture) {
      activeTextures.push(this._baseDiffuseRoughnessTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._reflectivityTexture) {
      activeTextures.push(this._reflectivityTexture);
    }
    if (this._metallicTexture) {
      activeTextures.push(this._metallicTexture);
    }
    if (this._metallicReflectanceTexture) {
      activeTextures.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture) {
      activeTextures.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture) {
      activeTextures.push(this._microSurfaceTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    return activeTextures;
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._albedoTexture === texture) {
      return true;
    }
    if (this._baseWeightTexture === texture) {
      return true;
    }
    if (this._baseDiffuseRoughnessTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._reflectivityTexture === texture) {
      return true;
    }
    if (this._metallicTexture === texture) {
      return true;
    }
    if (this._metallicReflectanceTexture === texture) {
      return true;
    }
    if (this._reflectanceTexture === texture) {
      return true;
    }
    if (this._microSurfaceTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Sets the required values to the prepass renderer.
   * It can't be sets when subsurface scattering of this material is disabled.
   * When scene have ability to enable subsurface prepass effect, it will enable.
   * @returns - If prepass is enabled or not.
   */
  setPrePassRenderer() {
    if (!this.subSurface?.isScatteringEnabled) {
      return false;
    }
    const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
    if (subSurfaceConfiguration) {
      subSurfaceConfiguration.enabled = true;
    }
    return true;
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeEffect - Forces the disposal of effects.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    this._breakShaderLoadedCheck = true;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      this._albedoTexture?.dispose();
      this._baseWeightTexture?.dispose();
      this._baseDiffuseRoughnessTexture?.dispose();
      this._ambientTexture?.dispose();
      this._opacityTexture?.dispose();
      this._reflectionTexture?.dispose();
      this._emissiveTexture?.dispose();
      this._metallicTexture?.dispose();
      this._reflectivityTexture?.dispose();
      this._bumpTexture?.dispose();
      this._lightmapTexture?.dispose();
      this._metallicReflectanceTexture?.dispose();
      this._reflectanceTexture?.dispose();
      this._microSurfaceTexture?.dispose();
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
};
PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
PBRBaseMaterial.ForceGLSL = false;
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBaseMaterial.prototype, "debugMode", void 0);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/sheenBlock.js
var SheenBlock = class _SheenBlock extends NodeMaterialBlock {
  /**
   * Create a new SheenBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.albedoScaling = false;
    this.linkSheenWithAlbedo = false;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheen", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", this, 1, _SheenBlock, "SheenBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("sheenOut");
    state._excludeVariableName("sheenMapData");
    state._excludeVariableName("vSheenColor");
    state._excludeVariableName("vSheenRoughness");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SheenBlock";
  }
  /**
   * Gets the intensity input component
   */
  get intensity() {
    return this._inputs[0];
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[1];
  }
  /**
   * Gets the roughness input component
   */
  get roughness() {
    return this._inputs[2];
  }
  /**
   * Gets the sheen object output component
   */
  get sheen() {
    return this._outputs[0];
  }
  prepareDefines(defines) {
    defines.setValue("SHEEN", true);
    defines.setValue("SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("SHEEN_LINKWITHALBEDO", this.linkSheenWithAlbedo, true);
    defines.setValue("SHEEN_ROUGHNESS", this.roughness.isConnected, true);
    defines.setValue("SHEEN_ALBEDOSCALING", this.albedoScaling, true);
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
   * @param state define the build state
   * @returns the shader code
   */
  getCode(reflectionBlock, state) {
    let code = "";
    const color = this.color.isConnected ? this.color.associatedVariableName : `vec3${state.fSuffix}(1.)`;
    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.";
    const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : "0.";
    const texture = `vec4${state.fSuffix}(0.)`;
    const isWebGPU = state.shaderLanguage === 1;
    code = `#ifdef SHEEN
            ${isWebGPU ? "var sheenOut: sheenOutParams" : "sheenOutParams sheenOut"};

            ${state._declareLocalVar("vSheenColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${color}, ${intensity});

            sheenOut = sheenBlock(
                vSheenColor
            #ifdef SHEEN_ROUGHNESS
                , ${roughness}
            #endif
                , roughness
            #ifdef SHEEN_TEXTURE
                , ${texture}
                ${isWebGPU ? `, ${texture}Sampler` : ""}
                , 1.0
            #endif
                , reflectanceF0
            #ifdef SHEEN_LINKWITHALBEDO
                , baseColor
                , surfaceAlbedo
            #endif
            #ifdef ENVIRONMENTBRDF
                , NdotV
                , environmentBrdf
            #endif
            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
                , AARoughnessFactors
                , ${isWebGPU ? "uniforms." : ""}${reflectionBlock?._vReflectionMicrosurfaceInfosName}
                , ${reflectionBlock?._vReflectionInfosName}
                , ${reflectionBlock?.reflectionColor}
                , ${isWebGPU ? "uniforms." : ""}vLightingIntensity
                #ifdef ${reflectionBlock?._define3DName}
                    , ${reflectionBlock?._cubeSamplerName}                                      
                    ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                #else
                    , ${reflectionBlock?._2DSamplerName}
                    ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}
                #endif
                , reflectionOut.reflectionCoords
                , NdotVUnclamped
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${reflectionBlock?._define3DName}
                        , ${reflectionBlock?._cubeSamplerName}                        
                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                        , ${reflectionBlock?._cubeSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                    #else
                        , ${reflectionBlock?._2DSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}
                        , ${reflectionBlock?._2DSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}
                    #endif
                #endif
                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(RADIANCEOCCLUSION)
                    , seo
                #endif
                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(${reflectionBlock?._define3DName})
                    , eho
                #endif
            #endif
            );

            #ifdef SHEEN_LINKWITHALBEDO
                surfaceAlbedo = sheenOut.surfaceAlbedo;
            #endif
        #endif
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.albedoScaling = ${this.albedoScaling};
`;
    codeString += `${this._codeVariableName}.linkSheenWithAlbedo = ${this.linkSheenWithAlbedo};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.albedoScaling = this.albedoScaling;
    serializationObject.linkSheenWithAlbedo = this.linkSheenWithAlbedo;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.albedoScaling = serializationObject.albedoScaling;
    this.linkSheenWithAlbedo = serializationObject.linkSheenWithAlbedo;
  }
};
__decorate([
  editableInPropertyPage("Albedo scaling", 0, "PROPERTIES", { embedded: true, notifiers: { update: true } })
], SheenBlock.prototype, "albedoScaling", void 0);
__decorate([
  editableInPropertyPage("Link sheen with albedo", 0, "PROPERTIES", { embedded: true, notifiers: { update: true } })
], SheenBlock.prototype, "linkSheenWithAlbedo", void 0);
RegisterClass("BABYLON.SheenBlock", SheenBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/anisotropyBlock.js
var AnisotropyBlock = class _AnisotropyBlock extends NodeMaterialBlock {
  /**
   * Create a new AnisotropyBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._tangentCorrectionFactorName = "";
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("direction", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, 0, TBNBlock, "TBNBlock"));
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", this, 1, _AnisotropyBlock, "AnisotropyBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("anisotropicOut");
    state._excludeVariableName("TBN");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "AnisotropyBlock";
  }
  /**
   * Gets the intensity input component
   */
  get intensity() {
    return this._inputs[0];
  }
  /**
   * Gets the direction input component
   */
  get direction() {
    return this._inputs[1];
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[2];
  }
  /**
   * Gets the worldTangent input component
   */
  get worldTangent() {
    return this._inputs[3];
  }
  /**
   * Gets the TBN input component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get TBN() {
    return this._inputs[4];
  }
  /**
   * Gets the roughness input component
   */
  get roughness() {
    return this._inputs[5];
  }
  /**
   * Gets the anisotropy object output component
   */
  get anisotropy() {
    return this._outputs[0];
  }
  _generateTBNSpace(state) {
    let code = "";
    const comments = `//${this.name}`;
    const uv = this.uv;
    const worldPosition = this.worldPositionConnectionPoint;
    const worldNormal = this.worldNormalConnectionPoint;
    const worldTangent = this.worldTangent;
    const isWebGPU = state.shaderLanguage === 1;
    if (!uv.isConnected) {
      state.sharedData.raiseBuildError(`You must connect the 'uv' input of the ${this.name} block!`);
    }
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const tbn = this.TBN;
    if (tbn.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
            ${isWebGPU ? "var TBN" : "mat3 TBN"} = ${tbn.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      code += `${state._declareLocalVar("tbnNormal", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormal.associatedVariableName}.xyz);
`;
      code += `${state._declareLocalVar("tbnTangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);
`;
      code += `${state._declareLocalVar("tbnBitangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};
`;
      code += `${isWebGPU ? "var vTBN" : "mat3 vTBN"} = ${isWebGPU ? "mat3x3f" : "mat3"}(tbnTangent, tbnBitangent, tbnNormal);
`;
    }
    code += `
            #if defined(${worldTangent.isConnected ? "TANGENT" : "IGNORE"}) && defined(NORMAL)
                ${isWebGPU ? "var TBN" : "mat3 TBN"} = vTBN;
            #else
                ${isWebGPU ? "var TBN" : "mat3 TBN"} = cotangent_frame(${worldNormal.associatedVariableName + ".xyz"}, ${"v_" + worldPosition.associatedVariableName + ".xyz"}, ${uv.isConnected ? uv.associatedVariableName : "vec2(0.)"}, vec2${state.fSuffix}(1., 1.));
            #endif
`;
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [tangentReplaceString]
    });
    return code;
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param state current state of the node material building
   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
   * @returns the shader code
   */
  getCode(state, generateTBNSpace = false) {
    let code = "";
    if (generateTBNSpace) {
      code += this._generateTBNSpace(state);
    }
    const isWebGPU = state.shaderLanguage === 1;
    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : "1.0";
    const direction = this.direction.isConnected ? this.direction.associatedVariableName : "vec2(1., 0.)";
    const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : "0.";
    code += `${isWebGPU ? "var anisotropicOut: anisotropicOutParams" : "anisotropicOutParams anisotropicOut"};
            anisotropicOut = anisotropicBlock(
                vec3(${direction}, ${intensity}),
                ${roughness},
            #ifdef ANISOTROPIC_TEXTURE
                vec3(0.),
            #endif
                TBN,
                normalW,
                viewDirectionW
            );
`;
    return code;
  }
  prepareDefines(defines) {
    defines.setValue("ANISOTROPIC", true);
    defines.setValue("ANISOTROPIC_TEXTURE", false, true);
    defines.setValue("ANISOTROPIC_LEGACY", !this.roughness.isConnected);
  }
  bind(effect, nodeMaterial, mesh) {
    super.bind(effect, nodeMaterial, mesh);
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
    }
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
      state.sharedData.bindableBlocks.push(this);
      this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
      state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);
    }
    return this;
  }
};
RegisterClass("BABYLON.AnisotropyBlock", AnisotropyBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/reflectionBlock.js
var ReflectionBlock = class _ReflectionBlock extends ReflectionTextureBaseBlock {
  _onGenerateOnlyFragmentCodeChanged() {
    if (this.position.isConnected) {
      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;
      Logger.Error("The position input must not be connected to be able to switch!");
      return false;
    }
    this._setTarget();
    return true;
  }
  _setTarget() {
    super._setTarget();
    this.getInputByName("position").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
    if (this.generateOnlyFragmentCode) {
      this.forceIrradianceInFragment = true;
    }
  }
  /**
   * Create a new ReflectionBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6);
    this.useSphericalHarmonics = true;
    this.forceIrradianceInFragment = false;
    this._isUnique = true;
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("reflection", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", this, 1, _ReflectionBlock, "ReflectionBlock"));
    this.position.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ReflectionBlock";
  }
  /**
   * Gets the position input component
   */
  get position() {
    return this._inputs[0];
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this.worldPositionConnectionPoint;
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this.worldNormalConnectionPoint;
  }
  /**
   * Gets the world input component
   */
  get world() {
    return this._inputs[1];
  }
  /**
   * Gets the camera (or eye) position component
   */
  get cameraPosition() {
    return this.cameraPositionConnectionPoint;
  }
  /**
   * Gets the view input component
   */
  get view() {
    return this.viewConnectionPoint;
  }
  /**
   * Gets the color input component
   */
  get color() {
    return this._inputs[2];
  }
  /**
   * Gets the reflection object output component
   */
  get reflection() {
    return this._outputs[0];
  }
  /**
   * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)
   */
  get hasTexture() {
    return !!this._getTexture();
  }
  /**
   * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)
   */
  get reflectionColor() {
    return this.color.isConnected ? this.color.associatedVariableName : "vec3(1., 1., 1.)";
  }
  _getTexture() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  }
  prepareDefines(defines) {
    super.prepareDefines(defines);
    const reflectionTexture = this._getTexture();
    const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;
    defines.setValue("REFLECTION", reflection, true);
    if (!reflection) {
      return;
    }
    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);
    defines.setValue("SPHERICAL_HARMONICS", this.useSphericalHarmonics, true);
    defines.setValue("GAMMAREFLECTION", reflectionTexture.gammaSpace, true);
    defines.setValue("RGBDREFLECTION", reflectionTexture.isRGBD, true);
    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
      if (reflectionTexture.isCube) {
        defines.setValue("USESPHERICALFROMREFLECTIONMAP", true);
        defines.setValue("USEIRRADIANCEMAP", false);
        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {
          defines.setValue("USESPHERICALINVERTEX", false);
        } else {
          defines.setValue("USESPHERICALINVERTEX", true);
        }
      }
    }
  }
  bind(effect, nodeMaterial, mesh, subMesh) {
    super.bind(effect, nodeMaterial, mesh);
    const reflectionTexture = this._getTexture();
    if (!reflectionTexture || !subMesh) {
      return;
    }
    if (reflectionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, reflectionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, reflectionTexture);
    }
    effect.setFloat(this._iblIntensityName, this._scene.iblIntensity * reflectionTexture.level);
    const width = reflectionTexture.getSize().width;
    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
    effect.setFloat2(this._vReflectionFilteringInfoName, width, Math.log2(width));
    const defines = subMesh.materialDefines;
    const polynomials = reflectionTexture.sphericalPolynomial;
    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
      if (defines.SPHERICAL_HARMONICS) {
        const preScaledHarmonics = polynomials.preScaledHarmonics;
        effect.setVector3("vSphericalL00", preScaledHarmonics.l00);
        effect.setVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
        effect.setVector3("vSphericalL10", preScaledHarmonics.l10);
        effect.setVector3("vSphericalL11", preScaledHarmonics.l11);
        effect.setVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
        effect.setVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
        effect.setVector3("vSphericalL20", preScaledHarmonics.l20);
        effect.setVector3("vSphericalL21", preScaledHarmonics.l21);
        effect.setVector3("vSphericalL22", preScaledHarmonics.l22);
      } else {
        effect.setFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
        effect.setFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
        effect.setFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
        effect.setFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
        effect.setFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
        effect.setFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
        effect.setFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
        effect.setFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
        effect.setFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
      }
    }
  }
  /**
   * Gets the code to inject in the vertex shader
   * @param state current state of the node material building
   * @returns the shader code
   */
  handleVertexSide(state) {
    let code = super.handleVertexSide(state);
    const isWebGPU = state.shaderLanguage === 1;
    state._emitFunctionFromInclude("harmonicsFunctions", `//${this.name}`, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    const reflectionVectorName = state._getFreeVariableName("reflectionVector");
    this._vEnvironmentIrradianceName = state._getFreeVariableName("vEnvironmentIrradiance");
    state._emitVaryingFromString(this._vEnvironmentIrradianceName, NodeMaterialBlockConnectionPointTypes.Vector3, "defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)");
    state._emitUniformFromString("vSphericalL00", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL1_1", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL10", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL11", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_2", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL2_1", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL20", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL21", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalL22", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS");
    state._emitUniformFromString("vSphericalX", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalY", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZ", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXX_ZZ", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYY_ZZ", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZZ", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalXY", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalYZ", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    state._emitUniformFromString("vSphericalZX", NodeMaterialBlockConnectionPointTypes.Vector3, "SPHERICAL_HARMONICS", true);
    code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
                ${state._declareLocalVar(reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = (${(isWebGPU ? "uniforms." : "") + this._reflectionMatrixName} * vec4${state.fSuffix}(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;
                #ifdef ${this._defineOppositeZ}
                    ${reflectionVectorName}.z *= -1.0;
                #endif
                ${isWebGPU ? "vertexOutputs." : ""}${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});
            #endif
`;
    return code;
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param state current state of the node material building
   * @param normalVarName name of the existing variable corresponding to the normal
   * @returns the shader code
   */
  getCode(state, normalVarName) {
    let code = "";
    this.handleFragmentSideInits(state);
    const isWebGPU = state.shaderLanguage === 1;
    state._emitFunctionFromInclude("harmonicsFunctions", `//${this.name}`, {
      replaceStrings: [
        { search: /uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g, replace: "" },
        { search: /uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g, replace: "" }
      ]
    });
    if (!isWebGPU) {
      state._emitFunction("sampleReflection", `
                #ifdef ${this._define3DName}
                    #define sampleReflection(s, c) textureCube(s, c)
                #else
                    #define sampleReflection(s, c) texture2D(s, c)
                #endif
`, `//${this.name}`);
      state._emitFunction("sampleReflectionLod", `
                #ifdef ${this._define3DName}
                    #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)
                #else
                    #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)
                #endif
`, `//${this.name}`);
    }
    const computeReflectionCoordsFunc = isWebGPU ? `
            fn computeReflectionCoordsPBR(worldPos: vec4f, worldNormal: vec3f) -> vec3f {
                ${this.handleFragmentSideCodeReflectionCoords(state, "worldNormal", "worldPos", true, true)}
                return ${this._reflectionVectorName};
            }
` : `
            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {
                ${this.handleFragmentSideCodeReflectionCoords(state, "worldNormal", "worldPos", true, true)}
                return ${this._reflectionVectorName};
            }
`;
    state._emitFunction("computeReflectionCoordsPBR", computeReflectionCoordsFunc, `//${this.name}`);
    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName("vReflectionMicrosurfaceInfos");
    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, NodeMaterialBlockConnectionPointTypes.Vector3);
    this._vReflectionInfosName = state._getFreeVariableName("vReflectionInfos");
    this._vReflectionFilteringInfoName = state._getFreeVariableName("vReflectionFilteringInfo");
    state._emitUniformFromString(this._vReflectionFilteringInfoName, NodeMaterialBlockConnectionPointTypes.Vector2);
    this._iblIntensityName = state._getFreeVariableName("iblIntensity");
    state._emitUniformFromString(this._iblIntensityName, NodeMaterialBlockConnectionPointTypes.Float);
    code += `#ifdef REFLECTION
            ${state._declareLocalVar(this._vReflectionInfosName, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(${(isWebGPU ? "uniforms." : "") + this._iblIntensityName}, 0.);

            ${isWebGPU ? "var reflectionOut: reflectionOutParams" : "reflectionOutParams reflectionOut"};

            reflectionOut = reflectionBlock(
                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : (isWebGPU ? "input." : "") + "v_" + this.worldPosition.associatedVariableName}.xyz
                , ${normalVarName}
                , alphaG
                , ${(isWebGPU ? "uniforms." : "") + this._vReflectionMicrosurfaceInfosName}
                , ${this._vReflectionInfosName}
                , ${this.reflectionColor}
            #ifdef ANISOTROPIC
                ,anisotropicOut
            #endif
            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})
                ,NdotVUnclamped
            #endif
            #ifdef ${this._defineLinearSpecularReflection}
                , roughness
            #endif
            #ifdef ${this._define3DName}
                , ${this._cubeSamplerName}
                ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : ""}
            #else
                , ${this._2DSamplerName}
                ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : ""}
            #endif
            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)
                , ${isWebGPU ? "input." : ""}${this._vEnvironmentIrradianceName}
            #endif
            #if (defined(USESPHERICALFROMREFLECTIONMAP) && (!defined(NORMAL) || !defined(USESPHERICALINVERTEX))) || (defined(USEIRRADIANCEMAP) && defined(REFLECTIONMAP_3D))
                    , ${this._reflectionMatrixName}
            #endif
            #ifdef USEIRRADIANCEMAP
                , irradianceSampler         // ** not handled **
                ${isWebGPU ? `, irradianceSamplerSampler` : ""}
                #ifdef USE_IRRADIANCE_DOMINANT_DIRECTION
                , vReflectionDominantDirection
                #endif
            #endif
            #ifndef LODBASEDMICROSFURACE
                #ifdef ${this._define3DName}
                    , ${this._cubeSamplerName}
                    ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : ""}
                    , ${this._cubeSamplerName}
                    ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : ""}
                #else
                    , ${this._2DSamplerName}
                    ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : ""}
                    , ${this._2DSamplerName}                    
                    ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : ""}
                #endif
            #endif
            #ifdef REALTIME_FILTERING
                , ${this._vReflectionFilteringInfoName}
                #ifdef IBL_CDF_FILTERING
                    , icdfSampler         // ** not handled **
                    ${isWebGPU ? `, icdfSamplerSampler` : ""}
                #endif
            #endif
            , viewDirectionW
            , diffuseRoughness
            , surfaceAlbedo
            );
        #endif
`;
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._defineLODReflectionAlpha = state._getFreeDefineName("LODINREFLECTIONALPHA");
      this._defineLinearSpecularReflection = state._getFreeDefineName("LINEARSPECULARREFLECTION");
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.texture) {
      codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};
`;
    }
    codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};
`;
    codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;
    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;
    serializationObject.gammaSpace = this.texture?.gammaSpace ?? true;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;
    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;
    if (this.texture) {
      this.texture.gammaSpace = serializationObject.gammaSpace;
    }
  }
};
__decorate([
  editableInPropertyPage("Spherical Harmonics", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], ReflectionBlock.prototype, "useSphericalHarmonics", void 0);
__decorate([
  editableInPropertyPage("Force irradiance in fragment", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], ReflectionBlock.prototype, "forceIrradianceInFragment", void 0);
RegisterClass("BABYLON.ReflectionBlock", ReflectionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/clearCoatBlock.js
var ClearCoatBlock = class _ClearCoatBlock extends NodeMaterialBlock {
  /**
   * Create a new ClearCoatBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._tangentCorrectionFactorName = "";
    this.remapF0OnInterfaceChange = true;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("normalMapColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintThickness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("worldTangent", NodeMaterialBlockConnectionPointTypes.Vector4, true);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);
    this.registerInput("TBN", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("TBN", this, 0, TBNBlock, "TBNBlock"));
    this.registerOutput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", this, 1, _ClearCoatBlock, "ClearCoatBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("clearcoatOut");
    state._excludeVariableName("vClearCoatParams");
    state._excludeVariableName("vClearCoatTintParams");
    state._excludeVariableName("vClearCoatRefractionParams");
    state._excludeVariableName("vClearCoatTangentSpaceParams");
    state._excludeVariableName("vGeometricNormaClearCoatW");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ClearCoatBlock";
  }
  /**
   * Gets the intensity input component
   */
  get intensity() {
    return this._inputs[0];
  }
  /**
   * Gets the roughness input component
   */
  get roughness() {
    return this._inputs[1];
  }
  /**
   * Gets the ior input component
   */
  get indexOfRefraction() {
    return this._inputs[2];
  }
  /**
   * Gets the bump texture input component
   */
  get normalMapColor() {
    return this._inputs[3];
  }
  /**
   * Gets the uv input component
   */
  get uv() {
    return this._inputs[4];
  }
  /**
   * Gets the tint color input component
   */
  get tintColor() {
    return this._inputs[5];
  }
  /**
   * Gets the tint "at distance" input component
   */
  get tintAtDistance() {
    return this._inputs[6];
  }
  /**
   * Gets the tint thickness input component
   */
  get tintThickness() {
    return this._inputs[7];
  }
  /**
   * Gets the world tangent input component
   */
  get worldTangent() {
    return this._inputs[8];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[9];
  }
  /**
   * Gets the TBN input component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get TBN() {
    return this._inputs[10];
  }
  /**
   * Gets the clear coat object output component
   */
  get clearcoat() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("ClearCoat intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
  }
  prepareDefines(defines) {
    defines.setValue("CLEARCOAT", true);
    defines.setValue("CLEARCOAT_TEXTURE", false, true);
    defines.setValue("CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE", true, true);
    defines.setValue("CLEARCOAT_TINT", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);
    defines.setValue("CLEARCOAT_BUMP", this.normalMapColor.isConnected, true);
    defines.setValue("CLEARCOAT_DEFAULTIOR", this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true, true);
    defines.setValue("CLEARCOAT_REMAP_F0", this.remapF0OnInterfaceChange, true);
  }
  bind(effect, nodeMaterial, mesh) {
    super.bind(effect, nodeMaterial, mesh);
    const indexOfRefraction = this.indexOfRefraction.connectInputBlock?.value ?? PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    const a = 1 - indexOfRefraction;
    const b = 1 + indexOfRefraction;
    const f0 = Math.pow(-a / b, 2);
    const eta = 1 / indexOfRefraction;
    effect.setFloat4("vClearCoatRefractionParams", f0, eta, a, b);
    const mainPBRBlock = this.clearcoat.hasEndpoints ? this.clearcoat.endpoints[0].ownerBlock : null;
    const perturbedNormalBlock = mainPBRBlock?.perturbedNormal.isConnected ? mainPBRBlock.perturbedNormal.connectedPoint.ownerBlock : null;
    if (this._scene._mirroredCameraPosition) {
      effect.setFloat2("vClearCoatTangentSpaceParams", perturbedNormalBlock?.invertX ? 1 : -1, perturbedNormalBlock?.invertY ? 1 : -1);
    } else {
      effect.setFloat2("vClearCoatTangentSpaceParams", perturbedNormalBlock?.invertX ? -1 : 1, perturbedNormalBlock?.invertY ? -1 : 1);
    }
    if (mesh) {
      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);
    }
  }
  _generateTBNSpace(state, worldPositionVarName, worldNormalVarName) {
    let code = "";
    const comments = `//${this.name}`;
    const worldTangent = this.worldTangent;
    const isWebGPU = state.shaderLanguage === 1;
    if (!isWebGPU) {
      state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    }
    const tangentReplaceString = { search: /defined\(TANGENT\)/g, replace: worldTangent.isConnected ? "defined(TANGENT)" : "defined(IGNORE)" };
    const tbn = this.TBN;
    if (tbn.isConnected) {
      state.compilationString += `
            #ifdef TBNBLOCK
                ${isWebGPU ? "var TBN" : "mat3 TBN"} = ${tbn.associatedVariableName};
            #endif
            `;
    } else if (worldTangent.isConnected) {
      code += `${state._declareLocalVar("tbnNormal", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormalVarName}.xyz);
`;
      code += `${state._declareLocalVar("tbnTangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);
`;
      code += `${state._declareLocalVar("tbnBitangent", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};
`;
      code += `${isWebGPU ? "var vTBN" : "mat3 vTBN"} = ${isWebGPU ? "mat3x3f" : "mat3"}(tbnTangent, tbnBitangent, tbnNormal);
`;
    }
    state._emitFunctionFromInclude("bumpFragmentMainFunctions", comments, {
      replaceStrings: [tangentReplaceString]
    });
    return code;
  }
  /** @internal */
  static _GetInitializationCode(state, ccBlock) {
    let code = "";
    const intensity = ccBlock?.intensity.isConnected ? ccBlock.intensity.associatedVariableName : "1.";
    const roughness = ccBlock?.roughness.isConnected ? ccBlock.roughness.associatedVariableName : "0.";
    const tintColor = ccBlock?.tintColor.isConnected ? ccBlock.tintColor.associatedVariableName : `vec3${state.fSuffix}(1.)`;
    const tintThickness = ccBlock?.tintThickness.isConnected ? ccBlock.tintThickness.associatedVariableName : "1.";
    code += `
            #ifdef CLEARCOAT
                ${state._declareLocalVar("vClearCoatParams", NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(${intensity}, ${roughness});
                ${state._declareLocalVar("vClearCoatTintParams", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${tintColor}, ${tintThickness});
            #endif
`;
    return code;
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param state current state of the node material building
   * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module
   * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
   * @param worldPosVarName name of the variable holding the world position
   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated
   * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)
   * @param worldNormalVarName name of the variable holding the world normal
   * @returns the shader code
   */
  static GetCode(state, ccBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName) {
    let code = "";
    const normalMapColor = ccBlock?.normalMapColor.isConnected ? ccBlock.normalMapColor.associatedVariableName : `vec3${state.fSuffix}(0.)`;
    const uv = ccBlock?.uv.isConnected ? ccBlock.uv.associatedVariableName : `vec2${state.fSuffix}(0.)`;
    const tintAtDistance = ccBlock?.tintAtDistance.isConnected ? ccBlock.tintAtDistance.associatedVariableName : "1.";
    const tintTexture = `vec4${state.fSuffix}(0.)`;
    if (ccBlock) {
      state._emitUniformFromString("vClearCoatRefractionParams", NodeMaterialBlockConnectionPointTypes.Vector4);
      state._emitUniformFromString("vClearCoatTangentSpaceParams", NodeMaterialBlockConnectionPointTypes.Vector2);
      const normalShading = ccBlock.worldNormal;
      code += `${state._declareLocalVar("vGeometricNormaClearCoatW", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${normalShading.isConnected ? "normalize(" + normalShading.associatedVariableName + ".xyz)" : "geometricNormalW"};
`;
    } else {
      code += `${state._declareLocalVar("vGeometricNormaClearCoatW", NodeMaterialBlockConnectionPointTypes.Vector3)} = geometricNormalW;
`;
    }
    if (generateTBNSpace && ccBlock) {
      code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);
      vTBNAvailable = ccBlock.worldTangent.isConnected;
    }
    const isWebGPU = state.shaderLanguage === 1;
    code += `${isWebGPU ? "var clearcoatOut: clearcoatOutParams" : "clearcoatOutParams clearcoatOut"};

        #ifdef CLEARCOAT
            clearcoatOut = clearcoatBlock(
                ${worldPosVarName}.xyz
                , vGeometricNormaClearCoatW
                , viewDirectionW
                , vClearCoatParams
                , specularEnvironmentR0
            #ifdef CLEARCOAT_TEXTURE
                , vec2${state.fSuffix}(0.)
            #endif
            #ifdef CLEARCOAT_TINT
                , vClearCoatTintParams
                , ${tintAtDistance}
                , ${isWebGPU ? "uniforms." : ""}vClearCoatRefractionParams
                #ifdef CLEARCOAT_TINT_TEXTURE
                    , ${tintTexture}
                #endif
            #endif
            #ifdef CLEARCOAT_BUMP
                , vec2${state.fSuffix}(0., 1.)
                , vec4${state.fSuffix}(${normalMapColor}, 0.)
                , ${uv}
                #if defined(${vTBNAvailable ? "TANGENT" : "IGNORE"}) && defined(NORMAL)
                    , vTBN
                #else
                    , ${isWebGPU ? "uniforms." : ""}vClearCoatTangentSpaceParams
                #endif
                #ifdef OBJECTSPACE_NORMALMAP
                    , normalMatrix
                #endif
            #endif
            #if defined(FORCENORMALFORWARD) && defined(NORMAL)
                , faceNormal
            #endif
            #ifdef REFLECTION
                , ${isWebGPU ? "uniforms." : ""}${reflectionBlock?._vReflectionMicrosurfaceInfosName}
                , ${reflectionBlock?._vReflectionInfosName}
                , ${reflectionBlock?.reflectionColor}
                , ${isWebGPU ? "uniforms." : ""}vLightingIntensity
                #ifdef ${reflectionBlock?._define3DName}
                    , ${reflectionBlock?._cubeSamplerName}       
                    ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                #else
                    , ${reflectionBlock?._2DSamplerName}       
                    ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${reflectionBlock?._define3DName}
                        , ${reflectionBlock?._cubeSamplerName}       
                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                        , ${reflectionBlock?._cubeSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                    #else
                        , ${reflectionBlock?._2DSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}
                        , ${reflectionBlock?._2DSamplerName}
                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : ""}                        
                    #endif
                #endif
            #endif
            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
                , (${state._generateTernary("1.", "-1.", isWebGPU ? "fragmentInputs.frontFacing" : "gl_FrontFacing")})
            #endif
            );
        #else
            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;
        #endif
`;
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.bindableBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
      this._tangentCorrectionFactorName = state._getFreeDefineName("tangentCorrectionFactor");
      state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.remapF0OnInterfaceChange = serializationObject.remapF0OnInterfaceChange ?? true;
  }
};
__decorate([
  editableInPropertyPage("Remap F0 on interface change", 0, "ADVANCED", { embedded: true })
], ClearCoatBlock.prototype, "remapF0OnInterfaceChange", void 0);
RegisterClass("BABYLON.ClearCoatBlock", ClearCoatBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/iridescenceBlock.js
var IridescenceBlock = class _IridescenceBlock extends NodeMaterialBlock {
  /**
   * Create a new IridescenceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("thickness", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("iridescence", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("iridescence", this, 1, _IridescenceBlock, "IridescenceBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("iridescenceOut");
    state._excludeVariableName("vIridescenceParams");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "IridescenceBlock";
  }
  /**
   * Gets the intensity input component
   */
  get intensity() {
    return this._inputs[0];
  }
  /**
   * Gets the indexOfRefraction input component
   */
  get indexOfRefraction() {
    return this._inputs[1];
  }
  /**
   * Gets the thickness input component
   */
  get thickness() {
    return this._inputs[2];
  }
  /**
   * Gets the iridescence object output component
   */
  get iridescence() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("Iridescence intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
      const indexOfRefractionInput = new InputBlock("Iridescence ior", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      indexOfRefractionInput.value = 1.3;
      indexOfRefractionInput.output.connectTo(this.indexOfRefraction);
      const thicknessInput = new InputBlock("Iridescence thickness", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      thicknessInput.value = 400;
      thicknessInput.output.connectTo(this.thickness);
    }
  }
  prepareDefines(defines) {
    defines.setValue("IRIDESCENCE", true, true);
    defines.setValue("IRIDESCENCE_TEXTURE", false, true);
    defines.setValue("IRIDESCENCE_THICKNESS_TEXTURE", false, true);
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param iridescenceBlock instance of a IridescenceBlock or null if the code must be generated without an active iridescence module
   * @param state defines the build state
   * @returns the shader code
   */
  static GetCode(iridescenceBlock, state) {
    let code = "";
    const intensityName = iridescenceBlock?.intensity.isConnected ? iridescenceBlock.intensity.associatedVariableName : "1.";
    const indexOfRefraction = iridescenceBlock?.indexOfRefraction.isConnected ? iridescenceBlock.indexOfRefraction.associatedVariableName : PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    const thickness = iridescenceBlock?.thickness.isConnected ? iridescenceBlock.thickness.associatedVariableName : PBRIridescenceConfiguration._DefaultMaximumThickness;
    const isWebGPU = state.shaderLanguage === 1;
    code += `${isWebGPU ? "var iridescenceOut: iridescenceOutParams" : "iridescenceOutParams iridescenceOut"};

        #ifdef IRIDESCENCE
            iridescenceOut = iridescenceBlock(
                vec4(${intensityName}, ${indexOfRefraction}, 1., ${thickness})
                , NdotV
                , specularEnvironmentR0
                #ifdef CLEARCOAT
                    , NdotVUnclamped
                    , vClearCoatParams
                #endif                
            );

            ${isWebGPU ? "let" : "float"} iridescenceIntensity = iridescenceOut.iridescenceIntensity;
            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;
        #endif
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.bindableBlocks.push(this);
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
  }
};
RegisterClass("BABYLON.IridescenceBlock", IridescenceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/refractionBlock.js
var RefractionBlock = class _RefractionBlock extends NodeMaterialBlock {
  /**
   * Create a new RefractionBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.linkRefractionWithTransparency = false;
    this.invertRefractionY = false;
    this.useThicknessAsDepth = false;
    this._isUnique = true;
    this.registerInput("intensity", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintAtDistance", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("volumeIndexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", this, 1, _RefractionBlock, "RefractionBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("vRefractionPosition");
    state._excludeVariableName("vRefractionSize");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "RefractionBlock";
  }
  /**
   * Gets the intensity input component
   */
  get intensity() {
    return this._inputs[0];
  }
  /**
   * Gets the tint at distance input component
   */
  get tintAtDistance() {
    return this._inputs[1];
  }
  /**
   * Gets the volume index of refraction input component
   */
  get volumeIndexOfRefraction() {
    return this._inputs[2];
  }
  /**
   * Gets the view input component
   */
  get view() {
    return this.viewConnectionPoint;
  }
  /**
   * Gets the refraction object output component
   */
  get refraction() {
    return this._outputs[0];
  }
  /**
   * Returns true if the block has a texture
   */
  get hasTexture() {
    return !!this._getTexture();
  }
  _getTexture() {
    if (this.texture) {
      return this.texture;
    }
    return this._scene.environmentTexture;
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.intensity.isConnected) {
      const intensityInput = new InputBlock("Refraction intensity", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      intensityInput.value = 1;
      intensityInput.output.connectTo(this.intensity);
    }
    if (this.view && !this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(defines) {
    const refractionTexture = this._getTexture();
    const refraction = refractionTexture && refractionTexture.getTextureMatrix;
    defines.setValue("SS_REFRACTION", refraction, true);
    if (!refraction) {
      return;
    }
    defines.setValue(this._define3DName, refractionTexture.isCube, true);
    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);
    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);
    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ, true);
    defines.setValue("SS_LINKREFRACTIONTOTRANSPARENCY", this.linkRefractionWithTransparency, true);
    defines.setValue("SS_GAMMAREFRACTION", refractionTexture.gammaSpace, true);
    defines.setValue("SS_RGBDREFRACTION", refractionTexture.isRGBD, true);
    defines.setValue("SS_USE_LOCAL_REFRACTIONMAP_CUBIC", refractionTexture.boundingBoxSize ? true : false, true);
    defines.setValue("SS_USE_THICKNESS_AS_DEPTH", this.useThicknessAsDepth, true);
  }
  isReady() {
    const texture = this._getTexture();
    if (texture && !texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh) {
    super.bind(effect, nodeMaterial, mesh);
    const refractionTexture = this._getTexture();
    if (!refractionTexture) {
      return;
    }
    if (refractionTexture.isCube) {
      effect.setTexture(this._cubeSamplerName, refractionTexture);
    } else {
      effect.setTexture(this._2DSamplerName, refractionTexture);
    }
    effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());
    let depth = 1;
    if (!refractionTexture.isCube) {
      if (refractionTexture.depth) {
        depth = refractionTexture.depth;
      }
    }
    const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;
    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);
    const width = refractionTexture.getSize().width;
    effect.setFloat2(this._vRefractionFilteringInfoName, width, Math.log2(width));
    if (refractionTexture.boundingBoxSize) {
      const cubeTexture = refractionTexture;
      effect.setVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
      effect.setVector3("vRefractionSize", cubeTexture.boundingBoxSize);
    }
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param state current state of the node material building
   * @returns the shader code
   */
  getCode(state) {
    const code = "";
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    this._cubeSamplerName = state._getFreeVariableName(this.name + "CubeSampler");
    state.samplers.push(this._cubeSamplerName);
    this._2DSamplerName = state._getFreeVariableName(this.name + "2DSampler");
    state.samplers.push(this._2DSamplerName);
    this._define3DName = state._getFreeDefineName("SS_REFRACTIONMAP_3D");
    const refractionTexture = this._getTexture();
    if (refractionTexture) {
      state._samplerDeclaration += `#ifdef ${this._define3DName}
`;
      state._emitCubeSampler(this._cubeSamplerName, void 0, true);
      state._samplerDeclaration += `#else
`;
      state._emit2DSampler(this._2DSamplerName, void 0, true);
      state._samplerDeclaration += `#endif
`;
    }
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    this._defineLODRefractionAlpha = state._getFreeDefineName("SS_LODINREFRACTIONALPHA");
    this._defineLinearSpecularRefraction = state._getFreeDefineName("SS_LINEARSPECULARREFRACTION");
    this._defineOppositeZ = state._getFreeDefineName("SS_REFRACTIONMAP_OPPOSITEZ");
    this._refractionMatrixName = state._getFreeVariableName("refractionMatrix");
    state._emitUniformFromString(this._refractionMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);
    if (state.shaderLanguage !== 1) {
      state._emitFunction("sampleRefraction", `
                #ifdef ${this._define3DName}
                    #define sampleRefraction(s, c) textureCube(s, c)
                #else
                    #define sampleRefraction(s, c) texture2D(s, c)
                #endif
`, `//${this.name}`);
      state._emitFunction("sampleRefractionLod", `
                #ifdef ${this._define3DName}
                    #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)
                #else
                    #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)
                #endif
`, `//${this.name}`);
    }
    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName("vRefractionMicrosurfaceInfos");
    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, NodeMaterialBlockConnectionPointTypes.Vector4);
    this._vRefractionInfosName = state._getFreeVariableName("vRefractionInfos");
    state._emitUniformFromString(this._vRefractionInfosName, NodeMaterialBlockConnectionPointTypes.Vector4);
    this._vRefractionFilteringInfoName = state._getFreeVariableName("vRefractionFilteringInfo");
    state._emitUniformFromString(this._vRefractionFilteringInfoName, NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emitUniformFromString("vRefractionPosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    state._emitUniformFromString("vRefractionSize", NodeMaterialBlockConnectionPointTypes.Vector3);
    return code;
  }
  _buildBlock(state) {
    this._scene = state.sharedData.scene;
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    if (this.texture) {
      if (this.texture.isCube) {
        codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}");
`;
      } else {
        codeString = `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}");
`;
      }
      codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`;
    }
    codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};
`;
    codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};
`;
    codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.texture && !this.texture.isRenderTarget) {
      serializationObject.texture = this.texture.serialize();
    }
    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;
    serializationObject.invertRefractionY = this.invertRefractionY;
    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.texture) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      if (serializationObject.texture.isCube) {
        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);
      } else {
        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
      }
    }
    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;
    this.invertRefractionY = serializationObject.invertRefractionY;
    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;
  }
};
__decorate([
  editableInPropertyPage("Link refraction to transparency", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], RefractionBlock.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  editableInPropertyPage("Invert refraction Y", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], RefractionBlock.prototype, "invertRefractionY", void 0);
__decorate([
  editableInPropertyPage("Use thickness as depth", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], RefractionBlock.prototype, "useThicknessAsDepth", void 0);
RegisterClass("BABYLON.RefractionBlock", RefractionBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/subSurfaceBlock.js
var SubSurfaceBlock = class _SubSurfaceBlock extends NodeMaterialBlock {
  /**
   * Create a new SubSurfaceBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this.applyAlbedoAfterSubSurface = PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;
    this._isUnique = true;
    this.registerInput("thickness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("tintColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("translucencyIntensity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("translucencyDiffusionDist", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("refraction", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("refraction", this, 0, RefractionBlock, "RefractionBlock"));
    this.registerInput("dispersion", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", this, 1, _SubSurfaceBlock, "SubSurfaceBlock"));
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("subSurfaceOut");
    state._excludeVariableName("vThicknessParam");
    state._excludeVariableName("vTintColor");
    state._excludeVariableName("vTranslucencyColor");
    state._excludeVariableName("vSubSurfaceIntensity");
    state._excludeVariableName("dispersion");
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SubSurfaceBlock";
  }
  /**
   * Gets the thickness component
   */
  get thickness() {
    return this._inputs[0];
  }
  /**
   * Gets the tint color input component
   */
  get tintColor() {
    return this._inputs[1];
  }
  /**
   * Gets the translucency intensity input component
   */
  get translucencyIntensity() {
    return this._inputs[2];
  }
  /**
   * Gets the translucency diffusion distance input component
   */
  get translucencyDiffusionDist() {
    return this._inputs[3];
  }
  /**
   * Gets the refraction object parameters
   */
  get refraction() {
    return this._inputs[4];
  }
  /**
   * Gets the dispersion input component
   */
  get dispersion() {
    return this._inputs[5];
  }
  /**
   * Gets the sub surface object output component
   */
  get subsurface() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.thickness.isConnected) {
      const thicknessInput = new InputBlock("SubSurface thickness", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);
      thicknessInput.value = 0;
      thicknessInput.output.connectTo(this.thickness);
    }
  }
  prepareDefines(defines) {
    const translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;
    defines.setValue("SUBSURFACE", translucencyEnabled || this.refraction.isConnected, true);
    defines.setValue("SS_TRANSLUCENCY", translucencyEnabled, true);
    defines.setValue("SS_THICKNESSANDMASK_TEXTURE", false, true);
    defines.setValue("SS_REFRACTIONINTENSITY_TEXTURE", false, true);
    defines.setValue("SS_TRANSLUCENCYINTENSITY_TEXTURE", false, true);
    defines.setValue("SS_USE_GLTF_TEXTURES", false, true);
    defines.setValue("SS_DISPERSION", this.dispersion.isConnected, true);
    defines.setValue("SS_APPLY_ALBEDO_AFTER_SUBSURFACE", this.applyAlbedoAfterSubSurface, true);
  }
  /**
   * Gets the main code of the block (fragment side)
   * @param state current state of the node material building
   * @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module
   * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module
   * @param worldPosVarName name of the variable holding the world position
   * @returns the shader code
   */
  static GetCode(state, ssBlock, reflectionBlock, worldPosVarName) {
    let code = "";
    const thickness = ssBlock?.thickness.isConnected ? ssBlock.thickness.associatedVariableName : "0.";
    const tintColor = ssBlock?.tintColor.isConnected ? ssBlock.tintColor.associatedVariableName : "vec3(1.)";
    const translucencyIntensity = ssBlock?.translucencyIntensity.isConnected ? ssBlock?.translucencyIntensity.associatedVariableName : "1.";
    const translucencyDiffusionDistance = ssBlock?.translucencyDiffusionDist.isConnected ? ssBlock?.translucencyDiffusionDist.associatedVariableName : "vec3(1.)";
    const refractionBlock = ssBlock?.refraction.isConnected ? ssBlock?.refraction.connectedPoint?.ownerBlock : null;
    const refractionTintAtDistance = refractionBlock?.tintAtDistance.isConnected ? refractionBlock.tintAtDistance.associatedVariableName : "1.";
    const refractionIntensity = refractionBlock?.intensity.isConnected ? refractionBlock.intensity.associatedVariableName : "1.";
    const refractionView = refractionBlock?.view.isConnected ? refractionBlock.view.associatedVariableName : "";
    const dispersion = ssBlock?.dispersion.isConnected ? ssBlock?.dispersion.associatedVariableName : "0.0";
    const isWebGPU = state.shaderLanguage === 1;
    code += refractionBlock?.getCode(state) ?? "";
    code += `${isWebGPU ? "var subSurfaceOut: subSurfaceOutParams" : "subSurfaceOutParams subSurfaceOut"};

        #ifdef SUBSURFACE
            ${state._declareLocalVar("vThicknessParam", NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(0., ${thickness});
            ${state._declareLocalVar("vTintColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${tintColor}, ${refractionTintAtDistance});
            ${state._declareLocalVar("vSubSurfaceIntensity", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3(${refractionIntensity}, ${translucencyIntensity}, 0.);
            ${state._declareLocalVar("dispersion", NodeMaterialBlockConnectionPointTypes.Float)} = ${dispersion};
            subSurfaceOut = subSurfaceBlock(
                vSubSurfaceIntensity
                , vThicknessParam
                , vTintColor
                , normalW
            #ifdef LEGACY_SPECULAR_ENERGY_CONSERVATION
        `;
    code += isWebGPU ? `, vec3f(max(colorSpecularEnvironmentReflectance.r, max(colorSpecularEnvironmentReflectance.g, colorSpecularEnvironmentReflectance.b)))/n` : `, vec3(max(colorSpecularEnvironmentReflectance.r, max(colorSpecularEnvironmentReflectance.g, colorSpecularEnvironmentReflectance.b)))/n`;
    code += `#else
                , baseSpecularEnvironmentReflectance
            #endif
            #ifdef SS_THICKNESSANDMASK_TEXTURE
                , vec4${state.fSuffix}(0.)
            #endif
            #ifdef REFLECTION
                #ifdef SS_TRANSLUCENCY
                    , ${(isWebGPU ? "uniforms." : "") + reflectionBlock?._reflectionMatrixName}
                    #ifdef USESPHERICALFROMREFLECTIONMAP
                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
                            , reflectionOut.irradianceVector
                        #endif
                        #if defined(REALTIME_FILTERING)
                            , ${reflectionBlock?._cubeSamplerName}
                            ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : ""}
                            , ${reflectionBlock?._vReflectionFilteringInfoName}
                        #endif
                        #endif
                    #ifdef USEIRRADIANCEMAP
                        , irradianceSampler
                        ${isWebGPU ? `, irradianceSamplerSampler` : ""}
                    #endif
                #endif
            #endif
            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
                , surfaceAlbedo
            #endif
            #ifdef SS_REFRACTION
                , ${worldPosVarName}.xyz
                , viewDirectionW
                , ${refractionView}
                , ${(isWebGPU ? "uniforms." : "") + (refractionBlock?._vRefractionInfosName ?? "")}
                , ${(isWebGPU ? "uniforms." : "") + (refractionBlock?._refractionMatrixName ?? "")}
                , ${(isWebGPU ? "uniforms." : "") + (refractionBlock?._vRefractionMicrosurfaceInfosName ?? "")}
                , ${isWebGPU ? "uniforms." : ""}vLightingIntensity
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    , alpha
                #endif
                #ifdef ${refractionBlock?._defineLODRefractionAlpha ?? "IGNORE"}
                    , NdotVUnclamped
                #endif
                #ifdef ${refractionBlock?._defineLinearSpecularRefraction ?? "IGNORE"}
                    , roughness
                #endif
                , alphaG
                #ifdef ${refractionBlock?._define3DName ?? "IGNORE"}
                    , ${refractionBlock?._cubeSamplerName ?? ""}
                    ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : ""}
                #else
                    , ${refractionBlock?._2DSamplerName ?? ""}
                    ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : ""}
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${refractionBlock?._define3DName ?? "IGNORE"}
                        , ${refractionBlock?._cubeSamplerName ?? ""}                        
                        ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : ""}
                        , ${refractionBlock?._cubeSamplerName ?? ""}                        
                        ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : ""}
                    #else
                        , ${refractionBlock?._2DSamplerName ?? ""}
                        ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : ""}
                        , ${refractionBlock?._2DSamplerName ?? ""}
                        ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : ""}
                    #endif
                #endif
                #ifdef ANISOTROPIC
                    , anisotropicOut
                #endif
                #ifdef REALTIME_FILTERING
                    , ${refractionBlock?._vRefractionFilteringInfoName ?? ""}
                #endif
                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
                    , vRefractionPosition
                    , vRefractionSize
                #endif
                #ifdef SS_DISPERSION
                    , dispersion
                #endif
            #endif
            #ifdef SS_TRANSLUCENCY
                , ${translucencyDiffusionDistance}
                , vTintColor
                #ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
                    , vec4${state.fSuffix}(0.)
                #endif
            #endif                
            );

            #ifdef SS_REFRACTION
                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    alpha = subSurfaceOut.alpha;
                #endif
            #endif
        #else
            subSurfaceOut.specularEnvironmentReflectance = colorSpecularEnvironmentReflectance;
        #endif
`;
    return code;
  }
  _buildBlock(state) {
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      state.sharedData.blocksWithDefines.push(this);
    }
    return this;
  }
};
__decorate([
  editableInPropertyPage("Apply albedo after sub-surface", 0, "ADVANCED")
], SubSurfaceBlock.prototype, "applyAlbedoAfterSubSurface", void 0);
RegisterClass("BABYLON.SubSurfaceBlock", SubSurfaceBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/PBR/pbrMetallicRoughnessBlock.js
var MapOutputToVariable = {
  ambientClr: ["finalAmbient", ""],
  diffuseDir: ["finalDiffuse", ""],
  specularDir: ["finalSpecularScaled", "!defined(UNLIT) && defined(SPECULARTERM)"],
  clearcoatDir: ["finalClearCoatScaled", "!defined(UNLIT) && defined(CLEARCOAT)"],
  sheenDir: ["finalSheenScaled", "!defined(UNLIT) && defined(SHEEN)"],
  diffuseInd: ["finalIrradiance", "!defined(UNLIT) && defined(REFLECTION)"],
  specularInd: ["finalRadianceScaled", "!defined(UNLIT) && defined(REFLECTION)"],
  clearcoatInd: ["clearcoatOut.finalClearCoatRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)"],
  sheenInd: ["sheenOut.finalSheenRadianceScaled", "!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)"],
  refraction: ["subSurfaceOut.finalRefraction", "!defined(UNLIT) && defined(SS_REFRACTION)"],
  lighting: ["finalColor.rgb", ""],
  shadow: ["aggShadow", ""],
  alpha: ["alpha", ""]
};
var PBRMetallicRoughnessBlock = class extends NodeMaterialBlock {
  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {
    const that = block;
    if (that.worldPosition.isConnected || that.worldNormal.isConnected) {
      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;
      Logger.Error("The worldPosition and worldNormal inputs must not be connected to be able to switch!");
      return false;
    }
    that._setTarget();
    return true;
  }
  _setTarget() {
    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);
    this.getInputByName("worldPosition").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
    this.getInputByName("worldNormal").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;
  }
  /**
   * Create a new ReflectionBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.VertexAndFragment);
    this._environmentBRDFTexture = null;
    this._metallicReflectanceColor = Color3.White();
    this._metallicF0Factor = 1;
    this.directIntensity = 1;
    this.environmentIntensity = 1;
    this.specularIntensity = 1;
    this.lightFalloff = 0;
    this.useAlphaTest = false;
    this.alphaTestCutoff = 0.5;
    this.useAlphaBlending = false;
    this.useRadianceOverAlpha = true;
    this.useSpecularOverAlpha = true;
    this.enableSpecularAntiAliasing = false;
    this.realTimeFiltering = false;
    this.realTimeFilteringQuality = 8;
    this.baseDiffuseModel = 0;
    this.useEnergyConservation = true;
    this.useRadianceOcclusion = true;
    this.useHorizonOcclusion = true;
    this.unlit = false;
    this.forceNormalForward = false;
    this.generateOnlyFragmentCode = false;
    this.debugMode = 0;
    this.debugLimit = 0;
    this.debugFactor = 1;
    this._isUnique = true;
    this.registerInput("worldPosition", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("worldNormal", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false);
    this.registerInput("cameraPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("perturbedNormal", NodeMaterialBlockConnectionPointTypes.Vector4, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("baseColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("metallic", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("roughness", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
    this.registerInput("ambientOcc", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("opacity", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("indexOfRefraction", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("ambientColor", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);
    this.registerInput("reflection", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("reflection", this, 0, ReflectionBlock, "ReflectionBlock"));
    this.registerInput("clearcoat", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("clearcoat", this, 0, ClearCoatBlock, "ClearCoatBlock"));
    this.registerInput("sheen", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("sheen", this, 0, SheenBlock, "SheenBlock"));
    this.registerInput("subsurface", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("subsurface", this, 0, SubSurfaceBlock, "SubSurfaceBlock"));
    this.registerInput("anisotropy", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("anisotropy", this, 0, AnisotropyBlock, "AnisotropyBlock"));
    this.registerInput("iridescence", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject("iridescence", this, 0, IridescenceBlock, "IridescenceBlock"));
    this.registerOutput("ambientClr", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("diffuseDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("clearcoatDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheenDir", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("diffuseInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("specularInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("clearcoatInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("sheenInd", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("refraction", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("lighting", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("shadow", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("alpha", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("vLightingIntensity");
    state._excludeVariableName("geometricNormalW");
    state._excludeVariableName("normalW");
    state._excludeVariableName("faceNormal");
    state._excludeVariableName("albedoOpacityOut");
    state._excludeVariableName("surfaceAlbedo");
    state._excludeVariableName("alpha");
    state._excludeVariableName("aoOut");
    state._excludeVariableName("baseColor");
    state._excludeVariableName("reflectivityOut");
    state._excludeVariableName("microSurface");
    state._excludeVariableName("roughness");
    state._excludeVariableName("vReflectivityColor");
    state._excludeVariableName("NdotVUnclamped");
    state._excludeVariableName("NdotV");
    state._excludeVariableName("alphaG");
    state._excludeVariableName("AARoughnessFactors");
    state._excludeVariableName("environmentBrdf");
    state._excludeVariableName("ambientMonochrome");
    state._excludeVariableName("seo");
    state._excludeVariableName("eho");
    state._excludeVariableName("environmentRadiance");
    state._excludeVariableName("irradianceVector");
    state._excludeVariableName("environmentIrradiance");
    state._excludeVariableName("diffuseBase");
    state._excludeVariableName("specularBase");
    state._excludeVariableName("preInfo");
    state._excludeVariableName("info");
    state._excludeVariableName("shadow");
    state._excludeVariableName("finalDiffuse");
    state._excludeVariableName("finalAmbient");
    state._excludeVariableName("ambientOcclusionForDirectDiffuse");
    state._excludeVariableName("finalColor");
    state._excludeVariableName("vClipSpacePosition");
    state._excludeVariableName("vDebugMode");
    state._excludeVariableName("vViewDepth");
    this._initShaderSourceAsync(state.shaderLanguage);
  }
  async _initShaderSourceAsync(shaderLanguage) {
    this._codeIsReady = false;
    if (shaderLanguage === 1) {
      await Promise.all([import("./pbr.vertex-OP6KEIZH.js"), import("./pbr.fragment-LEO4CZSS.js")]);
    } else {
      await Promise.all([import("./pbr.vertex-SPBYPWVL.js"), import("./pbr.fragment-QHW7PKPG.js")]);
    }
    this._codeIsReady = true;
    this.onCodeIsReadyObservable.notifyObservers(this);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "PBRMetallicRoughnessBlock";
  }
  /**
   * Gets the world position input component
   */
  get worldPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the world normal input component
   */
  get worldNormal() {
    return this._inputs[1];
  }
  /**
   * Gets the view matrix parameter
   */
  get view() {
    return this._inputs[2];
  }
  /**
   * Gets the camera position input component
   */
  get cameraPosition() {
    return this._inputs[3];
  }
  /**
   * Gets the perturbed normal input component
   */
  get perturbedNormal() {
    return this._inputs[4];
  }
  /**
   * Gets the base color input component
   */
  get baseColor() {
    return this._inputs[5];
  }
  /**
   * Gets the metallic input component
   */
  get metallic() {
    return this._inputs[6];
  }
  /**
   * Gets the roughness input component
   */
  get roughness() {
    return this._inputs[7];
  }
  /**
   * Gets the ambient occlusion input component
   */
  get ambientOcc() {
    return this._inputs[8];
  }
  /**
   * Gets the opacity input component
   */
  get opacity() {
    return this._inputs[9];
  }
  /**
   * Gets the index of refraction input component
   */
  get indexOfRefraction() {
    return this._inputs[10];
  }
  /**
   * Gets the ambient color input component
   */
  get ambientColor() {
    return this._inputs[11];
  }
  /**
   * Gets the reflection object parameters
   */
  get reflection() {
    return this._inputs[12];
  }
  /**
   * Gets the clear coat object parameters
   */
  get clearcoat() {
    return this._inputs[13];
  }
  /**
   * Gets the sheen object parameters
   */
  get sheen() {
    return this._inputs[14];
  }
  /**
   * Gets the sub surface object parameters
   */
  get subsurface() {
    return this._inputs[15];
  }
  /**
   * Gets the anisotropy object parameters
   */
  get anisotropy() {
    return this._inputs[16];
  }
  /**
   * Gets the iridescence object parameters
   */
  get iridescence() {
    return this._inputs[17];
  }
  /**
   * Gets the ambient output component
   */
  get ambientClr() {
    return this._outputs[0];
  }
  /**
   * Gets the diffuse output component
   */
  get diffuseDir() {
    return this._outputs[1];
  }
  /**
   * Gets the specular output component
   */
  get specularDir() {
    return this._outputs[2];
  }
  /**
   * Gets the clear coat output component
   */
  get clearcoatDir() {
    return this._outputs[3];
  }
  /**
   * Gets the sheen output component
   */
  get sheenDir() {
    return this._outputs[4];
  }
  /**
   * Gets the indirect diffuse output component
   */
  get diffuseInd() {
    return this._outputs[5];
  }
  /**
   * Gets the indirect specular output component
   */
  get specularInd() {
    return this._outputs[6];
  }
  /**
   * Gets the indirect clear coat output component
   */
  get clearcoatInd() {
    return this._outputs[7];
  }
  /**
   * Gets the indirect sheen output component
   */
  get sheenInd() {
    return this._outputs[8];
  }
  /**
   * Gets the refraction output component
   */
  get refraction() {
    return this._outputs[9];
  }
  /**
   * Gets the global lighting output component
   */
  get lighting() {
    return this._outputs[10];
  }
  /**
   * Gets the shadow output component
   */
  get shadow() {
    return this._outputs[11];
  }
  /**
   * Gets the alpha output component
   */
  get alpha() {
    return this._outputs[12];
  }
  autoConfigure(material, additionalFilteringInfo = () => true) {
    if (!this.cameraPosition.isConnected) {
      let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));
      if (!cameraPositionInput) {
        cameraPositionInput = new InputBlock("cameraPosition");
        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);
      }
      cameraPositionInput.output.connectTo(this.cameraPosition);
    }
    if (!this.view.isConnected) {
      let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));
      if (!viewInput) {
        viewInput = new InputBlock("view");
        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);
      }
      viewInput.output.connectTo(this.view);
    }
  }
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    defines.setValue("PBR", true);
    defines.setValue("METALLICWORKFLOW", true);
    defines.setValue("DEBUGMODE", this.debugMode, true);
    defines.setValue("DEBUGMODE_FORCERETURN", true);
    defines.setValue("NORMALXYSCALE", true);
    defines.setValue("BUMP", this.perturbedNormal.isConnected, true);
    defines.setValue("LODBASEDMICROSFURACE", this._scene.getEngine().getCaps().textureLOD);
    defines.setValue("ALBEDO", false, true);
    defines.setValue("OPACITY", this.opacity.isConnected, true);
    defines.setValue("AMBIENT", true, true);
    defines.setValue("AMBIENTINGRAYSCALE", false, true);
    defines.setValue("REFLECTIVITY", false, true);
    defines.setValue("AOSTOREINMETALMAPRED", false, true);
    defines.setValue("METALLNESSSTOREINMETALMAPBLUE", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPALPHA", false, true);
    defines.setValue("ROUGHNESSSTOREINMETALMAPGREEN", false, true);
    if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    } else if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", false);
      defines.setValue("USEGLTFLIGHTFALLOFF", true);
    } else {
      defines.setValue("USEPHYSICALLIGHTFALLOFF", true);
      defines.setValue("USEGLTFLIGHTFALLOFF", false);
    }
    const alphaTestCutOffString = this.alphaTestCutoff.toString();
    defines.setValue("ALPHABLEND", this.useAlphaBlending, true);
    defines.setValue("ALPHAFROMALBEDO", false, true);
    defines.setValue("ALPHATEST", this.useAlphaTest, true);
    defines.setValue("ALPHATESTVALUE", alphaTestCutOffString.indexOf(".") < 0 ? alphaTestCutOffString + "." : alphaTestCutOffString, true);
    defines.setValue("OPACITYRGB", false, true);
    defines.setValue("RADIANCEOVERALPHA", this.useRadianceOverAlpha, true);
    defines.setValue("SPECULAROVERALPHA", this.useSpecularOverAlpha, true);
    defines.setValue("SPECULARAA", this._scene.getEngine().getCaps().standardDerivatives && this.enableSpecularAntiAliasing, true);
    defines.setValue("REALTIME_FILTERING", this.realTimeFiltering, true);
    const scene = mesh.getScene();
    const engine = scene.getEngine();
    if (engine._features.needTypeSuffixInShaderConstants) {
      defines.setValue("NUM_SAMPLES", this.realTimeFilteringQuality + "u", true);
    } else {
      defines.setValue("NUM_SAMPLES", "" + this.realTimeFilteringQuality, true);
    }
    defines.setValue("BASE_DIFFUSE_MODEL", this.baseDiffuseModel, true);
    defines.setValue("BRDF_V_HEIGHT_CORRELATED", true);
    defines.setValue("LEGACY_SPECULAR_ENERGY_CONSERVATION", true);
    defines.setValue("MS_BRDF_ENERGY_CONSERVATION", this.useEnergyConservation, true);
    defines.setValue("RADIANCEOCCLUSION", this.useRadianceOcclusion, true);
    defines.setValue("HORIZONOCCLUSION", this.useHorizonOcclusion, true);
    defines.setValue("UNLIT", this.unlit, true);
    defines.setValue("FORCENORMALFORWARD", this.forceNormalForward, true);
    if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
      defines.setValue("ENVIRONMENTBRDF", true);
      defines.setValue("ENVIRONMENTBRDF_RGBD", this._environmentBRDFTexture.isRGBD, true);
    } else {
      defines.setValue("ENVIRONMENTBRDF", false);
      defines.setValue("ENVIRONMENTBRDF_RGBD", false);
    }
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);
    }
    if (!defines._areLightsDirty) {
      return;
    }
    if (!this.light) {
      PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);
      defines._needNormals = true;
      PrepareDefinesForMultiview(scene, defines);
    } else {
      const state = {
        needNormals: false,
        needRebuild: false,
        lightmapMode: false,
        shadowEnabled: false,
        specularEnabled: false
      };
      PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);
      if (state.needRebuild) {
        defines.rebuild();
      }
    }
  }
  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      const onlyUpdateBuffersList = state.uniforms.indexOf("vLightData" + lightIndex) >= 0;
      PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffers, onlyUpdateBuffersList, defines["IESLIGHTTEXTURE" + lightIndex], defines["CLUSTLIGHT" + lightIndex]);
    }
  }
  isReady(mesh, nodeMaterial, defines) {
    if (this._environmentBRDFTexture && !this._environmentBRDFTexture.isReady()) {
      return false;
    }
    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {
      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    return true;
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    if (!this.light) {
      BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);
    } else {
      BindLight(this.light, this._lightId, scene, effect, true);
    }
    effect.setTexture(this._environmentBrdfSamplerName, this._environmentBRDFTexture);
    effect.setFloat2("vDebugMode", this.debugLimit, this.debugFactor);
    const ambientScene = this._scene.ambientColor;
    if (ambientScene) {
      effect.setColor3("ambientFromScene", ambientScene);
    }
    const invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);
    effect.setFloat(this._invertNormalName, invertNormal ? -1 : 1);
    effect.setFloat4("vLightingIntensity", this.directIntensity, 1, this.environmentIntensity * this._scene.environmentIntensity, this.specularIntensity);
    const metallicF90 = this._metallicF0Factor;
    effect.setColor4(this._vMetallicReflectanceFactorsName, this._metallicReflectanceColor, metallicF90);
    if (nodeMaterial.imageProcessingConfiguration) {
      nodeMaterial.imageProcessingConfiguration.bind(effect);
    }
  }
  _injectVertexCode(state) {
    const worldPos = this.worldPosition;
    const worldNormal = this.worldNormal;
    const comments = `//${this.name}`;
    const isWebGPU = state.shaderLanguage === 1;
    if (!this.light) {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights"
      });
      this._lightId = 0;
      state.sharedData.dynamicUniformBlocks.push(this);
    } else {
      this._lightId = (state.counters["lightCounter"] !== void 0 ? state.counters["lightCounter"] : -1) + 1;
      state.counters["lightCounter"] = this._lightId;
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightVxUboDeclaration" : "lightVxFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    const worldPosVaryingName = "v_" + worldPos.associatedVariableName;
    if (state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {
      state.compilationString += (isWebGPU ? "vertexOutputs." : "") + `${worldPosVaryingName} = ${worldPos.associatedVariableName};
`;
    }
    const worldNormalVaryingName = "v_" + worldNormal.associatedVariableName;
    if (state._emitVaryingFromString(worldNormalVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {
      state.compilationString += (isWebGPU ? "vertexOutputs." : "") + `${worldNormalVaryingName} = ${worldNormal.associatedVariableName};
`;
    }
    const reflectionBlock = this.reflection.isConnected ? this.reflection.connectedPoint?.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.viewConnectionPoint = this.view;
    }
    state.compilationString += reflectionBlock?.handleVertexSide(state) ?? "";
    if (state._emitVaryingFromString("vClipSpacePosition", NodeMaterialBlockConnectionPointTypes.Vector4, "defined(IGNORE) || DEBUGMODE > 0")) {
      state._injectAtEnd += `#if DEBUGMODE > 0
`;
      state._injectAtEnd += (isWebGPU ? "vertexOutputs." : "") + `vClipSpacePosition = ${isWebGPU ? "vertexOutputs.position" : "gl_Position"};
`;
      state._injectAtEnd += `#endif
`;
    }
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: /worldPos/g, replace: worldPos.associatedVariableName }
        ]
      });
    } else {
      state.compilationString += `${state._declareLocalVar("worldPos", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldPos.associatedVariableName};
`;
      if (this.view.isConnected) {
        state.compilationString += `${state._declareLocalVar("view", NodeMaterialBlockConnectionPointTypes.Matrix)} = ${this.view.associatedVariableName};
`;
        state._emitVaryingFromString("vViewDepth", NodeMaterialBlockConnectionPointTypes.Float);
        state.compilationString += (state.shaderLanguage === 1 ? "vertexOutputs." : "") + `vViewDepth = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;
`;
      }
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights"
      });
    }
  }
  _getAlbedoOpacityCode(state) {
    const isWebGPU = state.shaderLanguage === 1;
    let code = isWebGPU ? "var albedoOpacityOut: albedoOpacityOutParams;\n" : `albedoOpacityOutParams albedoOpacityOut;
`;
    const albedoColor = this.baseColor.isConnected ? this.baseColor.associatedVariableName : "vec3(1.)";
    const opacity = this.opacity.isConnected ? this.opacity.associatedVariableName : "1.";
    code += `albedoOpacityOut = albedoOpacityBlock(
                vec4${state.fSuffix}(${albedoColor}, 1.)
            #ifdef ALBEDO
                ,vec4${state.fSuffix}(1.)
                ,vec2${state.fSuffix}(1., 1.)
            #endif
                ,1. /* Base Weight */
            #ifdef OPACITY
                ,vec4${state.fSuffix}(${opacity})
                ,vec2${state.fSuffix}(1., 1.)
            #endif
            );

            ${state._declareLocalVar("surfaceAlbedo", NodeMaterialBlockConnectionPointTypes.Vector3)} = albedoOpacityOut.surfaceAlbedo;
            ${state._declareLocalVar("alpha", NodeMaterialBlockConnectionPointTypes.Float)} = albedoOpacityOut.alpha;
`;
    return code;
  }
  _getAmbientOcclusionCode(state) {
    const isWebGPU = state.shaderLanguage === 1;
    let code = isWebGPU ? "var aoOut: ambientOcclusionOutParams;\n" : `ambientOcclusionOutParams aoOut;
`;
    const ao = this.ambientOcc.isConnected ? this.ambientOcc.associatedVariableName : "1.";
    code += `aoOut = ambientOcclusionBlock(
            #ifdef AMBIENT
                vec3${state.fSuffix}(${ao}),
                vec4${state.fSuffix}(0., 1.0, 1.0, 0.)
            #endif
            );
`;
    return code;
  }
  _getReflectivityCode(state) {
    const isWebGPU = state.shaderLanguage === 1;
    let code = isWebGPU ? "var reflectivityOut: reflectivityOutParams;\n" : `reflectivityOutParams reflectivityOut;
`;
    const aoIntensity = "1.";
    this._vMetallicReflectanceFactorsName = state._getFreeVariableName("vMetallicReflectanceFactors");
    state._emitUniformFromString(this._vMetallicReflectanceFactorsName, NodeMaterialBlockConnectionPointTypes.Vector4);
    this._baseDiffuseRoughnessName = state._getFreeVariableName("baseDiffuseRoughness");
    state._emitUniformFromString(this._baseDiffuseRoughnessName, NodeMaterialBlockConnectionPointTypes.Float);
    const outsideIOR = 1;
    const ior = this.indexOfRefraction.connectInputBlock?.value ?? 1.5;
    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
    code += `${state._declareLocalVar("baseColor", NodeMaterialBlockConnectionPointTypes.Vector3)} = surfaceAlbedo;
            ${isWebGPU ? "let" : `vec4${state.fSuffix}`} vReflectivityColor = vec4${state.fSuffix}(${this.metallic.associatedVariableName}, ${this.roughness.associatedVariableName}, ${this.indexOfRefraction.associatedVariableName || "1.5"}, ${f0});
            reflectivityOut = reflectivityBlock(
                vReflectivityColor
            #ifdef METALLICWORKFLOW
                , surfaceAlbedo
                , ${(isWebGPU ? "uniforms." : "") + this._vMetallicReflectanceFactorsName}
            #endif
                , ${(isWebGPU ? "uniforms." : "") + this._baseDiffuseRoughnessName}
            #ifdef BASE_DIFFUSE_ROUGHNESS
                , 0.
                , vec2${state.fSuffix}(0., 0.)
            #endif
            #ifdef REFLECTIVITY
                , vec3${state.fSuffix}(0., 0., ${aoIntensity})
                , vec4${state.fSuffix}(1.)
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)
                , aoOut.ambientOcclusionColor
            #endif
            #ifdef MICROSURFACEMAP
                , microSurfaceTexel <== not handled!
            #endif
            );

            ${state._declareLocalVar("microSurface", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.microSurface;
            ${state._declareLocalVar("roughness", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.roughness;
            ${state._declareLocalVar("diffuseRoughness", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.diffuseRoughness;

            #ifdef METALLICWORKFLOW
                surfaceAlbedo = reflectivityOut.surfaceAlbedo;
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;
            #endif
`;
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    this._scene = state.sharedData.scene;
    const isWebGPU = state.shaderLanguage === 1;
    if (!this._environmentBRDFTexture) {
      this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this._scene);
    }
    const reflectionBlock = this.reflection.isConnected ? this.reflection.connectedPoint?.ownerBlock : null;
    if (reflectionBlock) {
      reflectionBlock.worldPositionConnectionPoint = this.worldPosition;
      reflectionBlock.cameraPositionConnectionPoint = this.cameraPosition;
      reflectionBlock.worldNormalConnectionPoint = this.worldNormal;
      reflectionBlock.viewConnectionPoint = this.view;
    }
    if (state.target !== NodeMaterialBlockTargets.Fragment) {
      this._injectVertexCode(state);
      return this;
    }
    state.sharedData.forcedBindableBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.blockingBlocks.push(this);
    if (this.generateOnlyFragmentCode) {
      state.sharedData.dynamicUniformBlocks.push(this);
    }
    const comments = `//${this.name}`;
    const normalShading = this.perturbedNormal;
    let worldPosVarName = this.worldPosition.associatedVariableName;
    let worldPosVarName4 = this.worldPosition.associatedVariableName;
    let worldNormalVarName = this.worldNormal.associatedVariableName;
    if (this.generateOnlyFragmentCode) {
      worldPosVarName = state._getFreeVariableName("globalWorldPos");
      state._emitFunction("pbr_globalworldpos", `${state._declareLocalVar(worldPosVarName, NodeMaterialBlockConnectionPointTypes.Vector3, false, true)};
`, comments);
      state.compilationString += `${worldPosVarName} = ${this.worldPosition.associatedVariableName}.xyz;
`;
      worldPosVarName4 = state._getFreeVariableName("globalWorldPos4");
      state._emitFunction("pbr_globalworldpos4", `${state._declareLocalVar(worldPosVarName4, NodeMaterialBlockConnectionPointTypes.Vector4, false, true)};
`, comments);
      state.compilationString += `${worldPosVarName4} = ${this.worldPosition.associatedVariableName};
`;
      worldNormalVarName = state._getFreeVariableName("globalWorldNormal");
      state._emitFunction("pbr_globalworldnorm", `${state._declareLocalVar(worldNormalVarName, NodeMaterialBlockConnectionPointTypes.Vector4, false, true)};
`, comments);
      state.compilationString += `${worldNormalVarName} = ${this.worldNormal.associatedVariableName};
`;
      state.compilationString += state._emitCodeFromInclude("shadowsVertex", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: `worldPos,${this.worldPosition.associatedVariableName}`
      });
      state.compilationString += `#if DEBUGMODE > 0
`;
      state.compilationString += `${state._declareLocalVar("vClipSpacePosition", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}((vec2${state.fSuffix}(${isWebGPU ? "fragmentInputs.position" : "gl_FragCoord.xy"}) / vec2${state.fSuffix}(1.0)) * 2.0 - 1.0, 0.0, 1.0);
`;
      state.compilationString += `#endif
`;
    } else {
      worldPosVarName = (isWebGPU ? "input." : "") + "v_" + worldPosVarName;
      worldNormalVarName = (isWebGPU ? "input." : "") + "v_" + worldNormalVarName;
    }
    this._environmentBrdfSamplerName = state._getFreeVariableName("environmentBrdfSampler");
    state._emit2DSampler(this._environmentBrdfSamplerName);
    state.sharedData.hints.needAlphaBlending = state.sharedData.hints.needAlphaBlending || this.useAlphaBlending;
    state.sharedData.hints.needAlphaTesting = state.sharedData.hints.needAlphaTesting || this.useAlphaTest;
    state._emitExtension("lod", "#extension GL_EXT_shader_texture_lod : enable", "defined(LODBASEDMICROSFURACE)");
    state._emitExtension("derivatives", "#extension GL_OES_standard_derivatives : enable");
    state._emitUniformFromString("vDebugMode", NodeMaterialBlockConnectionPointTypes.Vector2, "defined(IGNORE) || DEBUGMODE > 0");
    state._emitUniformFromString("ambientFromScene", NodeMaterialBlockConnectionPointTypes.Vector3);
    state.uniforms.push("exposureLinear");
    state.uniforms.push("contrast");
    state.uniforms.push("vInverseScreenSize");
    state.uniforms.push("vignetteSettings1");
    state.uniforms.push("vignetteSettings2");
    state.uniforms.push("vCameraColorCurveNegative");
    state.uniforms.push("vCameraColorCurveNeutral");
    state.uniforms.push("vCameraColorCurvePositive");
    state.uniforms.push("txColorTransform");
    state.uniforms.push("colorTransformSettings");
    state.uniforms.push("ditherIntensity");
    if (!this.light) {
      if (this.generateOnlyFragmentCode && this.view.isConnected) {
        state.compilationString += `${state._declareLocalVar("vViewDepth", NodeMaterialBlockConnectionPointTypes.Float)} = (${this.view.associatedVariableName} * ${worldPosVarName4}).z;
`;
      }
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: this.generateOnlyFragmentCode ? "varying," : void 0
      });
    } else {
      state._emitFunctionFromInclude(state.supportUniformBuffers ? "lightUboDeclaration" : "lightFragmentDeclaration", comments, {
        replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]
      }, this._lightId.toString());
    }
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitFunctionFromInclude("importanceSampling", comments);
    state._emitFunctionFromInclude("pbrHelperFunctions", comments);
    state._emitFunctionFromInclude("imageProcessingDeclaration", comments);
    state._emitFunctionFromInclude("imageProcessingFunctions", comments);
    state._emitFunctionFromInclude("shadowsFragmentFunctions", comments);
    state._emitFunctionFromInclude("pbrDirectLightingSetupFunctions", comments);
    state._emitFunctionFromInclude("pbrDirectLightingFalloffFunctions", comments);
    state._emitFunctionFromInclude("pbrBRDFFunctions", comments, {
      replaceStrings: [{ search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" }]
    });
    state._emitFunctionFromInclude("hdrFilteringFunctions", comments);
    state._emitFunctionFromInclude("pbrDirectLightingFunctions", comments);
    state._emitFunctionFromInclude("pbrIBLFunctions", comments);
    state._emitFunctionFromInclude("pbrBlockAlbedoOpacity", comments);
    state._emitFunctionFromInclude("pbrBlockReflectivity", comments);
    state._emitFunctionFromInclude("pbrBlockAmbientOcclusion", comments);
    state._emitFunctionFromInclude("pbrBlockAlphaFresnel", comments);
    state._emitFunctionFromInclude("pbrBlockAnisotropic", comments);
    if (!isWebGPU) {
      state._emitFunctionFromInclude("pbrClusteredLightingFunctions", comments);
    }
    state._emitUniformFromString("vLightingIntensity", NodeMaterialBlockConnectionPointTypes.Vector4);
    if (reflectionBlock?.generateOnlyFragmentCode) {
      state.compilationString += reflectionBlock.handleVertexSide(state);
    }
    this._vNormalWName = state._getFreeVariableName("vNormalW");
    state.compilationString += `${state._declareLocalVar(this._vNormalWName, NodeMaterialBlockConnectionPointTypes.Vector4)} = normalize(${worldNormalVarName});
`;
    if (state._registerTempVariable("viewDirectionW")) {
      state.compilationString += `${state._declareLocalVar("viewDirectionW", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVarName}.xyz);
`;
    }
    state.compilationString += `${state._declareLocalVar("geometricNormalW", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._vNormalWName}.xyz;
`;
    state.compilationString += `${state._declareLocalVar("normalW", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${normalShading.isConnected ? "normalize(" + normalShading.associatedVariableName + ".xyz)" : "geometricNormalW"};
`;
    this._invertNormalName = state._getFreeVariableName("invertNormal");
    state._emitUniformFromString(this._invertNormalName, NodeMaterialBlockConnectionPointTypes.Float);
    state.compilationString += state._emitCodeFromInclude("pbrBlockNormalFinal", comments, {
      replaceStrings: [
        { search: /vPositionW/g, replace: worldPosVarName + ".xyz" },
        { search: /vEyePosition.w/g, replace: this._invertNormalName }
      ]
    });
    state.compilationString += this._getAlbedoOpacityCode(state);
    state.compilationString += state._emitCodeFromInclude("depthPrePass", comments);
    state.compilationString += this._getAmbientOcclusionCode(state);
    state.compilationString += state._emitCodeFromInclude("pbrBlockLightmapInit", comments);
    state.compilationString += `#ifdef UNLIT
                ${state._declareLocalVar("diffuseBase", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3${state.fSuffix}(1., 1., 1.);
            #else
`;
    state.compilationString += this._getReflectivityCode(state);
    state.compilationString += state._emitCodeFromInclude("pbrBlockGeometryInfo", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" }
      ]
    });
    const anisotropyBlock = this.anisotropy.isConnected ? this.anisotropy.connectedPoint?.ownerBlock : null;
    if (anisotropyBlock) {
      anisotropyBlock.worldPositionConnectionPoint = this.worldPosition;
      anisotropyBlock.worldNormalConnectionPoint = this.worldNormal;
      state.compilationString += anisotropyBlock.getCode(state, !this.perturbedNormal.isConnected);
    }
    if (reflectionBlock && reflectionBlock.hasTexture) {
      state.compilationString += reflectionBlock.getCode(state, anisotropyBlock ? "anisotropicOut.anisotropicNormal" : "normalW");
    }
    state._emitFunctionFromInclude("pbrBlockReflection", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? "LINEARSPECULARREFLECTION" },
        { search: /vReflectionFilteringInfo/g, replace: reflectionBlock?._vReflectionFilteringInfoName ?? "vReflectionFilteringInfo" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance0", comments, {
      replaceStrings: [{ search: /metallicReflectanceFactors/g, replace: (isWebGPU ? "uniforms." : "") + this._vMetallicReflectanceFactorsName }]
    });
    const sheenBlock = this.sheen.isConnected ? this.sheen.connectedPoint?.ownerBlock : null;
    if (sheenBlock) {
      state.compilationString += sheenBlock.getCode(reflectionBlock, state);
    }
    state._emitFunctionFromInclude("pbrBlockSheen", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? "LINEARSPECULARREFLECTION" }
      ]
    });
    const clearcoatBlock = this.clearcoat.isConnected ? this.clearcoat.connectedPoint?.ownerBlock : null;
    state.compilationString += ClearCoatBlock._GetInitializationCode(state, clearcoatBlock);
    const iridescenceBlock = this.iridescence.isConnected ? this.iridescence.connectedPoint?.ownerBlock : null;
    state.compilationString += IridescenceBlock.GetCode(iridescenceBlock, state);
    state._emitFunctionFromInclude("pbrBlockIridescence", comments, {
      replaceStrings: []
    });
    const generateTBNSpace = !this.perturbedNormal.isConnected && !this.anisotropy.isConnected;
    const isTangentConnectedToPerturbNormal = this.perturbedNormal.isConnected && (this.perturbedNormal.connectedPoint?.ownerBlock).worldTangent?.isConnected;
    const isTangentConnectedToAnisotropy = this.anisotropy.isConnected && (this.anisotropy.connectedPoint?.ownerBlock).worldTangent.isConnected;
    let vTBNAvailable = isTangentConnectedToPerturbNormal || !this.perturbedNormal.isConnected && isTangentConnectedToAnisotropy;
    state.compilationString += ClearCoatBlock.GetCode(state, clearcoatBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName);
    if (generateTBNSpace) {
      vTBNAvailable = clearcoatBlock?.worldTangent.isConnected ?? false;
    }
    state._emitFunctionFromInclude("pbrBlockClearcoat", comments, {
      replaceStrings: [
        { search: /computeReflectionCoords/g, replace: "computeReflectionCoordsPBR" },
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? "REFLECTIONMAP_PROJECTION" },
        { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" },
        { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? "LODINREFLECTIONALPHA" },
        { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? "LINEARSPECULARREFLECTION" },
        { search: /defined\(TANGENT\)/g, replace: vTBNAvailable ? "defined(TANGENT)" : "defined(IGNORE)" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockReflectance", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? "REFLECTIONMAP_SKYBOX" },
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" },
        { search: /uniforms\.vReflectivityColor/g, replace: "vReflectivityColor" }
      ]
    });
    const subsurfaceBlock = this.subsurface.isConnected ? this.subsurface.connectedPoint?.ownerBlock : null;
    const refractionBlock = this.subsurface.isConnected ? (this.subsurface.connectedPoint?.ownerBlock).refraction.connectedPoint?.ownerBlock : null;
    if (refractionBlock) {
      refractionBlock.viewConnectionPoint = this.view;
      refractionBlock.indexOfRefractionConnectionPoint = this.indexOfRefraction;
    }
    state.compilationString += SubSurfaceBlock.GetCode(state, subsurfaceBlock, reflectionBlock, worldPosVarName);
    state._emitFunctionFromInclude("pbrBlockSubSurface", comments, {
      replaceStrings: [
        { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? "REFLECTIONMAP_3D" },
        { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? "REFLECTIONMAP_OPPOSITEZ" },
        { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? "REFLECTIONMAP_PROJECTION" },
        { search: /SS_REFRACTIONMAP_3D/g, replace: refractionBlock?._define3DName ?? "SS_REFRACTIONMAP_3D" },
        { search: /SS_LODINREFRACTIONALPHA/g, replace: refractionBlock?._defineLODRefractionAlpha ?? "SS_LODINREFRACTIONALPHA" },
        { search: /SS_LINEARSPECULARREFRACTION/g, replace: refractionBlock?._defineLinearSpecularRefraction ?? "SS_LINEARSPECULARREFRACTION" },
        { search: /SS_REFRACTIONMAP_OPPOSITEZ/g, replace: refractionBlock?._defineOppositeZ ?? "SS_REFRACTIONMAP_OPPOSITEZ" }
      ]
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockDirectLighting", comments);
    if (this.light) {
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        replaceStrings: [
          { search: /{X}/g, replace: this._lightId.toString() },
          { search: new RegExp(`${isWebGPU ? "fragmentInputs." : ""}vPositionW`, "g"), replace: worldPosVarName + ".xyz" },
          { search: /uniforms\.vReflectivityColor/g, replace: "vReflectivityColor" }
        ]
      });
    } else {
      let substitutionVars = `vPositionW,${worldPosVarName}.xyz`;
      if (isWebGPU) {
        substitutionVars = "fragmentInputs." + substitutionVars;
        if (this.generateOnlyFragmentCode) {
          substitutionVars += `,fragmentInputs.vViewDepth,vViewDepth`;
        }
      }
      state.compilationString += state._emitCodeFromInclude("lightFragment", comments, {
        repeatKey: "maxSimultaneousLights",
        substitutionVars: substitutionVars + ",uniforms.vReflectivityColor,vReflectivityColor"
      });
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalLitComponents", comments);
    state.compilationString += `#endif
`;
    const aoColor = this.ambientColor.isConnected ? this.ambientColor.associatedVariableName : `vec3${state.fSuffix}(0., 0., 0.)`;
    let aoDirectLightIntensity = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();
    if (aoDirectLightIntensity.indexOf(".") === -1) {
      aoDirectLightIntensity += ".";
    }
    let replaceStrings = [
      { search: /vec3 finalEmissive[\s\S]*?finalEmissive\*=vLightingIntensity\.y;/g, replace: "" },
      { search: new RegExp(`${isWebGPU ? "uniforms." : ""}vAmbientColor`, "g"), replace: aoColor + ` * ${isWebGPU ? "uniforms." : ""}ambientFromScene` },
      { search: new RegExp(`${isWebGPU ? "uniforms." : ""}vAmbientInfos.w`, "g"), replace: aoDirectLightIntensity }
    ];
    if (isWebGPU) {
      replaceStrings[0] = { search: /var finalEmissive[\s\S]*?finalEmissive\*=uniforms.vLightingIntensity\.y;/g, replace: "" };
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalUnlitComponents", comments, {
      replaceStrings
    });
    state.compilationString += state._emitCodeFromInclude("pbrBlockFinalColorComposition", comments, {
      replaceStrings: [{ search: /finalEmissive/g, replace: `vec3${state.fSuffix}(0.)` }]
    });
    if (isWebGPU) {
      replaceStrings = [{ search: /mesh.visibility/g, replace: "1." }];
    } else {
      replaceStrings = [{ search: /visibility/g, replace: "1." }];
    }
    state.compilationString += state._emitCodeFromInclude("pbrBlockImageProcessing", comments, {
      replaceStrings
    });
    const colorOutput = isWebGPU ? "fragmentOutputs.color" : "gl_FragColor";
    replaceStrings = [
      { search: new RegExp(`${isWebGPU ? "fragmentInputs." : ""}vNormalW`, "g"), replace: this._vNormalWName },
      { search: new RegExp(`${isWebGPU ? "fragmentInputs." : ""}vPositionW`, "g"), replace: worldPosVarName },
      { search: /uniforms\.vReflectivityColor/g, replace: "vReflectivityColor" },
      {
        search: /albedoTexture\.rgb;/g,
        replace: `vec3${state.fSuffix}(1.);
${colorOutput}.rgb = toGammaSpace(${colorOutput}.rgb);
`
      }
    ];
    state.compilationString += state._emitCodeFromInclude("pbrDebug", comments, {
      replaceStrings
    });
    for (const output of this._outputs) {
      if (output.hasEndpoints) {
        const remap = MapOutputToVariable[output.name];
        if (remap) {
          const [varName, conditions] = remap;
          if (conditions) {
            state.compilationString += `#if ${conditions}
`;
          }
          state.compilationString += `${state._declareOutput(output)} = ${varName};
`;
          if (conditions) {
            state.compilationString += `#else
`;
            state.compilationString += `${state._declareOutput(output)} = vec3${state.fSuffix}(0.);
`;
            state.compilationString += `#endif
`;
          }
        } else {
          state.sharedData.raiseBuildError(`There's no remapping for the ${output.name} end point! No code generated`);
        }
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.lightFalloff = ${this.lightFalloff};
`;
    codeString += `${this._codeVariableName}.useAlphaTest = ${this.useAlphaTest};
`;
    codeString += `${this._codeVariableName}.alphaTestCutoff = ${this.alphaTestCutoff};
`;
    codeString += `${this._codeVariableName}.useAlphaBlending = ${this.useAlphaBlending};
`;
    codeString += `${this._codeVariableName}.useRadianceOverAlpha = ${this.useRadianceOverAlpha};
`;
    codeString += `${this._codeVariableName}.useSpecularOverAlpha = ${this.useSpecularOverAlpha};
`;
    codeString += `${this._codeVariableName}.enableSpecularAntiAliasing = ${this.enableSpecularAntiAliasing};
`;
    codeString += `${this._codeVariableName}.realTimeFiltering = ${this.realTimeFiltering};
`;
    codeString += `${this._codeVariableName}.realTimeFilteringQuality = ${this.realTimeFilteringQuality};
`;
    codeString += `${this._codeVariableName}.useEnergyConservation = ${this.useEnergyConservation};
`;
    codeString += `${this._codeVariableName}.useRadianceOcclusion = ${this.useRadianceOcclusion};
`;
    codeString += `${this._codeVariableName}.useHorizonOcclusion = ${this.useHorizonOcclusion};
`;
    codeString += `${this._codeVariableName}.unlit = ${this.unlit};
`;
    codeString += `${this._codeVariableName}.forceNormalForward = ${this.forceNormalForward};
`;
    codeString += `${this._codeVariableName}.debugMode = ${this.debugMode};
`;
    codeString += `${this._codeVariableName}.debugLimit = ${this.debugLimit};
`;
    codeString += `${this._codeVariableName}.debugFactor = ${this.debugFactor};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    if (this.light) {
      serializationObject.lightId = this.light.id;
    }
    serializationObject.lightFalloff = this.lightFalloff;
    serializationObject.useAlphaTest = this.useAlphaTest;
    serializationObject.alphaTestCutoff = this.alphaTestCutoff;
    serializationObject.useAlphaBlending = this.useAlphaBlending;
    serializationObject.useRadianceOverAlpha = this.useRadianceOverAlpha;
    serializationObject.useSpecularOverAlpha = this.useSpecularOverAlpha;
    serializationObject.enableSpecularAntiAliasing = this.enableSpecularAntiAliasing;
    serializationObject.realTimeFiltering = this.realTimeFiltering;
    serializationObject.realTimeFilteringQuality = this.realTimeFilteringQuality;
    serializationObject.useEnergyConservation = this.useEnergyConservation;
    serializationObject.useRadianceOcclusion = this.useRadianceOcclusion;
    serializationObject.useHorizonOcclusion = this.useHorizonOcclusion;
    serializationObject.unlit = this.unlit;
    serializationObject.forceNormalForward = this.forceNormalForward;
    serializationObject.debugMode = this.debugMode;
    serializationObject.debugLimit = this.debugLimit;
    serializationObject.debugFactor = this.debugFactor;
    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    if (serializationObject.lightId) {
      this.light = scene.getLightById(serializationObject.lightId);
    }
    this.lightFalloff = serializationObject.lightFalloff ?? 0;
    this.useAlphaTest = serializationObject.useAlphaTest;
    this.alphaTestCutoff = serializationObject.alphaTestCutoff;
    this.useAlphaBlending = serializationObject.useAlphaBlending;
    this.useRadianceOverAlpha = serializationObject.useRadianceOverAlpha;
    this.useSpecularOverAlpha = serializationObject.useSpecularOverAlpha;
    this.enableSpecularAntiAliasing = serializationObject.enableSpecularAntiAliasing;
    this.realTimeFiltering = !!serializationObject.realTimeFiltering;
    this.realTimeFilteringQuality = serializationObject.realTimeFilteringQuality ?? 8;
    this.useEnergyConservation = serializationObject.useEnergyConservation;
    this.useRadianceOcclusion = serializationObject.useRadianceOcclusion;
    this.useHorizonOcclusion = serializationObject.useHorizonOcclusion;
    this.unlit = serializationObject.unlit;
    this.forceNormalForward = !!serializationObject.forceNormalForward;
    this.debugMode = serializationObject.debugMode;
    this.debugLimit = serializationObject.debugLimit;
    this.debugFactor = serializationObject.debugFactor;
    this.generateOnlyFragmentCode = !!serializationObject.generateOnlyFragmentCode;
    this._setTarget();
  }
};
__decorate([
  editableInPropertyPage("Direct lights", 1, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "directIntensity", void 0);
__decorate([
  editableInPropertyPage("Environment lights", 1, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "environmentIntensity", void 0);
__decorate([
  editableInPropertyPage("Specular highlights", 1, "INTENSITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "specularIntensity", void 0);
__decorate([
  editableInPropertyPage("Light falloff", 5, "LIGHTING & COLORS", {
    notifiers: { update: true },
    options: [
      { label: "Physical", value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL },
      { label: "GLTF", value: PBRBaseMaterial.LIGHTFALLOFF_GLTF },
      { label: "Standard", value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "lightFalloff", void 0);
__decorate([
  editableInPropertyPage("Alpha Testing", 0, "OPACITY")
], PBRMetallicRoughnessBlock.prototype, "useAlphaTest", void 0);
__decorate([
  editableInPropertyPage("Alpha CutOff", 1, "OPACITY", { min: 0, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "alphaTestCutoff", void 0);
__decorate([
  editableInPropertyPage("Alpha blending", 0, "OPACITY")
], PBRMetallicRoughnessBlock.prototype, "useAlphaBlending", void 0);
__decorate([
  editableInPropertyPage("Radiance over alpha", 0, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useRadianceOverAlpha", void 0);
__decorate([
  editableInPropertyPage("Specular over alpha", 0, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  editableInPropertyPage("Specular anti-aliasing", 0, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  editableInPropertyPage("Realtime filtering", 0, "RENDERING", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "realTimeFiltering", void 0);
__decorate([
  editableInPropertyPage("Realtime filtering quality", 5, "RENDERING", {
    notifiers: { update: true },
    options: [
      { label: "Low", value: 8 },
      { label: "Medium", value: 16 },
      { label: "High", value: 64 }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "realTimeFilteringQuality", void 0);
__decorate([
  editableInPropertyPage("Diffuse Model", 5, "RENDERING", {
    notifiers: { update: true },
    options: [
      { label: "Lambert", value: 2 },
      { label: "Burley", value: 1 },
      { label: "Oren-Nayar", value: 0 },
      { label: "Legacy", value: 3 }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "baseDiffuseModel", void 0);
__decorate([
  editableInPropertyPage("Energy Conservation", 0, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useEnergyConservation", void 0);
__decorate([
  editableInPropertyPage("Radiance occlusion", 0, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useRadianceOcclusion", void 0);
__decorate([
  editableInPropertyPage("Horizon occlusion", 0, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "useHorizonOcclusion", void 0);
__decorate([
  editableInPropertyPage("Unlit", 0, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "unlit", void 0);
__decorate([
  editableInPropertyPage("Force normal forward", 0, "ADVANCED", { notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "forceNormalForward", void 0);
__decorate([
  editableInPropertyPage("Generate only fragment code", 0, "ADVANCED", {
    notifiers: { rebuild: true, update: true, onValidation: PBRMetallicRoughnessBlock._OnGenerateOnlyFragmentCodeChanged }
  })
], PBRMetallicRoughnessBlock.prototype, "generateOnlyFragmentCode", void 0);
__decorate([
  editableInPropertyPage("Debug mode", 5, "DEBUG", {
    notifiers: { update: true },
    options: [
      { label: "None", value: 0 },
      // Geometry
      { label: "Normalized position", value: 1 },
      { label: "Normals", value: 2 },
      { label: "Tangents", value: 3 },
      { label: "Bitangents", value: 4 },
      { label: "Bump Normals", value: 5 },
      //{ label: "UV1", value: 6 },
      //{ label: "UV2", value: 7 },
      { label: "ClearCoat Normals", value: 8 },
      { label: "ClearCoat Tangents", value: 9 },
      { label: "ClearCoat Bitangents", value: 10 },
      { label: "Anisotropic Normals", value: 11 },
      { label: "Anisotropic Tangents", value: 12 },
      { label: "Anisotropic Bitangents", value: 13 },
      // Maps
      //{ label: "Emissive Map", value: 23 },
      //{ label: "Light Map", value: 24 },
      // Env
      { label: "Env Refraction", value: 40 },
      { label: "Env Reflection", value: 41 },
      { label: "Env Clear Coat", value: 42 },
      // Lighting
      { label: "Direct Diffuse", value: 50 },
      { label: "Direct Specular", value: 51 },
      { label: "Direct Clear Coat", value: 52 },
      { label: "Direct Sheen", value: 53 },
      { label: "Env Irradiance", value: 54 },
      // Lighting Params
      { label: "Surface Albedo", value: 60 },
      { label: "Reflectance 0", value: 61 },
      { label: "Metallic", value: 62 },
      { label: "Metallic F0", value: 71 },
      { label: "Roughness", value: 63 },
      { label: "AlphaG", value: 64 },
      { label: "NdotV", value: 65 },
      { label: "ClearCoat Color", value: 66 },
      { label: "ClearCoat Roughness", value: 67 },
      { label: "ClearCoat NdotV", value: 68 },
      { label: "Transmittance", value: 69 },
      { label: "Refraction Transmittance", value: 70 },
      // Misc
      { label: "SEO", value: 80 },
      { label: "EHO", value: 81 },
      { label: "Energy Factor", value: 82 },
      { label: "Specular Reflectance", value: 83 },
      { label: "Clear Coat Reflectance", value: 84 },
      { label: "Sheen Reflectance", value: 85 },
      { label: "Luminance Over Alpha", value: 86 },
      { label: "Alpha", value: 87 },
      { label: "Albedo color", value: 88 },
      { label: "Ambient occlusion color", value: 89 }
    ]
  })
], PBRMetallicRoughnessBlock.prototype, "debugMode", void 0);
__decorate([
  editableInPropertyPage("Split position", 1, "DEBUG", { min: -1, max: 1, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "debugLimit", void 0);
__decorate([
  editableInPropertyPage("Output factor", 1, "DEBUG", { min: 0, max: 5, notifiers: { update: true } })
], PBRMetallicRoughnessBlock.prototype, "debugFactor", void 0);
RegisterClass("BABYLON.PBRMetallicRoughnessBlock", PBRMetallicRoughnessBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/modBlock.js
var ModBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ModBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ModBlock";
  }
  /**
   * Gets the left operand input component
   */
  get left() {
    return this._inputs[0];
  }
  /**
   * Gets the right operand input component
   */
  get right() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    if (state.shaderLanguage === 0) {
      state.compilationString += state._declareOutput(output) + ` = mod(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`;
    } else {
      state.compilationString += state._declareOutput(output) + ` = (${this.left.associatedVariableName} % ${this.right.associatedVariableName});
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.ModBlock", ModBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixBuilderBlock.js
var MatrixBuilderBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MatrixBuilder
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("row0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerInput("row3", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MatrixBuilder";
  }
  /**
   * Gets the row0 vector
   */
  get row0() {
    return this._inputs[0];
  }
  /**
   * Gets the row1 vector
   */
  get row1() {
    return this._inputs[1];
  }
  /**
   * Gets the row2 vector
   */
  get row2() {
    return this._inputs[2];
  }
  /**
   * Gets the row3 vector
   */
  get row3() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure() {
    if (!this.row0.isConnected) {
      const row0Input = new InputBlock("row0");
      row0Input.value = new Vector4(1, 0, 0, 0);
      row0Input.output.connectTo(this.row0);
    }
    if (!this.row1.isConnected) {
      const row1Input = new InputBlock("row1");
      row1Input.value = new Vector4(0, 1, 0, 0);
      row1Input.output.connectTo(this.row1);
    }
    if (!this.row2.isConnected) {
      const row2Input = new InputBlock("row2");
      row2Input.value = new Vector4(0, 0, 1, 0);
      row2Input.output.connectTo(this.row2);
    }
    if (!this.row3.isConnected) {
      const row3Input = new InputBlock("row3");
      row3Input.value = new Vector4(0, 0, 0, 1);
      row3Input.output.connectTo(this.row3);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const row0 = this.row0;
    const row1 = this.row1;
    const row2 = this.row2;
    const row3 = this.row3;
    const mat4 = state.shaderLanguage === 1 ? "mat4x4f" : "mat4";
    state.compilationString += state._declareOutput(output) + ` = ${mat4}(${row0.associatedVariableName}, ${row1.associatedVariableName}, ${row2.associatedVariableName}, ${row3.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixBuilder", MatrixBuilderBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/conditionalBlock.js
var ConditionalBlockConditions;
(function(ConditionalBlockConditions2) {
  ConditionalBlockConditions2[ConditionalBlockConditions2["Equal"] = 0] = "Equal";
  ConditionalBlockConditions2[ConditionalBlockConditions2["NotEqual"] = 1] = "NotEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["LessThan"] = 2] = "LessThan";
  ConditionalBlockConditions2[ConditionalBlockConditions2["GreaterThan"] = 3] = "GreaterThan";
  ConditionalBlockConditions2[ConditionalBlockConditions2["LessOrEqual"] = 4] = "LessOrEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["GreaterOrEqual"] = 5] = "GreaterOrEqual";
  ConditionalBlockConditions2[ConditionalBlockConditions2["Xor"] = 6] = "Xor";
  ConditionalBlockConditions2[ConditionalBlockConditions2["Or"] = 7] = "Or";
  ConditionalBlockConditions2[ConditionalBlockConditions2["And"] = 8] = "And";
})(ConditionalBlockConditions || (ConditionalBlockConditions = {}));
var ConditionalBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ConditionalBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.condition = ConditionalBlockConditions.LessThan;
    this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("b", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("true", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("false", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._linkConnectionTypes(2, 3);
    this._outputs[0]._typeConnectionSource = this._inputs[2];
    this._outputs[0]._defaultConnectionPointType = NodeMaterialBlockConnectionPointTypes.Float;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ConditionalBlock";
  }
  /**
   * Gets the first operand component
   */
  get a() {
    return this._inputs[0];
  }
  /**
   * Gets the second operand component
   */
  get b() {
    return this._inputs[1];
  }
  /**
   * Gets the value to return if condition is true
   */
  get true() {
    return this._inputs[2];
  }
  /**
   * Gets the value to return if condition is false
   */
  get false() {
    return this._inputs[3];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  autoConfigure(nodeMaterial) {
    if (!this.true.isConnected) {
      const minInput = nodeMaterial.getBlockByPredicate((b) => b.isInput && b.value === 1 && b.name === "True") || new InputBlock("True");
      minInput.value = 1;
      minInput.output.connectTo(this.true);
    }
    if (!this.false.isConnected) {
      const maxInput = nodeMaterial.getBlockByPredicate((b) => b.isInput && b.value === 0 && b.name === "False") || new InputBlock("False");
      maxInput.value = 0;
      maxInput.output.connectTo(this.false);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const trueStatement = this.true.isConnected ? this.true.associatedVariableName : "1.0";
    const falseStatement = this.false.isConnected ? this.false.associatedVariableName : "0.0";
    switch (this.condition) {
      case ConditionalBlockConditions.Equal: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} == ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.NotEqual: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} != ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.LessThan: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} < ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.LessOrEqual: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} <= ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.GreaterThan: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} > ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.GreaterOrEqual: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} >= ${this.b.associatedVariableName}`)};
`;
        break;
      }
      case ConditionalBlockConditions.Xor: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `(((${this.a.associatedVariableName} + ${this.b.associatedVariableName}) % 2.0) > 0.0)`)};
`;
        break;
      }
      case ConditionalBlockConditions.Or: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `(min(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 1.0) > 0.0)`)};
`;
        break;
      }
      case ConditionalBlockConditions.And: {
        state.compilationString += state._declareOutput(output) + ` = ${state._generateTernary(trueStatement, falseStatement, `(${this.a.associatedVariableName} * ${this.b.associatedVariableName} > 0.0)`)};
`;
        break;
      }
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.condition = this.condition;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.condition = serializationObject.condition;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.condition = BABYLON.ConditionalBlockConditions.${ConditionalBlockConditions[this.condition]};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Condition", 5, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "Equal", value: ConditionalBlockConditions.Equal },
      { label: "NotEqual", value: ConditionalBlockConditions.NotEqual },
      { label: "LessThan", value: ConditionalBlockConditions.LessThan },
      { label: "GreaterThan", value: ConditionalBlockConditions.GreaterThan },
      { label: "LessOrEqual", value: ConditionalBlockConditions.LessOrEqual },
      { label: "GreaterOrEqual", value: ConditionalBlockConditions.GreaterOrEqual },
      { label: "Xor", value: ConditionalBlockConditions.Xor },
      { label: "And", value: ConditionalBlockConditions.And },
      { label: "Or", value: ConditionalBlockConditions.Or }
    ]
  })
], ConditionalBlock.prototype, "condition", void 0);
RegisterClass("BABYLON.ConditionalBlock", ConditionalBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/cloudBlock.js
var CloudBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new CloudBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.octaves = 6;
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("chaos", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.registerInput("offsetX", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("offsetY", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("offsetZ", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);
    this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CloudBlock";
  }
  /**
   * Gets the seed input component
   */
  get seed() {
    return this._inputs[0];
  }
  /**
   * Gets the chaos input component
   */
  get chaos() {
    return this._inputs[1];
  }
  /**
   * Gets the offset X input component
   */
  get offsetX() {
    return this._inputs[2];
  }
  /**
   * Gets the offset Y input component
   */
  get offsetY() {
    return this._inputs[3];
  }
  /**
   * Gets the offset Z input component
   */
  get offsetZ() {
    return this._inputs[4];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    if (!this._outputs[0].hasEndpoints) {
      return;
    }
    let functionString = `

        float cloudRandom(float p) { 
            float temp = fract(p * 0.011); 
            temp *= temp + 7.5; 
            temp *= temp + temp; 
            return fract(temp); 
        }

        // Based on Morgan McGuire @morgan3d
        // https://www.shadertoy.com/view/4dS3Wd
        float cloudNoise2(vec2 x, vec2 chaos) {
            vec2 step = chaos * vec2(75., 120.) + vec2(75., 120.);

            vec2 i = floor(x);
            vec2 f = fract(x);

            float n = dot(i, step);

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(
                    mix(cloudRandom(n + dot(step, vec2(0, 0))), cloudRandom(n + dot(step, vec2(1, 0))), u.x),
                    mix(cloudRandom(n + dot(step, vec2(0, 1))), cloudRandom(n + dot(step, vec2(1, 1))), u.x),
                    u.y
                );
        }

        float cloudNoise3(vec3 x, vec3 chaos) {
            vec3 step = chaos * vec3(60., 120., 75.) + vec3(60., 120., 75.);

            vec3 i = floor(x);
            vec3 f = fract(x);

            float n = dot(i, step);

            vec3 u = f * f * (3.0 - 2.0 * f);
            return mix(mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 0))), cloudRandom(n + dot(step, vec3(1, 0, 0))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 0))), cloudRandom(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
                       mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 1))), cloudRandom(n + dot(step, vec3(1, 0, 1))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 1))), cloudRandom(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
        }`;
    let fractalBrownianString = `
        float fbm2(vec2 st, vec2 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = .5;
            float frequency = 0.;

            // Loop of octaves
            vec2 tempST = st;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * cloudNoise2(tempST, chaos);
                tempST *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        float fbm3(vec3 x, vec3 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = 0.5;
            vec3 tempX = x;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * cloudNoise3(tempX, chaos);
                tempX = tempX * 2.0;
                amplitude *= 0.5;
            }
            return value;
        }`;
    if (state.shaderLanguage === 1) {
      functionString = state._babylonSLtoWGSL(functionString);
      fractalBrownianString = state._babylonSLtoWGSL(fractalBrownianString);
    }
    const fbmNewName = `fbm${this.octaves}`;
    state._emitFunction("CloudBlockCode", functionString, "// CloudBlockCode");
    state._emitFunction("CloudBlockCodeFBM" + this.octaves, fractalBrownianString.replace(/fbm/gi, fbmNewName).replace(/OCTAVES/gi, (this.octaves | 0).toString()), "// CloudBlockCode FBM");
    const localVariable = state._getFreeVariableName("st");
    const seedType = this.seed.connectedPoint?.type || NodeMaterialBlockConnectionPointTypes.Vector3;
    state.compilationString += `${state._declareLocalVar(localVariable, seedType)} = ${this.seed.associatedVariableName};
`;
    if (this.offsetX.isConnected) {
      state.compilationString += `${localVariable}.x += 0.1 * ${this.offsetX.associatedVariableName};
`;
    }
    if (this.offsetY.isConnected) {
      state.compilationString += `${localVariable}.y += 0.1 * ${this.offsetY.associatedVariableName};
`;
    }
    if (this.offsetZ.isConnected && seedType === NodeMaterialBlockConnectionPointTypes.Vector3) {
      state.compilationString += `${localVariable}.z += 0.1 * ${this.offsetZ.associatedVariableName};
`;
    }
    let chaosValue = "";
    if (this.chaos.isConnected) {
      chaosValue = this.chaos.associatedVariableName;
    } else {
      const addF = state.fSuffix;
      chaosValue = this.seed.connectedPoint?.type === NodeMaterialBlockConnectionPointTypes.Vector2 ? `vec2${addF}(0., 0.)` : `vec3${addF}(0., 0., 0.)`;
    }
    state.compilationString += state._declareOutput(this._outputs[0]) + ` = ${fbmNewName}${this.seed.connectedPoint?.type === NodeMaterialBlockConnectionPointTypes.Vector2 ? "2" : "3"}(${localVariable}, ${chaosValue});
`;
    return this;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.octaves = ${this.octaves};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.octaves = this.octaves;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.octaves = serializationObject.octaves;
  }
};
__decorate([
  editableInPropertyPage("Octaves", 2, void 0, { embedded: true })
], CloudBlock.prototype, "octaves", void 0);
RegisterClass("BABYLON.CloudBlock", CloudBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/voronoiNoiseBlock.js
var VoronoiNoiseBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new VoronoiNoiseBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("seed", NodeMaterialBlockConnectionPointTypes.Vector2);
    this.registerInput("offset", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerInput("density", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
    this.registerOutput("cells", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "VoronoiNoiseBlock";
  }
  /**
   * Gets the seed input component
   */
  get seed() {
    return this._inputs[0];
  }
  /**
   * Gets the offset input component
   */
  get offset() {
    return this._inputs[1];
  }
  /**
   * Gets the density input component
   */
  get density() {
    return this._inputs[2];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the output component
   */
  get cells() {
    return this._outputs[1];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this.seed.isConnected) {
      return;
    }
    let functionString = `vec2 voronoiRandom(vec2 p){
            p = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));
            return fract(sin(p)*18.5453);
        }
        `;
    if (state.shaderLanguage === 1) {
      functionString = state._babylonSLtoWGSL(functionString);
    }
    state._emitFunction("voronoiRandom", functionString, "// Voronoi random generator");
    functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){
            vec2 n = floor(seed * density);
            vec2 f = fract(seed * density);
            vec3 m = vec3( 8.0 );
            for( int j=-1; j<=1; j++ ){
                for( int i=-1; i<=1; i++ ){
                    vec2  g = vec2( float(i), float(j) );
                    vec2  o = voronoiRandom( n + g);
                    vec2  r = g - f + (0.5+0.5*sin(offset+6.2831*o));
                    float d = dot( r, r );
                    if( d<m.x ){
                        m = vec3( d, o );
                        outValue = m.x;
                        cells = m.y;
                    }
                }
			}
        }
        `;
    if (state.shaderLanguage === 1) {
      functionString = state._babylonSLtoWGSL(functionString);
    } else {
      functionString = state._babylonSLtoGLSL(functionString);
    }
    state._emitFunction("voronoi", functionString, "// Voronoi");
    const tempOutput = state._getFreeVariableName("tempOutput");
    const tempCells = state._getFreeVariableName("tempCells");
    const ref = state.shaderLanguage === 1 ? "&" : "";
    state.compilationString += `${state._declareLocalVar(tempOutput, NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;
`;
    state.compilationString += `${state._declareLocalVar(tempCells, NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;
`;
    state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${ref}${tempOutput}, ${ref}${tempCells});
`;
    if (this.output.hasEndpoints) {
      state.compilationString += state._declareOutput(this.output) + ` = ${tempOutput};
`;
    }
    if (this.cells.hasEndpoints) {
      state.compilationString += state._declareOutput(this.cells) + ` = ${tempCells};
`;
    }
    return this;
  }
};
RegisterClass("BABYLON.VoronoiNoiseBlock", VoronoiNoiseBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/elbowBlock.js
var ElbowBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new ElbowBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ElbowBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets or sets the target of the block
   */
  get target() {
    const input = this._inputs[0];
    if (input.isConnected) {
      const block = input.connectedPoint.ownerBlock;
      if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return block.target;
      }
      if (input.connectedPoint.target !== NodeMaterialBlockTargets.VertexAndFragment) {
        return input.connectedPoint.target;
      }
    }
    return this._target;
  }
  set target(value) {
    if ((this._target & value) !== 0) {
      return;
    }
    this._target = value;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const input = this._inputs[0];
    state.compilationString += state._declareOutput(output) + ` = ${input.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.ElbowBlock", ElbowBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/triPlanarBlock.js
var TriPlanarBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets the texture associated with the node
   */
  get texture() {
    if (this.source.isConnected) {
      return (this.source.connectedPoint?.ownerBlock).texture;
    }
    return this._texture;
  }
  set texture(texture) {
    if (this._texture === texture) {
      return;
    }
    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;
    if (!texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this._texture);
      });
    }
    this._texture = texture;
    if (texture && scene) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(texture);
      });
    }
  }
  /**
   * Gets the textureY associated with the node
   */
  get textureY() {
    if (this.sourceY.isConnected) {
      return (this.sourceY.connectedPoint?.ownerBlock).texture;
    }
    return null;
  }
  /**
   * Gets the textureZ associated with the node
   */
  get textureZ() {
    if (this.sourceZ?.isConnected) {
      return (this.sourceY.connectedPoint?.ownerBlock).texture;
    }
    return null;
  }
  _getImageSourceBlock(connectionPoint) {
    return connectionPoint?.isConnected ? connectionPoint.connectedPoint.ownerBlock : null;
  }
  /**
   * Gets the sampler name associated with this texture
   */
  get samplerName() {
    const imageSourceBlock = this._getImageSourceBlock(this.source);
    if (imageSourceBlock) {
      return imageSourceBlock.samplerName;
    }
    return this._samplerName;
  }
  /**
   * Gets the samplerY name associated with this texture
   */
  get samplerYName() {
    return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;
  }
  /**
   * Gets the samplerZ name associated with this texture
   */
  get samplerZName() {
    return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;
  }
  /**
   * Gets a boolean indicating that this block is linked to an ImageSourceBlock
   */
  get hasImageSource() {
    return this.source.isConnected;
  }
  /**
   * Gets or sets a boolean indicating if content needs to be converted to gamma space
   */
  set convertToGammaSpace(value) {
    if (value === this._convertToGammaSpace) {
      return;
    }
    this._convertToGammaSpace = value;
    if (this.texture) {
      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;
      scene?.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToGammaSpace() {
    return this._convertToGammaSpace;
  }
  /**
   * Gets or sets a boolean indicating if content needs to be converted to linear space
   */
  set convertToLinearSpace(value) {
    if (value === this._convertToLinearSpace) {
      return;
    }
    this._convertToLinearSpace = value;
    if (this.texture) {
      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;
      scene?.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this.texture);
      });
    }
  }
  get convertToLinearSpace() {
    return this._convertToLinearSpace;
  }
  /**
   * Create a new TriPlanarBlock
   * @param name defines the block name
   * @param hideSourceZ defines a boolean indicating that normal Z should not be used (false by default)
   */
  constructor(name6, hideSourceZ = false) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.projectAsCube = false;
    this._convertToGammaSpace = false;
    this._convertToLinearSpace = false;
    this.disableLevelMultiplication = false;
    this.registerInput("position", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);
    this.registerInput("sharpness", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerInput("source", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("source", this, 0, ImageSourceBlock, "ImageSourceBlock"));
    this.registerInput("sourceY", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("sourceY", this, 0, ImageSourceBlock, "ImageSourceBlock"));
    if (!hideSourceZ) {
      this.registerInput("sourceZ", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject("sourceZ", this, 0, ImageSourceBlock, "ImageSourceBlock"));
    }
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this.registerOutput("level", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "TriPlanarBlock";
  }
  /**
   * Gets the position input component
   */
  get position() {
    return this._inputs[0];
  }
  /**
   * Gets the normal input component
   */
  get normal() {
    return this._inputs[1];
  }
  /**
   * Gets the sharpness input component
   */
  get sharpness() {
    return this._inputs[2];
  }
  /**
   * Gets the source input component
   */
  get source() {
    return this._inputs[3];
  }
  /**
   * Gets the sourceY input component
   */
  get sourceY() {
    return this._inputs[4];
  }
  /**
   * Gets the sourceZ input component
   */
  get sourceZ() {
    return this._inputs[5];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the r output component
   */
  get r() {
    return this._outputs[2];
  }
  /**
   * Gets the g output component
   */
  get g() {
    return this._outputs[3];
  }
  /**
   * Gets the b output component
   */
  get b() {
    return this._outputs[4];
  }
  /**
   * Gets the a output component
   */
  get a() {
    return this._outputs[5];
  }
  /**
   * Gets the level output component
   */
  get level() {
    return this._outputs[6];
  }
  prepareDefines(defines) {
    if (!defines._areTexturesDirty) {
      return;
    }
    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;
    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;
    defines.setValue(this._linearDefineName, toGamma, true);
    defines.setValue(this._gammaDefineName, toLinear, true);
  }
  isReady() {
    if (this.texture && !this.texture.isReadyOrNotBlocking()) {
      return false;
    }
    return true;
  }
  bind(effect) {
    if (!this.texture) {
      return;
    }
    effect.setFloat(this._textureInfoName, this.texture.level);
    if (!this._imageSource) {
      effect.setTexture(this._samplerName, this.texture);
    }
  }
  _samplerFunc(state) {
    if (state.shaderLanguage === 1) {
      return "textureSample";
    }
    return "texture2D";
  }
  _generateTextureSample(textureName, uv, state) {
    if (state.shaderLanguage === 1) {
      return `${this._samplerFunc(state)}(${textureName},${textureName + `Sampler`}, ${uv})`;
    }
    return `${this._samplerFunc(state)}(${textureName}, ${uv})`;
  }
  _generateTextureLookup(state) {
    const samplerName = this.samplerName;
    const samplerYName = this.samplerYName ?? samplerName;
    const samplerZName = this.samplerZName ?? samplerName;
    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : "1.0";
    const x = state._getFreeVariableName("x");
    const y = state._getFreeVariableName("y");
    const z = state._getFreeVariableName("z");
    const w = state._getFreeVariableName("w");
    const n = state._getFreeVariableName("n");
    const uvx = state._getFreeVariableName("uvx");
    const uvy = state._getFreeVariableName("uvy");
    const uvz = state._getFreeVariableName("uvz");
    state.compilationString += `
            ${state._declareLocalVar(n, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.normal.associatedVariableName}.xyz;

            ${state._declareLocalVar(uvx, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.yz;
            ${state._declareLocalVar(uvy, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.zx;
            ${state._declareLocalVar(uvz, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.xy;
        `;
    if (this.projectAsCube) {
      state.compilationString += `
                ${uvx}.xy = ${uvx}.yx;

                if (${n}.x >= 0.0) {
                    ${uvx}.x = -${uvx}.x;
                }
                if (${n}.y < 0.0) {
                    ${uvy}.y = -${uvy}.y;
                }
                if (${n}.z < 0.0) {
                    ${uvz}.x = -${uvz}.x;
                }
            `;
    }
    const suffix = state.fSuffix;
    state.compilationString += `
            ${state._declareLocalVar(x, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerName, uvx, state)};
            ${state._declareLocalVar(y, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerYName, uvy, state)};
            ${state._declareLocalVar(z, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerZName, uvz, state)};
           
            // blend weights
            ${state._declareLocalVar(w, NodeMaterialBlockConnectionPointTypes.Vector3)} = pow(abs(${n}), vec3${suffix}(${sharpness}));

            // blend and return
            ${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        
        `;
  }
  _generateConversionCode(state, output, swizzle) {
    let vecSpecifier = "";
    if (state.shaderLanguage === 1 && (output.type === NodeMaterialBlockConnectionPointTypes.Vector3 || output.type === NodeMaterialBlockConnectionPointTypes.Color3)) {
      vecSpecifier = "Vec3";
    }
    if (swizzle !== "a") {
      if (!this.texture || !this.texture.gammaSpace) {
        state.compilationString += `#ifdef ${this._linearDefineName}
                    ${output.associatedVariableName} = toGammaSpace${vecSpecifier}(${output.associatedVariableName});
                    #endif
                `;
      }
      state.compilationString += `#ifdef ${this._gammaDefineName}
                ${output.associatedVariableName} = toLinearSpace${vecSpecifier}(${output.associatedVariableName});
                #endif
            `;
    }
  }
  _writeOutput(state, output, swizzle) {
    let complement = "";
    if (!this.disableLevelMultiplication) {
      complement = ` * ${state.shaderLanguage === 1 ? "uniforms." : ""}${this._textureInfoName}`;
    }
    state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle}${complement};
`;
    this._generateConversionCode(state, output, swizzle);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (this.source.isConnected) {
      this._imageSource = this.source.connectedPoint.ownerBlock;
    } else {
      this._imageSource = null;
    }
    this._textureInfoName = state._getFreeVariableName("textureInfoName");
    this.level.associatedVariableName = (state.shaderLanguage === 1 ? "uniforms." : "") + this._textureInfoName;
    this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
    this._linearDefineName = state._getFreeDefineName("ISLINEAR");
    this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
    if (!this._imageSource) {
      this._samplerName = state._getFreeVariableName(this.name + "Texture");
      state._emit2DSampler(this._samplerName);
    }
    state.sharedData.blockingBlocks.push(this);
    state.sharedData.textureBlocks.push(this);
    state.sharedData.blocksWithDefines.push(this);
    state.sharedData.bindableBlocks.push(this);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitUniformFromString(this._textureInfoName, NodeMaterialBlockConnectionPointTypes.Float);
    this._generateTextureLookup(state);
    for (const output of this._outputs) {
      if (output.hasEndpoints && output.name !== "level") {
        this._writeOutput(state, output, output.name);
      }
    }
    return this;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};
`;
    codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};
`;
    if (!this.texture) {
      return codeString;
    }
    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`;
    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`;
    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`;
    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`;
    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`;
    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`;
    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`;
    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`;
    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`;
    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`;
    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`;
    return codeString;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.convertToGammaSpace = this.convertToGammaSpace;
    serializationObject.convertToLinearSpace = this.convertToLinearSpace;
    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;
    serializationObject.projectAsCube = this.projectAsCube;
    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== "VideoTexture") {
      serializationObject.texture = this.texture.serialize();
    }
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.convertToGammaSpace = serializationObject.convertToGammaSpace;
    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;
    this.projectAsCube = !!serializationObject.projectAsCube;
    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== void 0) {
      rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
    }
  }
};
__decorate([
  editableInPropertyPage("Project as cube", 0, "ADVANCED", { embedded: true, notifiers: { update: true } })
], TriPlanarBlock.prototype, "projectAsCube", void 0);
RegisterClass("BABYLON.TriPlanarBlock", TriPlanarBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/biPlanarBlock.js
var BiPlanarBlock = class extends TriPlanarBlock {
  /**
   * Create a new BiPlanarBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, true);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "BiPlanarBlock";
  }
  _declareLocalVarAsVec3I(name6, state) {
    if (state.shaderLanguage === 1) {
      return `var ${name6}: vec3<i32>`;
    } else {
      return `ivec3 ${name6}`;
    }
  }
  _getTextureGrad(state, samplerName) {
    if (state.shaderLanguage === 1) {
      return `textureSampleGrad(${samplerName},${samplerName + `Sampler`}`;
    }
    return `textureGrad(${samplerName}`;
  }
  _generateTextureLookup(state) {
    const samplerName = this.samplerName;
    const samplerYName = this.samplerYName ?? this.samplerName;
    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : "1.0";
    const dpdx = state._getFreeVariableName("dxValue");
    const dpdy = state._getFreeVariableName("dyValue");
    const n = state._getFreeVariableName("n");
    const ma = state._getFreeVariableName("ma");
    const mi = state._getFreeVariableName("mi");
    const me = state._getFreeVariableName("me");
    const x = state._getFreeVariableName("x");
    const y = state._getFreeVariableName("y");
    const w = state._getFreeVariableName("w");
    let ivec3 = "ivec3";
    let dpdxFunc = "dFdx";
    let dpdyFunc = "dFdy";
    const suffix = state.fSuffix;
    if (state.shaderLanguage === 1) {
      ivec3 = "vec3<i32>";
      dpdxFunc = "dpdx";
      dpdyFunc = "dpdy";
    }
    state.compilationString += `
            // grab coord derivatives for texturing
            ${state._declareLocalVar(dpdx, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${dpdxFunc}(${this.position.associatedVariableName}.xyz);
            ${state._declareLocalVar(dpdy, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${dpdyFunc}(${this.position.associatedVariableName}.xyz);
            ${state._declareLocalVar(n, NodeMaterialBlockConnectionPointTypes.Vector3)} = abs(${this.normal.associatedVariableName}.xyz);
        
            // determine major axis (in x; yz are following axis)
            ${this._declareLocalVarAsVec3I(ma, state)} = ${state._generateTernary(`${ivec3}(0,1,2)`, `${state._generateTernary(`${ivec3}(1,2,0)`, `${ivec3}(2,0,1)`, `(${n}.y>${n}.z)`)}`, `(${n}.x>${n}.y && ${n}.x>${n}.z)`)};                    

            // determine minor axis (in x; yz are following axis)
            ${this._declareLocalVarAsVec3I(mi, state)} =  ${state._generateTernary(`${ivec3}(0,1,2)`, `${state._generateTernary(`${ivec3}(1,2,0)`, `${ivec3}(2,0,1)`, `(${n}.y<${n}.z)`)}`, `(${n}.x<${n}.y && ${n}.x<${n}.z)`)};  
                              
            // determine median axis (in x;  yz are following axis)
            ${this._declareLocalVarAsVec3I(me, state)} = ${ivec3}(3) - ${mi} - ${ma};
            
            // project+fetch
            ${state._declareLocalVar(x, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._getTextureGrad(state, samplerName)}, vec2${suffix}(${this.position.associatedVariableName}[${ma}.y], ${this.position.associatedVariableName}[${ma}.z]), 
                                    vec2${suffix}(${dpdx}[${ma}.y],${dpdx}[${ma}.z]), 
                                    vec2${suffix}(${dpdy}[${ma}.y],${dpdy}[${ma}.z]));
            ${state._declareLocalVar(y, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._getTextureGrad(state, samplerYName)}, vec2${suffix}(${this.position.associatedVariableName}[${me}.y], ${this.position.associatedVariableName}[${me}.z]), 
                                    vec2${suffix}(${dpdx}[${me}.y],${dpdx}[${me}.z]),
                                    vec2${suffix}(${dpdy}[${me}.y],${dpdy}[${me}.z]));
            
            // blend factors
            ${state._declareLocalVar(w, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${suffix}(${n}[${ma}.x],${n}[${me}.x]);
            // make local support
            ${w} = clamp( (${w}-0.5773)/(1.0-0.5773), vec2${suffix}(0.0), vec2${suffix}(1.0) );
            // shape transition
            ${w} = pow( ${w}, vec2${suffix}(${sharpness}/8.0) );
            // blend and return
            ${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = (${x}*${w}.x + ${y}*${w}.y) / (${w}.x + ${w}.y);
        `;
  }
};
RegisterClass("BABYLON.BiPlanarBlock", BiPlanarBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixDeterminantBlock.js
var MatrixDeterminantBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MatrixDeterminantBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Float);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MatrixDeterminantBlock";
  }
  /**
   * Gets the input matrix
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this.output;
    const input = this.input;
    state.compilationString += state._declareOutput(output) + ` = determinant(${input.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixDeterminantBlock", MatrixDeterminantBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixTransposeBlock.js
var MatrixTransposeBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MatrixTransposeBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MatrixTransposeBlock";
  }
  /**
   * Gets the input matrix
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this.output;
    const input = this.input;
    state.compilationString += state._declareOutput(output) + ` = transpose(${input.associatedVariableName});
`;
    return this;
  }
};
RegisterClass("BABYLON.MatrixTransposeBlock", MatrixTransposeBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/meshAttributeExistsBlock.js
var MeshAttributeExistsBlockTypes;
(function(MeshAttributeExistsBlockTypes2) {
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["None"] = 0] = "None";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["Normal"] = 1] = "Normal";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["Tangent"] = 2] = "Tangent";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["VertexColor"] = 3] = "VertexColor";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV1"] = 4] = "UV1";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV2"] = 5] = "UV2";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV3"] = 6] = "UV3";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV4"] = 7] = "UV4";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV5"] = 8] = "UV5";
  MeshAttributeExistsBlockTypes2[MeshAttributeExistsBlockTypes2["UV6"] = 9] = "UV6";
})(MeshAttributeExistsBlockTypes || (MeshAttributeExistsBlockTypes = {}));
var MeshAttributeExistsBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MeshAttributeExistsBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.attributeType = 0;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("fallback", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._linkConnectionTypes(0, 1);
    this._inputs[0].onConnectionObservable.add((other) => {
      if (this.attributeType) {
        return;
      }
      const sourceBlock = other.ownerBlock;
      if (sourceBlock instanceof InputBlock && sourceBlock.isAttribute) {
        switch (sourceBlock.name) {
          case "color":
            this.attributeType = 3;
            break;
          case "normal":
            this.attributeType = 1;
            break;
          case "tangent":
            this.attributeType = 2;
            break;
          case "uv":
            this.attributeType = 4;
            break;
          case "uv2":
            this.attributeType = 5;
            break;
          case "uv3":
            this.attributeType = 6;
            break;
          case "uv4":
            this.attributeType = 7;
            break;
          case "uv5":
            this.attributeType = 8;
            break;
          case "uv6":
            this.attributeType = 9;
            break;
        }
      } else if (sourceBlock instanceof MorphTargetsBlock) {
        switch (this.input.connectedPoint?.name) {
          case "normalOutput":
            this.attributeType = 1;
            break;
          case "tangentOutput":
            this.attributeType = 2;
            break;
          case "uvOutput":
            this.attributeType = 4;
            break;
          case "uv2Output":
            this.attributeType = 5;
            break;
        }
      }
    });
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MeshAttributeExistsBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the fallback component when speciefied attribute doesn't exist
   */
  get fallback() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    let attributeDefine2 = null;
    switch (this.attributeType) {
      case 3:
        attributeDefine2 = "VERTEXCOLOR_NME";
        break;
      case 1:
        attributeDefine2 = "NORMAL";
        break;
      case 2:
        attributeDefine2 = "TANGENT";
        break;
      case 4:
        attributeDefine2 = "UV1";
        break;
      case 5:
        attributeDefine2 = "UV2";
        break;
      case 6:
        attributeDefine2 = "UV3";
        break;
      case 7:
        attributeDefine2 = "UV4";
        break;
      case 8:
        attributeDefine2 = "UV5";
        break;
      case 9:
        attributeDefine2 = "UV6";
        break;
    }
    const output = state._declareOutput(this.output);
    if (attributeDefine2) {
      state.compilationString += `#ifdef ${attributeDefine2}
`;
    }
    state.compilationString += `${output} = ${this.input.associatedVariableName};
`;
    if (attributeDefine2) {
      state.compilationString += `#else
`;
      state.compilationString += `${output} = ${this.fallback.associatedVariableName};
`;
      state.compilationString += `#endif
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.attributeType = this.attributeType;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.attributeType = serializationObject.attributeType ?? 0;
  }
  _dumpPropertiesCode() {
    let codeString = super._dumpPropertiesCode();
    codeString += `${this._codeVariableName}.attributeType = ${this.attributeType};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Attribute lookup", 5, void 0, {
    notifiers: { update: true },
    embedded: true,
    options: [
      {
        label: "(None)",
        value: 0
        /* MeshAttributeExistsBlockTypes.None */
      },
      {
        label: "Normal",
        value: 1
        /* MeshAttributeExistsBlockTypes.Normal */
      },
      {
        label: "Tangent",
        value: 2
        /* MeshAttributeExistsBlockTypes.Tangent */
      },
      {
        label: "Vertex Color",
        value: 3
        /* MeshAttributeExistsBlockTypes.VertexColor */
      },
      {
        label: "UV1",
        value: 4
        /* MeshAttributeExistsBlockTypes.UV1 */
      },
      {
        label: "UV2",
        value: 5
        /* MeshAttributeExistsBlockTypes.UV2 */
      },
      {
        label: "UV3",
        value: 6
        /* MeshAttributeExistsBlockTypes.UV3 */
      },
      {
        label: "UV4",
        value: 7
        /* MeshAttributeExistsBlockTypes.UV4 */
      },
      {
        label: "UV5",
        value: 8
        /* MeshAttributeExistsBlockTypes.UV5 */
      },
      {
        label: "UV6",
        value: 9
        /* MeshAttributeExistsBlockTypes.UV6 */
      }
    ]
  })
], MeshAttributeExistsBlock.prototype, "attributeType", void 0);
RegisterClass("BABYLON.MeshAttributeExistsBlock", MeshAttributeExistsBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/curveBlock.js
var CurveBlockTypes;
(function(CurveBlockTypes2) {
  CurveBlockTypes2[CurveBlockTypes2["EaseInSine"] = 0] = "EaseInSine";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutSine"] = 1] = "EaseOutSine";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutSine"] = 2] = "EaseInOutSine";
  CurveBlockTypes2[CurveBlockTypes2["EaseInQuad"] = 3] = "EaseInQuad";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutQuad"] = 4] = "EaseOutQuad";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutQuad"] = 5] = "EaseInOutQuad";
  CurveBlockTypes2[CurveBlockTypes2["EaseInCubic"] = 6] = "EaseInCubic";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutCubic"] = 7] = "EaseOutCubic";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutCubic"] = 8] = "EaseInOutCubic";
  CurveBlockTypes2[CurveBlockTypes2["EaseInQuart"] = 9] = "EaseInQuart";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutQuart"] = 10] = "EaseOutQuart";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutQuart"] = 11] = "EaseInOutQuart";
  CurveBlockTypes2[CurveBlockTypes2["EaseInQuint"] = 12] = "EaseInQuint";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutQuint"] = 13] = "EaseOutQuint";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutQuint"] = 14] = "EaseInOutQuint";
  CurveBlockTypes2[CurveBlockTypes2["EaseInExpo"] = 15] = "EaseInExpo";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutExpo"] = 16] = "EaseOutExpo";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutExpo"] = 17] = "EaseInOutExpo";
  CurveBlockTypes2[CurveBlockTypes2["EaseInCirc"] = 18] = "EaseInCirc";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutCirc"] = 19] = "EaseOutCirc";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutCirc"] = 20] = "EaseInOutCirc";
  CurveBlockTypes2[CurveBlockTypes2["EaseInBack"] = 21] = "EaseInBack";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutBack"] = 22] = "EaseOutBack";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutBack"] = 23] = "EaseInOutBack";
  CurveBlockTypes2[CurveBlockTypes2["EaseInElastic"] = 24] = "EaseInElastic";
  CurveBlockTypes2[CurveBlockTypes2["EaseOutElastic"] = 25] = "EaseOutElastic";
  CurveBlockTypes2[CurveBlockTypes2["EaseInOutElastic"] = 26] = "EaseInOutElastic";
})(CurveBlockTypes || (CurveBlockTypes = {}));
var CurveBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new CurveBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.type = CurveBlockTypes.EaseInOutSine;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Object);
    this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Int);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "CurveBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  _duplicateEntry(entry, component) {
    return `ret.${component} = ${entry.replace(/VAL/g, "v." + component)}`;
  }
  _duplicateEntryDirect(entry) {
    return `return ${entry.replace(/VAL/g, "v")}`;
  }
  _duplicateVector(entry, inputType, isWGSL) {
    if (inputType === "float" || inputType === "f32") {
      return this._duplicateEntryDirect(entry);
    }
    const size = parseInt(inputType.replace("vec", ""));
    let code = isWGSL ? `
            var ret: vec${size}f = vec${size}f(0.0);
        ` : `
            vec${size} ret = vec${size}(0.0);
        `;
    for (let i = 1; i <= size; i++) {
      code += this._duplicateEntry(entry, i === 1 ? "x" : i === 2 ? "y" : i === 3 ? "z" : "w") + ";\n";
    }
    code += "return ret;\n";
    return code;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    let registeredFunction = "";
    let registeredFunctionName = "";
    const inputType = state._getShaderType(this.input.type);
    const isWGSL = state.shaderLanguage === 1;
    registeredFunctionName = CurveBlockTypes[this.type] + "_" + inputType.replace("<", "").replace(">", "");
    switch (this.type) {
      case CurveBlockTypes.EaseInSine:
        registeredFunction = `return 1.0 - cos((v * 3.1415) / 2.0)`;
        break;
      case CurveBlockTypes.EaseOutSine:
        registeredFunction = `return sin((v * 3.1415) / 2.0)`;
        break;
      case CurveBlockTypes.EaseInOutSine:
        registeredFunction = `return -(cos(v * 3.1415) - 1.0) / 2.0`;
        break;
      case CurveBlockTypes.EaseInQuad:
        registeredFunction = `return v * v`;
        break;
      case CurveBlockTypes.EaseOutQuad:
        registeredFunction = `return (1.0 - v) * (1.0 - v)`;
        break;
      case CurveBlockTypes.EaseInOutQuad: {
        const entry = state._generateTernary("2.0 * VAL * VAL", "1.0 - pow(-2.0 * VAL + 2.0, 2.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInCubic:
        registeredFunction = `return v * v * v`;
        break;
      case CurveBlockTypes.EaseOutCubic: {
        const entry = "1.0 - pow(1.0 - VAL, 3.0)";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutCubic: {
        const entry = state._generateTernary("4.0 * VAL * VAL * VAL", "1.0 - pow(-2.0 * VAL + 2.0, 3.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInQuart:
        registeredFunction = `return v * v * v * v`;
        break;
      case CurveBlockTypes.EaseOutQuart: {
        const entry = "1.0 - pow(1.0 - VAL, 4.0)";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutQuart: {
        const entry = state._generateTernary("8.0 * VAL * VAL * VAL * VAL", "1.0 - pow(-2.0 * VAL + 2.0, 4.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInQuint:
        registeredFunction = `return v * v * v * v * v`;
        break;
      case CurveBlockTypes.EaseOutQuint: {
        const entry = "1.0 - pow(1.0 - VAL, 5.0)";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutQuint: {
        const entry = state._generateTernary("16.0 * VAL * VAL * VAL * VAL * VAL", "1.0 - pow(-2.0 * VAL + 2.0, 5.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInExpo: {
        const entry = state._generateTernary("0.0", "pow(2.0, 10.0 * VAL - 10.0)", "VAL == 0.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseOutExpo: {
        const entry = state._generateTernary("1.0", "1.0 - pow(2.0, -10.0 * VAL)", "VAL == 1.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutExpo: {
        const entry = state._generateTernary("0.0", state._generateTernary("1.0", state._generateTernary("pow(2.0, 20.0 * VAL - 10.0) / 2.0", "(2.0 - pow(2.0, -20.0 * VAL + 10.0)) / 2.0", "VAL < 0.5"), "VAL == 1.0"), "VAL == 0.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInCirc: {
        const entry = "1.0 - sqrt(1.0 - pow(VAL, 2.0))";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseOutCirc: {
        const entry = "sqrt(1.0 - pow(VAL - 1.0, 2.0))";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutCirc: {
        const entry = state._generateTernary("(1.0 - sqrt(1.0 - pow(2.0 * VAL, 2.0))) / 2.0", "(sqrt(1.0 - pow(-2.0 * VAL + 2.0, 2.0)) + 1.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInBack: {
        registeredFunction = "return 2.70158 * v * v * v - 1.70158 * v * v";
        break;
      }
      case CurveBlockTypes.EaseOutBack: {
        const entry = "2.70158 * pow(VAL - 1.0, 3.0) + 1.70158 * pow(VAL - 1.0, 2.0)";
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutBack: {
        const entry = state._generateTernary("(pow(2.0 * VAL, 2.0) * ((3.5949095) * 2.0 * VAL - 2.5949095)) / 2.0", "(pow(2.0 * VAL - 2.0, 2.0) * (3.5949095 * (VAL * 2.0 - 2.0) + 3.5949095) + 2.0) / 2.0", "VAL < 0.5");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInElastic: {
        const entry = state._generateTernary("0.0", state._generateTernary("1.0", "-pow(2.0, 10.0 * VAL - 10.0) * sin((VAL * 10.0 - 10.75) * ((2.0 * 3.1415) / 3.0))", "VAL == 1.0"), "VAL == 0.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseOutElastic: {
        const entry = state._generateTernary("0.0", state._generateTernary("1.0", "pow(2.0, -10.0 * VAL) * sin((VAL * 10.0 - 0.75) * ((2.0 * 3.1415) / 3.0)) + 1.0", "VAL == 1.0"), "VAL == 0.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
      case CurveBlockTypes.EaseInOutElastic: {
        const entry = state._generateTernary("0.0", state._generateTernary("1.0", state._generateTernary("-(pow(2.0, 20.0 * VAL - 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0", "(pow(2.0, -20.0 * VAL + 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0 + 1.0", "VAL < 0.5"), "VAL == 1.0"), "VAL == 0.0");
        registeredFunction = this._duplicateVector(entry, inputType, isWGSL);
        break;
      }
    }
    if (isWGSL) {
      state._emitFunction(registeredFunctionName, `fn ${registeredFunctionName}(v: ${inputType}) -> ${inputType}  {${registeredFunction};}
`, "");
    } else {
      state._emitFunction(registeredFunctionName, `${inputType} ${registeredFunctionName}(${inputType} v) {${registeredFunction};}
`, "");
    }
    state.compilationString += state._declareOutput(output) + ` = ${registeredFunctionName}(${this.input.associatedVariableName});
`;
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.curveType = this.type;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.type = serializationObject.curveType;
  }
  _dumpPropertiesCode() {
    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.type = BABYLON.CurveBlockTypes.${CurveBlockTypes[this.type]};
`;
    return codeString;
  }
};
__decorate([
  editableInPropertyPage("Type", 5, "ADVANCED", {
    notifiers: { rebuild: true },
    embedded: true,
    options: [
      { label: "EaseInSine", value: CurveBlockTypes.EaseInSine },
      { label: "EaseOutSine", value: CurveBlockTypes.EaseOutSine },
      { label: "EaseInOutSine", value: CurveBlockTypes.EaseInOutSine },
      { label: "EaseInQuad", value: CurveBlockTypes.EaseInQuad },
      { label: "EaseOutQuad", value: CurveBlockTypes.EaseOutQuad },
      { label: "EaseInOutQuad", value: CurveBlockTypes.EaseInOutQuad },
      { label: "EaseInCubic", value: CurveBlockTypes.EaseInCubic },
      { label: "EaseOutCubic", value: CurveBlockTypes.EaseOutCubic },
      { label: "EaseInOutCubic", value: CurveBlockTypes.EaseInOutCubic },
      { label: "EaseInQuart", value: CurveBlockTypes.EaseInQuart },
      { label: "EaseOutQuart", value: CurveBlockTypes.EaseOutQuart },
      { label: "EaseInOutQuart", value: CurveBlockTypes.EaseInOutQuart },
      { label: "EaseInQuint", value: CurveBlockTypes.EaseInQuint },
      { label: "EaseOutQuint", value: CurveBlockTypes.EaseOutQuint },
      { label: "EaseInOutQuint", value: CurveBlockTypes.EaseInOutQuint },
      { label: "EaseInExpo", value: CurveBlockTypes.EaseInExpo },
      { label: "EaseOutExpo", value: CurveBlockTypes.EaseOutExpo },
      { label: "EaseInOutExpo", value: CurveBlockTypes.EaseInOutExpo },
      { label: "EaseInCirc", value: CurveBlockTypes.EaseInCirc },
      { label: "EaseOutCirc", value: CurveBlockTypes.EaseOutCirc },
      { label: "EaseInOutCirc", value: CurveBlockTypes.EaseInOutCirc },
      { label: "EaseInBack", value: CurveBlockTypes.EaseInBack },
      { label: "EaseOutBack", value: CurveBlockTypes.EaseOutBack },
      { label: "EaseInOutBack", value: CurveBlockTypes.EaseInOutBack },
      { label: "EaseInElastic", value: CurveBlockTypes.EaseInElastic },
      { label: "EaseOutElastic", value: CurveBlockTypes.EaseOutElastic },
      { label: "EaseInOutElastic", value: CurveBlockTypes.EaseInOutElastic }
    ]
  })
], CurveBlock.prototype, "type", void 0);
RegisterClass("BABYLON.CurveBlock", CurveBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorConverterBlock.js
var ColorConverterBlock = class extends NodeMaterialBlock {
  /**
   * Create a new ColorConverterBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerInput("hsl ", NodeMaterialBlockConnectionPointTypes.Color3, true);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
    this.registerOutput("hsl", NodeMaterialBlockConnectionPointTypes.Color3);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "ColorConverterBlock";
  }
  /**
   * Gets the rgb value (input)
   */
  get rgbIn() {
    return this._inputs[0];
  }
  /**
   * Gets the hsl value (input)
   */
  get hslIn() {
    return this._inputs[1];
  }
  /**
   * Gets the rgb value (output)
   */
  get rgbOut() {
    return this._outputs[0];
  }
  /**
   * Gets the hsl value (output)
   */
  get hslOut() {
    return this._outputs[1];
  }
  _inputRename(name6) {
    if (name6 === "rgb ") {
      return "rgbIn";
    }
    if (name6 === "hsl ") {
      return "hslIn";
    }
    return name6;
  }
  _outputRename(name6) {
    if (name6 === "rgb") {
      return "rgbOut";
    }
    if (name6 === "hsl") {
      return "hslOut";
    }
    return name6;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const rgbInput = this.rgbIn;
    const hslInput = this.hslIn;
    const rbgOutput = this._outputs[0];
    const hslOutput = this._outputs[1];
    const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
    let rgb2hsl = `
            vec3 rgb2hsl(vec3 color) {
                float r = color.r;
                float g = color.g;
                float b = color.b;

                float maxc = max(r, max(g, b));
                float minc = min(r, min(g, b));
                float h = 0.0;
                float s = 0.0;
                float l = (maxc + minc) / 2.0;

                if (maxc != minc) {
                    float d = maxc - minc;
                    if (l > 0.5) {
                        s = d / (2.0 - maxc - minc);
                    } else {
                        s = d / (maxc + minc);
                    }

                    if (maxc == r) {
                        float add = 0.0;
                        if (g < b) {
                            add = 6.0;
                        }
                        h = (g - b) / d + add;
                    } else if (maxc == g) {
                        h = (b - r) / d + 2.0;
                    } else if (maxc == b) {
                        h = (r - g) / d + 4.0;
                    }
                    h /= 6.0;
                }

                return vec3(h, s, l);
            }`;
    let hue2rgb = `
            float hue2rgb(float p, float q, float tt) {
                float t = tt;
                if (t < 0.0) {
                    t += 1.0;
                }
                if (t > 1.0) {
                    t -= 1.0;
                }
                if (t < 1.0/6.0) {
                    return p + (q - p) * 6.0 * t;
                }
                if (t < 1.0/2.0) {
                    return q;
                }
                if (t < 2.0/3.0) {
                    return p + (q - p) * (2.0/3.0 - t) * 6.0;
                }
                return p;
            }`;
    let hsl2rgb = `
            vec3 hsl2rgb(vec3 hsl) {
                float h = hsl.x;
                float s = hsl.y;
                float l = hsl.z;

                float r;
                float g;
                float b;

                if (s == 0.0) {
                    // Achromatic (grey)
                    r = l;
                    g = l;
                    b = l; 
                } else {
                    float q;
                
                    if (l < 0.5) {
                        q = l * (1.0 + s);
                    } else {
                        q = (l + s - l * s);
                    }

                    float p = 2.0 * l - q;

                    r = hue2rgb(p, q, h + 1.0/3.0);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1.0/3.0);
                }

                return vec3(r, g, b);
            }`;
    if (state.shaderLanguage === 1) {
      rgb2hsl = state._babylonSLtoWGSL(rgb2hsl);
      hue2rgb = state._babylonSLtoWGSL(hue2rgb);
      hsl2rgb = state._babylonSLtoWGSL(hsl2rgb);
    }
    state._emitFunction("rgb2hsl", rgb2hsl, "");
    state._emitFunction("hue2rgb", hue2rgb, "");
    state._emitFunction("hsl2rgb", hsl2rgb, "");
    if (rgbInput.isConnected) {
      if (rbgOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(rbgOutput) + ` = ${rgbInput.associatedVariableName};
`;
      }
      if (hslOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(hslOutput) + ` = rgb2hsl(${rgbInput.associatedVariableName});
`;
      }
    } else if (hslInput.isConnected) {
      if (rbgOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(rbgOutput) + ` = hsl2rgb(${hslInput.associatedVariableName});
`;
      }
      if (hslOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(hslOutput) + ` = ${hslInput.associatedVariableName};
`;
      }
    } else {
      if (rbgOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(rbgOutput) + ` =  ${vec3}(0.);
`;
      }
      if (hslOutput.hasEndpoints) {
        state.compilationString += state._declareOutput(hslOutput) + ` =  ${vec3}(0.);
`;
      }
    }
    return this;
  }
};
RegisterClass("BABYLON.ColorConverterBlock", ColorConverterBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/loopBlock.js
var LoopBlock = class _LoopBlock extends NodeMaterialBlock {
  /**
   * Creates a new LoopBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.iterations = 4;
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this.registerInput("iterations", NodeMaterialBlockConnectionPointTypes.Float, true);
    this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
    this.registerOutput("index", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("loopID", NodeMaterialBlockConnectionPointTypes.Object, void 0, new NodeMaterialConnectionPointCustomObject("loopID", this, 1, _LoopBlock, "LoopBlock"));
    this._outputs[0]._typeConnectionSource = this._inputs[0];
    this._outputs[0]._forPostBuild = true;
    this._outputs[2]._redirectedSource = this._inputs[0];
    this._outputs[1]._preventBubbleUp = true;
    this._outputs[2]._preventBubbleUp = true;
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "LoopBlock";
  }
  /**
   * Gets the main input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the iterations input component
   */
  get iterationsInput() {
    return this._inputs[1];
  }
  /**
   * Gets the output component
   */
  get output() {
    return this._outputs[0];
  }
  /**
   * Gets the index component which will be incremented at each iteration
   */
  get index() {
    return this._outputs[1];
  }
  /**
   * Gets the loop ID component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get loopID() {
    return this._outputs[2];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const output = this._outputs[0];
    const index = this._outputs[1];
    const indexName = state._getFreeVariableName("index");
    const decl = state.shaderLanguage === 1 ? "var" : "int";
    const castFloat = state.shaderLanguage === 1 ? "f32" : "float";
    const castInt = state.shaderLanguage === 1 ? "i32" : "int";
    state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName};
`;
    const iterations = this.iterationsInput.isConnected ? `${castInt}(${this.iterationsInput.associatedVariableName})` : this.iterations;
    state.compilationString += `for (${decl} ${indexName} = 0; ${indexName} < ${iterations}; ${indexName}++){
`;
    state.compilationString += `${state._declareOutput(index)} = ${castFloat}(${indexName});
`;
    return this;
  }
  _postBuildBlock(state) {
    super._postBuildBlock(state);
    state.compilationString += `}
`;
    return this;
  }
  _dumpPropertiesCode() {
    return super._dumpPropertiesCode() + `${this._codeVariableName}.iterations = ${this.iterations};
`;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.iterations = this.iterations;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.iterations = serializationObject.iterations;
  }
};
__decorate([
  editableInPropertyPage("Iterations", 2, void 0, { embedded: true })
], LoopBlock.prototype, "iterations", void 0);
RegisterClass("BABYLON.LoopBlock", LoopBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/storageReadBlock.js
var StorageReadBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new StorageReadBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("loopID", NodeMaterialBlockConnectionPointTypes.Object, false, void 0, new NodeMaterialConnectionPointCustomObject("loopID", this, 0, LoopBlock, "LoopBlock"));
    this.registerOutput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this._outputs[0]._linkedConnectionSource = this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "StorageReadBlock";
  }
  /**
   * Gets the loop link component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get loopID() {
    return this._inputs[0];
  }
  /**
   * Gets the value component
   */
  get value() {
    return this._outputs[0];
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const value = this.value;
    if (!this.loopID.isConnected) {
      return this;
    }
    const loopBlock = this.loopID.connectedPoint.ownerBlock;
    state.compilationString += state._declareOutput(value) + ` = ${loopBlock.output.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.StorageReadBlock", StorageReadBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/storageWriteBlock.js
var StorageWriteBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new StorageWriteBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("loopID", NodeMaterialBlockConnectionPointTypes.Object, false, void 0, new NodeMaterialConnectionPointCustomObject("loopID", this, 0, LoopBlock, "LoopBlock"));
    this.registerInput("value", NodeMaterialBlockConnectionPointTypes.AutoDetect);
    this._linkConnectionTypes(0, 1);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "StorageWriteBlock";
  }
  /**
   * Gets the loop link component
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get loopID() {
    return this._inputs[0];
  }
  /**
   * Gets the value component
   */
  get value() {
    return this._inputs[1];
  }
  /** Gets a boolean indicating that this connection will be used in the fragment shader
   * @returns true if connected in fragment shader
   */
  isConnectedInFragmentShader() {
    if (!this.loopID.isConnected) {
      return false;
    }
    const loopBlock = this.loopID.connectedPoint.ownerBlock;
    return loopBlock.output.isConnectedInFragmentShader;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const value = this.value;
    if (!this.loopID.isConnected) {
      return this;
    }
    const loopBlock = this.loopID.connectedPoint.ownerBlock;
    state.compilationString += `${loopBlock.output.associatedVariableName} = ${value.associatedVariableName};
`;
    return this;
  }
};
RegisterClass("BABYLON.StorageWriteBlock", StorageWriteBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/matrixSplitterBlock.js
var MatrixSplitterBlock = class extends NodeMaterialBlock {
  /**
   * Creates a new MatrixSplitterBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Neutral);
    this.registerInput("input", NodeMaterialBlockConnectionPointTypes.Matrix);
    this.registerOutput("row0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("row1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("row2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("row3", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("col0", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("col1", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("col2", NodeMaterialBlockConnectionPointTypes.Vector4);
    this.registerOutput("col3", NodeMaterialBlockConnectionPointTypes.Vector4);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "MatrixSplitterBlock";
  }
  /**
   * Gets the input component
   */
  get input() {
    return this._inputs[0];
  }
  /**
   * Gets the row0 output vector
   */
  get row0() {
    return this._outputs[0];
  }
  /**
   * Gets the row1 output vector
   */
  get row1() {
    return this._outputs[1];
  }
  /**
   * Gets the row2 output vector
   */
  get row2() {
    return this._outputs[2];
  }
  /**
   * Gets the row3 output vector
   */
  get row3() {
    return this._outputs[3];
  }
  /**
   * Gets the col0 output vector
   */
  get col0() {
    return this._outputs[4];
  }
  /**
   * Gets the col1 output vector
   */
  get col1() {
    return this._outputs[5];
  }
  /**
   * Gets the col2 output vector
   */
  get col2() {
    return this._outputs[6];
  }
  /**
   * Gets the col3 output vector
   */
  get col3() {
    return this._outputs[7];
  }
  _exportColumn(state, col, input, columnIndex) {
    const vec4 = state.shaderLanguage === 1 ? "vec4f" : "vec4";
    state.compilationString += state._declareOutput(col) + ` = ${vec4}(${input}[0][${columnIndex}], ${input}[1][${columnIndex}], ${input}[2][${columnIndex}], ${input}[3][${columnIndex}]);
`;
  }
  _buildBlock(state) {
    super._buildBlock(state);
    const input = this._inputs[0].associatedVariableName;
    const row0 = this.row0;
    const row1 = this.row1;
    const row2 = this.row2;
    const row3 = this.row3;
    const col0 = this.col0;
    const col1 = this.col1;
    const col2 = this.col2;
    const col3 = this.col3;
    if (row0.hasEndpoints) {
      state.compilationString += state._declareOutput(row0) + ` = ${input}[0];
`;
    }
    if (row1.hasEndpoints) {
      state.compilationString += state._declareOutput(row1) + ` = ${input}[1];
`;
    }
    if (row2.hasEndpoints) {
      state.compilationString += state._declareOutput(row2) + ` = ${input}[2];
`;
    }
    if (row3.hasEndpoints) {
      state.compilationString += state._declareOutput(row3) + ` = ${input}[3];
`;
    }
    if (col0.hasEndpoints) {
      this._exportColumn(state, col0, input, 0);
    }
    if (col1.hasEndpoints) {
      this._exportColumn(state, col1, input, 1);
    }
    if (col2.hasEndpoints) {
      this._exportColumn(state, col2, input, 2);
    }
    if (col3.hasEndpoints) {
      this._exportColumn(state, col3, input, 3);
    }
    return this;
  }
};
RegisterClass("BABYLON.MatrixSplitterBlock", MatrixSplitterBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/GaussianSplatting/gaussianSplattingBlock.js
var GaussianSplattingBlock = class extends NodeMaterialBlock {
  /**
   * Create a new GaussianSplattingBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this._isUnique = true;
    this.registerInput("splatPosition", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("splatScale", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Vertex);
    this.registerInput("world", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("view", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerInput("projection", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("splatVertex", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("SH", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Vertex);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GaussianSplattingBlock";
  }
  /**
   * Gets the position input component
   */
  get splatPosition() {
    return this._inputs[0];
  }
  /**
   * Gets the scale input component
   */
  get splatScale() {
    return this._inputs[1];
  }
  /**
   * Gets the View matrix input component
   */
  get world() {
    return this._inputs[2];
  }
  /**
   * Gets the View matrix input component
   */
  get view() {
    return this._inputs[3];
  }
  /**
   * Gets the projection matrix input component
   */
  get projection() {
    return this._inputs[4];
  }
  /**
   * Gets the splatVertex output component
   */
  get splatVertex() {
    return this._outputs[0];
  }
  /**
   * Gets the SH output contribution
   */
  get SH() {
    return this._outputs[1];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("focal");
    state._excludeVariableName("invViewport");
    state._excludeVariableName("kernelSize");
    state._excludeVariableName("eyePosition");
  }
  /**
   * Update defines for shader compilation
   * @param defines defines the material defines to update
   * @param nodeMaterial defines the node material requesting the update
   * @param mesh defines the mesh to be rendered
   */
  prepareDefines(defines, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    if (mesh.getClassName() == "GaussianSplattingMesh") {
      defines.setValue("SH_DEGREE", mesh.shDegree, true);
    }
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      return;
    }
    state.sharedData.blocksWithDefines.push(this);
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("gaussianSplattingVertexDeclaration", comments);
    state._emitFunctionFromInclude("gaussianSplatting", comments);
    state._emitFunctionFromInclude("helperFunctions", comments);
    state._emitUniformFromString("focal", NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emitUniformFromString("invViewport", NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emitUniformFromString("kernelSize", NodeMaterialBlockConnectionPointTypes.Float);
    state._emitUniformFromString("eyePosition", NodeMaterialBlockConnectionPointTypes.Vector3);
    state._emitUniformFromString("viewDirectionFactor", NodeMaterialBlockConnectionPointTypes.Vector3);
    state.attributes.push(VertexBuffer.PositionKind);
    state.attributes.push("splatIndex0");
    state.attributes.push("splatIndex1");
    state.attributes.push("splatIndex2");
    state.attributes.push("splatIndex3");
    state.sharedData.nodeMaterial.backFaceCulling = false;
    const splatPosition = this.splatPosition;
    const splatScale = this.splatScale;
    const world = this.world;
    const view = this.view;
    const projection = this.projection;
    const output = this.splatVertex;
    const sh = this.SH;
    const addF = state.fSuffix;
    let splatScaleParameter = `vec2${addF}(1.,1.)`;
    if (splatScale.isConnected) {
      splatScaleParameter = splatScale.associatedVariableName;
    }
    let input = "position";
    let uniforms = "";
    if (state.shaderLanguage === 1) {
      input = "input.position";
      uniforms = ", uniforms.focal, uniforms.invViewport, uniforms.kernelSize";
    }
    if (this.SH.isConnected) {
      state.compilationString += `#if SH_DEGREE > 0
`;
      if (state.shaderLanguage === 1) {
        state.compilationString += `let worldRot: mat3x3f =  mat3x3f(${world.associatedVariableName}[0].xyz, ${world.associatedVariableName}[1].xyz, ${world.associatedVariableName}[2].xyz);`;
        state.compilationString += `let normWorldRot: mat3x3f = inverseMat3(worldRot);`;
        state.compilationString += `var dir: vec3f = normalize(normWorldRot * (${splatPosition.associatedVariableName}.xyz - uniforms.eyePosition));
`;
        state.compilationString += `dir *= uniforms.viewDirectionFactor;
`;
      } else {
        state.compilationString += `mat3 worldRot = mat3(${world.associatedVariableName});`;
        state.compilationString += `mat3 normWorldRot = inverseMat3(worldRot);`;
        state.compilationString += `vec3 dir = normalize(normWorldRot * (${splatPosition.associatedVariableName}.xyz - eyePosition));
`;
        state.compilationString += `dir *= viewDirectionFactor;
`;
      }
      state.compilationString += `${state._declareOutput(sh)} = computeSH(splat, dir);
`;
      state.compilationString += `#else
`;
      state.compilationString += `${state._declareOutput(sh)} = vec3${addF}(0.,0.,0.);
`;
      state.compilationString += `#endif;
`;
    } else {
      state.compilationString += `${state._declareOutput(sh)} = vec3${addF}(0.,0.,0.);`;
    }
    state.compilationString += `${state._declareOutput(output)} = gaussianSplatting(${input}.xy, ${splatPosition.associatedVariableName}, ${splatScaleParameter}, covA, covB, ${world.associatedVariableName}, ${view.associatedVariableName}, ${projection.associatedVariableName}${uniforms});
`;
    return this;
  }
};
RegisterClass("BABYLON.GaussianSplattingBlock", GaussianSplattingBlock);

// node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js
var MapMap = class {
  constructor() {
    this.mm = /* @__PURE__ */ new Map();
  }
  get(a, b) {
    const m = this.mm.get(a);
    if (m !== void 0) {
      return m.get(b);
    }
    return void 0;
  }
  set(a, b, v) {
    let m = this.mm.get(a);
    if (m === void 0) {
      this.mm.set(a, m = /* @__PURE__ */ new Map());
    }
    m.set(b, v);
  }
};
var ShadowDepthWrapper = class {
  /** Gets the standalone status of the wrapper */
  get standalone() {
    return this._options?.standalone ?? false;
  }
  /** Gets the base material the wrapper is built upon */
  get baseMaterial() {
    return this._baseMaterial;
  }
  /** Gets the doNotInjectCode status of the wrapper */
  get doNotInjectCode() {
    return this._options?.doNotInjectCode ?? false;
  }
  /**
   * Instantiate a new shadow depth wrapper.
   * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to
   * generate the shadow depth map. For more information, please refer to the documentation:
   * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
   * @param baseMaterial Material to wrap
   * @param scene Define the scene the material belongs to
   * @param options Options used to create the wrapper
   */
  constructor(baseMaterial, scene, options) {
    this._baseMaterial = baseMaterial;
    this._scene = scene ?? EngineStore.LastCreatedScene;
    this._options = options;
    this._subMeshToEffect = /* @__PURE__ */ new Map();
    this._subMeshToDepthWrapper = new MapMap();
    this._meshes = /* @__PURE__ */ new Map();
    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params) => {
      const mesh = params.subMesh?.getMesh();
      if (mesh && !this._meshes.has(mesh)) {
        this._meshes.set(mesh, mesh.onDisposeObservable.add((mesh2) => {
          const iterator = this._subMeshToEffect.keys();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const subMesh = key.value;
            if (subMesh?.getMesh() === mesh2) {
              this._subMeshToEffect.delete(subMesh);
              this._deleteDepthWrapperEffect(subMesh);
            }
          }
        }));
      }
      if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {
        this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);
        this._deleteDepthWrapperEffect(params.subMesh);
      }
    });
  }
  _deleteDepthWrapperEffect(subMesh) {
    const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);
    if (depthWrapperEntries) {
      depthWrapperEntries.forEach((depthWrapper) => {
        depthWrapper.mainDrawWrapper.effect?.dispose();
      });
      this._subMeshToDepthWrapper.mm.delete(subMesh);
    }
  }
  /**
   * Gets the effect to use to generate the depth map
   * @param subMesh subMesh to get the effect for
   * @param shadowGenerator shadow generator to get the effect for
   * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from
   * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified
   */
  getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {
    const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);
    if (!entry) {
      return null;
    }
    let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];
    if (!drawWrapper) {
      drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());
      drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);
    }
    return drawWrapper;
  }
  /**
   * Specifies that the submesh is ready to be used for depth rendering
   * @param subMesh submesh to check
   * @param defines the list of defines to take into account when checking the effect
   * @param shadowGenerator combined with subMesh, it defines the effect to check
   * @param useInstances specifies that instances should be used
   * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {
    if (this.standalone) {
      if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {
        return false;
      }
    }
    return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;
  }
  /**
   * Disposes the resources
   */
  dispose() {
    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);
    this._onEffectCreatedObserver = null;
    const iterator = this._meshes.entries();
    for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
      const [mesh, observer] = entry.value;
      mesh.onDisposeObservable.remove(observer);
    }
  }
  _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {
    const engine = this._scene.getEngine();
    const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);
    if (!origEffectAndRenderPassId) {
      return null;
    }
    const [origEffect, origRenderPassId] = origEffectAndRenderPassId;
    if (!origEffect.isReady()) {
      return null;
    }
    let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);
    if (!params) {
      const mainDrawWrapper = new DrawWrapper(engine);
      mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;
      params = {
        drawWrapper: [],
        mainDrawWrapper,
        depthDefines: "",
        token: RandomGUID()
      };
      params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;
      this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);
    }
    const join = defines.join("\n");
    if (params.mainDrawWrapper.effect) {
      if (join === params.depthDefines) {
        return params.mainDrawWrapper.effect;
      }
    }
    params.depthDefines = join;
    const uniforms = origEffect.getUniformNames().slice();
    let vertexCode = origEffect.vertexSourceCodeBeforeMigration, fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;
    if (!vertexCode && !fragmentCode) {
      return null;
    }
    if (!this.doNotInjectCode) {
      const vertexNormalBiasCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapVertexNormalBias>`, vertexMetricCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapVertexMetric>`, fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapFragmentSoftTransparentShadow>`, fragmentBlockCode = `#include<shadowMapFragment>`, vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;
      if (origEffect.shaderLanguage === 0) {
        vertexCode = vertexCode.replace(/void\s+?main/g, `
${vertexExtraDeclartion}
void main`);
      } else {
        vertexCode = vertexCode.replace(/@vertex/g, `
${vertexExtraDeclartion}
@vertex`);
      }
      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);
      if (vertexCode.indexOf("#define SHADOWDEPTH_METRIC") !== -1) {
        vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);
      } else {
        vertexCode = vertexCode.replace(/}\s*$/g, vertexMetricCode + "\n}");
      }
      vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g, "");
      const hasLocationForSoftTransparentShadow = fragmentCode.indexOf("#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW") >= 0 || fragmentCode.indexOf("#define CUSTOM_FRAGMENT_BEFORE_FOG") >= 0;
      const hasLocationForFragment = fragmentCode.indexOf("#define SHADOWDEPTH_FRAGMENT") !== -1;
      let fragmentCodeToInjectAtEnd = "";
      if (!hasLocationForSoftTransparentShadow) {
        fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + "\n";
      } else {
        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);
      }
      fragmentCode = fragmentCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapFragmentExtraDeclaration"] + "\nvoid main");
      if (hasLocationForFragment) {
        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);
      } else {
        fragmentCodeToInjectAtEnd += fragmentBlockCode + "\n";
      }
      if (fragmentCodeToInjectAtEnd) {
        fragmentCode = fragmentCode.replace(/}\s*$/g, fragmentCodeToInjectAtEnd + "}");
      }
      uniforms.push("biasAndScaleSM", "depthValuesSM", "lightDataSM", "softTransparentShadowSM");
    }
    params.mainDrawWrapper.effect = engine.createEffect({
      vertexSource: vertexCode,
      fragmentSource: fragmentCode,
      vertexToken: params.token,
      fragmentToken: params.token
    }, {
      attributes: origEffect.getAttributesNames(),
      uniformsNames: uniforms,
      uniformBuffersNames: origEffect.getUniformBuffersNames(),
      samplers: origEffect.getSamplers(),
      defines: join + "\n" + origEffect.defines.replace("#define SHADOWS", "").replace(/#define SHADOW\d/g, ""),
      indexParameters: origEffect.getIndexParameters(),
      shaderLanguage: origEffect.shaderLanguage
    }, engine);
    for (let id = 0; id < params.drawWrapper.length; ++id) {
      if (id !== passIdForDrawWrapper) {
        params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);
      }
    }
    return params.mainDrawWrapper.effect;
  }
};

// node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.fragment.js
var name = "gaussianSplattingDepthPixelShader";
var shader = `precision highp float;varying vec2 vPosition;varying vec4 vColor;void main(void) {float A=-dot(vPosition,vPosition);
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
float alpha=exp(A)*vColor.a;if (A<-4.) discard;
#else
if (A<-1.) discard;
#endif
}`;
if (!ShaderStore.ShadersStore[name]) {
  ShaderStore.ShadersStore[name] = shader;
}

// node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.vertex.js
var name2 = "gaussianSplattingDepthVertexShader";
var shader2 = `#include<__decl__gaussianSplattingVertex>
uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec2 vPosition;varying vec4 vColor;
#include<gaussianSplatting>
void main(void) {float splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPosGS=world*vec4(splat.center.xyz,1.0);vPosition=position.xy;vColor=splat.color;gl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,world,view,projection);}`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader2;
}

// node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.fragment.js
var name3 = "gaussianSplattingDepthPixelShader";
var shader3 = `#include<gaussianSplattingFragmentDeclaration>
#include<shadowMapFragmentExtraDeclaration>
varying vPosition: vec2f;varying vColor: vec4f;fn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
if (A<-4.) {discard;}
#else
if (A<-1.) {discard;}
#endif
return vec4f(inColor.rgb,alpha);}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
var alpha : f32=fragmentOutputs.color.a;
#endif
}
`;
if (!ShaderStore.ShadersStoreWGSL[name3]) {
  ShaderStore.ShadersStoreWGSL[name3] = shader3;
}

// node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.vertex.js
var name4 = "gaussianSplattingDepthVertexShader";
var shader4 = `#include<sceneUboDeclaration>
#include<meshUboDeclaration>
attribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;varying vPosition: vec2f;varying vColor: vec4f;
#include<gaussianSplatting>
@vertex
fn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);}`;
if (!ShaderStore.ShadersStoreWGSL[name4]) {
  ShaderStore.ShadersStoreWGSL[name4] = shader4;
}

// node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js
var GaussianSplattingMaterialDefines = class extends MaterialDefines {
  /**
   * Constructor of the defines.
   */
  constructor() {
    super();
    this.FOG = false;
    this.THIN_INSTANCES = true;
    this.LOGARITHMICDEPTH = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.SH_DEGREE = 0;
    this.COMPENSATION = false;
    this.rebuild();
  }
};
var GaussianSplattingMaterial = class _GaussianSplattingMaterial extends PushMaterial {
  /**
   * Instantiates a Gaussian Splatting Material in the given scene
   * @param name The friendly name of the material
   * @param scene The scene to add the material to
   */
  constructor(name6, scene) {
    super(name6, scene);
    this.kernelSize = _GaussianSplattingMaterial.KernelSize;
    this._compensation = _GaussianSplattingMaterial.Compensation;
    this._isDirty = false;
    this.backFaceCulling = false;
    this.shadowDepthWrapper = _GaussianSplattingMaterial._MakeGaussianSplattingShadowDepthWrapper(scene, this.shaderLanguage);
  }
  /**
   * Set compensation default value is `GaussianSplattingMaterial.Compensation`
   */
  set compensation(value) {
    this._isDirty = this._isDirty != value;
    this._compensation = value;
  }
  /**
   * Get compensation
   */
  get compensation() {
    return this._compensation;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha test mode.
   * @returns false
   */
  needAlphaTesting() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha blend mode.
   * @returns true
   */
  needAlphaBlending() {
    return true;
  }
  /**
   * Checks whether the material is ready to be rendered for a given mesh.
   * @param mesh The mesh to render
   * @param subMesh The submesh to check against
   * @returns true if all the dependencies are ready (Textures, Effects...)
   */
  isReadyForSubMesh(mesh, subMesh) {
    const useInstances = true;
    const drawWrapper = subMesh._drawWrapper;
    let defines = subMesh.materialDefines;
    if (defines && this._isDirty) {
      defines.markAsUnprocessed();
    }
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();
    }
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    const gsMesh = mesh;
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines, void 0, void 0, void 0, this._isVertexOutputInvariant);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (engine.version > 1 || engine.isWebGPU) {
      defines["SH_DEGREE"] = gsMesh.shDegree;
    }
    const splatMaterial = gsMesh.material;
    defines["COMPENSATION"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : _GaussianSplattingMaterial.Compensation;
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      PrepareAttributesForInstances(_GaussianSplattingMaterial._Attribs, defines);
      PrepareUniformsAndSamplersList({
        uniformsNames: _GaussianSplattingMaterial._Uniforms,
        uniformBuffersNames: _GaussianSplattingMaterial._UniformBuffers,
        samplers: _GaussianSplattingMaterial._Samplers,
        defines
      });
      AddClipPlaneUniforms(_GaussianSplattingMaterial._Uniforms);
      const join = defines.toString();
      const effect = scene.getEngine().createEffect("gaussianSplatting", {
        attributes: _GaussianSplattingMaterial._Attribs,
        uniformsNames: _GaussianSplattingMaterial._Uniforms,
        uniformBuffersNames: _GaussianSplattingMaterial._UniformBuffers,
        samplers: _GaussianSplattingMaterial._Samplers,
        defines: join,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: {},
        shaderLanguage: this._shaderLanguage,
        extraInitializationsAsync: async () => {
          if (this._shaderLanguage === 1) {
            await Promise.all([import("./gaussianSplatting.fragment-RFD76TKG.js"), import("./gaussianSplatting.vertex-5OHJVE6H.js")]);
          } else {
            await Promise.all([import("./gaussianSplatting.fragment-ZYLQJ2SQ.js"), import("./gaussianSplatting.vertex-CSVA6QDK.js")]);
          }
        }
      }, engine);
      subMesh.setEffect(effect, defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    this._isDirty = false;
    return true;
  }
  /**
   * Bind material effect for a specific Gaussian Splatting mesh
   * @param mesh Gaussian splatting mesh
   * @param effect Splatting material or node material
   * @param scene scene that contains mesh and camera used for rendering
   */
  static BindEffect(mesh, effect, scene) {
    const engine = scene.getEngine();
    const camera = scene.activeCamera;
    const renderWidth = engine.getRenderWidth();
    const renderHeight = engine.getRenderHeight();
    const gsMesh = mesh;
    const gsMaterial = gsMesh.material;
    const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;
    effect.setFloat2("invViewport", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);
    let focal = 1e3;
    if (camera) {
      const t = camera.getProjectionMatrix().m[5];
      if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {
        focal = renderHeight * t / 2;
      } else {
        focal = renderWidth * t / 2;
      }
    }
    effect.setFloat2("focal", focal, focal);
    effect.setVector3("viewDirectionFactor", gsMesh.viewDirectionFactor);
    effect.setFloat("kernelSize", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : _GaussianSplattingMaterial.KernelSize);
    scene.bindEyePosition(effect, "eyePosition", true);
    if (gsMesh.covariancesATexture) {
      const textureSize = gsMesh.covariancesATexture.getSize();
      effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
      effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
      effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
      effect.setTexture("centersTexture", gsMesh.centersTexture);
      effect.setTexture("colorsTexture", gsMesh.colorsTexture);
      if (gsMesh.shTextures) {
        for (let i = 0; i < gsMesh.shTextures?.length; i++) {
          effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);
        }
      }
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    if (mustRebind) {
      this.bindView(effect);
      this.bindViewProjection(effect);
      _GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);
      BindClipPlane(effect, this, scene);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    BindFogParameters(scene, mesh, effect);
    if (this.useLogarithmicDepth) {
      BindLogDepth(defines, effect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  static _MakeGaussianSplattingShadowDepthWrapper(scene, shaderLanguage) {
    const shaderMaterial = new ShaderMaterial("gaussianSplattingDepth", scene, {
      vertex: "gaussianSplattingDepth",
      fragment: "gaussianSplattingDepth"
    }, {
      attributes: _GaussianSplattingMaterial._Attribs,
      uniforms: _GaussianSplattingMaterial._Uniforms,
      samplers: _GaussianSplattingMaterial._Samplers,
      uniformBuffers: _GaussianSplattingMaterial._UniformBuffers,
      shaderLanguage
    });
    const shadowDepthWrapper = new ShadowDepthWrapper(shaderMaterial, scene, {
      standalone: true
    });
    shaderMaterial.onBindObservable.add((mesh) => {
      const effect = shaderMaterial.getEffect();
      const gsMaterial = mesh.material;
      const gsMesh = mesh;
      mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
      shaderMaterial.bindView(effect);
      shaderMaterial.bindViewProjection(effect);
      const shadowmapWidth = scene.getEngine().getRenderWidth();
      const shadowmapHeight = scene.getEngine().getRenderHeight();
      effect.setFloat2("invViewport", 1 / shadowmapWidth, 1 / shadowmapHeight);
      const projection = scene.getProjectionMatrix();
      const t = projection.m[5];
      const focal = shadowmapWidth * t / 2;
      effect.setFloat2("focal", focal, focal);
      effect.setFloat("kernelSize", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : _GaussianSplattingMaterial.KernelSize);
      if (gsMesh.covariancesATexture) {
        const textureSize = gsMesh.covariancesATexture.getSize();
        effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
        effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
        effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
        effect.setTexture("centersTexture", gsMesh.centersTexture);
        effect.setTexture("colorsTexture", gsMesh.colorsTexture);
      }
    });
    return shadowDepthWrapper;
  }
  /**
   * Clones the material.
   * @param name The cloned name.
   * @returns The cloned material.
   */
  clone(name6) {
    return SerializationHelper.Clone(() => new _GaussianSplattingMaterial(name6, this.getScene()), this);
  }
  /**
   * Serializes the current material to its JSON representation.
   * @returns The JSON representation.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GaussianSplattingMaterial";
    return serializationObject;
  }
  /**
   * Gets the class name of the material
   * @returns "GaussianSplattingMaterial"
   */
  getClassName() {
    return "GaussianSplattingMaterial";
  }
  /**
   * Parse a JSON input to create back a Gaussian Splatting material.
   * @param source The JSON data to parse
   * @param scene The scene to create the parsed material in
   * @param rootUrl The root url of the assets the material depends upon
   * @returns the instantiated GaussianSplattingMaterial.
   */
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);
  }
};
GaussianSplattingMaterial.KernelSize = 0.3;
GaussianSplattingMaterial.Compensation = false;
GaussianSplattingMaterial._Attribs = [VertexBuffer.PositionKind, "splatIndex0", "splatIndex1", "splatIndex2", "splatIndex3"];
GaussianSplattingMaterial._Samplers = ["covariancesATexture", "covariancesBTexture", "centersTexture", "colorsTexture", "shTexture0", "shTexture1", "shTexture2"];
GaussianSplattingMaterial._UniformBuffers = ["Scene", "Mesh"];
GaussianSplattingMaterial._Uniforms = [
  "world",
  "view",
  "projection",
  "vFogInfos",
  "vFogColor",
  "logarithmicDepthConstant",
  "invViewport",
  "dataTextureSize",
  "focal",
  "eyePosition",
  "kernelSize",
  "viewDirectionFactor"
];
RegisterClass("BABYLON.GaussianSplattingMaterial", GaussianSplattingMaterial);

// node_modules/@babylonjs/core/Materials/Node/Blocks/GaussianSplatting/splatReaderBlock.js
var SplatReaderBlock = class extends NodeMaterialBlock {
  /**
   * Create a new SplatReaderBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Vertex);
    this._isUnique = true;
    this.registerInput("splatIndex", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("splatPosition", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Vertex);
    this.registerOutput("splatColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Vertex);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "SplatReaderBlock";
  }
  /**
   * Gets the splat index input component
   */
  get splatIndex() {
    return this._inputs[0];
  }
  /**
   * Gets the splatPosition output component
   */
  get splatPosition() {
    return this._outputs[0];
  }
  /**
   * Gets the splatColor output component
   */
  get splatColor() {
    return this._outputs[1];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("covA");
    state._excludeVariableName("covB");
    state._excludeVariableName("vPosition");
    state._excludeVariableName("covariancesATexture");
    state._excludeVariableName("covariancesBTexture");
    state._excludeVariableName("centersTexture");
    state._excludeVariableName("colorsTexture");
    state._excludeVariableName("dataTextureSize");
  }
  bind(effect, nodeMaterial, mesh) {
    if (!mesh) {
      return;
    }
    const scene = mesh.getScene();
    GaussianSplattingMaterial.BindEffect(mesh, effect, scene);
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Fragment) {
      return;
    }
    state.sharedData.bindableBlocks.push(this);
    const comments = `//${this.name}`;
    state._emit2DSampler("covariancesATexture");
    state._emit2DSampler("covariancesBTexture");
    state._emit2DSampler("centersTexture");
    state._emit2DSampler("colorsTexture");
    state._emit2DSampler("shTexture0", "SH_DEGREE > 0", void 0, void 0, true, "highp");
    state._emit2DSampler("shTexture1", "SH_DEGREE > 0", void 0, void 0, true, "highp");
    state._emit2DSampler("shTexture2", "SH_DEGREE > 0", void 0, void 0, true, "highp");
    state._emitFunctionFromInclude("gaussianSplattingVertexDeclaration", comments);
    state._emitFunctionFromInclude("gaussianSplatting", comments);
    state._emitVaryingFromString("vPosition", NodeMaterialBlockConnectionPointTypes.Vector2);
    state._emitUniformFromString("dataTextureSize", NodeMaterialBlockConnectionPointTypes.Vector2);
    const splatPosition = this.splatPosition;
    const splatColor = this.splatColor;
    const splatVariablename = state._getFreeVariableName("splat");
    if (state.shaderLanguage === 1) {
      state.compilationString += `let splatIndex: f32 = getSplatIndex(i32(input.position.z + 0.5), input.splatIndex0, input.splatIndex1, input.splatIndex2, input.splatIndex3);`;
      state.compilationString += `var ${splatVariablename}: Splat = readSplat(splatIndex, uniforms.dataTextureSize);
`;
      state.compilationString += `var covA: vec3f = splat.covA.xyz; var covB: vec3f = vec3f(splat.covA.w, splat.covB.xy);
`;
      state.compilationString += "vertexOutputs.vPosition = input.position.xy;\n";
    } else {
      state.compilationString += `float splatIndex = getSplatIndex(int(position.z + 0.5));`;
      state.compilationString += `Splat ${splatVariablename} = readSplat(splatIndex);
`;
      state.compilationString += `vec3 covA = splat.covA.xyz; vec3 covB = vec3(splat.covA.w, splat.covB.xy);
`;
      state.compilationString += "vPosition = position.xy;\n";
    }
    state.compilationString += `${state._declareOutput(splatPosition)} = ${splatVariablename}.center.xyz;
`;
    state.compilationString += `${state._declareOutput(splatColor)} = ${splatVariablename}.color;
`;
    return this;
  }
};
RegisterClass("BABYLON.SplatReaderBlock", SplatReaderBlock);

// node_modules/@babylonjs/core/Materials/Node/Blocks/GaussianSplatting/gaussianBlock.js
var GaussianBlock = class extends NodeMaterialBlock {
  /**
   * Create a new GaussianBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment);
    this._isUnique = false;
    this.registerInput("splatColor", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);
    this.registerOutput("alpha", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "GaussianBlock";
  }
  /**
   * Gets the color input component
   */
  get splatColor() {
    return this._inputs[0];
  }
  /**
   * Gets the rgba output component
   */
  get rgba() {
    return this._outputs[0];
  }
  /**
   * Gets the rgb output component
   */
  get rgb() {
    return this._outputs[1];
  }
  /**
   * Gets the alpha output component
   */
  get alpha() {
    return this._outputs[2];
  }
  /**
   * Initialize the block and prepare the context for build
   * @param state defines the state that will be used for the build
   */
  initialize(state) {
    state._excludeVariableName("vPosition");
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (state.target === NodeMaterialBlockTargets.Vertex) {
      return;
    }
    const comments = `//${this.name}`;
    state._emitFunctionFromInclude("clipPlaneFragmentDeclaration", comments);
    state._emitFunctionFromInclude("logDepthDeclaration", comments);
    state._emitFunctionFromInclude("fogFragmentDeclaration", comments);
    state._emitFunctionFromInclude("gaussianSplattingFragmentDeclaration", comments);
    state._emitVaryingFromString("vPosition", NodeMaterialBlockConnectionPointTypes.Vector2);
    const tempSplatColor = state._getFreeVariableName("tempSplatColor");
    const color = this.splatColor;
    const rgba = this._outputs[0];
    const rgb = this._outputs[1];
    const alpha = this._outputs[2];
    if (state.shaderLanguage === 1) {
      state.compilationString += `let ${tempSplatColor}:vec4f = gaussianColor(${color.associatedVariableName}, input.vPosition);
`;
    } else {
      state.compilationString += `vec4 ${tempSplatColor} = gaussianColor(${color.associatedVariableName});
`;
    }
    state.compilationString += `${state._declareOutput(rgba)} = ${tempSplatColor}.rgba;`;
    state.compilationString += `${state._declareOutput(rgb)} = ${tempSplatColor}.rgb;`;
    state.compilationString += `${state._declareOutput(alpha)} = ${tempSplatColor}.a;`;
    return this;
  }
};
RegisterClass("BABYLON.GaussianBlock", GaussianBlock);

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/gaussianSplattingVertexDeclaration.js
var name5 = "gaussianSplattingVertexDeclaration";
var shader5 = `attribute position: vec3f;attribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;`;
if (!ShaderStore.IncludesShadersStoreWGSL[name5]) {
  ShaderStore.IncludesShadersStoreWGSL[name5] = shader5;
}
var gaussianSplattingVertexDeclarationWGSL = { name: name5, shader: shader5 };

// node_modules/@babylonjs/core/Materials/Node/Blocks/debugBlock.js
var NodeMaterialDebugBlock = class extends NodeMaterialBlock {
  /**
   * Gets or sets a boolean indicating that the block is active
   */
  get isActive() {
    return this._isActive && this.debug.isConnected;
  }
  set isActive(value) {
    if (this._isActive === value) {
      return;
    }
    this._isActive = value;
  }
  /**
   * Creates a new NodeMaterialDebugBlock
   * @param name defines the block name
   */
  constructor(name6) {
    super(name6, NodeMaterialBlockTargets.Fragment, true, true);
    this._isActive = false;
    this.renderAlpha = false;
    this.registerInput("debug", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);
    this.debug.excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);
  }
  /** @internal */
  get _isFinalOutputAndActive() {
    return this.isActive;
  }
  /** @internal */
  get _hasPrecedence() {
    return true;
  }
  /**
   * Gets the rgba input component
   */
  get debug() {
    return this._inputs[0];
  }
  /**
   * Gets the current class name
   * @returns the class name
   */
  getClassName() {
    return "NodeMaterialDebugBlock";
  }
  _buildBlock(state) {
    super._buildBlock(state);
    if (!this._isActive) {
      return this;
    }
    let outputString = "gl_FragColor";
    if (state.shaderLanguage === 1) {
      outputString = "fragmentOutputs.color";
    }
    const debug = this.debug;
    if (!debug.connectedPoint) {
      return this;
    }
    if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
      state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, ${debug.associatedVariableName}, ${debug.associatedVariableName}, 1.0);
`;
    } else if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector2) {
      state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, 0., 1.0);
`;
    } else if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color3 || debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
      state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, 1.0);
`;
    } else if (this.renderAlpha) {
      state.compilationString += `${outputString}  =${debug.associatedVariableName};
`;
    } else {
      state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}.rgb, 1.0);
`;
    }
    return this;
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.isActive = this._isActive;
    serializationObject.renderAlpha = this.renderAlpha;
    return serializationObject;
  }
  _deserialize(serializationObject, scene, rootUrl) {
    super._deserialize(serializationObject, scene, rootUrl);
    this.isActive = serializationObject.isActive;
    this.renderAlpha = serializationObject.renderAlpha;
  }
};
__decorate([
  editableInPropertyPage("Render Alpha", 0, void 0)
], NodeMaterialDebugBlock.prototype, "renderAlpha", void 0);
RegisterClass("BABYLON.NodeMaterialDebugBlock", NodeMaterialDebugBlock);

export {
  NodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialConnectionPoint,
  NodeMaterialBlock,
  VertexOutputBlock,
  NodeMaterialSystemValues,
  AnimatedInputBlockTypes,
  InputBlock,
  BonesBlock,
  InstancesBlock,
  MorphTargetsBlock,
  PointLight,
  LightInformationBlock,
  PropertyTypeForEdition,
  editableInPropertyPage,
  FragmentOutputBlockColorSpace,
  FragmentOutputBlock,
  NodeMaterialModes,
  ScreenSizeBlock,
  SfeModeDefine,
  SmartFilterFragmentOutputBlock,
  ImageProcessingBlock,
  NodeMaterialConnectionPointCustomObject,
  TBNBlock,
  PerturbNormalBlock,
  DiscardBlock,
  FrontFacingBlock,
  DerivativeBlock,
  FragCoordBlock,
  ScreenSpaceBlock,
  TwirlBlock,
  HeightToNormalBlock,
  FragDepthBlock,
  ShadowMapBlock,
  PrePassOutputBlock,
  RawTexture,
  TransformBlock,
  CurrentScreenBlock,
  ParticleTextureBlock,
  ParticleRampGradientBlock,
  ParticleBlendMultiplyBlock,
  VectorMergerBlock,
  RemapBlock,
  MultiplyBlock,
  BaseParticleSystem,
  ColorSplitterBlock,
  ProceduralTextureSceneComponent,
  ProceduralTexture,
  TrigonometryBlockOperations,
  TrigonometryBlock,
  NodeMaterialDefines,
  NodeMaterial,
  ImageSourceBlock,
  AmbientOcclusionBlock,
  FogBlock,
  LightBlock,
  TextureBlock,
  CubeTexture,
  ReflectionTextureBaseBlock,
  ReflectionTextureBlock,
  SceneDepthBlock,
  DepthSourceBlock,
  ClipPlanesBlock,
  SmartFilterTextureBlock,
  PrePassTextureBlock,
  NodeMaterialTeleportInBlock,
  NodeMaterialTeleportOutBlock,
  AddBlock,
  ScaleBlock,
  ClampBlock,
  CrossBlock,
  CustomBlock,
  DotBlock,
  NormalizeBlock,
  ColorMergerBlock,
  VectorSplitterBlock,
  LerpBlock,
  DivideBlock,
  SubtractBlock,
  StepBlock,
  OneMinusBlock,
  ViewDirectionBlock,
  FresnelBlock,
  MaxBlock,
  MinBlock,
  DistanceBlock,
  LengthBlock,
  NegateBlock,
  PowBlock,
  RandomNumberBlock,
  ArcTan2Block,
  SmoothStepBlock,
  ReciprocalBlock,
  ReplaceColorBlock,
  PosterizeBlock,
  WaveBlockKind,
  WaveBlock,
  GradientBlockColorStep,
  GradientBlock,
  NLerpBlock,
  WorleyNoise3DBlock,
  SimplexPerlin3DBlock,
  NormalBlendBlock,
  Rotate2dBlock,
  ReflectBlock,
  RefractBlock,
  DesaturateBlock,
  GetEnvironmentBRDFTexture,
  GetEnvironmentFuzzBRDFTexture,
  BRDFTextureTools,
  MaterialBRDFDefines,
  PBRBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  SheenBlock,
  AnisotropyBlock,
  ReflectionBlock,
  ClearCoatBlock,
  IridescenceBlock,
  RefractionBlock,
  SubSurfaceBlock,
  PBRMetallicRoughnessBlock,
  ModBlock,
  MatrixBuilderBlock,
  ConditionalBlockConditions,
  ConditionalBlock,
  CloudBlock,
  VoronoiNoiseBlock,
  ElbowBlock,
  TriPlanarBlock,
  BiPlanarBlock,
  MatrixDeterminantBlock,
  MatrixTransposeBlock,
  MeshAttributeExistsBlockTypes,
  MeshAttributeExistsBlock,
  CurveBlockTypes,
  CurveBlock,
  ColorConverterBlock,
  LoopBlock,
  StorageReadBlock,
  StorageWriteBlock,
  MatrixSplitterBlock,
  GaussianSplattingBlock,
  ShadowDepthWrapper,
  GaussianSplattingMaterial,
  SplatReaderBlock,
  GaussianBlock,
  gaussianSplattingVertexDeclarationWGSL,
  NodeMaterialDebugBlock
};
//# sourceMappingURL=chunk-F5HGXHX7.js.map
