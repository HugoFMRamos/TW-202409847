{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialBlockTargets.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBlockConnectionPoint.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/vertexOutputBlock.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialSystemValues.ts", "../../../dev/core/src/Materials/Node/Blocks/Input/animatedInputBlockTypes.ts", "../../../dev/core/src/Materials/Node/Blocks/Input/inputBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/bonesBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/instancesBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/morphTargetsBlock.ts", "../../../dev/core/src/Lights/pointLight.ts", "../../../dev/core/src/Materials/Node/Blocks/Vertex/lightInformationBlock.ts", "../../../dev/core/src/Decorators/nodeDecorator.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/fragmentOutputBlock.ts", "../../../dev/core/src/Materials/Node/Enums/nodeMaterialModes.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/screenSizeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/imageProcessingBlock.ts", "../../../dev/core/src/Materials/Node/nodeMaterialConnectionPointCustomObject.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/TBNBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/perturbNormalBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/discardBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/frontFacingBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/derivativeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/fragCoordBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/screenSpaceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/twirlBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/heightToNormalBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/fragDepthBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/shadowMapBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/prePassOutputBlock.ts", "../../../dev/core/src/Materials/Textures/rawTexture.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBuildState.ts", "../../../dev/core/src/Materials/Node/nodeMaterialBuildStateSharedData.ts", "../../../dev/core/src/Materials/Node/Blocks/transformBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/currentScreenBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleTextureBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleRampGradientBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/vectorMergerBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/remapBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/baseMathBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/multiplyBlock.ts", "../../../dev/core/src/Particles/baseParticleSystem.ts", "../../../dev/core/src/Materials/Node/Blocks/colorSplitterBlock.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts", "../../../dev/core/src/Materials/Node/Blocks/trigonometryBlock.ts", "../../../dev/core/src/Materials/Node/nodeMaterial.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/imageSourceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Fragment/ambientOcclusionBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/fogBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/lightBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/textureBlock.ts", "../../../dev/core/src/Materials/Textures/cubeTexture.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/reflectionTextureBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/sceneDepthBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/depthSourceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/clipPlanesBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Dual/smartFilterTextureBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Input/prePassTextureBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Teleport/teleportInBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/Teleport/teleportOutBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/addBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/scaleBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/clampBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/crossBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/customBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/dotBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/normalizeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/colorMergerBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/vectorSplitterBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/lerpBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/divideBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/subtractBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/stepBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/oneMinusBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/viewDirectionBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/fresnelBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/maxBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/minBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/distanceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/lengthBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/negateBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/powBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/randomNumberBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/arcTan2Block.ts", "../../../dev/core/src/Materials/Node/Blocks/smoothStepBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/reciprocalBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/replaceColorBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/posterizeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/waveBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/gradientBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/nLerpBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/worleyNoise3DBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/simplexPerlin3DBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/normalBlendBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/rotate2dBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/reflectBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/refractBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/desaturateBlock.ts", "../../../dev/core/src/Misc/brdfTextureTools.ts", "../../../dev/core/src/Materials/PBR/pbrBRDFConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrClearCoatConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrIridescenceConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrAnisotropicConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrSheenConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrSubSurfaceConfiguration.ts", "../../../dev/core/src/Materials/PBR/pbrBaseMaterial.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/sheenBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/anisotropyBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/reflectionBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/clearCoatBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/iridescenceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/refractionBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/subSurfaceBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/PBR/pbrMetallicRoughnessBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/modBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/matrixBuilderBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/conditionalBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/cloudBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/voronoiNoiseBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/elbowBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/triPlanarBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/biPlanarBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/matrixDeterminantBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/matrixTransposeBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/meshAttributeExistsBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/curveBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/colorConverterBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/loopBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/storageReadBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/storageWriteBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/matrixSplitterBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/GaussianSplatting/gaussianSplattingBlock.ts", "../../../dev/core/src/Materials/shadowDepthWrapper.ts", "../../../dev/core/src/Shaders/gaussianSplattingDepth.fragment.ts", "../../../dev/core/src/Shaders/gaussianSplattingDepth.vertex.ts", "../../../dev/core/src/ShadersWGSL/gaussianSplattingDepth.fragment.ts", "../../../dev/core/src/ShadersWGSL/gaussianSplattingDepth.vertex.ts", "../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingMaterial.ts", "../../../dev/core/src/Materials/Node/Blocks/GaussianSplatting/splatReaderBlock.ts", "../../../dev/core/src/Materials/Node/Blocks/GaussianSplatting/gaussianBlock.ts", "../../../dev/core/src/ShadersWGSL/ShadersInclude/gaussianSplattingVertexDeclaration.ts", "../../../dev/core/src/Materials/Node/Blocks/debugBlock.ts"],
  "sourcesContent": ["/**\r\n * Defines the kind of connection point for node based material\r\n */\r\nexport enum NodeMaterialBlockConnectionPointTypes {\r\n    /** Float */\r\n    Float = 0x0001,\r\n    /** Int */\r\n    Int = 0x0002,\r\n    /** Vector2 */\r\n    Vector2 = 0x0004,\r\n    /** Vector3 */\r\n    Vector3 = 0x0008,\r\n    /** Vector4 */\r\n    Vector4 = 0x0010,\r\n    /** Color3 */\r\n    Color3 = 0x0020,\r\n    /** Color4 */\r\n    Color4 = 0x0040,\r\n    /** Matrix */\r\n    Matrix = 0x0080,\r\n    /** Custom object */\r\n    Object = 0x0100,\r\n    /** Detect type based on connection */\r\n    AutoDetect = 0x0400,\r\n    /** Output type that will be defined by input type */\r\n    BasedOnInput = 0x0800,\r\n    /** Bitmask of all types */\r\n    All = 0x0fff,\r\n}\r\n", "/**\r\n * Enum used to define the target of a block\r\n */\r\nexport enum NodeMaterialBlockTargets {\r\n    /** Vertex shader */\r\n    Vertex = 1,\r\n    /** Fragment shader */\r\n    Fragment = 2,\r\n    /** Neutral */\r\n    Neutral = 4,\r\n    /** Vertex and Fragment */\r\n    VertexAndFragment = Vertex | Fragment,\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport const enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible,\r\n    /** Points are incompatible because they are in the same hierarchy **/\r\n    HierarchyIssue,\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport const enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output,\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isInactive: boolean = false;\r\n\r\n    /**\r\n     * Boolean used to provide visual clue to users when some ports are not active in the current block configuration\r\n     */\r\n    public get isInactive(): boolean {\r\n        return this._isInactive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preventBubbleUp = false;\r\n\r\n    /** @internal */\r\n    public readonly _ownerBlock: NodeMaterialBlock;\r\n\r\n    private _connectedPointBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _connectedPointTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    private get _connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPointBackingField;\r\n    }\r\n\r\n    private set _connectedPoint(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._connectedPointBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._connectedPointTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._connectedPointBackingField = value));\r\n        if (this._connectedPointBackingField) {\r\n            this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    private readonly _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private readonly _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @internal */\r\n    public _redirectedSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _typeConnectionSourceBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _typeConnectionSourceTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    /** @internal */\r\n    public get _typeConnectionSource(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._typeConnectionSourceBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _typeConnectionSource(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._typeConnectionSourceBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._typeConnectionSourceTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._typeConnectionSourceBackingField = value));\r\n        if (this._typeConnectionSourceBackingField) {\r\n            this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _defaultConnectionPointTypeBackingField: Nullable<NodeMaterialBlockConnectionPointTypes> = null;\r\n\r\n    /** @internal */\r\n    public get _defaultConnectionPointType(): Nullable<NodeMaterialBlockConnectionPointTypes> {\r\n        return this._defaultConnectionPointTypeBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _defaultConnectionPointType(value: Nullable<NodeMaterialBlockConnectionPointTypes>) {\r\n        this._updateTypeDependentState(() => (this._defaultConnectionPointTypeBackingField = value));\r\n    }\r\n\r\n    /** @internal */\r\n    public _isMainLinkSource = false;\r\n\r\n    private _linkedConnectionSourceBackingField: Nullable<NodeMaterialConnectionPoint> = null;\r\n    private _linkedConnectionSourceTypeChangedObserver: Nullable<Observer<NodeMaterialBlockConnectionPointTypes>>;\r\n\r\n    /** @internal */\r\n    public get _linkedConnectionSource(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._linkedConnectionSourceBackingField;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _linkedConnectionSource(value: Nullable<NodeMaterialConnectionPoint>) {\r\n        if (this._linkedConnectionSourceBackingField === value) {\r\n            return;\r\n        }\r\n\r\n        this._linkedConnectionSourceTypeChangedObserver?.remove();\r\n        this._updateTypeDependentState(() => (this._linkedConnectionSourceBackingField = value));\r\n        this._isMainLinkSource = false;\r\n        if (this._linkedConnectionSourceBackingField) {\r\n            this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(() => {\r\n                this._notifyTypeChanged();\r\n            });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @internal */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** @internal */\r\n    public _forPostBuild = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[] = [];\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public readonly onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when this point is disconnected\r\n     */\r\n    public readonly onDisconnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Observable triggered when the type of the connection point is changed\r\n     */\r\n    public readonly onTypeChangedObservable = new Observable<NodeMaterialBlockConnectionPointTypes>();\r\n    private _isTypeChangeObservableNotifying = false;\r\n\r\n    /**\r\n     * Gets the declaration variable name in the shader\r\n     */\r\n    public get declarationVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).declarationVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.declarationVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource) {\r\n                if (this._linkedConnectionSource.isConnected) {\r\n                    if (this._linkedConnectionSource.connectedPoint!._redirectedSource && this._linkedConnectionSource.connectedPoint!._redirectedSource.isConnected) {\r\n                        return this._linkedConnectionSource.connectedPoint!._redirectedSource.type;\r\n                    }\r\n                    return this._linkedConnectionSource.type;\r\n                }\r\n                if (this._linkedConnectionSource._defaultConnectionPointType) {\r\n                    return this._linkedConnectionSource._defaultConnectionPointType;\r\n                }\r\n            }\r\n\r\n            if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {\r\n            if (this._typeConnectionSource) {\r\n                if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {\r\n                    return this._defaultConnectionPointType;\r\n                }\r\n                return this._typeConnectionSource.type;\r\n            } else if (this._defaultConnectionPointType) {\r\n                return this._defaultConnectionPointType;\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._updateTypeDependentState(() => (this._type = value));\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public readonly name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @internal */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection has a path to the vertex output*/\r\n    public get isDirectlyConnectedToVertexOutput(): boolean {\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.isConnectedInFragmentShader()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n        const otherBlock = connectionPoint.ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (const output of otherBlock.outputs) {\r\n                if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (\r\n                (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) ||\r\n                (connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            ) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n        }\r\n\r\n        // Check hierarchy\r\n        let targetBlock = otherBlock;\r\n        let sourceBlock = ownerBlock;\r\n        if (this.direction === NodeMaterialConnectionPointDirection.Input) {\r\n            targetBlock = ownerBlock;\r\n            sourceBlock = otherBlock;\r\n        }\r\n\r\n        if (targetBlock.isAnAncestorOf(sourceBlock)) {\r\n            return NodeMaterialConnectionPointCompatibilityStates.HierarchyIssue;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `Cannot connect these two connectors. source: \"${this.ownerBlock.name}\".${this.name}, target: \"${connectionPoint.ownerBlock.name}\".${connectionPoint.name}`;\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n\r\n        this.onDisconnectionObservable.notifyObservers(endpoint);\r\n        endpoint.onDisconnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Fill the list of excluded connection point types with all types other than those passed in the parameter\r\n     * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list\r\n     */\r\n    public addExcludedConnectionPointFromAllowedTypes(mask: number): void {\r\n        let bitmask = 1;\r\n        while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {\r\n            if (!(mask & bitmask)) {\r\n                this.excludedConnectionPointTypes.push(bitmask);\r\n            }\r\n            bitmask = bitmask << 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        if (this.displayName) {\r\n            serializationObject.displayName = this.displayName;\r\n        }\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n        this.onDisconnectionObservable.clear();\r\n        this.onTypeChangedObservable.clear();\r\n\r\n        this._connectedPoint = null;\r\n        this._typeConnectionSource = null;\r\n        this._linkedConnectionSource = null;\r\n    }\r\n\r\n    private _updateTypeDependentState(update: () => void) {\r\n        const previousType = this.type;\r\n        update();\r\n        if (this.type !== previousType) {\r\n            this._notifyTypeChanged();\r\n        }\r\n    }\r\n\r\n    private _notifyTypeChanged() {\r\n        // Disallow re-entrancy\r\n        if (this._isTypeChangeObservableNotifying) {\r\n            return;\r\n        }\r\n\r\n        this._isTypeChangeObservableNotifying = true;\r\n        this.onTypeChangedObservable.notifyObservers(this.type);\r\n        this._isTypeChangeObservableNotifying = false;\r\n    }\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _isLoop = false;\r\n    private _isTeleportOut = false;\r\n    private _isTeleportIn = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n    protected _codeIsReady = true;\r\n    /** @internal */\r\n    public _isFinalOutput = false;\r\n\r\n    /** @internal */\r\n    public get _isFinalOutputAndActive() {\r\n        return this._isFinalOutput;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _hasPrecedence() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the block code is ready (if the code loading is async)\r\n     */\r\n    public onCodeIsReadyObservable = new Observable<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block has is code ready to be used\r\n     */\r\n    public get codeIsReady() {\r\n        return this._codeIsReady;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport out\r\n     */\r\n    public get isTeleportOut(): boolean {\r\n        return this._isTeleportOut;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a teleport in\r\n     */\r\n    public get isTeleportIn(): boolean {\r\n        return this._isTeleportIn;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this block is a loop\r\n     */\r\n    public get isLoop(): boolean {\r\n        return this._isLoop;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isFinalOutput defines a boolean indicating that this block is generating a final output and no other block should be generated after\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isFinalOutput = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isFinalOutput = isFinalOutput;\r\n        switch (this.getClassName()) {\r\n            case \"InputBlock\":\r\n                this._isInput = true;\r\n                break;\r\n            case \"NodeMaterialTeleportOutBlock\":\r\n                this._isTeleportOut = true;\r\n                break;\r\n            case \"NodeMaterialTeleportInBlock\":\r\n                this._isTeleportIn = true;\r\n                break;\r\n            case \"LoopBlock\":\r\n                this._isLoop = true;\r\n                break;\r\n        }\r\n\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setInitialTarget(target: NodeMaterialBlockTargets): void {\r\n        this._target = target;\r\n        // marked as read only\r\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\r\n        (this._originalTargetIsNeutral as boolean) = target === NodeMaterialBlockTargets.Neutral;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader\r\n     * @returns true if connected in fragment shader\r\n     */\r\n    public isConnectedInFragmentShader() {\r\n        return this.outputs.some((o) => o.isConnectedInFragmentShader);\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (\r\n                    !forOutput ||\r\n                    forOutput.type === input.type ||\r\n                    input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect ||\r\n                    input.acceptedConnectionPointTypes.indexOf(forOutput.type) !== -1\r\n                ) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _postBuildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(fallbacks: EffectFallbacks, mesh?: AbstractMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param defines defines the material defines to update\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, defines: NodeMaterialDefines, mesh?: AbstractMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n            this._inputs[inputIndex0]._isMainLinkSource = true;\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (block.isTeleportOut && (block as NodeMaterialTeleportOutBlock).entryPoint?.isConnectedToUniform) {\r\n            // In that case, we skip the context switch as the teleport out block is connected to a uniform\r\n            return;\r\n        }\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.declarationVariableName, connectedPoint.type)) {\r\n                    const prefix = state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\";\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL && connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Matrix) {\r\n                        // We can't pass a matrix as a varying in WGSL, so we need to split it into 4 vectors\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r0 = ${connectedPoint.associatedVariableName}[0];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r1 = ${connectedPoint.associatedVariableName}[1];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r2 = ${connectedPoint.associatedVariableName}[2];\\n`;\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName}_r3 = ${connectedPoint.associatedVariableName}[3];\\n`;\r\n                    } else {\r\n                        state._vertexState.compilationString += `${prefix}${\"v_\" + connectedPoint.declarationVariableName} = ${connectedPoint.associatedVariableName};\\n`;\r\n                    }\r\n                }\r\n                const prefix = state.shaderLanguage === ShaderLanguage.WGSL && connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Matrix ? \"fragmentInputs.\" : \"\";\r\n                input.associatedVariableName = prefix + \"v_\" + connectedPoint.declarationVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"postprocess_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _customBuildStep(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): void {\r\n        // Must be implemented by children\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        this._customBuildStep(state, activeBlocks);\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\n//${this.name}\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if (output._forPostBuild) {\r\n                continue;\r\n            }\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block) {\r\n                    if (((block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) || state._terminalBlocks.has(block)) {\r\n                        this._processBuild(block, state, endpoint, activeBlocks);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._postBuildBlock(state);\r\n\r\n        // Compile post build connected blocks\r\n        for (const output of this._outputs) {\r\n            if (!output._forPostBuild) {\r\n                continue;\r\n            }\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        let codeString = `\\n// ${this.getClassName()}\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string, urlRewriter?: (url: string) => string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            for (let i = 0; i < serializedInputs.length; i++) {\r\n                const port = serializedInputs[i];\r\n\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            }\r\n        }\r\n        if (serializedOutputs) {\r\n            for (let i = 0; i < serializedOutputs.length; i++) {\r\n                const port = serializedOutputs[i];\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onCodeIsReadyObservable.clear();\r\n\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Immutable } from \"../../../../types\";\r\n\r\nimport type { FragmentOutputBlock } from \"../Fragment/fragmentOutputBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to output the vertex position\r\n */\r\nexport class VertexOutputBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VertexOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex, true);\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VertexOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input component\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    private _isLogarithmicDepthEnabled(nodeList: Immutable<NodeMaterialBlock[]>, useLogarithmicDepth: boolean): boolean {\r\n        if (useLogarithmicDepth) {\r\n            return true;\r\n        }\r\n\r\n        for (const node of nodeList) {\r\n            if ((node as FragmentOutputBlock).useLogarithmicDepth) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.vector;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `vertexOutputs.position = ${input.associatedVariableName};\\n`;\r\n        } else {\r\n            state.compilationString += `gl_Position = ${input.associatedVariableName};\\n`;\r\n        }\r\n\r\n        // TODOWGSL\r\n        if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state._emitVaryingFromString(\"vFragmentDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n            const fragDepth = isWebGPU ? \"vertexOutputs.vFragmentDepth\" : \"vFragmentDepth\";\r\n            const uniformP = isWebGPU ? \"uniforms.\" : \"\";\r\n            const position = isWebGPU ? \"vertexOutputs.position\" : \"gl_Position\";\r\n\r\n            state.compilationString += `${fragDepth} = 1.0 + ${position}.w;\\n`;\r\n            state.compilationString += `${position}.z = log2(max(0.000001, ${fragDepth})) * ${uniformP}logarithmicDepthConstant;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VertexOutputBlock\", VertexOutputBlock);\r\n", "/**\r\n * Enum used to define system values e.g. values automatically provided by the system\r\n */\r\nexport enum NodeMaterialSystemValues {\r\n    /** World */\r\n    World = 1,\r\n    /** View */\r\n    View = 2,\r\n    /** Projection */\r\n    Projection = 3,\r\n    /** ViewProjection */\r\n    ViewProjection = 4,\r\n    /** WorldView */\r\n    WorldView = 5,\r\n    /** WorldViewProjection */\r\n    WorldViewProjection = 6,\r\n    /** CameraPosition */\r\n    CameraPosition = 7,\r\n    /** Fog Color */\r\n    FogColor = 8,\r\n    /** Delta time */\r\n    DeltaTime = 9,\r\n    /** Camera parameters */\r\n    CameraParameters = 10,\r\n    /** Material alpha */\r\n    MaterialAlpha = 11,\r\n    /** Projection */\r\n    ProjectionInverse = 12,\r\n}\r\n", "/**\r\n * Enum defining the type of animations supported by InputBlock\r\n */\r\nexport enum AnimatedInputBlockTypes {\r\n    /** No animation */\r\n    None,\r\n    /** Time based animation (is incremented by 0.6 each second). Will only work for floats */\r\n    Time,\r\n    /** Time elapsed (in seconds) since the engine was initialized. Will only work for floats */\r\n    RealTime,\r\n    MouseInfo,\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Effect } from \"../../../../Materials/effect\";\r\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Color3, Color4, TmpColors, TmpVectors } from \"../../../../Maths/math\";\r\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes\";\r\nimport { Observable } from \"../../../../Misc/observable\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { PrecisionDate } from \"../../../../Misc/precisionDate\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\nconst remapAttributeName: { [name: string]: string } = {\r\n    position2d: \"position\",\r\n    // From particle.vertex:\r\n    particle_uv: \"vUV\",\r\n    particle_color: \"vColor\",\r\n    particle_texturemask: \"textureMask\",\r\n    particle_positionw: \"vPositionW\",\r\n    // From postprocess.vertex:\r\n    postprocess_uv: \"vUV\",\r\n};\r\n\r\nconst attributeInFragmentOnly: { [name: string]: boolean } = {\r\n    particle_uv: true,\r\n    particle_color: true,\r\n    particle_texturemask: true,\r\n    particle_positionw: true,\r\n    postprocess_uv: true,\r\n};\r\n\r\nconst attributeAsUniform: { [name: string]: boolean } = {\r\n    particle_texturemask: true,\r\n};\r\n\r\nconst attributeDefine: { [name: string]: string } = {\r\n    normal: \"NORMAL\",\r\n    tangent: \"TANGENT\",\r\n    uv: \"UV1\",\r\n    uv2: \"UV2\",\r\n    uv3: \"UV3\",\r\n    uv4: \"UV4\",\r\n    uv5: \"UV5\",\r\n    uv6: \"UV6\",\r\n    uv7: \"UV7\",\r\n    uv8: \"UV8\",\r\n};\r\n\r\n/**\r\n * Block used to expose an input value\r\n */\r\nexport class InputBlock extends NodeMaterialBlock {\r\n    private _mode = NodeMaterialBlockConnectionPointMode.Undefined;\r\n    private _associatedVariableName: string;\r\n    private _storedValue: any;\r\n    private _valueCallback: () => any;\r\n    private _type: NodeMaterialBlockConnectionPointTypes;\r\n    private _animationType = AnimatedInputBlockTypes.None;\r\n    private _prefix = \"\";\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public min: number = 0;\r\n\r\n    /** Gets or set a value used to limit the range of float values */\r\n    public max: number = 0;\r\n\r\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\r\n    public isBoolean: boolean = false;\r\n\r\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\r\n    public matrixMode: number = 0;\r\n\r\n    /** @internal */\r\n    public _systemValue: Nullable<NodeMaterialSystemValues> = null;\r\n\r\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\r\n    public isConstant = false;\r\n\r\n    /** Gets or sets the group to use to display this block in the Inspector */\r\n    public groupInInspector = \"\";\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<InputBlock>();\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this.isUniform && this.value != null) {\r\n                if (!isNaN(this.value)) {\r\n                    this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                    return this._type;\r\n                }\r\n\r\n                switch (this.value.getClassName()) {\r\n                    case \"Vector2\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"Vector3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"Vector4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"Color3\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case \"Color4\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                    case \"Matrix\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isAttribute) {\r\n                switch (this.name) {\r\n                    case \"splatIndex\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case \"position\":\r\n                    case \"normal\":\r\n                    case \"particle_positionw\":\r\n                    case \"splatPosition\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case \"uv\":\r\n                    case \"uv2\":\r\n                    case \"uv3\":\r\n                    case \"uv4\":\r\n                    case \"uv5\":\r\n                    case \"uv6\":\r\n                    case \"position2d\":\r\n                    case \"particle_uv\":\r\n                    case \"splatScale\":\r\n                    case \"postprocess_uv\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\r\n                        return this._type;\r\n                    case \"matricesIndices\":\r\n                    case \"matricesWeights\":\r\n                    case \"matricesIndicesExtra\":\r\n                    case \"matricesWeightsExtra\":\r\n                    case \"world0\":\r\n                    case \"world1\":\r\n                    case \"world2\":\r\n                    case \"world3\":\r\n                    case \"tangent\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                    case \"color\":\r\n                    case \"instanceColor\":\r\n                    case \"particle_color\":\r\n                    case \"particle_texturemask\":\r\n                    case \"splatColor\":\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color4;\r\n                        return this._type;\r\n                }\r\n            }\r\n\r\n            if (this.isSystemValue) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.World:\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                    case NodeMaterialSystemValues.View:\r\n                    case NodeMaterialSystemValues.ViewProjection:\r\n                    case NodeMaterialSystemValues.Projection:\r\n                    case NodeMaterialSystemValues.ProjectionInverse:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraPosition:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.FogColor:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Color3;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.DeltaTime:\r\n                    case NodeMaterialSystemValues.MaterialAlpha:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Float;\r\n                        return this._type;\r\n                    case NodeMaterialSystemValues.CameraParameters:\r\n                        this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n                        return this._type;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InputBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, type: NodeMaterialBlockConnectionPointTypes = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n        super(name, target, false);\r\n\r\n        this._type = type;\r\n\r\n        this.setDefaultValue();\r\n\r\n        this.registerOutput(\"output\", type);\r\n    }\r\n\r\n    /**\r\n     * Validates if a name is a reserve word.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public override validateBlockName(newName: string) {\r\n        if (!this.isAttribute) {\r\n            return super.validateBlockName(newName);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a vertex attribute\r\n     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\r\n     * @returns the current connection point\r\n     */\r\n    public setAsAttribute(attributeName?: string): InputBlock {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\r\n        if (attributeName) {\r\n            this.name = attributeName;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the source of this connection point to a system value\r\n     * @param value define the system value to use (world, view, etc...) or null to switch to manual value\r\n     * @returns the current connection point\r\n     */\r\n    public setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock {\r\n        this.systemValue = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the value of that point.\r\n     * Please note that this value will be ignored if valueCallback is defined\r\n     */\r\n    public get value(): any {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return this._storedValue;\r\n    }\r\n\r\n    public set value(value: any) {\r\n        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n            if (this.isBoolean) {\r\n                value = value ? 1 : 0;\r\n            } else if (this.min !== this.max) {\r\n                value = Math.max(this.min, value);\r\n                value = Math.min(this.max, value);\r\n            }\r\n        }\r\n\r\n        this._storedValue = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a callback used to get the value of that point.\r\n     * Please note that setting this value will force the connection point to ignore the value property\r\n     */\r\n    public get valueCallback(): () => any {\r\n        return this._valueCallback;\r\n    }\r\n\r\n    public set valueCallback(value: () => any) {\r\n        this._valueCallback = value;\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    /**\r\n     * Gets the declaration variable name in the shader\r\n     */\r\n    public get declarationVariableName(): string {\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._prefix + this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Gets or sets the type of animation applied to the input */\r\n    public get animationType() {\r\n        return this._animationType;\r\n    }\r\n\r\n    public set animationType(value: AnimatedInputBlockTypes) {\r\n        this._animationType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this connection point not defined yet\r\n     */\r\n    public get isUndefined(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an uniform.\r\n     * In this case the connection point name must be the name of the uniform to use.\r\n     * Can only be set on inputs\r\n     */\r\n    public get isUniform(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\r\n    }\r\n\r\n    public set isUniform(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is coming from an attribute.\r\n     * In this case the connection point name must be the name of the attribute to use\r\n     * Can only be set on inputs\r\n     */\r\n    public get isAttribute(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\r\n    }\r\n\r\n    public set isAttribute(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is generating a varying variable.\r\n     * Can only be set on exit points\r\n     */\r\n    public get isVarying(): boolean {\r\n        return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\r\n    }\r\n\r\n    public set isVarying(value: boolean) {\r\n        this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current connection point is a system value\r\n     */\r\n    public get isSystemValue(): boolean {\r\n        return this._systemValue != null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current well known value or null if not defined as a system value\r\n     */\r\n    public get systemValue(): Nullable<NodeMaterialSystemValues> {\r\n        return this._systemValue;\r\n    }\r\n\r\n    public set systemValue(value: Nullable<NodeMaterialSystemValues>) {\r\n        this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\r\n        this.associatedVariableName = \"\";\r\n        this._systemValue = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"InputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Animate the input if animationType !== None\r\n     * @param scene defines the rendering scene\r\n     */\r\n    public animate(scene: Scene) {\r\n        switch (this._animationType) {\r\n            case AnimatedInputBlockTypes.Time: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value += scene.getAnimationRatio() * 0.01;\r\n                }\r\n                break;\r\n            }\r\n            case AnimatedInputBlockTypes.RealTime: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                    this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1000;\r\n                }\r\n                break;\r\n            }\r\n            case AnimatedInputBlockTypes.MouseInfo: {\r\n                if (this.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    const event = scene._inputManager._originMouseEvent;\r\n                    if (event) {\r\n                        const x = event.offsetX;\r\n                        const y = event.offsetY;\r\n                        const z = (event.buttons & 1) != 0 ? 1 : 0;\r\n                        const w = (event.buttons & 2) != 0 ? 1 : 0;\r\n                        this.value = new Vector4(x, y, z, w);\r\n                    } else {\r\n                        this.value = new Vector4(0, 0, 0, 0);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _emitDefine(define: string, notDefine = false): string {\r\n        return `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n    }\r\n\r\n    public override initialize() {\r\n        this.associatedVariableName = \"\";\r\n    }\r\n\r\n    /**\r\n     * Set the input block to its default value (based on its type)\r\n     */\r\n    public setDefaultValue() {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                this.value = 0;\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                this.value = Vector2.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                this.value = Vector3.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                this.value = Vector4.Zero();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                this.value = Color3.White();\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                this.value = new Color4(1, 1, 1, 1);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                this.value = Matrix.Identity();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _emitConstant(state: NodeMaterialBuildState) {\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return `${state._emitFloat(this.value)}`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return `vec2(${this.value.x}, ${this.value.y})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _noContextSwitch(): boolean {\r\n        return attributeInFragmentOnly[this.name];\r\n    }\r\n\r\n    private _emit(state: NodeMaterialBuildState) {\r\n        // Uniforms\r\n        if (this.isUniform) {\r\n            if (!this._associatedVariableName) {\r\n                this._associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\r\n            }\r\n\r\n            if (this.isConstant) {\r\n                if (state.constants.indexOf(this.associatedVariableName) !== -1) {\r\n                    return;\r\n                }\r\n                state.constants.push(this.associatedVariableName);\r\n                state._constantDeclaration += state._declareOutput(this.output, true) + ` = ${this._emitConstant(state)};\\n`;\r\n                return;\r\n            }\r\n\r\n            if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\r\n                return;\r\n            }\r\n\r\n            state._emitUniformFromString(this._associatedVariableName, this.type);\r\n\r\n            if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._prefix = \"uniforms.\";\r\n            }\r\n\r\n            // well known\r\n            const hints = state.sharedData.hints;\r\n            if (this._systemValue !== null && this._systemValue !== undefined) {\r\n                switch (this._systemValue) {\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                        hints.needWorldViewMatrix = true;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                        hints.needWorldViewProjectionMatrix = true;\r\n                        break;\r\n                }\r\n            } else {\r\n                if (this._animationType !== AnimatedInputBlockTypes.None) {\r\n                    state.sharedData.animatedInputs.push(this);\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Attribute\r\n        if (this.isAttribute) {\r\n            this.associatedVariableName = remapAttributeName[this.name] ?? this.name;\r\n\r\n            if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\r\n                // Attribute for fragment need to be carried over by varyings\r\n                if (attributeInFragmentOnly[this.name]) {\r\n                    if (attributeAsUniform[this.name]) {\r\n                        state._emitUniformFromString(this.declarationVariableName, this.type);\r\n                        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            this._prefix = `vertexInputs.`;\r\n                        }\r\n                    } else {\r\n                        state._emitVaryingFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                } else {\r\n                    this._emit(state._vertexState);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const alreadyDeclared = state.attributes.indexOf(this.declarationVariableName) !== -1;\r\n\r\n            if (!alreadyDeclared) {\r\n                state.attributes.push(this.declarationVariableName);\r\n            }\r\n\r\n            if (attributeInFragmentOnly[this.name]) {\r\n                if (attributeAsUniform[this.name]) {\r\n                    if (!alreadyDeclared) {\r\n                        state._emitUniformFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                        this._prefix = `uniforms.`;\r\n                    }\r\n                } else {\r\n                    if (!alreadyDeclared) {\r\n                        state._emitVaryingFromString(this.declarationVariableName, this.type);\r\n                    }\r\n                    if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                        this._prefix = `fragmentInputs.`;\r\n                    }\r\n                }\r\n            } else {\r\n                if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                    if (!alreadyDeclared) {\r\n                        const defineName = attributeDefine[this.name];\r\n                        if (defineName) {\r\n                            state._attributeDeclaration += this._emitDefine(defineName);\r\n                            state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};\\n`;\r\n                            state._attributeDeclaration += `#else\\n`;\r\n                            state._attributeDeclaration += `var<private> ${this.declarationVariableName}: ${state._getShaderType(this.type)} = ${state._getShaderType(this.type)}(0.);\\n`;\r\n                            state._attributeDeclaration += `#endif\\n`;\r\n                        } else {\r\n                            state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};\\n`;\r\n                        }\r\n                    }\r\n                    this._prefix = `vertexInputs.`;\r\n                } else {\r\n                    if (!alreadyDeclared) {\r\n                        const defineName = attributeDefine[this.name];\r\n                        if (defineName) {\r\n                            state._attributeDeclaration += this._emitDefine(defineName);\r\n                            state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};\\n`;\r\n                            state._attributeDeclaration += `#else\\n`;\r\n                            state._attributeDeclaration += `${state._getShaderType(this.type)} ${this.declarationVariableName} = ${state._getShaderType(this.type)}(0.);\\n`;\r\n                            state._attributeDeclaration += `#endif\\n`;\r\n                        } else {\r\n                            state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};\\n`;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix) {\r\n        if (!this._systemValue) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this._associatedVariableName;\r\n        switch (this._systemValue) {\r\n            case NodeMaterialSystemValues.World:\r\n                effect.setMatrix(variableName, world);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldView:\r\n                effect.setMatrix(variableName, worldView);\r\n                break;\r\n            case NodeMaterialSystemValues.WorldViewProjection:\r\n                effect.setMatrix(variableName, worldViewProjection);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _transmit(effect: Effect, scene: Scene, material: NodeMaterial) {\r\n        if (this.isAttribute) {\r\n            return;\r\n        }\r\n\r\n        const variableName = this._associatedVariableName;\r\n        if (this._systemValue) {\r\n            switch (this._systemValue) {\r\n                case NodeMaterialSystemValues.World:\r\n                case NodeMaterialSystemValues.WorldView:\r\n                case NodeMaterialSystemValues.WorldViewProjection:\r\n                    return;\r\n                case NodeMaterialSystemValues.View:\r\n                    effect.setMatrix(variableName, scene.getViewMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.Projection:\r\n                    effect.setMatrix(variableName, scene.getProjectionMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.ProjectionInverse: {\r\n                    const projectionMatrix = scene.getProjectionMatrix();\r\n                    projectionMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n                    effect.setMatrix(variableName, TmpVectors.Matrix[0]);\r\n                    break;\r\n                }\r\n                case NodeMaterialSystemValues.ViewProjection:\r\n                    effect.setMatrix(variableName, scene.getTransformMatrix());\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraPosition:\r\n                    scene.bindEyePosition(effect, variableName, true);\r\n                    break;\r\n                case NodeMaterialSystemValues.FogColor:\r\n                    effect.setColor3(variableName, scene.fogColor);\r\n                    break;\r\n                case NodeMaterialSystemValues.DeltaTime:\r\n                    effect.setFloat(variableName, scene.deltaTime / 1000.0);\r\n                    break;\r\n                case NodeMaterialSystemValues.CameraParameters:\r\n                    if (scene.activeCamera) {\r\n                        effect.setFloat4(\r\n                            variableName,\r\n                            scene.getEngine().hasOriginBottomLeft ? -1 : 1,\r\n                            scene.activeCamera.minZ,\r\n                            scene.activeCamera.maxZ,\r\n                            1 / scene.activeCamera.maxZ\r\n                        );\r\n                    }\r\n                    break;\r\n                case NodeMaterialSystemValues.MaterialAlpha:\r\n                    effect.setFloat(variableName, material.alpha);\r\n                    break;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const value = this._valueCallback ? this._valueCallback() : this._storedValue;\r\n\r\n        if (value === null) {\r\n            return;\r\n        }\r\n\r\n        switch (this.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                effect.setFloat(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                effect.setInt(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setColor3(variableName, TmpColors.Color3[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\r\n                if (this.convertToGammaSpace) {\r\n                    TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                if (this.convertToLinearSpace) {\r\n                    TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\r\n                }\r\n                effect.setDirectColor4(variableName, TmpColors.Color4[0]);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                effect.setVector2(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                effect.setVector3(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                effect.setVector4(variableName, value);\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                effect.setMatrix(variableName, value);\r\n                break;\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.isUniform || this.isSystemValue) {\r\n            state.sharedData.inputBlocks.push(this);\r\n        }\r\n\r\n        this._emit(state);\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n\r\n        if (this.isAttribute) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\n`;\r\n        }\r\n        if (this.isSystemValue) {\r\n            return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue!]});\\n`;\r\n        }\r\n        if (this.isUniform) {\r\n            const codes: string[] = [];\r\n\r\n            let valueString = \"\";\r\n\r\n            switch (this.type) {\r\n                case NodeMaterialBlockConnectionPointTypes.Float:\r\n                    valueString = `${this.value}`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                    valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                    valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                    valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Color4:\r\n                    valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\r\n                    if (this.convertToGammaSpace) {\r\n                        valueString += \".toGammaSpace()\";\r\n                    }\r\n                    if (this.convertToLinearSpace) {\r\n                        valueString += \".toLinearSpace()\";\r\n                    }\r\n                    break;\r\n                case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                    valueString = `BABYLON.Matrix.FromArray([${(this.value as Matrix).m.join(\", \")}])`;\r\n                    break;\r\n            }\r\n\r\n            // Common Property \"Value\"\r\n            codes.push(`${variableName}.value = ${valueString}`);\r\n\r\n            // Float-Value-Specific Properties\r\n            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                codes.push(\r\n                    `${variableName}.min = ${this.min}`,\r\n                    `${variableName}.max = ${this.max}`,\r\n                    `${variableName}.isBoolean = ${this.isBoolean}`,\r\n                    `${variableName}.matrixMode = ${this.matrixMode}`,\r\n                    `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`\r\n                );\r\n            }\r\n\r\n            // Common Property \"Type\"\r\n            codes.push(`${variableName}.isConstant = ${this.isConstant}`);\r\n\r\n            codes.push(\"\");\r\n\r\n            return super._dumpPropertiesCode() + codes.join(\";\\n\");\r\n        }\r\n        return super._dumpPropertiesCode();\r\n    }\r\n\r\n    public override dispose() {\r\n        this.onValueChangedObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.mode = this._mode;\r\n        serializationObject.systemValue = this._systemValue;\r\n        serializationObject.animationType = this._animationType;\r\n        serializationObject.min = this.min;\r\n        serializationObject.max = this.max;\r\n        serializationObject.isBoolean = this.isBoolean;\r\n        serializationObject.matrixMode = this.matrixMode;\r\n        serializationObject.isConstant = this.isConstant;\r\n        serializationObject.groupInInspector = this.groupInInspector;\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n\r\n        if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\r\n            if (this._storedValue.asArray) {\r\n                serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\r\n                serializationObject.value = this._storedValue.asArray();\r\n            } else {\r\n                serializationObject.valueType = \"number\";\r\n                serializationObject.value = this._storedValue;\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this._mode = serializationObject.mode;\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this._type = serializationObject.type;\r\n\r\n        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\r\n        this._animationType = serializationObject.animationType;\r\n        this.min = serializationObject.min || 0;\r\n        this.max = serializationObject.max || 0;\r\n        this.isBoolean = !!serializationObject.isBoolean;\r\n        this.matrixMode = serializationObject.matrixMode || 0;\r\n        this.isConstant = !!serializationObject.isConstant;\r\n        this.groupInInspector = serializationObject.groupInInspector || \"\";\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        // Tangents back compat\r\n        if (\r\n            serializationObject.name === \"tangent\" &&\r\n            serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute &&\r\n            serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3\r\n        ) {\r\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n        }\r\n\r\n        if (!serializationObject.valueType) {\r\n            return;\r\n        }\r\n\r\n        if (serializationObject.valueType === \"number\") {\r\n            this._storedValue = serializationObject.value;\r\n        } else {\r\n            const valueType = GetClass(serializationObject.valueType);\r\n\r\n            if (valueType) {\r\n                this._storedValue = valueType.FromArray(serializationObject.value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport type { EffectFallbacks } from \"../../../effectFallbacks\";\r\nimport { BindBonesParameters, PrepareDefinesForBones } from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add support for vertex skinning (bones)\r\n */\r\nexport class BonesBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new BonesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"matricesIndices\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"matricesWeights\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"matricesIndicesExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"matricesWeightsExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"boneSampler\");\r\n        state._excludeVariableName(\"boneTextureWidth\");\r\n        state._excludeVariableName(\"mBones\");\r\n        state._excludeVariableName(\"BonesPerMesh\");\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([import(\"../../../../ShadersWGSL/ShadersInclude/bonesDeclaration\"), import(\"../../../../ShadersWGSL/ShadersInclude/bonesVertex\")]);\r\n        } else {\r\n            await Promise.all([import(\"../../../../Shaders/ShadersInclude/bonesDeclaration\"), import(\"../../../../Shaders/ShadersInclude/bonesVertex\")]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"BonesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix indices input component\r\n     */\r\n    public get matricesIndices(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix weights input component\r\n     */\r\n    public get matricesWeights(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the extra matrix indices input component\r\n     */\r\n    public get matricesIndicesExtra(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the extra matrix weights input component\r\n     */\r\n    public get matricesWeightsExtra(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.matricesIndices.isConnected) {\r\n            let matricesIndicesInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"matricesIndices\" && additionalFilteringInfo(b));\r\n\r\n            if (!matricesIndicesInput) {\r\n                matricesIndicesInput = new InputBlock(\"matricesIndices\");\r\n                matricesIndicesInput.setAsAttribute(\"matricesIndices\");\r\n            }\r\n            matricesIndicesInput.output.connectTo(this.matricesIndices);\r\n        }\r\n        if (!this.matricesWeights.isConnected) {\r\n            let matricesWeightsInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"matricesWeights\" && additionalFilteringInfo(b));\r\n\r\n            if (!matricesWeightsInput) {\r\n                matricesWeightsInput = new InputBlock(\"matricesWeights\");\r\n                matricesWeightsInput.setAsAttribute(\"matricesWeights\");\r\n            }\r\n            matricesWeightsInput.output.connectTo(this.matricesWeights);\r\n        }\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n    }\r\n\r\n    public override provideFallbacks(fallbacks: EffectFallbacks, mesh?: AbstractMesh) {\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n        }\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        BindBonesParameters(mesh, effect);\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!defines._areAttributesDirty || !mesh) {\r\n            return;\r\n        }\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for compilation fallbacks\r\n        state.sharedData.blocksWithFallbacks.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.forcedBindableBlocks.push(this);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register internal uniforms and samplers\r\n        state.uniforms.push(\"boneTextureWidth\");\r\n        state.uniforms.push(\"mBones\");\r\n\r\n        state.samplers.push(\"boneSampler\");\r\n\r\n        // Emit code\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"bonesDeclaration\", comments, {\r\n            removeAttributes: true,\r\n            removeUniforms: false,\r\n            removeVaryings: true,\r\n            removeIfDef: false,\r\n        });\r\n\r\n        const influenceVariablename = state._getFreeVariableName(\"influence\");\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"bonesVertex\", comments, {\r\n            replaceStrings: [\r\n                {\r\n                    search: /finalWorld=finalWorld\\*influence;/,\r\n                    replace: \"\",\r\n                },\r\n                {\r\n                    search: /influence/gm,\r\n                    replace: influenceVariablename,\r\n                },\r\n            ],\r\n        });\r\n\r\n        const output = this._outputs[0];\r\n        const worldInput = this.world;\r\n\r\n        state.compilationString += `#if NUM_BONE_INFLUENCERS>0\\n`;\r\n        state.compilationString += state._declareOutput(output) + ` = ${worldInput.associatedVariableName} * ${influenceVariablename};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += state._declareOutput(output) + ` = ${worldInput.associatedVariableName};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BonesBlock\", BonesBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { SubMesh } from \"../../../../Meshes/subMesh\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add support for instances\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n */\r\nexport class InstancesBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new InstancesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"world0\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"world1\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"world2\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"world3\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"instanceID\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"InstancesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the first world row input component\r\n     */\r\n    public get world0(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the second world row input component\r\n     */\r\n    public get world1(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the third world row input component\r\n     */\r\n    public get world2(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the forth world row input component\r\n     */\r\n    public get world3(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the instanceID component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get instanceID(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.world0.connectedPoint) {\r\n            let world0Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"world0\" && additionalFilteringInfo(b));\r\n\r\n            if (!world0Input) {\r\n                world0Input = new InputBlock(\"world0\");\r\n                world0Input.setAsAttribute(\"world0\");\r\n            }\r\n            world0Input.output.connectTo(this.world0);\r\n        }\r\n        if (!this.world1.connectedPoint) {\r\n            let world1Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"world1\" && additionalFilteringInfo(b));\r\n\r\n            if (!world1Input) {\r\n                world1Input = new InputBlock(\"world1\");\r\n                world1Input.setAsAttribute(\"world1\");\r\n            }\r\n            world1Input.output.connectTo(this.world1);\r\n        }\r\n        if (!this.world2.connectedPoint) {\r\n            let world2Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"world2\" && additionalFilteringInfo(b));\r\n\r\n            if (!world2Input) {\r\n                world2Input = new InputBlock(\"world2\");\r\n                world2Input.setAsAttribute(\"world2\");\r\n            }\r\n            world2Input.output.connectTo(this.world2);\r\n        }\r\n        if (!this.world3.connectedPoint) {\r\n            let world3Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"world3\" && additionalFilteringInfo(b));\r\n\r\n            if (!world3Input) {\r\n                world3Input = new InputBlock(\"world3\");\r\n                world3Input.setAsAttribute(\"world3\");\r\n            }\r\n            world3Input.output.connectTo(this.world3);\r\n        }\r\n        if (!this.world.connectedPoint) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"world\" && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        this.world.define = \"!INSTANCES || THIN_INSTANCES\";\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        let changed = false;\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines.setValue(\"INSTANCES\", useInstances);\r\n            changed = true;\r\n        }\r\n\r\n        if (subMesh && defines[\"THIN_INSTANCES\"] !== !!subMesh?.getRenderingMesh().hasThinInstances) {\r\n            defines.setValue(\"THIN_INSTANCES\", !!subMesh?.getRenderingMesh().hasThinInstances);\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const engine = state.sharedData.scene.getEngine();\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Emit code\r\n        const output = this._outputs[0];\r\n        const instanceID = this._outputs[1];\r\n        const world0 = this.world0;\r\n        const world1 = this.world1;\r\n        const world2 = this.world2;\r\n        const world3 = this.world3;\r\n\r\n        let mat4 = \"mat4\";\r\n        let instance = \"gl_InstanceID\";\r\n        let floatCast = \"float\";\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            mat4 = \"mat4x4f\";\r\n            instance = \"vertexInputs.instanceIndex\";\r\n            floatCast = \"f32\";\r\n        }\r\n\r\n        state.compilationString += `#ifdef INSTANCES\\n`;\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = ${mat4}(${world0.associatedVariableName}, ${world1.associatedVariableName}, ${world2.associatedVariableName}, ${world3.associatedVariableName});\\n`;\r\n        state.compilationString += `#ifdef THIN_INSTANCES\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = ${this.world.associatedVariableName} * ${output.associatedVariableName};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        if (engine._caps.canUseGLInstanceID) {\r\n            state.compilationString += state._declareOutput(instanceID) + ` = ${floatCast}(${instance});\\n`;\r\n        } else {\r\n            state.compilationString += state._declareOutput(instanceID) + ` = 0.0;\\n`;\r\n        }\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.world.associatedVariableName};\\n`;\r\n        state.compilationString += state._declareOutput(instanceID) + ` = 0.0;\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InstancesBlock\", InstancesBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../../../../Buffers/buffer\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport { BindMorphTargetParameters, PrepareDefinesForMorphTargets } from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\r\nexport class MorphTargetsBlock extends NodeMaterialBlock {\r\n    private _repeatableContentAnchor: string;\r\n\r\n    /**\r\n     * Create a new MorphTargetsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.tangent.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"uv2\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n        this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"uv2Output\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"colorOutput\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MorphTargetsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv2 input component\r\n     */\r\n    public get uv2(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the position output component\r\n     */\r\n    public get positionOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal output component\r\n     */\r\n    public get normalOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get tangentOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv output component\r\n     */\r\n    public get uvOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv2 output component\r\n     */\r\n    public get uv2Output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the color output component\r\n     */\r\n    public get colorOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"morphTargetInfluences\");\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/morphTargetsVertex\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/morphTargetsVertex\"),\r\n                import(\"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobal\"),\r\n                import(\"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\" && additionalFilteringInfo(b));\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n        if (!this.uv2.isConnected) {\r\n            let uv2Input = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv2\" && additionalFilteringInfo(b));\r\n\r\n            if (!uv2Input) {\r\n                uv2Input = new InputBlock(\"uv2\");\r\n                uv2Input.setAsAttribute(\"uv2\");\r\n            }\r\n            uv2Input.output.connectTo(this.uv2);\r\n        }\r\n        if (!this.color.isConnected) {\r\n            let colorInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"color\" && additionalFilteringInfo(b));\r\n\r\n            if (!colorInput) {\r\n                colorInput = new InputBlock(\"color\");\r\n                colorInput.setAsAttribute(\"color\");\r\n            }\r\n            colorInput.output.connectTo(this.color);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if ((<Mesh>mesh).morphTargetManager) {\r\n            const morphTargetManager = (<Mesh>mesh).morphTargetManager;\r\n\r\n            if (morphTargetManager?.isUsingTextureForTargets && (morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers) !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n                defines.markAsAttributesDirty();\r\n            }\r\n        }\r\n\r\n        if (!defines._areAttributesDirty) {\r\n            return;\r\n        }\r\n\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\r\n            BindMorphTargetParameters(mesh, effect);\r\n\r\n            if (mesh.morphTargetManager.isUsingTextureForTargets) {\r\n                mesh.morphTargetManager._bind(effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, defines: NodeMaterialDefines, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const uv2 = this.uv2;\r\n        const color = this.color;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const uv2Output = this.uv2Output;\r\n        const colorOutput = this.colorOutput;\r\n        const state = vertexShaderState;\r\n        const repeatCount = defines.NUM_MORPH_INFLUENCERS;\r\n\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        const supportPositions = manager && manager.supportsPositions;\r\n        const supportNormals = manager && manager.supportsNormals;\r\n        const supportTangents = manager && manager.supportsTangents;\r\n        const supportUVs = manager && manager.supportsUVs;\r\n        const supportUV2s = manager && manager.supportsUV2s;\r\n        const supportColors = manager && manager.supportsColors;\r\n\r\n        let injectionCode = \"\";\r\n\r\n        if (manager?.isUsingTextureForTargets && repeatCount > 0) {\r\n            injectionCode += `${state._declareLocalVar(\"vertexID\", NodeMaterialBlockConnectionPointTypes.Float)};\\n`;\r\n        }\r\n\r\n        injectionCode += `#ifdef MORPHTARGETS\\n`;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const uniformsPrefix = isWebGPU ? \"uniforms.\" : \"\";\r\n        if (manager?.isUsingTextureForTargets) {\r\n            injectionCode += `for (${isWebGPU ? \"var\" : \"int\"} i = 0; i < NUM_MORPH_INFLUENCERS; i++) {\\n`;\r\n            injectionCode += `if (${isWebGPU ? \"f32\" : \"float\"}(i) >= ${uniformsPrefix}morphTargetCount) { break; }\\n`;\r\n\r\n            injectionCode += `vertexID = ${isWebGPU ? \"f32(vertexInputs.vertexIndex\" : \"float(gl_VertexID\"}) * ${uniformsPrefix}morphTargetTextureInfo.x;\\n`;\r\n            if (supportPositions) {\r\n                injectionCode += `#ifdef MORPHTARGETS_POSITION\\n`;\r\n                injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${position.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];\\n`;\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n            injectionCode += `#ifdef MORPHTARGETTEXTURE_HASPOSITIONS\\n`;\r\n            injectionCode += `vertexID += 1.0;\\n`;\r\n            injectionCode += `#endif\\n`;\r\n\r\n            if (supportNormals) {\r\n                injectionCode += `#ifdef MORPHTARGETS_NORMAL\\n`;\r\n                injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${normal.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];\\n`;\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n            injectionCode += `#ifdef MORPHTARGETTEXTURE_HASNORMALS\\n`;\r\n            injectionCode += `vertexID += 1.0;\\n`;\r\n            injectionCode += `#endif\\n`;\r\n\r\n            if (supportUVs) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV\\n`;\r\n                injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${uv.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];\\n`;\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n            injectionCode += `#ifdef MORPHTARGETTEXTURE_HASUVS\\n`;\r\n            injectionCode += `vertexID += 1.0;\\n`;\r\n            injectionCode += `#endif\\n`;\r\n\r\n            if (supportTangents) {\r\n                injectionCode += `#ifdef MORPHTARGETS_TANGENT\\n`;\r\n                injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(i, vertexID) - ${tangent.associatedVariableName}.xyz) * ${uniformsPrefix}morphTargetInfluences[i];\\n`;\r\n\r\n                if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\n`;\r\n                }\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n            injectionCode += `#ifdef MORPHTARGETTEXTURE_HASTANGENTS\\n`;\r\n            injectionCode += `vertexID += 1.0;\\n`;\r\n            injectionCode += `#endif\\n`;\r\n\r\n            if (supportUV2s) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV2\\n`;\r\n                injectionCode += `${uv2Output.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${uv2.associatedVariableName}) * morphTargetInfluences[i];\\n`;\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n            injectionCode += `#ifdef MORPHTARGETTEXTURE_HASUV2S\\n`;\r\n            injectionCode += `vertexID += 1.0;\\n`;\r\n            injectionCode += `#endif\\n`;\r\n\r\n            if (supportColors) {\r\n                injectionCode += `#ifdef MORPHTARGETS_COLOR\\n`;\r\n                injectionCode += `${colorOutput.associatedVariableName} += (readVector4FromRawSampler(i, vertexID) - ${color.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[i];\\n`;\r\n                injectionCode += `#endif\\n`;\r\n            }\r\n\r\n            injectionCode += \"}\\n\";\r\n        } else {\r\n            for (let index = 0; index < repeatCount; index++) {\r\n                if (supportPositions) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_POSITION\\n`;\r\n                    injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n\r\n                if (supportNormals && defines[\"NORMAL\"]) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_NORMAL\\n`;\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n\r\n                if (supportUVs && defines[\"UV1\"]) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_UV\\n`;\r\n                    injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * ${uniformsPrefix}morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n\r\n                if (supportTangents && defines[\"TANGENT\"]) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_TANGENT\\n`;\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * ${uniformsPrefix}morphTargetInfluences[${index}];\\n`;\r\n\r\n                    if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                        injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\n`;\r\n                    } else {\r\n                        injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\n`;\r\n                    }\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n\r\n                if (supportUV2s && defines[\"UV2\"]) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_UV2\\n`;\r\n                    injectionCode += `${uv2Output.associatedVariableName}.xy += (uv2_${index} - ${uv2.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n\r\n                if (supportColors && defines[\"VERTEXCOLOR_NME\"]) {\r\n                    injectionCode += `#ifdef MORPHTARGETS_COLOR\\n`;\r\n                    injectionCode += `${colorOutput.associatedVariableName} += (color${index} - ${color.associatedVariableName}) * ${uniformsPrefix}morphTargetInfluences[${index}];\\n`;\r\n                    injectionCode += `#endif\\n`;\r\n                }\r\n            }\r\n        }\r\n        injectionCode += `#endif\\n`;\r\n\r\n        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\r\n\r\n        if (repeatCount > 0) {\r\n            for (let index = 0; index < repeatCount; index++) {\r\n                if (supportPositions) {\r\n                    state.attributes.push(VertexBuffer.PositionKind + index);\r\n                }\r\n\r\n                if (supportNormals && defines[\"NORMAL\"]) {\r\n                    state.attributes.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (supportTangents && defines[\"TANGENT\"]) {\r\n                    state.attributes.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (supportUVs && defines[\"UV1\"]) {\r\n                    state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n\r\n                if (supportUV2s && defines[\"UV2\"]) {\r\n                    state.attributes.push(VertexBuffer.UV2Kind + \"_\" + index);\r\n                }\r\n\r\n                if (supportColors && defines[\"VERTEXCOLOR_NME\"]) {\r\n                    state.attributes.push(VertexBuffer.ColorKind + index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Register for repeatable content generation\r\n        state.sharedData.repeatableContentBlocks.push(this);\r\n\r\n        // Emit code\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const uv2 = this.uv2;\r\n        const color = this.color;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const uv2Output = this.uv2Output;\r\n        const colorOutput = this.colorOutput;\r\n        const comments = `//${this.name}`;\r\n\r\n        state.uniforms.push(\"morphTargetInfluences\");\r\n        state.uniforms.push(\"morphTargetCount\");\r\n        state.uniforms.push(\"morphTargetTextureInfo\");\r\n        state.uniforms.push(\"morphTargetTextureIndices\");\r\n        state.samplers.push(\"morphTargets\");\r\n\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\r\n            repeatKey: \"maxSimultaneousMorphTargets\",\r\n        });\r\n\r\n        state.compilationString += `${state._declareOutput(positionOutput)} = ${position.associatedVariableName};\\n`;\r\n        state.compilationString += `#ifdef NORMAL\\n`;\r\n        state.compilationString += `${state._declareOutput(normalOutput)} = ${normal.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${state._declareOutput(normalOutput)} = vec3(0., 0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef TANGENT\\n`;\r\n        state.compilationString += `${state._declareOutput(tangentOutput)} = ${tangent.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${state._declareOutput(tangentOutput)} = vec4(0., 0., 0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef UV1\\n`;\r\n        state.compilationString += `${state._declareOutput(uvOutput)} = ${uv.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${state._declareOutput(uvOutput)} = vec2(0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef UV2\\n`;\r\n        state.compilationString += `${state._declareOutput(uv2Output)} = ${uv2.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${state._declareOutput(uv2Output)} = vec2(0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n        state.compilationString += `#ifdef VERTEXCOLOR_NME\\n`;\r\n        state.compilationString += `${state._declareOutput(colorOutput)} = ${color.associatedVariableName};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `${state._declareOutput(colorOutput)} = vec4(0., 0., 0., 0.);\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        // Repeatable content\r\n        this._repeatableContentAnchor = state._repeatableContentAnchor;\r\n        state.compilationString += this._repeatableContentAnchor;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\r\n    return () => new PointLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A point light is a light defined by an unique point in world space.\r\n * The light is emitted in every direction from this point.\r\n * A good example of a point light is a standard light bulb.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class PointLight extends ShadowLight {\r\n    private _shadowAngle = Math.PI / 2;\r\n    /**\r\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    @serialize()\r\n    public get shadowAngle(): number {\r\n        return this._shadowAngle;\r\n    }\r\n    /**\r\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    public set shadowAngle(value: number) {\r\n        this._shadowAngle = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Gets the direction if it has been set.\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override set direction(value: Vector3) {\r\n        const previousNeedCube = this.needCube();\r\n        this._direction = value;\r\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.recreateShadowMap();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\r\n     * A PointLight emits the light in every direction.\r\n     * It can cast shadows.\r\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\r\n     * ```javascript\r\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\r\n     * ```\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the point light in the scene\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointLight\"\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PointLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 0.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_POINTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the shadowmap should be a cube texture.\r\n     * @returns true if the shadowmap needs to be a cube texture.\r\n     */\r\n    public override needCube(): boolean {\r\n        return !this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    public override getShadowDirection(faceIndex?: number): Vector3 {\r\n        if (this.direction) {\r\n            return super.getShadowDirection(faceIndex);\r\n        } else {\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    return new Vector3(1.0, 0.0, 0.0);\r\n                case 1:\r\n                    return new Vector3(-1.0, 0.0, 0.0);\r\n                case 2:\r\n                    return new Vector3(0.0, -1.0, 0.0);\r\n                case 3:\r\n                    return new Vector3(0.0, 1.0, 0.0);\r\n                case 4:\r\n                    return new Vector3(0.0, 0.0, 1.0);\r\n                case 5:\r\n                    return new Vector3(0.0, 0.0, -1.0);\r\n            }\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\r\n     * - fov = PI / 2\r\n     * - aspect ratio : 1.0\r\n     * - z-near and far equal to the active camera minZ and maxZ.\r\n     * Returns the PointLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        const minZ = this.getDepthMinZ(activeCamera);\r\n        const maxZ = this.getDepthMaxZ(activeCamera);\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this.shadowAngle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The point light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): PointLight {\r\n        const offset = this._scene.floatingOriginOffset;\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\r\n                \"vLightData\",\r\n                this.transformedPosition.x - offset.x,\r\n                this.transformedPosition.y - offset.y,\r\n                this.transformedPosition.z - offset.z,\r\n                0.0,\r\n                lightIndex\r\n            );\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const offset = this._scene.floatingOriginOffset;\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"POINTLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.PointLight\", PointLight);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport { PointLight } from \"../../../../Lights/pointLight\";\r\nimport type { ShadowGenerator } from \"../../../../Lights/Shadows/shadowGenerator\";\r\nimport type { ShadowLight } from \"../../../../Lights\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to get data information from a light\r\n */\r\nexport class LightInformationBlock extends NodeMaterialBlock {\r\n    private _lightDataUniformName: string;\r\n    private _lightColorUniformName: string;\r\n    private _lightShadowUniformName: string;\r\n    private _lightShadowExtraUniformName: string;\r\n    private _lightTypeDefineName: string;\r\n    private _forcePrepareDefines: boolean;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /**\r\n     * Creates a new LightInformationBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerOutput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowBias\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowNormalBias\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowDepthScale\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowDepthRange\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"LightInformationBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow bias output component\r\n     */\r\n    public get shadowBias(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow normal bias output component\r\n     */\r\n    public get shadowNormalBias(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow depth scale component\r\n     */\r\n    public get shadowDepthScale(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow depth range component\r\n     */\r\n    public get shadowDepthRange(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if (this.light && this.light.isDisposed()) {\r\n            this.light = null;\r\n        }\r\n\r\n        let light = this.light;\r\n        const scene = nodeMaterial.getScene();\r\n\r\n        if (!light && scene.lights.length) {\r\n            light = this.light = scene.lights[0];\r\n            this._forcePrepareDefines = true;\r\n        }\r\n\r\n        if (!light || !light.isEnabled) {\r\n            effect.setFloat3(this._lightDataUniformName, 0, 0, 0);\r\n            effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);\r\n            return;\r\n        }\r\n\r\n        light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);\r\n\r\n        effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);\r\n\r\n        const generator = light.getShadowGenerator() as ShadowGenerator;\r\n        if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {\r\n            if (generator) {\r\n                effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);\r\n            } else {\r\n                effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        if (this.shadowDepthRange) {\r\n            if (generator && scene.activeCamera) {\r\n                const shadowLight = light as ShadowLight;\r\n                effect.setFloat2(\r\n                    this._lightShadowExtraUniformName,\r\n                    shadowLight.getDepthMinZ(scene.activeCamera),\r\n                    shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera)\r\n                );\r\n            } else {\r\n                effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        if (!defines._areLightsDirty && !this._forcePrepareDefines) {\r\n            return;\r\n        }\r\n\r\n        this._forcePrepareDefines = false;\r\n\r\n        const light = this.light;\r\n        defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const direction = this.direction;\r\n        const color = this.color;\r\n        const intensity = this.intensity;\r\n        const shadowBias = this.shadowBias;\r\n        const shadowNormalBias = this.shadowNormalBias;\r\n        const shadowDepthScale = this.shadowDepthScale;\r\n        const shadowDepthRange = this.shadowDepthRange;\r\n\r\n        this._lightDataUniformName = state._getFreeVariableName(\"lightData\");\r\n        this._lightColorUniformName = state._getFreeVariableName(\"lightColor\");\r\n        this._lightShadowUniformName = state._getFreeVariableName(\"shadowData\");\r\n        this._lightShadowExtraUniformName = state._getFreeVariableName(\"shadowExtraData\");\r\n        this._lightTypeDefineName = state._getFreeDefineName(\"LIGHTPOINTTYPE\");\r\n\r\n        const uniformAdd = state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\";\r\n\r\n        state._emitUniformFromString(this._lightDataUniformName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state._emitUniformFromString(this._lightColorUniformName, NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        state.compilationString += `#ifdef ${this._lightTypeDefineName}\\n`;\r\n        state.compilationString +=\r\n            state._declareOutput(direction) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${uniformAdd}${this._lightDataUniformName});\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += state._declareOutput(direction) + ` = ${uniformAdd}${this._lightDataUniformName};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += state._declareOutput(color) + ` = ${uniformAdd}${this._lightColorUniformName}.rgb;\\n`;\r\n        state.compilationString += state._declareOutput(intensity) + ` = ${uniformAdd}${this._lightColorUniformName}.a;\\n`;\r\n\r\n        if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {\r\n            state._emitUniformFromString(this._lightShadowUniformName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n            if (shadowBias.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(shadowBias) + ` = ${uniformAdd}${this._lightShadowUniformName}.x;\\n`;\r\n            }\r\n            if (shadowNormalBias.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(shadowNormalBias) + ` = ${uniformAdd}${this._lightShadowUniformName}.y;\\n`;\r\n            }\r\n            if (shadowDepthScale.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(shadowDepthScale) + ` = ${uniformAdd}${this._lightShadowUniformName}.z;\\n`;\r\n            }\r\n        }\r\n\r\n        if (shadowDepthRange.hasEndpoints) {\r\n            state._emitUniformFromString(this._lightShadowExtraUniformName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n            state.compilationString += state._declareOutput(shadowDepthRange) + ` = ${this._lightShadowUniformName};\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LightInformationBlock\", LightInformationBlock);\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Enum defining the type of properties that can be edited in the property pages in the node editor\r\n */\r\nexport const enum PropertyTypeForEdition {\r\n    /** property is a boolean */\r\n    Boolean,\r\n    /** property is a float */\r\n    Float,\r\n    /** property is a int */\r\n    Int,\r\n    /** property is a Vector2 */\r\n    Vector2,\r\n    /** property is a Vector3 */\r\n    Vector3,\r\n    /** property is a list of values */\r\n    List,\r\n    /** property is a Color3 */\r\n    Color3,\r\n    /** property is a Color4 */\r\n    Color4,\r\n    /** property (int) should be edited as a combo box with a list of sampling modes */\r\n    SamplingMode,\r\n    /** property (int) should be edited as a combo box with a list of texture formats */\r\n    TextureFormat,\r\n    /** property (int) should be edited as a combo box with a list of texture types */\r\n    TextureType,\r\n    /** property is a string */\r\n    String,\r\n    /** property is a matrix */\r\n    Matrix,\r\n    /** property is a viewport */\r\n    Viewport,\r\n}\r\n\r\n/**\r\n * Interface that defines an option in a variable of type list\r\n */\r\nexport interface IEditablePropertyListOption {\r\n    /** label of the option */\r\n    label: string;\r\n    /** value of the option */\r\n    value: number;\r\n}\r\n\r\n/**\r\n * Interface that defines the options available for an editable property\r\n */\r\nexport interface IEditablePropertyOption {\r\n    /**\r\n     * Define if the property is displayed inside the source block or in a separate property tab\r\n     */\r\n    embedded?: boolean;\r\n    /** min value */\r\n    min?: number;\r\n    /** max value */\r\n    max?: number;\r\n    /** notifiers: indicates which actions to take when the property is changed */\r\n    notifiers?: {\r\n        /** the entity should be rebuilt */\r\n        rebuild?: boolean;\r\n        /** the preview should be updated */\r\n        update?: boolean;\r\n        /** the onPreviewCommandActivated observer of the preview manager should be triggered */\r\n        activatePreviewCommand?: boolean;\r\n        /** a callback to trigger */\r\n        callback?: (scene: Nullable<Scene>, block: any) => boolean | undefined | void;\r\n        /** a callback to validate the property. Returns true if the property is ok, else false. If false, the rebuild/update/callback events won't be called */\r\n        onValidation?: (block: any, propertyName: string) => boolean;\r\n    };\r\n    /** list of the options for a variable of type list */\r\n    options?: IEditablePropertyListOption[];\r\n}\r\n\r\n/**\r\n * Interface that describes an editable property\r\n */\r\nexport interface IPropertyDescriptionForEdition {\r\n    /** name of the property */\r\n    propertyName: string;\r\n    /** display name of the property */\r\n    displayName: string;\r\n    /** type of the property */\r\n    type: PropertyTypeForEdition;\r\n    /** group of the property - all properties with the same group value will be displayed in a specific section */\r\n    groupName: string;\r\n    /** options for the property */\r\n    options: IEditablePropertyOption;\r\n    /** name of the class that contains the property */\r\n    className: string;\r\n}\r\n\r\n/**\r\n * Decorator that flags a property in a node block as being editable\r\n * @param displayName the display name of the property\r\n * @param propertyType the type of the property\r\n * @param groupName the group name of the property\r\n * @param options the options of the property\r\n * @returns the decorator\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function editableInPropertyPage(\r\n    displayName: string,\r\n    propertyType: PropertyTypeForEdition = PropertyTypeForEdition.Boolean,\r\n    groupName: string = \"PROPERTIES\",\r\n    options?: IEditablePropertyOption\r\n) {\r\n    return (target: any, propertyKey: string) => {\r\n        let propStore: IPropertyDescriptionForEdition[] = target._propStore;\r\n        if (!propStore) {\r\n            propStore = [];\r\n            target._propStore = propStore;\r\n        }\r\n        propStore.push({\r\n            propertyName: propertyKey,\r\n            displayName: displayName,\r\n            type: propertyType,\r\n            groupName: groupName,\r\n            options: options ?? {},\r\n            className: target.getClassName(),\r\n        });\r\n    };\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { BindLogDepth } from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Color spaces supported by the fragment output block\r\n */\r\nexport enum FragmentOutputBlockColorSpace {\r\n    /** Unspecified */\r\n    NoColorSpace,\r\n    /** Gamma */\r\n    Gamma,\r\n    /** Linear */\r\n    Linear,\r\n}\r\n\r\n/**\r\n * Block used to output the final color\r\n */\r\nexport class FragmentOutputBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _additionalColorDefineName: string;\r\n    protected _outputString: string;\r\n\r\n    /**\r\n     * Create a new FragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true, true);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"glow\", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\r\n    public convertToGammaSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\r\n    public convertToLinearSpace = false;\r\n\r\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\r\n    @editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true })\r\n    public useLogarithmicDepth = false;\r\n\r\n    /**\r\n     * Gets or sets the color space used for the block\r\n     */\r\n    @editableInPropertyPage(\"Color space\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"No color space\", value: FragmentOutputBlockColorSpace.NoColorSpace },\r\n            { label: \"Gamma\", value: FragmentOutputBlockColorSpace.Gamma },\r\n            { label: \"Linear\", value: FragmentOutputBlockColorSpace.Linear },\r\n        ],\r\n    })\r\n    public get colorSpace() {\r\n        if (this.convertToGammaSpace) {\r\n            return FragmentOutputBlockColorSpace.Gamma;\r\n        }\r\n        if (this.convertToLinearSpace) {\r\n            return FragmentOutputBlockColorSpace.Linear;\r\n        }\r\n        return FragmentOutputBlockColorSpace.NoColorSpace;\r\n    }\r\n\r\n    public set colorSpace(value: FragmentOutputBlockColorSpace) {\r\n        this.convertToGammaSpace = value === FragmentOutputBlockColorSpace.Gamma;\r\n        this.convertToLinearSpace = value === FragmentOutputBlockColorSpace.Linear;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"logarithmicDepthConstant\");\r\n        state._excludeVariableName(\"vFragmentDepth\");\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb input component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the a input component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the additionalColor input component (named glow in the UI for now)\r\n     */\r\n    public get additionalColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the glow input component\r\n     */\r\n    public get glow(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    protected _getOutputString(state: NodeMaterialBuildState): string {\r\n        return state.shaderLanguage === ShaderLanguage.WGSL ? \"fragmentOutputsColor\" : \"gl_FragColor\";\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial) {\r\n        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._additionalColorDefineName, this.additionalColor.connectedPoint && nodeMaterial._useAdditionalColor, true);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {\r\n            BindLogDepth(undefined, effect, mesh.getScene());\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgba = this.rgba;\r\n        const rgb = this.rgb;\r\n        const a = this.a;\r\n        const additionalColor = this.additionalColor;\r\n\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\r\n            state._emitUniformFromString(\"logarithmicDepthConstant\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state._emitVaryingFromString(\"vFragmentDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            state._excludeVariableName(\"useAdditionalColor\");\r\n            state._emitUniformFromString(\"useAdditionalColor\", NodeMaterialBlockConnectionPointTypes.Float);\r\n            this._additionalColorDefineName = state._getFreeDefineName(\"USEADDITIONALCOLOR\");\r\n        }\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        const outputString = this._getOutputString(state);\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `var ${outputString} : vec4<f32>;\\r\\n`;\r\n        }\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n            state.compilationString += `#ifdef ${this._additionalColorDefineName}\\n`;\r\n            if (additionalColor.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n            state.compilationString += `#else\\n`;\r\n        }\r\n\r\n        if (rgba.connectedPoint) {\r\n            if (a.isConnected) {\r\n                state.compilationString += `${outputString} = ${vec4}(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${rgba.associatedVariableName};\\n`;\r\n            }\r\n        } else if (rgb.connectedPoint) {\r\n            let aValue = \"1.0\";\r\n\r\n            if (a.connectedPoint) {\r\n                aValue = a.associatedVariableName;\r\n            }\r\n\r\n            if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            } else {\r\n                state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${aValue});\\n`;\r\n            }\r\n        } else {\r\n            state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\r\n        }\r\n\r\n        if (additionalColor.connectedPoint) {\r\n            state.compilationString += `#endif\\n`;\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${outputString}  = toLinearSpace(${outputString});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${outputString}  = toGammaSpace(${outputString});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `#if !defined(PREPASS)\\r\\n`;\r\n            state.compilationString += `fragmentOutputs.color = ${outputString};\\r\\n`;\r\n            state.compilationString += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\r\n            const fragDepth = isWebGPU ? \"input.vFragmentDepth\" : \"vFragmentDepth\";\r\n            const uniformP = isWebGPU ? \"uniforms.\" : \"\";\r\n            const output = isWebGPU ? \"fragmentOutputs.fragDepth\" : \"gl_FragDepthEXT\";\r\n\r\n            state.compilationString += `${output} = log2(${fragDepth}) * ${uniformP}logarithmicDepthConstant * 0.5;\\n`;\r\n        }\r\n\r\n        state.compilationString += `#if defined(PREPASS)\\r\\n`;\r\n        state.compilationString += `${isWebGPU ? \"fragmentOutputs.fragData0\" : \"gl_FragData[0]\"} = ${outputString};\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\r\n", "/**\r\n * Enum used to define the material modes\r\n */\r\nexport enum NodeMaterialModes {\r\n    /** Regular material */\r\n    Material = 0,\r\n    /** For post process */\r\n    PostProcess = 1,\r\n    /** For particle system */\r\n    Particle = 2,\r\n    /** For procedural texture */\r\n    ProceduralTexture = 3,\r\n    /** For gaussian splatting */\r\n    GaussianSplatting = 4,\r\n    /** For SFE */\r\n    SFE = 5,\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to get the screen sizes\r\n */\r\nexport class ScreenSizeBlock extends NodeMaterialBlock {\r\n    private _varName: string;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Name of the variable in the shader that holds the screen size\r\n     */\r\n    public get associatedVariableName(): string {\r\n        return this._varName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ScreenSizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ScreenSizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                code += `${state._declareOutput(output)} = ${varName}.${output.name};\\n`;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            state.sharedData.raiseBuildError(\"ScreenSizeBlock must only be used in a fragment shader\");\r\n            return this;\r\n        }\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._varName = state._getFreeVariableName(\"screenSize\");\r\n        state._emitUniformFromString(this._varName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        const prefix = state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\";\r\n        state.compilationString += this.writeOutputs(state, prefix + this._varName);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSizeBlock\", ScreenSizeBlock);\r\n", "import { FragmentOutputBlock } from \"./fragmentOutputBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { ScreenSizeBlock } from \"../Fragment/screenSizeBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport const SfeModeDefine = \"USE_SFE_FRAMEWORK\";\r\n\r\n/**\r\n * Block used to output the final color with Smart Filters structural support.\r\n */\r\nexport class SmartFilterFragmentOutputBlock extends FragmentOutputBlock {\r\n    /**\r\n     * Create a new SmartFilterFragmentOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SmartFilterFragmentOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        super.initialize(state);\r\n\r\n        if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {\r\n            state.sharedData.raiseBuildError(\"SmartFilterFragmentOutputBlock should not be used outside of SFE mode.\");\r\n        }\r\n\r\n        if (state.sharedData.nodeMaterial.shaderLanguage !== ShaderLanguage.GLSL) {\r\n            state.sharedData.raiseBuildError(\"WebGPU is not supported in SmartFilters mode.\");\r\n        }\r\n\r\n        // Annotate uniforms of InputBlocks and bindable blocks with their current values\r\n        if (!state.sharedData.formatConfig.getUniformAnnotation) {\r\n            state.sharedData.formatConfig.getUniformAnnotation = (name: string) => {\r\n                for (const block of state.sharedData.nodeMaterial.attachedBlocks) {\r\n                    if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name) {\r\n                        return this._generateInputBlockAnnotation(block);\r\n                    }\r\n                    if (block instanceof ScreenSizeBlock && block.associatedVariableName === name) {\r\n                        return this._generateScreenSizeBlockAnnotation();\r\n                    }\r\n                }\r\n                return \"\";\r\n            };\r\n        }\r\n\r\n        // Do our best to clean up variable names, as they will be used as display names.\r\n        state.sharedData.formatConfig.formatVariablename = (n: string) => {\r\n            let name = n;\r\n\r\n            const hasUnderscoredPrefix = name.length > 1 && name[1] === \"_\";\r\n            if (hasUnderscoredPrefix) {\r\n                name = name.substring(2);\r\n            }\r\n\r\n            return name.replace(/[^a-zA-Z]+/g, \"\");\r\n        };\r\n    }\r\n\r\n    private _generateInputBlockAnnotation(inputBlock: InputBlock): string {\r\n        const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;\r\n        return `// { \"default\": ${JSON.stringify(value)} }\\n`;\r\n    }\r\n\r\n    private _generateScreenSizeBlockAnnotation(): string {\r\n        return `// { \"autoBind\": \"outputResolution\" }\\n`;\r\n    }\r\n\r\n    private _getMainUvName(state: NodeMaterialBuildState): string {\r\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\r\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\r\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\r\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\r\n            return \"\";\r\n        }\r\n        return screenUv.associatedVariableName;\r\n    }\r\n\r\n    protected override _getOutputString(): string {\r\n        return \"outColor\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const outputString = this._getOutputString();\r\n\r\n        state._customEntryHeader += `#ifdef ${SfeModeDefine}\\n`;\r\n        state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main\\n`;\r\n        state._customEntryHeader += `#else\\n`;\r\n        state._customEntryHeader += `void main(void) {\\n`;\r\n        state._customEntryHeader += `#endif\\n`;\r\n        state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);\\n`;\r\n\r\n        state.compilationString += `\\n#ifndef ${SfeModeDefine}\\n`;\r\n        state.compilationString += `gl_FragColor = ${outputString};\\n`;\r\n        state.compilationString += `#else\\n`;\r\n        state.compilationString += `return ${outputString};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SmartFilterFragmentOutputBlock\", SmartFilterFragmentOutputBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add image processing support to fragment shader\r\n */\r\nexport class ImageProcessingBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ImageProcessingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines if the input should be converted to linear space (default: true)\r\n     */\r\n    @editableInPropertyPage(\"Convert input to linear space\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\r\n    public convertInputToLinearSpace: boolean = true;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ImageProcessingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"exposureLinear\");\r\n        state._excludeVariableName(\"contrast\");\r\n        state._excludeVariableName(\"vInverseScreenSize\");\r\n        state._excludeVariableName(\"vignetteSettings1\");\r\n        state._excludeVariableName(\"vignetteSettings2\");\r\n        state._excludeVariableName(\"vCameraColorCurveNegative\");\r\n        state._excludeVariableName(\"vCameraColorCurveNeutral\");\r\n        state._excludeVariableName(\"vCameraColorCurvePositive\");\r\n        state._excludeVariableName(\"txColorTransform\");\r\n        state._excludeVariableName(\"colorTransformSettings\");\r\n        state._excludeVariableName(\"ditherIntensity\");\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/helperFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/imageProcessingDeclaration\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/imageProcessingFunctions\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/helperFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/imageProcessingDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/imageProcessingFunctions\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    public override isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial) {\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if (!nodeMaterial.imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        nodeMaterial.imageProcessingConfiguration.bind(effect);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for blocking\r\n        state.sharedData.blockingBlocks.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Uniforms\r\n        state.uniforms.push(\"exposureLinear\");\r\n        state.uniforms.push(\"contrast\");\r\n        state.uniforms.push(\"vInverseScreenSize\");\r\n        state.uniforms.push(\"vignetteSettings1\");\r\n        state.uniforms.push(\"vignetteSettings2\");\r\n        state.uniforms.push(\"vCameraColorCurveNegative\");\r\n        state.uniforms.push(\"vCameraColorCurveNeutral\");\r\n        state.uniforms.push(\"vCameraColorCurvePositive\");\r\n        state.uniforms.push(\"txColorTransform\");\r\n        state.uniforms.push(\"colorTransformSettings\");\r\n        state.uniforms.push(\"ditherIntensity\");\r\n\r\n        // Emit code\r\n        const color = this.color;\r\n        const output = this._outputs[0];\r\n        const comments = `//${this.name}`;\r\n        const overrideText = state.shaderLanguage === ShaderLanguage.WGSL ? \"Vec3\" : \"\";\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\r\n\r\n        if (color.connectedPoint?.isConnected) {\r\n            if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                state.compilationString += `${state._declareOutput(output)} = ${color.associatedVariableName};\\n`;\r\n            } else {\r\n                state.compilationString += `${state._declareOutput(output)} = vec4${state.fSuffix}(${color.associatedVariableName}, 1.0);\\n`;\r\n            }\r\n            state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS\\n`;\r\n            if (this.convertInputToLinearSpace) {\r\n                state.compilationString += `${output.associatedVariableName} = vec4${state.fSuffix}(toLinearSpace${overrideText}(${color.associatedVariableName}.rgb), ${color.associatedVariableName}.a);\\n`;\r\n            }\r\n            state.compilationString += `#else\\n`;\r\n            state.compilationString += `#ifdef IMAGEPROCESSING\\n`;\r\n            if (this.convertInputToLinearSpace) {\r\n                state.compilationString += `${output.associatedVariableName} = vec4${state.fSuffix}(toLinearSpace${overrideText}(${color.associatedVariableName}.rgb), ${color.associatedVariableName}.a);\\n`;\r\n            }\r\n            state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});\\n`;\r\n            state.compilationString += `#endif\\n`;\r\n            state.compilationString += `#endif\\n`;\r\n\r\n            if (this.rgb.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(this.rgb) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertInputToLinearSpace = serializationObject.convertInputToLinearSpace ?? true;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageProcessingBlock\", ImageProcessingBlock);\r\n", "import type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointCompatibilityStates } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines a connection point to be used for points with a custom object type\r\n */\r\nexport class NodeMaterialConnectionPointCustomObject<T extends NodeMaterialBlock> extends NodeMaterialConnectionPoint {\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     * @param _blockType\r\n     * @param _blockName\r\n     */\r\n    public constructor(\r\n        name: string,\r\n        ownerBlock: NodeMaterialBlock,\r\n        direction: NodeMaterialConnectionPointDirection,\r\n        // @internal\r\n        public _blockType: new (...args: any[]) => T,\r\n        private _blockName: string\r\n    ) {\r\n        super(name, ownerBlock, direction);\r\n\r\n        this.needDualDirectionValidation = true;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public override checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        return connectionPoint instanceof NodeMaterialConnectionPointCustomObject && connectionPoint._blockName === this._blockName\r\n            ? NodeMaterialConnectionPointCompatibilityStates.Compatible\r\n            : NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public override createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return [new this._blockType(this._blockName), this.name];\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement TBN matrix\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class TBNBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new TBNBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.normal.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\r\n\r\n        this.registerOutput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Output, TBNBlock, \"TBNBlock\")\r\n        );\r\n\r\n        this.registerOutput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TBNBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"tbnNormal\");\r\n        state._excludeVariableName(\"tbnTangent\");\r\n        state._excludeVariableName(\"tbnBitangent\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN output component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the row0 of the output matrix\r\n     */\r\n    public get row0(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the row1 of the output matrix\r\n     */\r\n    public get row1(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the row2 of the output matrix\r\n     */\r\n    public get row2(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public override get target() {\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {}\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate(\r\n                (b) => b.isAttribute && b.name === \"tangent\" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4 && additionalFilteringInfo(b)\r\n            );\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n\r\n        let normalAvailable = normal.isConnected;\r\n        if (normal.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(normal.connectInputBlock?.name)) {\r\n            normalAvailable = false;\r\n        }\r\n\r\n        let tangentAvailable = tangent.isConnected;\r\n        if (tangent.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(tangent.connectInputBlock?.name)) {\r\n            tangentAvailable = false;\r\n        }\r\n\r\n        const useTBNBlock = normalAvailable && tangentAvailable;\r\n\r\n        defines.setValue(\"TBNBLOCK\", useTBNBlock, true);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const world = this.world;\r\n        const tbn = this.TBN;\r\n        const row0 = this.row0;\r\n        const row1 = this.row1;\r\n        const row2 = this.row2;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const mat3 = isWebGPU ? \"mat3x3f\" : \"mat3\";\r\n        const fSuffix = isWebGPU ? \"f\" : \"\";\r\n\r\n        // Fragment\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `\r\n                // ${this.name}\r\n                ${state._declareLocalVar(\"tbnNormal\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${normal.associatedVariableName}).xyz;\r\n                ${state._declareLocalVar(\"tbnTangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${tangent.associatedVariableName}.xyz);\r\n                ${state._declareLocalVar(\"tbnBitangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;\r\n                ${isWebGPU ? \"var\" : \"mat3\"} ${tbn.associatedVariableName} = ${mat3}(${world.associatedVariableName}[0].xyz, ${world.associatedVariableName}[1].xyz, ${world.associatedVariableName}[2].xyz) * ${mat3}(tbnTangent, tbnBitangent, tbnNormal);\r\n            `;\r\n\r\n            if (row0.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(row0) +\r\n                    ` = vec3${fSuffix}(${tbn.associatedVariableName}[0][0], ${tbn.associatedVariableName}[0][1], ${tbn.associatedVariableName}[0][2]);\\n`;\r\n            }\r\n            if (row1.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(row1) +\r\n                    ` = vec3${fSuffix}(${tbn.associatedVariableName}[1[0], ${tbn.associatedVariableName}[1][1], ${tbn.associatedVariableName}[1][2]);\\n`;\r\n            }\r\n            if (row2.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(row2) +\r\n                    ` = vec3${fSuffix}(${tbn.associatedVariableName}[2][0], ${tbn.associatedVariableName}[2][1], ${tbn.associatedVariableName}[2][2]);\\n`;\r\n            }\r\n\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TBNBlock\", TBNBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { TextureBlock } from \"../Dual/textureBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { TBNBlock } from \"./TBNBlock\";\r\n\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport type { Nullable } from \"../../../../types\";\r\n\r\n/**\r\n * Block used to perturb normals based on a normal map\r\n */\r\nexport class PerturbNormalBlock extends NodeMaterialBlock {\r\n    private _tangentSpaceParameterName = \"\";\r\n    private _tangentCorrectionFactorName = \"\";\r\n    private _worldMatrixName = \"\";\r\n\r\n    /** Gets or sets a boolean indicating that normal should be inverted on X axis */\r\n    @editableInPropertyPage(\"Invert X axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: true } })\r\n    public invertX = false;\r\n    /** Gets or sets a boolean indicating that normal should be inverted on Y axis */\r\n    @editableInPropertyPage(\"Invert Y axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: true } })\r\n    public invertY = false;\r\n    /** Gets or sets a boolean indicating that parallax occlusion should be enabled */\r\n    @editableInPropertyPage(\"Use parallax occlusion\", PropertyTypeForEdition.Boolean, undefined, {\r\n        embedded: true,\r\n        notifiers: {\r\n            update: true,\r\n            callback: (_scene: Nullable<Scene>, block: PerturbNormalBlock) => {\r\n                block.parallaxScale._isInactive = block.useParallaxOcclusion;\r\n                block.parallaxHeight._isInactive = block.useParallaxOcclusion;\r\n                return true;\r\n            },\r\n        },\r\n    })\r\n    public useParallaxOcclusion = false;\r\n    /** Gets or sets a boolean indicating that sampling mode is in Object space */\r\n    @editableInPropertyPage(\"Object Space Mode\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: true } })\r\n    public useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Create a new PerturbNormalBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        // Vertex\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false);\r\n        this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, false);\r\n        this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float, false);\r\n        this.registerInput(\"viewDirection\", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"parallaxScale\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"parallaxHeight\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        // Fragment\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"uvOffset\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PerturbNormalBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world tangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal map color input component\r\n     */\r\n    public get normalMapColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the strength input component\r\n     */\r\n    public get strength(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the view direction input component\r\n     */\r\n    public get viewDirection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the parallax scale input component\r\n     */\r\n    public get parallaxScale(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the parallax height input component\r\n     */\r\n    public get parallaxHeight(): NodeMaterialConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the World input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[10];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv offset output component\r\n     */\r\n    public get uvOffset(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/bumpFragment\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/bumpFragmentMainFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/bumpFragmentFunctions\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/bumpFragment\"),\r\n                import(\"../../../../Shaders/ShadersInclude/bumpFragmentMainFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/bumpFragmentFunctions\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial) {\r\n        const normalSamplerName = (this.normalMapColor.connectedPoint!._ownerBlock as TextureBlock).samplerName;\r\n        const useParallax =\r\n            this.viewDirection.isConnected && ((this.useParallaxOcclusion && !!normalSamplerName) || (!this.useParallaxOcclusion && this.parallaxHeight.isConnected));\r\n\r\n        defines.setValue(\"BUMP\", true);\r\n        defines.setValue(\"PARALLAX\", useParallax, true);\r\n        defines.setValue(\"PARALLAX_RHS\", nodeMaterial.getScene().useRightHandedSystem, true);\r\n        defines.setValue(\"PARALLAXOCCLUSION\", this.useParallaxOcclusion, true);\r\n        defines.setValue(\"OBJECTSPACE_NORMALMAP\", this.useObjectSpaceNormalMap, true);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (nodeMaterial.getScene()._mirroredCameraPosition) {\r\n            effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1.0 : -1.0, this.invertY ? 1.0 : -1.0);\r\n        } else {\r\n            effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1.0 : 1.0, this.invertY ? -1.0 : 1.0);\r\n        }\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n\r\n            if (this.useObjectSpaceNormalMap && !this.world.isConnected) {\r\n                // World default to the mesh world matrix\r\n                effect.setMatrix(this._worldMatrixName, mesh.getWorldMatrix());\r\n            }\r\n        }\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute();\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n\r\n        if (!this.strength.isConnected) {\r\n            const strengthInput = new InputBlock(\"strength\");\r\n            strengthInput.value = 1.0;\r\n            strengthInput.output.connectTo(this.strength);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPosition;\r\n        const worldNormal = this.worldNormal;\r\n        const worldTangent = this.worldTangent;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const mat3 = isWebGPU ? \"mat3x3f\" : \"mat3\";\r\n        const fSuffix = isWebGPU ? \"f\" : \"\";\r\n        const uniformPrefix = isWebGPU ? \"uniforms.\" : \"\";\r\n        const fragmentInputsPrefix = isWebGPU ? \"fragmentInputs.\" : \"\";\r\n\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._tangentSpaceParameterName = state._getFreeDefineName(\"tangentSpaceParameter\");\r\n\r\n        state._emitUniformFromString(this._tangentSpaceParameterName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n\r\n        state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._worldMatrixName = state._getFreeDefineName(\"perturbNormalWorldMatrix\");\r\n\r\n        state._emitUniformFromString(this._worldMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);\r\n\r\n        let normalSamplerName = null;\r\n        if (this.normalMapColor.connectedPoint) {\r\n            normalSamplerName = (this.normalMapColor.connectedPoint._ownerBlock as TextureBlock).samplerName;\r\n        }\r\n        const useParallax =\r\n            this.viewDirection.isConnected && ((this.useParallaxOcclusion && !!normalSamplerName) || (!this.useParallaxOcclusion && this.parallaxHeight.isConnected));\r\n\r\n        const replaceForParallaxInfos = !this.parallaxScale.isConnectedToInputBlock\r\n            ? \"0.05\"\r\n            : this.parallaxScale.connectInputBlock!.isConstant\r\n              ? state._emitFloat(this.parallaxScale.connectInputBlock!.value)\r\n              : this.parallaxScale.associatedVariableName;\r\n\r\n        const replaceForBumpInfos =\r\n            this.strength.isConnectedToInputBlock && this.strength.connectInputBlock!.isConstant\r\n                ? `\\n#if !defined(NORMALXYSCALE)\\n1.0/\\n#endif\\n${state._emitFloat(this.strength.connectInputBlock!.value)}`\r\n                : `\\n#if !defined(NORMALXYSCALE)\\n1.0/\\n#endif\\n${this.strength.associatedVariableName}`;\r\n\r\n        if (!isWebGPU) {\r\n            state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n        }\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n        const tbnVarying = { search: /varying mat3 vTBN;/g, replace: \"\" };\r\n        const normalMatrixReplaceString = { search: isWebGPU ? /uniform normalMatrix: mat4x4f;/g : /uniform mat4 normalMatrix;/g, replace: \"\" };\r\n\r\n        const tbn = this.TBN;\r\n        if (tbn.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            ${isWebGPU ? \"var\" : \"mat3\"} vTBN = ${tbn.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            state.compilationString += `${state._declareLocalVar(\"tbnNormal\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"tbnTangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"tbnBitangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${uniformPrefix}${this._tangentCorrectionFactorName};\\n`;\r\n            state.compilationString += `${isWebGPU ? \"var\" : \"mat3\"} vTBN = ${mat3}(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        let replaceStrings = [tangentReplaceString, tbnVarying, normalMatrixReplaceString];\r\n\r\n        if (isWebGPU) {\r\n            replaceStrings.push({ search: /varying vTBN0: vec3f;/g, replace: \"\" });\r\n            replaceStrings.push({ search: /varying vTBN1: vec3f;/g, replace: \"\" });\r\n            replaceStrings.push({ search: /varying vTBN2: vec3f;/g, replace: \"\" });\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: replaceStrings,\r\n        });\r\n\r\n        const replaceString0 = isWebGPU\r\n            ? \"fn parallaxOcclusion(vViewDirCoT: vec3f, vNormalCoT: vec3f, texCoord: vec2f, parallaxScale:f32, bumpSampler: texture_2d<f32>, bumpSamplerSampler: sampler)\"\r\n            : \"#define inline\\nvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)\";\r\n\r\n        const searchExp0 = isWebGPU\r\n            ? /fn parallaxOcclusion\\(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32\\)/g\r\n            : /vec2 parallaxOcclusion\\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\\)/g;\r\n\r\n        const replaceString1 = isWebGPU\r\n            ? \"fn parallaxOffset(viewDir: vec3f, heightScale: f32, height_: f32)\"\r\n            : \"vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)\";\r\n\r\n        const searchExp1 = isWebGPU ? /fn parallaxOffset\\(viewDir: vec3f,heightScale: f32\\)/g : /vec2 parallaxOffset\\(vec3 viewDir,float heightScale\\)/g;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentFunctions\", comments, {\r\n            replaceStrings: [\r\n                { search: /#include<samplerFragmentDeclaration>\\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\\)/g, replace: \"\" },\r\n                { search: /uniform sampler2D bumpSampler;/g, replace: \"\" },\r\n                {\r\n                    search: searchExp0,\r\n                    replace: replaceString0,\r\n                },\r\n                { search: searchExp1, replace: replaceString1 },\r\n                { search: /texture.+?bumpSampler,.*?vBumpUV\\)\\.w/g, replace: \"height_\" },\r\n            ],\r\n        });\r\n\r\n        const normalRead = isWebGPU ? `textureSample(${normalSamplerName}, ${normalSamplerName + Constants.AUTOSAMPLERSUFFIX}` : `texture2D(${normalSamplerName}`;\r\n\r\n        const uvForPerturbNormal = !useParallax || !normalSamplerName ? this.normalMapColor.associatedVariableName : `${normalRead}, ${uv.associatedVariableName} + uvOffset).xyz`;\r\n\r\n        const tempOutput = state._getFreeVariableName(\"tempOutput\");\r\n        state.compilationString += state._declareLocalVar(tempOutput, NodeMaterialBlockConnectionPointTypes.Vector3) + ` = vec3${fSuffix}(0.);\\n`;\r\n\r\n        replaceStrings = [\r\n            { search: new RegExp(`texture.+?bumpSampler${isWebGPU ? \"Sampler,fragmentInputs.\" : \",\"}vBumpUV\\\\)`, \"g\"), replace: `${uvForPerturbNormal}` },\r\n            {\r\n                search: /#define CUSTOM_FRAGMENT_BUMP_FRAGMENT/g,\r\n                replace: `${state._declareLocalVar(\"normalMatrix\", NodeMaterialBlockConnectionPointTypes.Matrix)} = toNormalMatrix(${this.world.isConnected ? this.world.associatedVariableName : uniformPrefix + this._worldMatrixName});`,\r\n            },\r\n            {\r\n                search: new RegExp(\r\n                    `perturbNormal\\\\(TBN,texture.+?bumpSampler${isWebGPU ? \"Sampler,fragmentInputs.\" : \",\"}vBumpUV\\\\+uvOffset\\\\).xyz,${uniformPrefix}vBumpInfos.y\\\\)`,\r\n                    \"g\"\r\n                ),\r\n                replace: `perturbNormal(TBN, ${uvForPerturbNormal}, ${uniformPrefix}vBumpInfos.y)`,\r\n            },\r\n            {\r\n                search: /parallaxOcclusion\\(invTBN\\*-viewDirectionW,invTBN\\*normalW,(fragmentInputs\\.)?vBumpUV,(uniforms\\.)?vBumpInfos.z\\)/g,\r\n                replace: `parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), ${fragmentInputsPrefix}vBumpUV, ${uniformPrefix}vBumpInfos.z, ${\r\n                    isWebGPU\r\n                        ? useParallax && this.useParallaxOcclusion\r\n                            ? `${normalSamplerName}, ${normalSamplerName + Constants.AUTOSAMPLERSUFFIX}`\r\n                            : \"bump, bumpSampler\"\r\n                        : useParallax && this.useParallaxOcclusion\r\n                          ? normalSamplerName\r\n                          : \"bumpSampler\"\r\n                })`,\r\n            },\r\n            {\r\n                search: /parallaxOffset\\(invTBN\\*viewDirectionW,vBumpInfos\\.z\\)/g,\r\n                replace: `parallaxOffset(invTBN * viewDirectionW, ${uniformPrefix}vBumpInfos.z, ${useParallax ? this.parallaxHeight.associatedVariableName : \"0.\"})`,\r\n            },\r\n            { search: isWebGPU ? /uniforms.vBumpInfos.y/g : /vBumpInfos.y/g, replace: replaceForBumpInfos },\r\n            { search: isWebGPU ? /uniforms.vBumpInfos.z/g : /vBumpInfos.z/g, replace: replaceForParallaxInfos },\r\n            { search: /normalW=/g, replace: tempOutput + \" = \" },\r\n            isWebGPU\r\n                ? {\r\n                      search: /mat3x3f\\(uniforms\\.normalMatrix\\[0\\].xyz,uniforms\\.normalMatrix\\[1\\]\\.xyz,uniforms\\.normalMatrix\\[2\\].xyz\\)\\*normalW/g,\r\n                      replace: `${mat3}(normalMatrix[0].xyz, normalMatrix[1].xyz, normalMatrix[2].xyz) * ` + tempOutput,\r\n                  }\r\n                : {\r\n                      search: /mat3\\(normalMatrix\\)\\*normalW/g,\r\n                      replace: `${mat3}(normalMatrix) * ` + tempOutput,\r\n                  },\r\n            { search: /normalW/g, replace: worldNormal.associatedVariableName + \".xyz\" },\r\n            { search: /viewDirectionW/g, replace: useParallax ? this.viewDirection.associatedVariableName : `vec3${fSuffix}(0.)` },\r\n            tangentReplaceString,\r\n        ];\r\n\r\n        if (isWebGPU) {\r\n            replaceStrings.push({ search: /fragmentInputs.vBumpUV/g, replace: uv.associatedVariableName });\r\n            replaceStrings.push({ search: /input.vPositionW/g, replace: worldPosition.associatedVariableName + \".xyz\" });\r\n            replaceStrings.push({ search: /uniforms.vTangentSpaceParams/g, replace: uniformPrefix + this._tangentSpaceParameterName });\r\n            replaceStrings.push({ search: /var TBN: mat3x3f=mat3x3<f32>\\(input.vTBN0,input.vTBN1,input.vTBN2\\);/g, replace: `var TBN = vTBN;` });\r\n        } else {\r\n            replaceStrings.push({ search: /vBumpUV/g, replace: uv.associatedVariableName });\r\n            replaceStrings.push({ search: /vPositionW/g, replace: worldPosition.associatedVariableName + \".xyz\" });\r\n            replaceStrings.push({ search: /vTangentSpaceParams/g, replace: uniformPrefix + this._tangentSpaceParameterName });\r\n        }\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"bumpFragment\", comments, {\r\n            replaceStrings: replaceStrings,\r\n        });\r\n\r\n        state.compilationString += state._declareOutput(this.output) + ` = vec4${fSuffix}(${tempOutput}, 0.);\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.invertX = ${this.invertX};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.invertY = ${this.invertY};\\n`;\r\n        codeString += `${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};\\n`;\r\n        codeString += `${this._codeVariableName}.useObjectSpaceNormalMap = ${this.useObjectSpaceNormalMap};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.invertX = this.invertX;\r\n        serializationObject.invertY = this.invertY;\r\n        serializationObject.useParallaxOcclusion = this.useParallaxOcclusion;\r\n        serializationObject.useObjectSpaceNormalMap = this.useObjectSpaceNormalMap;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.invertX = serializationObject.invertX;\r\n        this.invertY = serializationObject.invertY;\r\n        this.useParallaxOcclusion = !!serializationObject.useParallaxOcclusion;\r\n        this.useObjectSpaceNormalMap = !!serializationObject.useObjectSpaceNormalMap;\r\n\r\n        this.parallaxScale._isInactive = this.useParallaxOcclusion;\r\n        this.parallaxHeight._isInactive = this.useParallaxOcclusion;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PerturbNormalBlock\", PerturbNormalBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n/**\r\n * Block used to discard a pixel if a value is smaller than a cutoff\r\n */\r\nexport class DiscardBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new DiscardBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"cutoff\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DiscardBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the cutoff input component\r\n     */\r\n    public get cutoff(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        state.sharedData.hints.needAlphaTesting = true;\r\n\r\n        if (!this.cutoff.isConnected || !this.value.isConnected) {\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `if (${this.value.associatedVariableName} < ${this.cutoff.associatedVariableName}) { discard; }\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DiscardBlock\", DiscardBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n/**\r\n * Block used to test if the fragment shader is front facing\r\n */\r\nexport class FrontFacingBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new FrontFacingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FrontFacingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            state.sharedData.raiseBuildError(\"FrontFacingBlock must only be used in a fragment shader\");\r\n            return this;\r\n        }\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = ${state._generateTernary(\"1.0\", \"0.0\", state.shaderLanguage === ShaderLanguage.GLSL ? \"gl_FrontFacing\" : \"fragmentInputs.frontFacing\")};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FrontFacingBlock\", FrontFacingBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to get the derivative value on x and y of a given input\r\n */\r\nexport class DerivativeBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new DerivativeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerOutput(\"dx\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n        this.registerOutput(\"dy\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._outputs[1]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DerivativeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the derivative output on x\r\n     */\r\n    public get dx(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the derivative output on y\r\n     */\r\n    public get dy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const dx = this._outputs[0];\r\n        const dy = this._outputs[1];\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n        let dpdx = \"dFdx\";\r\n        let dpdy = \"dFdy\";\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            dpdx = \"dpdx\";\r\n            dpdy = \"dpdy\";\r\n        }\r\n\r\n        if (dx.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(dx) + ` = ${dpdx}(${this.input.associatedVariableName});\\n`;\r\n        }\r\n\r\n        if (dy.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(dy) + ` = ${dpdy}(${this.input.associatedVariableName});\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DerivativeBlock\", DerivativeBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to make gl_FragCoord available\r\n */\r\nexport class FragCoordBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new FragCoordBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FragCoordBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected writeOutputs(state: NodeMaterialBuildState): string {\r\n        let code = \"\";\r\n\r\n        const coord = state.shaderLanguage === ShaderLanguage.WGSL ? \"fragmentInputs.position\" : \"gl_FragCoord\";\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                code += `${state._declareOutput(output)} = ${coord}.${output.name};\\n`;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            state.sharedData.raiseBuildError(\"FragCoordBlock must only be used in a fragment shader\");\r\n            return this;\r\n        }\r\n\r\n        state.compilationString += this.writeOutputs(state);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragCoordBlock\", FragCoordBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\n\r\n/**\r\n * Block used to transform a vector3 or a vector4 into screen space\r\n */\r\nexport class ScreenSpaceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ScreenSpaceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"worldViewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ScreenSpaceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldViewProjection transform input\r\n     */\r\n    public get worldViewProjection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the x output component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the y output component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.worldViewProjection.isConnected) {\r\n            let worldViewProjectionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.WorldViewProjection && additionalFilteringInfo(b));\r\n\r\n            if (!worldViewProjectionInput) {\r\n                worldViewProjectionInput = new InputBlock(\"worldViewProjection\");\r\n                worldViewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.WorldViewProjection);\r\n            }\r\n            worldViewProjectionInput.output.connectTo(this.worldViewProjection);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const worldViewProjection = this.worldViewProjection;\r\n\r\n        if (!vector.connectedPoint) {\r\n            return;\r\n        }\r\n\r\n        const worldViewProjectionName = worldViewProjection.associatedVariableName;\r\n\r\n        const tempVariableName = state._getFreeVariableName(\"screenSpaceTemp\");\r\n\r\n        switch (vector.connectedPoint.type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                state.compilationString += `${state._declareLocalVar(tempVariableName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldViewProjectionName} * vec4${state.fSuffix}(${vector.associatedVariableName}, 1.0);\\n`;\r\n                break;\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                state.compilationString += `${state._declareLocalVar(tempVariableName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldViewProjectionName} * ${vector.associatedVariableName};\\n`;\r\n                break;\r\n        }\r\n\r\n        state.compilationString += `${tempVariableName} = vec4${state.fSuffix}(${tempVariableName}.xy / ${tempVariableName}.w, ${tempVariableName}.zw);`;\r\n        state.compilationString += `${tempVariableName} = vec4${state.fSuffix}(${tempVariableName}.xy * 0.5 + vec2${state.fSuffix}(0.5, 0.5), ${tempVariableName}.zw);`;\r\n\r\n        if (this.output.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.output) + ` = ${tempVariableName}.xy;\\n`;\r\n        }\r\n        if (this.x.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.x) + ` = ${tempVariableName}.x;\\n`;\r\n        }\r\n        if (this.y.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.y) + ` = ${tempVariableName}.y;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSpaceBlock\", ScreenSpaceBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { Vector2 } from \"../../../../Maths/math.vector\";\r\n\r\n/**\r\n * Block used to generate a twirl\r\n */\r\nexport class TwirlBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new TwirlBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"center\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TwirlBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the strength component\r\n     */\r\n    public get strength(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the center component\r\n     */\r\n    public get center(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset component\r\n     */\r\n    public get offset(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the x output component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the y output component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.center.isConnected) {\r\n            const centerInput = new InputBlock(\"center\");\r\n            centerInput.value = new Vector2(0.5, 0.5);\r\n\r\n            centerInput.output.connectTo(this.center);\r\n        }\r\n\r\n        if (!this.strength.isConnected) {\r\n            const strengthInput = new InputBlock(\"strength\");\r\n            strengthInput.value = 1.0;\r\n\r\n            strengthInput.output.connectTo(this.strength);\r\n        }\r\n\r\n        if (!this.offset.isConnected) {\r\n            const offsetInput = new InputBlock(\"offset\");\r\n            offsetInput.value = new Vector2(0, 0);\r\n\r\n            offsetInput.output.connectTo(this.offset);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const tempDelta = state._getFreeVariableName(\"delta\");\r\n        const tempAngle = state._getFreeVariableName(\"angle\");\r\n        const tempX = state._getFreeVariableName(\"x\");\r\n        const tempY = state._getFreeVariableName(\"y\");\r\n        const tempResult = state._getFreeVariableName(\"result\");\r\n\r\n        state.compilationString += `        \r\n            ${state._declareLocalVar(tempDelta, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};\r\n            ${state._declareLocalVar(tempAngle, NodeMaterialBlockConnectionPointTypes.Float)} = ${this.strength.associatedVariableName} * length(${tempDelta});\r\n            ${state._declareLocalVar(tempX, NodeMaterialBlockConnectionPointTypes.Float)} = cos(${tempAngle}) * ${tempDelta}.x - sin(${tempAngle}) * ${tempDelta}.y;\r\n            ${state._declareLocalVar(tempY, NodeMaterialBlockConnectionPointTypes.Float)} = sin(${tempAngle}) * ${tempDelta}.x + cos(${tempAngle}) * ${tempDelta}.y;\r\n            ${state._declareLocalVar(tempResult, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2(${tempX} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${tempY} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);\r\n        `;\r\n\r\n        if (this.output.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.output) + ` = ${tempResult};\\n`;\r\n        }\r\n\r\n        if (this.x.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.x) + ` = ${tempResult}.x;\\n`;\r\n        }\r\n\r\n        if (this.y.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.y) + ` = ${tempResult}.y;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TwirlBlock\", TwirlBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to convert a height vector to a normal\r\n */\r\nexport class HeightToNormalBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new HeightToNormalBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[3].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines if the output should be generated in world or tangent space.\r\n     * Note that in tangent space the result is also scaled by 0.5 and offsetted by 0.5 so that it can directly be used as a PerturbNormal.normalMapColor input\r\n     */\r\n    @editableInPropertyPage(\"Generate in world space instead of tangent space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public generateInWorldSpace: boolean = false;\r\n\r\n    /**\r\n     * Defines that the worldNormal input will be normalized by the HeightToNormal block before being used\r\n     */\r\n    @editableInPropertyPage(\"Force normalization for the worldNormal input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public automaticNormalizationNormal: boolean = true;\r\n\r\n    /**\r\n     * Defines that the worldTangent input will be normalized by the HeightToNormal block before being used\r\n     */\r\n    @editableInPropertyPage(\"Force normalization for the worldTangent input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { notifiers: { update: true } })\r\n    public automaticNormalizationTangent: boolean = true;\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"HeightToNormalBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the position component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const fPrefix = state.fSuffix;\r\n\r\n        if (!this.generateInWorldSpace && !this.worldTangent.isConnected) {\r\n            state.sharedData.raiseBuildError(`You must connect the 'worldTangent' input of the ${this.name} block!`);\r\n        }\r\n\r\n        const startCode = this.generateInWorldSpace\r\n            ? \"\"\r\n            : `\r\n            vec3 biTangent = cross(norm, tgt);\r\n            mat3 TBN = mat3(tgt, biTangent, norm);\r\n            `;\r\n\r\n        const endCode = this.generateInWorldSpace\r\n            ? \"\"\r\n            : `\r\n            result = TBN * result;\r\n            result = result * vec3(0.5) + vec3(0.5);\r\n            `;\r\n\r\n        let heightToNormal = `\r\n            vec4 heightToNormal(float height, vec3 position, vec3 tangent, vec3 normal) {\r\n                vec3 tgt = ${this.automaticNormalizationTangent ? \"normalize(tangent);\" : \"tangent;\"}\r\n                vec3 norm = ${this.automaticNormalizationNormal ? \"normalize(normal);\" : \"normal;\"}\r\n                ${startCode}\r\n                vec3 worlddX = dFdx(position);\r\n                vec3 worlddY = dFdy(position);\r\n                vec3 crossX = cross(norm, worlddX);\r\n                vec3 crossY = cross(worlddY, norm);\r\n                float d = abs(dot(crossY, worlddX));\r\n                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));\r\n                inToNormal.y *= -1.0;\r\n                vec3 result = normalize((d * norm) - inToNormal);\r\n                ${endCode}\r\n                return vec4(result, 0.);\r\n            }`;\r\n\r\n        if (isWebGPU) {\r\n            heightToNormal = state._babylonSLtoWGSL(heightToNormal);\r\n        } else {\r\n            state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n        }\r\n        state._emitFunction(\"heightToNormal\", heightToNormal, \"// heightToNormal\");\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${\r\n                this.worldTangent.isConnected ? this.worldTangent.associatedVariableName : `vec3${fPrefix}(0.)`\r\n            }.xyz, ${this.worldNormal.associatedVariableName});\\n`;\r\n\r\n        if (this.xyz.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};\\n`;\r\n        codeString += `${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.generateInWorldSpace = this.generateInWorldSpace;\r\n        serializationObject.automaticNormalizationNormal = this.automaticNormalizationNormal;\r\n        serializationObject.automaticNormalizationTangent = this.automaticNormalizationTangent;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.generateInWorldSpace = serializationObject.generateInWorldSpace;\r\n        this.automaticNormalizationNormal = serializationObject.automaticNormalizationNormal;\r\n        this.automaticNormalizationTangent = serializationObject.automaticNormalizationTangent;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HeightToNormalBlock\", HeightToNormalBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * Block used to write the fragment depth\r\n */\r\nexport class FragDepthBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new FragDepthBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"worldPos\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"viewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FragDepthBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the depth input component\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldPos input component\r\n     */\r\n    public get worldPos(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the viewProjection input component\r\n     */\r\n    public get viewProjection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const fragDepth = state.shaderLanguage === ShaderLanguage.GLSL ? \"gl_FragDepth\" : \"fragmentOutputs.fragDepth\";\r\n\r\n        if (this.depth.isConnected) {\r\n            state.compilationString += `${fragDepth} = ${this.depth.associatedVariableName};\\n`;\r\n        } else if (this.worldPos.isConnected && this.viewProjection.isConnected) {\r\n            state.compilationString += `\r\n                ${state._declareLocalVar(\"p\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.viewProjection.associatedVariableName} * ${this.worldPos.associatedVariableName};\r\n                ${state._declareLocalVar(\"v\", NodeMaterialBlockConnectionPointTypes.Float)} = p.z / p.w;\r\n                #ifndef IS_NDC_HALF_ZRANGE\r\n                    v = v * 0.5 + 0.5;\r\n                #endif\r\n                ${fragDepth} = v;\r\n    \r\n            `;\r\n        } else {\r\n            Logger.Warn(\"FragDepthBlock: either the depth input or both the worldPos and viewProjection inputs must be connected!\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FragDepthBlock\", FragDepthBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to output the depth to a shadow map\r\n */\r\nexport class ShadowMapBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ShadowMapBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n        this.registerInput(\"viewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this.worldNormal.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ShadowMapBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vPositionWSM\");\r\n        state._excludeVariableName(\"lightDataSM\");\r\n        state._excludeVariableName(\"biasAndScaleSM\");\r\n        state._excludeVariableName(\"depthValuesSM\");\r\n        state._excludeVariableName(\"clipPos\");\r\n        state._excludeVariableName(\"worldPos\");\r\n        state._excludeVariableName(\"zSM\");\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/shadowMapVertexMetric\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/packingFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/shadowMapFragment\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/shadowMapVertexMetric\"),\r\n                import(\"../../../../Shaders/ShadersInclude/packingFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/shadowMapFragment\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the view x projection input component\r\n     */\r\n    public get viewProjection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth output component\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const comments = `//${this.name}`;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        state._emitUniformFromString(\"biasAndScaleSM\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state._emitUniformFromString(\"lightDataSM\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state._emitUniformFromString(\"depthValuesSM\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        state._emitFunctionFromInclude(\"packingFunctions\", comments);\r\n\r\n        state.compilationString += `${state._declareLocalVar(\"worldPos\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.worldPosition.associatedVariableName};\\n`;\r\n        state.compilationString += `${state._declareLocalVar(\"vPositionWSM\", NodeMaterialBlockConnectionPointTypes.Vector3)};\\n`;\r\n        state.compilationString += `${state._declareLocalVar(\"vDepthMetricSM\", NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;\\n`;\r\n        state.compilationString += `${state._declareLocalVar(\"zSM\", NodeMaterialBlockConnectionPointTypes.Float)};\\n`;\r\n\r\n        if (this.worldNormal.isConnected) {\r\n            state.compilationString += `${state._declareLocalVar(\"vNormalW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexNormalBias\", comments);\r\n        }\r\n\r\n        state.compilationString += `${state._declareLocalVar(\"clipPos\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.viewProjection.associatedVariableName} * worldPos;\\n`;\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexMetric\", comments, {\r\n            replaceStrings: [\r\n                {\r\n                    search: /gl_Position/g,\r\n                    replace: \"clipPos\",\r\n                },\r\n                {\r\n                    search: /vertexOutputs.position/g,\r\n                    replace: \"clipPos\",\r\n                },\r\n                {\r\n                    search: /vertexOutputs\\.vDepthMetricSM/g,\r\n                    replace: \"vDepthMetricSM\",\r\n                },\r\n            ],\r\n        });\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"shadowMapFragment\", comments, {\r\n            replaceStrings: [\r\n                {\r\n                    search: /return;/g,\r\n                    replace: \"\",\r\n                },\r\n                {\r\n                    search: /fragmentInputs\\.vDepthMetricSM/g,\r\n                    replace: \"vDepthMetricSM\",\r\n                },\r\n            ],\r\n        });\r\n        const output = isWebGPU ? \"fragmentOutputs.fragDepth\" : \"gl_FragDepth\";\r\n        state.compilationString += `\r\n            #if SM_DEPTHTEXTURE == 1\r\n                #ifdef IS_NDC_HALF_ZRANGE\r\n                    ${output} = (clipPos.z / clipPos.w);\r\n                #else\r\n                    ${output} = (clipPos.z / clipPos.w) * 0.5 + 0.5;\r\n                #endif\r\n            #endif\r\n        `;\r\n\r\n        state.compilationString += `${state._declareOutput(this.depth)} = vec3${state.fSuffix}(depthSM, 1., 1.);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShadowMapBlock\", ShadowMapBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to output values on the prepass textures\r\n * @see https://playground.babylonjs.com/#WW65SN#9\r\n */\r\nexport class PrePassOutputBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new PrePassOutputBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true);\r\n\r\n        this.registerInput(\"viewDepth\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"screenDepth\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"localPosition\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"viewNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"reflectivity\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"velocity\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"velocityLinear\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n\r\n        this.inputs[2].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.inputs[4].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.inputs[5].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.inputs[6].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n        this.inputs[7].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.inputs[8].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PrePassOutputBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the view depth component\r\n     */\r\n    public get viewDepth(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the screen depth component\r\n     */\r\n    public get screenDepth(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the position in local space component\r\n     */\r\n    public get localPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the view normal component\r\n     */\r\n    public get viewNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the reflectivity component\r\n     */\r\n    public get reflectivity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the velocity component\r\n     */\r\n    public get velocity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity component\r\n     */\r\n    public get velocityLinear(): NodeMaterialConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    private _getFragData(isWebGPU: boolean, index: number) {\r\n        return isWebGPU ? `fragmentOutputs.fragData${index}` : `gl_FragData[${index}]`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const worldPosition = this.worldPosition;\r\n        const localPosition = this.localPosition;\r\n        const viewNormal = this.viewNormal;\r\n        const worldNormal = this.worldNormal;\r\n        const viewDepth = this.viewDepth;\r\n        const reflectivity = this.reflectivity;\r\n        const screenDepth = this.screenDepth;\r\n        const velocity = this.velocity;\r\n        const velocityLinear = this.velocityLinear;\r\n\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `#if defined(PREPASS)\\r\\n`;\r\n        state.compilationString += isWebGPU ? `var fragData: array<vec4<f32>, SCENE_MRT_COUNT>;\\r\\n` : `vec4 fragData[SCENE_MRT_COUNT];\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef PREPASS_DEPTH\\r\\n`;\r\n        if (viewDepth.connectedPoint) {\r\n            state.compilationString += ` fragData[PREPASS_DEPTH_INDEX] = ${vec4}(${viewDepth.associatedVariableName}, 0.0, 0.0, 1.0);\\r\\n`;\r\n        } else {\r\n            // We have to write something on the viewDepth output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_DEPTH_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_SCREENSPACE_DEPTH\\r\\n`;\r\n        if (screenDepth.connectedPoint) {\r\n            state.compilationString += ` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(${screenDepth.associatedVariableName}, 0.0, 0.0, 1.0);\\r\\n`;\r\n        } else {\r\n            // We have to write something on the viewDepth output or it will raise a gl error\r\n            state.compilationString += ` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_POSITION\\r\\n`;\r\n        if (worldPosition.connectedPoint) {\r\n            state.compilationString += `fragData[PREPASS_POSITION_INDEX] = ${vec4}(${worldPosition.associatedVariableName}.rgb, ${\r\n                worldPosition.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? worldPosition.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the position output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_POSITION_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_LOCAL_POSITION\\r\\n`;\r\n        if (localPosition.connectedPoint) {\r\n            state.compilationString += ` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(${localPosition.associatedVariableName}.rgb, ${\r\n                localPosition.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? localPosition.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the position output or it will raise a gl error\r\n            state.compilationString += ` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_NORMAL\\r\\n`;\r\n        if (viewNormal.connectedPoint) {\r\n            state.compilationString += ` fragData[PREPASS_NORMAL_INDEX] = ${vec4}(${viewNormal.associatedVariableName}.rgb, ${\r\n                viewNormal.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? viewNormal.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the normal output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_NORMAL_INDEX] = ${vec4}(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_WORLD_NORMAL\\r\\n`;\r\n        if (worldNormal.connectedPoint) {\r\n            state.compilationString += ` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(${worldNormal.associatedVariableName}.rgb, ${\r\n                worldNormal.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? worldNormal.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the normal output or it will raise a gl error\r\n            state.compilationString += ` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_REFLECTIVITY\\r\\n`;\r\n        if (reflectivity.connectedPoint) {\r\n            state.compilationString += ` fragData[PREPASS_REFLECTIVITY_INDEX] = ${vec4}(${reflectivity.associatedVariableName}.rgb, ${\r\n                reflectivity.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? reflectivity.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the reflectivity output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_REFLECTIVITY_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_VELOCITY\\r\\n`;\r\n        if (velocity.connectedPoint) {\r\n            state.compilationString += ` fragData[PREPASS_VELOCITY_INDEX] = ${vec4}(${velocity.associatedVariableName}.rgb, ${\r\n                velocity.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? velocity.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the reflectivity output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_VELOCITY_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef PREPASS_VELOCITY_LINEAR\\r\\n`;\r\n        if (velocityLinear.connectedPoint) {\r\n            state.compilationString += ` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${vec4}(${velocityLinear.associatedVariableName}.rgb, ${\r\n                velocityLinear.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? velocityLinear.associatedVariableName + \".a\" : \"1.0\"\r\n            });\\r\\n`;\r\n        } else {\r\n            // We have to write something on the reflectivity output or it will raise a gl error\r\n            state.compilationString += ` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${vec4}(0.0, 0.0, 0.0, 1.0);\\r\\n`;\r\n        }\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 1\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 1)} = fragData[1];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 2\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 2)} = fragData[2];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 3\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 3)} = fragData[3];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 4\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 4)} = fragData[4];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 5\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 5)} = fragData[5];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 6\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 6)} = fragData[6];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#if SCENE_MRT_COUNT > 7\\r\\n`;\r\n        state.compilationString += `${this._getFragData(isWebGPU, 7)} = fragData[7];\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PrePassOutputBlock\", PrePassOutputBlock);\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    private _waitingForData: boolean;\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean,\r\n        waitDataToBeReady?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._waitingForData = !!waitDataToBeReady && !data;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n        this._waitingForData = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        if (!this._texture) {\r\n            return super.clone();\r\n        }\r\n\r\n        const rawTexture = new RawTexture(\r\n            null,\r\n            this.getSize().width,\r\n            this.getSize().height,\r\n            this.format,\r\n            this.getScene(),\r\n            this._texture.generateMipMaps,\r\n            this._invertY,\r\n            this.samplingMode,\r\n            this._texture.type,\r\n            this._texture._creationFlags,\r\n            this._useSRGBBuffer\r\n        );\r\n\r\n        rawTexture._texture = this._texture;\r\n        this._texture.incrementReferences();\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        return super.isReady() && !this._waitingForData;\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false,\r\n        waitDataToBeReady: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            creationFlags,\r\n            useSRGBBuffer,\r\n            waitDataToBeReady\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { ShaderStore as EngineShaderStore } from \"../../Engines/shaderStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport type { _IProcessingOptions } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { WebGLShaderProcessor } from \"core/Engines/WebGL/webGLShaderProcessors\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to store node based material build state\r\n */\r\nexport class NodeMaterialBuildState {\r\n    /** Gets or sets a boolean indicating if the current state can emit uniform buffers */\r\n    public supportUniformBuffers = false;\r\n    /**\r\n     * Gets the list of emitted attributes\r\n     */\r\n    public attributes: string[] = [];\r\n    /**\r\n     * Gets the list of emitted uniforms\r\n     */\r\n    public uniforms: string[] = [];\r\n    /**\r\n     * Gets the list of emitted constants\r\n     */\r\n    public constants: string[] = [];\r\n    /**\r\n     * Gets the list of emitted samplers\r\n     */\r\n    public samplers: string[] = [];\r\n    /**\r\n     * Gets the list of emitted functions\r\n     */\r\n    public functions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted extensions\r\n     */\r\n    public extensions: { [key: string]: string } = {};\r\n    /**\r\n     * Gets the list of emitted prePass outputs - if using the prepass\r\n     */\r\n    public prePassOutput: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Gets the target of the compilation state\r\n     */\r\n    public target: NodeMaterialBlockTargets;\r\n    /**\r\n     * Gets the list of emitted counters\r\n     */\r\n    public counters: { [key: string]: number } = {};\r\n\r\n    /**\r\n     * Shared data between multiple NodeMaterialBuildState instances\r\n     */\r\n    public sharedData: NodeMaterialBuildStateSharedData;\r\n\r\n    /** @internal */\r\n    public _terminalBlocks: Set<NodeMaterialBlock> = new Set();\r\n\r\n    /** @internal */\r\n    public _vertexState: NodeMaterialBuildState;\r\n\r\n    /** @internal */\r\n    public _attributeDeclaration = \"\";\r\n    /** @internal */\r\n    public _uniformDeclaration = \"\";\r\n    /** @internal */\r\n    public _constantDeclaration = \"\";\r\n    /** @internal */\r\n    public _samplerDeclaration = \"\";\r\n    /** @internal */\r\n    public _varyingTransfer = \"\";\r\n    /** @internal */\r\n    public _injectAtEnd = \"\";\r\n    /** @internal */\r\n    public _injectAtTop = \"\";\r\n    /** @internal */\r\n    public _customEntryHeader = \"\";\r\n    /** @internal */\r\n    private _repeatableContentAnchorIndex = 0;\r\n    /** @internal */\r\n    public _builtCompilationString = \"\";\r\n\r\n    /**\r\n     * Gets the emitted compilation strings\r\n     */\r\n    public compilationString = \"\";\r\n\r\n    /**\r\n     * Gets the current shader language to use\r\n     */\r\n    public get shaderLanguage() {\r\n        return this.sharedData.nodeMaterial.shaderLanguage;\r\n    }\r\n\r\n    /** Gets suffix to add behind type casting */\r\n    public get fSuffix() {\r\n        return this.shaderLanguage === ShaderLanguage.WGSL ? \"f\" : \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the processed, compiled shader code\r\n     * @param defines defines to use for the shader processing\r\n     * @returns the raw shader code used by the engine\r\n     */\r\n    public async getProcessedShaderAsync(defines: string): Promise<string> {\r\n        if (!this._builtCompilationString) {\r\n            Logger.Error(\"getProcessedShaderAsync: Shader not built yet.\");\r\n            return \"\";\r\n        }\r\n\r\n        const engine = this.sharedData.nodeMaterial.getScene().getEngine();\r\n        const options: _IProcessingOptions = {\r\n            defines: defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: this.target === NodeMaterialBlockTargets.Fragment,\r\n            shouldUseHighPrecisionShader: engine._shouldUseHighPrecisionShader,\r\n            processor: engine._getShaderProcessor(this.shaderLanguage),\r\n            supportsUniformBuffers: engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this.shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage),\r\n            version: (engine.version * 100).toString(),\r\n            platformName: engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        // Export WebGL2 shaders with WebGL1 syntax for max compatibility\r\n        if (!engine.isWebGPU && engine.version > 1.0) {\r\n            options.processor = new WebGLShaderProcessor();\r\n        }\r\n\r\n        return await new Promise((resolve) => {\r\n            Process(\r\n                this._builtCompilationString,\r\n                options,\r\n                (migratedCode, _) => {\r\n                    resolve(migratedCode);\r\n                },\r\n                engine\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Finalize the compilation strings\r\n     * @param state defines the current compilation state\r\n     */\r\n    public finalize(state: NodeMaterialBuildState) {\r\n        const emitComments = state.sharedData.emitComments;\r\n        const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;\r\n\r\n        let entryPointString = `\\n${emitComments ? \"//Entry point\\n\" : \"\"}`;\r\n        if (this._customEntryHeader) {\r\n            entryPointString += this._customEntryHeader;\r\n        } else if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            if (isFragmentMode) {\r\n                entryPointString += `@fragment\\nfn main(input: FragmentInputs) -> FragmentOutputs {\\n${this.sharedData.varyingInitializationsFragment}`;\r\n            } else {\r\n                entryPointString += `@vertex\\nfn main(input: VertexInputs) -> FragmentInputs{\\n`;\r\n            }\r\n        } else {\r\n            entryPointString += `void main(void) {\\n`;\r\n        }\r\n\r\n        this.compilationString = entryPointString + this.compilationString;\r\n\r\n        if (this._constantDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Constants\\n\" : \"\"}${this._constantDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        let functionCode = \"\";\r\n        for (const functionName in this.functions) {\r\n            functionCode += this.functions[functionName] + `\\n`;\r\n        }\r\n        this.compilationString = `\\n${functionCode}\\n${this.compilationString}`;\r\n\r\n        if (!isFragmentMode && this._varyingTransfer) {\r\n            this.compilationString = `${this.compilationString}\\n${this._varyingTransfer}`;\r\n        }\r\n\r\n        if (this._injectAtEnd) {\r\n            this.compilationString = `${this.compilationString}\\n${this._injectAtEnd}`;\r\n        }\r\n\r\n        this.compilationString = `${this.compilationString}\\n}`;\r\n\r\n        if (this.sharedData.varyingDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Varyings\\n\" : \"\"}${isFragmentMode ? this.sharedData.varyingDeclarationFragment : this.sharedData.varyingDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._samplerDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Samplers\\n\" : \"\"}${this._samplerDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._uniformDeclaration) {\r\n            this.compilationString = `\\n${emitComments ? \"//Uniforms\\n\" : \"\"}${this._uniformDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this._attributeDeclaration && !isFragmentMode) {\r\n            this.compilationString = `\\n${emitComments ? \"//Attributes\\n\" : \"\"}${this._attributeDeclaration}\\n${this.compilationString}`;\r\n        }\r\n\r\n        if (this.shaderLanguage !== ShaderLanguage.WGSL) {\r\n            this.compilationString = \"precision highp float;\\n\" + this.compilationString;\r\n            this.compilationString = \"#if defined(WEBGL2) || defined(WEBGPU)\\nprecision highp sampler2DArray;\\n#endif\\n\" + this.compilationString;\r\n\r\n            if (isFragmentMode) {\r\n                this.compilationString =\r\n                    \"#if defined(PREPASS)\\r\\n#extension GL_EXT_draw_buffers : require\\r\\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\\r\\nhighp vec4 gl_FragColor;\\r\\n#endif\\r\\n\" +\r\n                    this.compilationString;\r\n            }\r\n\r\n            for (const extensionName in this.extensions) {\r\n                const extension = this.extensions[extensionName];\r\n                this.compilationString = `\\n${extension}\\n${this.compilationString}`;\r\n            }\r\n        }\r\n\r\n        if (this._injectAtTop) {\r\n            this.compilationString = `${this._injectAtTop}\\n${this.compilationString}`;\r\n        }\r\n\r\n        this._builtCompilationString = this.compilationString;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _repeatableContentAnchor(): string {\r\n        return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeVariableName(prefix: string): string {\r\n        prefix = this.sharedData.formatConfig.formatVariablename(prefix);\r\n\r\n        if (this.sharedData.variableNames[prefix] === undefined) {\r\n            this.sharedData.variableNames[prefix] = 0;\r\n\r\n            // Check reserved words\r\n            if (prefix === \"output\" || prefix === \"texture\") {\r\n                return prefix + this.sharedData.variableNames[prefix];\r\n            }\r\n\r\n            return prefix;\r\n        } else {\r\n            this.sharedData.variableNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.variableNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFreeDefineName(prefix: string): string {\r\n        if (this.sharedData.defineNames[prefix] === undefined) {\r\n            this.sharedData.defineNames[prefix] = 0;\r\n        } else {\r\n            this.sharedData.defineNames[prefix]++;\r\n        }\r\n\r\n        return prefix + this.sharedData.defineNames[prefix];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _excludeVariableName(name: string) {\r\n        this.sharedData.variableNames[name] = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DSampler(name: string, define = \"\", force = false, annotation?: string, unsignedSampler?: boolean, precision?: string) {\r\n        if (this.samplers.indexOf(name) < 0 || force) {\r\n            if (define) {\r\n                this._samplerDeclaration += `#if ${define}\\n`;\r\n            }\r\n\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                const unsignedSamplerPrefix = unsignedSampler ? \"u\" : \"f\";\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_2d<${unsignedSamplerPrefix}32>;\\n`;\r\n            } else {\r\n                const unsignedSamplerPrefix = unsignedSampler ? \"u\" : \"\";\r\n                const precisionDecl = precision ?? \"\";\r\n                this._samplerDeclaration += `uniform ${precisionDecl} ${unsignedSamplerPrefix}sampler2D ${name}; ${annotation ? annotation : \"\"}\\n`;\r\n            }\r\n\r\n            if (define) {\r\n                this._samplerDeclaration += `#endif\\n`;\r\n            }\r\n\r\n            if (!force) {\r\n                this.samplers.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCubeSampler(name: string, define = \"\", force = false) {\r\n        if (this.samplers.indexOf(name) < 0 || force) {\r\n            if (define) {\r\n                this._samplerDeclaration += `#if ${define}\\n`;\r\n            }\r\n\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_cube<f32>;\\n`;\r\n            } else {\r\n                this._samplerDeclaration += `uniform samplerCube ${name};\\n`;\r\n            }\r\n\r\n            if (define) {\r\n                this._samplerDeclaration += `#endif\\n`;\r\n            }\r\n\r\n            if (!force) {\r\n                this.samplers.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emit2DArraySampler(name: string) {\r\n        if (this.samplers.indexOf(name) < 0) {\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                this._samplerDeclaration += `var ${name + Constants.AUTOSAMPLERSUFFIX}: sampler;\\n`;\r\n                this._samplerDeclaration += `var ${name}: texture_2d_array<f32>;\\n`;\r\n            } else {\r\n                this._samplerDeclaration += `uniform sampler2DArray ${name};\\n`;\r\n            }\r\n            this.samplers.push(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getGLType(type: NodeMaterialBlockConnectionPointTypes): string {\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getShaderType(type: NodeMaterialBlockConnectionPointTypes) {\r\n        const isWGSL = this.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        switch (type) {\r\n            case NodeMaterialBlockConnectionPointTypes.Float:\r\n                return isWGSL ? \"f32\" : \"float\";\r\n            case NodeMaterialBlockConnectionPointTypes.Int:\r\n                return isWGSL ? \"i32\" : \"int\";\r\n            case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                return isWGSL ? \"vec2f\" : \"vec2\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color3:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                return isWGSL ? \"vec3f\" : \"vec3\";\r\n            case NodeMaterialBlockConnectionPointTypes.Color4:\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4:\r\n                return isWGSL ? \"vec4f\" : \"vec4\";\r\n            case NodeMaterialBlockConnectionPointTypes.Matrix:\r\n                return isWGSL ? \"mat4x4f\" : \"mat4\";\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitExtension(name: string, extension: string, define: string = \"\") {\r\n        if (this.extensions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (define) {\r\n            extension = `#if ${define}\\n${extension}\\n#endif`;\r\n        }\r\n        this.extensions[name] = extension;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunction(name: string, code: string, comments: string) {\r\n        if (this.functions[name]) {\r\n            return;\r\n        }\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        this.functions[name] = code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitCodeFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n        }\r\n    ) {\r\n        const store = EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage);\r\n\r\n        if (options && options.repeatKey) {\r\n            return `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n        }\r\n\r\n        let code = store[includeName] + \"\\n\";\r\n\r\n        if (this.sharedData.emitComments) {\r\n            code = comments + `\\n` + code;\r\n        }\r\n\r\n        if (!options) {\r\n            return code;\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                code = code.replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFunctionFromInclude(\r\n        includeName: string,\r\n        comments: string,\r\n        options?: {\r\n            repeatKey?: string;\r\n            substitutionVars?: string;\r\n            removeAttributes?: boolean;\r\n            removeUniforms?: boolean;\r\n            removeVaryings?: boolean;\r\n            removeIfDef?: boolean;\r\n            replaceStrings?: { search: RegExp; replace: string }[];\r\n        },\r\n        storeKey: string = \"\"\r\n    ) {\r\n        const key = includeName + storeKey;\r\n        if (this.functions[key]) {\r\n            return;\r\n        }\r\n        const store = EngineShaderStore.GetIncludesShadersStore(this.shaderLanguage);\r\n\r\n        if (!options || (!options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings)) {\r\n            if (options && options.repeatKey) {\r\n                this.functions[key] = `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\r\n            } else {\r\n                this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? \"(\" + options?.substitutionVars + \")\" : \"\"}\\n`;\r\n            }\r\n\r\n            if (this.sharedData.emitComments) {\r\n                this.functions[key] = comments + `\\n` + this.functions[key];\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.functions[key] = store[includeName];\r\n\r\n        if (this.sharedData.emitComments) {\r\n            this.functions[key] = comments + `\\n` + this.functions[key];\r\n        }\r\n\r\n        if (options.removeIfDef) {\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#ifdef.+$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#endif.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#else.*$/gm, \"\");\r\n            this.functions[key] = this.functions[key].replace(/^\\s*?#elif.*$/gm, \"\");\r\n        }\r\n\r\n        if (options.removeAttributes) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?attribute .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeUniforms) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?uniform .*?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.removeVaryings) {\r\n            this.functions[key] = this.functions[key].replace(/\\s*?(varying|in) .+?;/g, \"\\n\");\r\n        }\r\n\r\n        if (options.replaceStrings) {\r\n            for (let index = 0; index < options.replaceStrings.length; index++) {\r\n                const replaceString = options.replaceStrings[index];\r\n                this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerTempVariable(name: string) {\r\n        if (this.sharedData.temps.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.temps.push(name);\r\n        return true;\r\n    }\r\n\r\n    private _emitDefineStart(define?: string, notDefine = false) {\r\n        let code = \"\";\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                code = `#if ${define}\\n`;\r\n            } else {\r\n                code = `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _emitDefineEnd(define?: string) {\r\n        return define ? `#endif\\n` : \"\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitVaryingFromString(name: string, type: NodeMaterialBlockConnectionPointTypes, define: string = \"\", notDefine = false) {\r\n        if (this.sharedData.varyings.indexOf(name) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        this.sharedData.varyings.push(name);\r\n\r\n        const shaderType = this._getShaderType(type);\r\n\r\n        const emitCode = (forFragment = false) => {\r\n            let code = this._emitDefineStart(define, notDefine);\r\n            if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                switch (shaderType) {\r\n                    case \"i32\":\r\n                    case \"f32\":\r\n                    case \"vec2f\":\r\n                    case \"vec3f\":\r\n                    case \"vec4f\":\r\n                        code += `varying ${name}: ${shaderType};\\n`;\r\n\r\n                        if (forFragment) {\r\n                            code += `var<private> ${name}: ${shaderType};\\n`;\r\n                            this.sharedData.varyingInitializationsFragment +=\r\n                                this._emitDefineStart(define, notDefine) + `${name} = fragmentInputs.${name};\\n` + this._emitDefineEnd(define);\r\n                        }\r\n                        break;\r\n                    case \"mat4x4f\":\r\n                        // We can't pass a matrix as a varying in WGSL, so we need to split it into 4 vectors\r\n                        code += `varying ${name}_r0: vec4f;\\n`;\r\n                        code += `varying ${name}_r1: vec4f;\\n`;\r\n                        code += `varying ${name}_r2: vec4f;\\n`;\r\n                        code += `varying ${name}_r3: vec4f;\\n`;\r\n\r\n                        if (forFragment) {\r\n                            code += `var<private> ${name}: mat4x4f;\\n`;\r\n                            this.sharedData.varyingInitializationsFragment +=\r\n                                this._emitDefineStart(define, notDefine) +\r\n                                `${name} = mat4x4f(fragmentInputs.${name}_r0, fragmentInputs.${name}_r1, fragmentInputs.${name}_r2, fragmentInputs.${name}_r3);\\n` +\r\n                                this._emitDefineEnd(define);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        code += `varying ${name}: ${shaderType};\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                code += `varying ${shaderType} ${name};\\n`;\r\n            }\r\n            code += this._emitDefineEnd(define);\r\n            return code;\r\n        };\r\n\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            this.sharedData.varyingDeclaration += emitCode(false);\r\n            this.sharedData.varyingDeclarationFragment += emitCode(true);\r\n        } else {\r\n            const code = emitCode();\r\n            this.sharedData.varyingDeclaration += code;\r\n            this.sharedData.varyingDeclarationFragment += code;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getVaryingName(name: string): string {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return (this.target !== NodeMaterialBlockTargets.Fragment ? \"vertexOutputs.\" : \"fragmentInputs.\") + name;\r\n        }\r\n\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitUniformFromString(name: string, type: NodeMaterialBlockConnectionPointTypes, define: string = \"\", notDefine = false) {\r\n        if (this.uniforms.indexOf(name) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.uniforms.push(name);\r\n\r\n        if (define) {\r\n            if (define.startsWith(\"defined(\")) {\r\n                this._uniformDeclaration += `#if ${define}\\n`;\r\n            } else {\r\n                this._uniformDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\r\n            }\r\n        }\r\n        if (this.sharedData.formatConfig.getUniformAnnotation) {\r\n            this._uniformDeclaration += this.sharedData.formatConfig.getUniformAnnotation(name);\r\n        }\r\n        const shaderType = this._getShaderType(type);\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            this._uniformDeclaration += `uniform ${name}: ${shaderType};\\n`;\r\n        } else {\r\n            this._uniformDeclaration += `uniform ${shaderType} ${name};\\n`;\r\n        }\r\n        if (define) {\r\n            this._uniformDeclaration += `#endif\\n`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTernary(trueStatement: string, falseStatement: string, condition: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `select(${falseStatement}, ${trueStatement}, ${condition})`;\r\n        }\r\n\r\n        return `(${condition}) ? ${trueStatement} : ${falseStatement}`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _emitFloat(value: number) {\r\n        if (value.toString() === value.toFixed(0)) {\r\n            return `${value}.0`;\r\n        }\r\n\r\n        return value.toString();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _declareOutput(output: NodeMaterialConnectionPoint, isConst?: boolean): string {\r\n        return this._declareLocalVar(output.associatedVariableName, output.type, isConst);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _declareLocalVar(name: string, type: NodeMaterialBlockConnectionPointTypes, isConst?: boolean, isVarPrivate?: boolean): string {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${isConst ? \"const\" : \"var\" + (isVarPrivate ? \"<private>\" : \"\")} ${name}: ${this._getShaderType(type)}`;\r\n        } else {\r\n            return `${isConst ? \"const \" : \"\"}${this._getShaderType(type)} ${name}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerCubeFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSample\";\r\n        }\r\n        return \"textureCube\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSample\";\r\n        }\r\n        return \"texture2D\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _samplerLODFunc() {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSampleLevel\";\r\n        }\r\n        return \"texture2DLodEXT\";\r\n    }\r\n\r\n    public _toLinearSpace(output: NodeMaterialConnectionPoint) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            if (output.type === NodeMaterialBlockConnectionPointTypes.Color3 || output.type === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                return `toLinearSpaceVec3(${output.associatedVariableName})`;\r\n            }\r\n\r\n            return `toLinearSpace(${output.associatedVariableName})`;\r\n        }\r\n        return `toLinearSpace(${output.associatedVariableName})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSample(uv: string, samplerName: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv})`;\r\n        }\r\n        return `${this._samplerFunc()}(${samplerName}, ${uv})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleLOD(uv: string, samplerName: string, lod: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerLODFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv}, ${lod})`;\r\n        }\r\n        return `${this._samplerLODFunc()}(${samplerName}, ${uv}, ${lod})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleCube(uv: string, samplerName: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerCubeFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv})`;\r\n        }\r\n        return `${this._samplerCubeFunc()}(${samplerName}, ${uv})`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateTextureSampleCubeLOD(uv: string, samplerName: string, lod: string) {\r\n        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerCubeFunc()}(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}, ${uv}, ${lod})`;\r\n        }\r\n        return `${this._samplerCubeFunc()}(${samplerName}, ${uv}, ${lod})`;\r\n    }\r\n\r\n    private _convertVariableDeclarationToWGSL(type: string, dest: string, source: string): string {\r\n        return source.replace(new RegExp(`(${type})\\\\s+(\\\\w+)`, \"g\"), `var $2: ${dest}`);\r\n    }\r\n\r\n    private _convertVariableConstructorsToWGSL(type: string, dest: string, source: string): string {\r\n        return source.replace(new RegExp(`(${type})\\\\(`, \"g\"), ` ${dest}(`);\r\n    }\r\n\r\n    private _convertOutParametersToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`out\\\\s+var\\\\s+(\\\\w+)\\\\s*:\\\\s*(\\\\w+)`, \"g\"), `$1: ptr<function, $2>`);\r\n    }\r\n\r\n    private _convertTernaryOperandsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`\\\\[(.*?)\\\\?(.*?):(.*)\\\\]`, \"g\"), (match, condition, trueCase, falseCase) => `select(${falseCase}, ${trueCase}, ${condition})`);\r\n    }\r\n\r\n    private _convertModOperatorsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`mod\\\\((.+?),\\\\s*(.+?)\\\\)`, \"g\"), (match, left, right) => `((${left})%(${right}))`);\r\n    }\r\n\r\n    private _convertConstToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`const var`, \"g\"), `const`);\r\n    }\r\n\r\n    private _convertInnerFunctionsToWGSL(source: string): string {\r\n        return source.replace(new RegExp(`inversesqrt`, \"g\"), `inverseSqrt`);\r\n    }\r\n\r\n    private _convertFunctionsToWGSL(source: string): string {\r\n        const regex = /var\\s+(\\w+)\\s*:\\s*(\\w+)\\((.*)\\)/g;\r\n\r\n        let match: RegExpMatchArray | null;\r\n        while ((match = regex.exec(source)) !== null) {\r\n            const funcName = match[1];\r\n            const funcType = match[2];\r\n            const params = match[3]; // All parameters as a single string\r\n\r\n            // Processing the parameters to match 'name: type' format\r\n            const formattedParams = params.replace(/var\\s/g, \"\");\r\n\r\n            // Constructing the final output string\r\n            source = source.replace(match[0], `fn ${funcName}(${formattedParams}) -> ${funcType}`);\r\n        }\r\n        return source;\r\n    }\r\n\r\n    public _babylonSLtoWGSL(code: string) {\r\n        // variable declarations\r\n        code = this._convertVariableDeclarationToWGSL(\"void\", \"voidnull\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"bool\", \"bool\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"int\", \"i32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"uint\", \"u32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"float\", \"f32\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec2\", \"vec2f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec3\", \"vec3f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"vec4\", \"vec4f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat2\", \"mat2x2f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat3\", \"mat3x3f\", code);\r\n        code = this._convertVariableDeclarationToWGSL(\"mat4\", \"mat4x4f\", code);\r\n\r\n        // Type constructors\r\n        code = this._convertVariableConstructorsToWGSL(\"float\", \"f32\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec2\", \"vec2f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec3\", \"vec3f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"vec4\", \"vec4f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat2\", \"mat2x2f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat3\", \"mat3x3f\", code);\r\n        code = this._convertVariableConstructorsToWGSL(\"mat4\", \"mat4x4f\", code);\r\n\r\n        // Ternary operands\r\n        code = this._convertTernaryOperandsToWGSL(code);\r\n\r\n        // Mod operators\r\n        code = this._convertModOperatorsToWGSL(code);\r\n\r\n        // Const\r\n        code = this._convertConstToWGSL(code);\r\n\r\n        // Inner functions\r\n        code = this._convertInnerFunctionsToWGSL(code);\r\n\r\n        // Out paramters\r\n        code = this._convertOutParametersToWGSL(code);\r\n        code = code.replace(/\\[\\*\\]/g, \"*\");\r\n\r\n        // Functions\r\n        code = this._convertFunctionsToWGSL(code);\r\n\r\n        // Remove voidnull\r\n        code = code.replace(/\\s->\\svoidnull/g, \"\");\r\n\r\n        // Derivatives\r\n        code = code.replace(/dFdx/g, \"dpdx\");\r\n        code = code.replace(/dFdy/g, \"dpdy\");\r\n\r\n        return code;\r\n    }\r\n\r\n    private _convertTernaryOperandsToGLSL(source: string): string {\r\n        return source.replace(new RegExp(`\\\\[(.+?)\\\\?(.+?):(.+)\\\\]`, \"g\"), (match, condition, trueCase, falseCase) => `${condition} ? ${trueCase} : ${falseCase}`);\r\n    }\r\n\r\n    public _babylonSLtoGLSL(code: string) {\r\n        /** Remove BSL specifics */\r\n        code = code.replace(/\\[\\*\\]/g, \"\");\r\n        code = this._convertTernaryOperandsToGLSL(code);\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Immutable, Nullable } from \"../../types\";\r\nimport type { NodeMaterial, NodeMaterialTextureBlocks } from \"./nodeMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n     * The node material we are currently building\r\n     */\r\n    public nodeMaterial: NodeMaterial;\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public temps: string[] = [];\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings: string[] = [];\r\n\r\n    /**\r\n     * Gets the varying declaration string (for vertex shader)\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * Gets the varying declaration string (for fragment shader)\r\n     * This is potentially different from varyingDeclaration only in WebGPU\r\n     */\r\n    public varyingDeclarationFragment = \"\";\r\n\r\n    /**\r\n     * Gets the varying initialization string (for fragment shader)\r\n     * Only used in WebGPU, to reconstruct the varying values from the vertex shader if their types is mat4x4f\r\n     */\r\n    public varyingInitializationsFragment = \"\";\r\n\r\n    /**\r\n     * List of the fragment output nodes\r\n     */\r\n    public fragmentOutputNodes: Immutable<Array<NodeMaterialBlock>>;\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks: InputBlock[] = [];\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\r\n     */\r\n    public forcedBindableBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a repeatable content\r\n     */\r\n    public repeatableContentBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can provide a dynamic list of uniforms\r\n     */\r\n    public dynamicUniformBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs: InputBlock[] = [];\r\n\r\n    /**\r\n     * Configurations used to format the generated code\r\n     */\r\n    public formatConfig = {\r\n        getUniformAnnotation: null as Nullable<(name: string) => string>,\r\n        formatVariablename: (name: string) => name.replace(/[^a-zA-Z_]+/g, \"\"),\r\n    };\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false,\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>(),\r\n        customErrors: new Array<string>(),\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Push a new error to the build state, avoiding exceptions that can break the build process\r\n     * @param message defines the error message to push\r\n     */\r\n    public raiseBuildError(message: string) {\r\n        if (this.checks.customErrors.indexOf(message) !== -1) {\r\n            this.checks.customErrors.push(message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     * @returns true if all checks pass\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.\\n\";\r\n        }\r\n        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\r\n        }\r\n        for (const customError of this.checks.customErrors) {\r\n            errorMessage += customError + \"\\n\";\r\n        }\r\n\r\n        if (errorMessage) {\r\n            errorMessage = \"Node material build failed: \\n\" + errorMessage;\r\n            Logger.Error(errorMessage);\r\n            this.nodeMaterial.onBuildErrorObservable.notifyObservers(errorMessage);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { InputBlock } from \"./Input/inputBlock\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\r\n */\r\nexport class TransformBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Defines the value to use to complement W value to transform it to a Vector4\r\n     */\r\n    public complementW = 1;\r\n\r\n    /**\r\n     * Defines the value to use to complement z value to transform it to a Vector4\r\n     */\r\n    public complementZ = 0;\r\n\r\n    /**\r\n     * Boolean indicating if the transformation is made for a direction vector and not a position vector\r\n     * If set to true the complementW value will be set to 0 else it will be set to 1\r\n     */\r\n    @editableInPropertyPage(\"Transform as direction\", PropertyTypeForEdition.Boolean, undefined, { embedded: true })\r\n    public get transformAsDirection() {\r\n        return this.complementW === 0;\r\n    }\r\n\r\n    public set transformAsDirection(value: boolean) {\r\n        this.complementW = value ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a new TransformBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.target = NodeMaterialBlockTargets.Vertex;\r\n\r\n        this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (other.ownerBlock.isInput) {\r\n                const otherAsInput = other.ownerBlock as InputBlock;\r\n\r\n                if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\r\n                    this.complementW = 0;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TransformBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vector input\r\n     */\r\n    public get vector(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz output component\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix transform input\r\n     */\r\n    public get transform(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const vector = this.vector;\r\n        const transform = this.transform;\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        if (vector.connectedPoint) {\r\n            // None uniform scaling case.\r\n            if (this.complementW === 0 || this.transformAsDirection) {\r\n                const comments = `//${this.name}`;\r\n                state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n                state.sharedData.blocksWithDefines.push(this);\r\n\r\n                const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\r\n                if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                    state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);\\n`;\r\n                } else {\r\n                    state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\r\n                }\r\n                state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\r\n                state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\r\n                state.compilationString += `#endif\\n`;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) +\r\n                            ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                }\r\n            } else {\r\n                const transformName = transform.associatedVariableName;\r\n                switch (vector.connectedPoint.type) {\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector2:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) +\r\n                            ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    case NodeMaterialBlockConnectionPointTypes.Vector3:\r\n                    case NodeMaterialBlockConnectionPointTypes.Color3:\r\n                        state.compilationString +=\r\n                            state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\r\n                        break;\r\n                    default:\r\n                        state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            if (this.xyz.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (mesh && mesh.nonUniformScaling) {\r\n            defines.setValue(\"NONUNIFORMSCALING\", true);\r\n        }\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.complementZ = this.complementZ;\r\n        serializationObject.complementW = this.complementW;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\r\n        this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\n/**\r\n * Base block used as input for post process\r\n */\r\nexport class CurrentScreenBlock extends NodeMaterialBlock {\r\n    protected _samplerName = \"textureSampler\";\r\n    protected _linearDefineName: string;\r\n    protected _gammaDefineName: string;\r\n    protected _mainUVName: string;\r\n    protected _tempTextureRead: string;\r\n    protected _texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The name of the sampler to read the screen texture from.\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n    public set texture(value: Nullable<BaseTexture>) {\r\n        this._texture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new CurrentScreenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CurrentScreenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(this.samplerName);\r\n    }\r\n\r\n    public override get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _getMainUvName(state: NodeMaterialBuildState): string {\r\n        return \"vMain\" + this.uv.associatedVariableName;\r\n    }\r\n\r\n    protected _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n            }\r\n        }\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n            const textureReadFunc =\r\n                state.shaderLanguage === ShaderLanguage.GLSL\r\n                    ? `texture2D(${this.samplerName},`\r\n                    : `textureSampleLevel(${this.samplerName}, ${this.samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n            const complement = state.shaderLanguage === ShaderLanguage.GLSL ? \"\" : \", 0\";\r\n\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName}${complement});\\n`;\r\n            return;\r\n        }\r\n\r\n        const textureReadFunc =\r\n            state.shaderLanguage === ShaderLanguage.GLSL\r\n                ? `texture2D(${this.samplerName},`\r\n                : `textureSample(${this.samplerName}, ${this.samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName});\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    protected _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected _emitUvAndSampler(state: NodeMaterialBuildState) {\r\n        state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        state._emit2DSampler(this.samplerName);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\r\n            state.sharedData.blockingBlocks.push(this);\r\n        }\r\n        if (state.sharedData.textureBlocks.indexOf(this) < 0) {\r\n            state.sharedData.textureBlocks.push(this);\r\n        }\r\n        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n        this._mainUVName = this._getMainUvName(state);\r\n\r\n        this._emitUvAndSampler(state);\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines, NodeMaterial } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\" && additionalFilteringInfo(b));\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(this.uv.associatedVariableName, this._samplerName)};\\n`;\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used for the particle ramp gradient section\r\n */\r\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleRampGradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleRampGradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rampColor output component\r\n     */\r\n    public get rampColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"remapRanges\");\r\n        state._excludeVariableName(\"rampSampler\");\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"alpha\");\r\n        state._excludeVariableName(\"remappedColorIndex\");\r\n        state._excludeVariableName(\"rampColor\");\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(\"rampSampler\", \"RAMPGRADIENT\");\r\n        state._emitVaryingFromString(\"remapRanges\", NodeMaterialBlockConnectionPointTypes.Vector4, \"RAMPGRADIENT\");\r\n\r\n        const varyingString = state.shaderLanguage === ShaderLanguage.GLSL ? \"\" : \"fragmentInputs.\";\r\n\r\n        state.compilationString += `\r\n            #ifdef RAMPGRADIENT\r\n                ${state._declareLocalVar(\"baseColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.color.associatedVariableName};\r\n                ${state._declareLocalVar(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.color.associatedVariableName}.a;\r\n\r\n                ${state._declareLocalVar(\"remappedColorIndex\", NodeMaterialBlockConnectionPointTypes.Float)} = clamp((alpha - ${varyingString}remapRanges.x) / ${varyingString}remapRanges.y, 0.0, 1.0);\r\n\r\n                ${state._declareLocalVar(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(\"vec2(1.0 - remappedColorIndex, 0.)\", \"rampSampler\")};\r\n\r\n                // Remapped alpha\r\n                ${state._declareOutput(this.rampColor)} = vec4${state.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${varyingString}remapRanges.z) / ${varyingString}remapRanges.w, 0.0, 1.0));\r\n            #else\r\n                ${state._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle blend multiply section\r\n */\r\nexport class ParticleBlendMultiplyBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleBlendMultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaTexture\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"alphaColor\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"blendColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ParticleBlendMultiplyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaTexture input component\r\n     */\r\n    public get alphaTexture(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the alphaColor input component\r\n     */\r\n    public get alphaColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the blendColor output component\r\n     */\r\n    public get blendColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sourceAlpha\");\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `\r\n            #ifdef BLENDMULTIPLYMODE\r\n                ${state._declareOutput(this.blendColor)};\r\n                ${state._declareLocalVar(\"sourceAlpha\", NodeMaterialBlockConnectionPointTypes.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};\r\n                ${this.blendColor.associatedVariableName} = vec4${state.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);\r\n            #else\r\n                ${state._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleBlendMultiplyBlock\", ParticleBlendMultiplyBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Block used to create a Vector2/3/4 out of individual inputs (one for each component)\r\n */\r\nexport class VectorMergerBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the swizzle for x (meaning which component to affect to the output.x)\r\n     */\r\n    public xSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"x\";\r\n    /**\r\n     * Gets or sets the swizzle for y (meaning which component to affect to the output.y)\r\n     */\r\n    public ySwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"y\";\r\n    /**\r\n     * Gets or sets the swizzle for z (meaning which component to affect to the output.z)\r\n     */\r\n    public zSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"z\";\r\n    /**\r\n     * Gets or sets the swizzle for w (meaning which component to affect to the output.w)\r\n     */\r\n    public wSwizzle: \"x\" | \"y\" | \"z\" | \"w\" = \"w\";\r\n\r\n    /**\r\n     * Create a new VectorMergerBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"xyzw \", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"zw \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n        this.registerInput(\"x\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"y\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"z\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"w\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VectorMergerBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (input)\r\n     */\r\n    public get zwIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (input)\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (input)\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (input)\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (input)\r\n     */\r\n    public get w(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (output)\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zwOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     * @deprecated Please use xyOut instead.\r\n     */\r\n    public get xy(): NodeMaterialConnectionPoint {\r\n        return this.xyOut;\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     * @deprecated Please use xyzOut instead.\r\n     */\r\n    public get xyz(): NodeMaterialConnectionPoint {\r\n        return this.xyzOut;\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"xyzw \") {\r\n            return \"xyzwIn\";\r\n        }\r\n        if (name === \"xyz \") {\r\n            return \"xyzIn\";\r\n        }\r\n        if (name === \"xy \") {\r\n            return \"xyIn\";\r\n        }\r\n        if (name === \"zw \") {\r\n            return \"zwIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private _buildSwizzle(len: number) {\r\n        const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;\r\n\r\n        return \".\" + swizzle.substring(0, len);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const xInput = this.x;\r\n        const yInput = this.y;\r\n        const zInput = this.z;\r\n        const wInput = this.w;\r\n        const xyInput = this.xyIn;\r\n        const zwInput = this.zwIn;\r\n        const xyzInput = this.xyzIn;\r\n        const xyzwInput = this.xyzwIn;\r\n\r\n        const v4Output = this._outputs[0];\r\n        const v3Output = this._outputs[1];\r\n        const v2Output = this._outputs[2];\r\n        const v2CompOutput = this._outputs[3];\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        if (xyzwInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v4Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v3Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyzInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v4Output) +\r\n                    ` = ${vec4}(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v3Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n        } else if (xyInput.isConnected) {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${\r\n                            wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v3Output) +\r\n                    ` = ${vec3}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"})${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(v2Output) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v2CompOutput) +\r\n                        ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        } else {\r\n            if (v4Output.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zwInput.associatedVariableName\r\n                        })${this._buildSwizzle(4)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v4Output) +\r\n                        ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                            zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                        }, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n                }\r\n            }\r\n\r\n            if (v3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v3Output) +\r\n                    ` = ${vec3}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"}, ${\r\n                        zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"\r\n                    })${this._buildSwizzle(3)};\\n`;\r\n            }\r\n\r\n            if (v2Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(v2Output) +\r\n                    ` = ${vec2}(${xInput.isConnected ? this._writeVariable(xInput) : \"0.0\"}, ${yInput.isConnected ? this._writeVariable(yInput) : \"0.0\"})${this._buildSwizzle(2)};\\n`;\r\n            }\r\n\r\n            if (v2CompOutput.hasEndpoints) {\r\n                if (zwInput.isConnected) {\r\n                    state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};\\n`;\r\n                } else {\r\n                    state.compilationString +=\r\n                        state._declareOutput(v2CompOutput) +\r\n                        ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : \"0.0\"}, ${wInput.isConnected ? this._writeVariable(wInput) : \"0.0\"})${this._buildSwizzle(\r\n                            2\r\n                        )};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.xSwizzle = this.xSwizzle;\r\n        serializationObject.ySwizzle = this.ySwizzle;\r\n        serializationObject.zSwizzle = this.zSwizzle;\r\n        serializationObject.wSwizzle = this.wSwizzle;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.xSwizzle = serializationObject.xSwizzle ?? \"x\";\r\n        this.ySwizzle = serializationObject.ySwizzle ?? \"y\";\r\n        this.zSwizzle = serializationObject.zSwizzle ?? \"z\";\r\n        this.wSwizzle = serializationObject.wSwizzle ?? \"w\";\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.xSwizzle = \"${this.xSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.ySwizzle = \"${this.ySwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.zSwizzle = \"${this.zSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.wSwizzle = \"${this.wSwizzle}\";\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorMergerBlock\", VectorMergerBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\n/**\r\n * Block used to remap a float from a range to a new one\r\n */\r\nexport class RemapBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the source range\r\n     */\r\n    @editableInPropertyPage(\"From\", PropertyTypeForEdition.Vector2)\r\n    public sourceRange = new Vector2(-1, 1);\r\n\r\n    /**\r\n     * Gets or sets the target range\r\n     */\r\n    @editableInPropertyPage(\"To\", PropertyTypeForEdition.Vector2)\r\n    public targetRange = new Vector2(0, 1);\r\n\r\n    /**\r\n     * Creates a new RemapBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"sourceMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"sourceMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMin\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"targetMax\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"RemapBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source min input component\r\n     */\r\n    public get sourceMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the source max input component\r\n     */\r\n    public get sourceMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the target min input component\r\n     */\r\n    public get targetMin(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the target max input component\r\n     */\r\n    public get targetMax(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);\r\n        const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);\r\n\r\n        const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);\r\n        const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.sourceRange = this.sourceRange.asArray();\r\n        serializationObject.targetRange = this.targetRange.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);\r\n        this.targetRange = Vector2.FromArray(serializationObject.targetRange);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RemapBlock\", RemapBlock);\r\n", "import type { Observer } from \"core/Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\n\r\n/**\r\n * Block used to perform a mathematical operation on 2 values\r\n */\r\nexport class BaseMathBlock extends NodeMaterialBlock {\r\n    private readonly _connectionObservers: Observer<NodeMaterialBlockConnectionPointTypes>[];\r\n\r\n    protected constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this.output._typeConnectionSource = this.left;\r\n        this._linkConnectionTypes(0, 1, true);\r\n\r\n        this.left.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.right.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._connectionObservers = [\r\n            this.left.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),\r\n            this.right.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _updateInputOutputTypes() {\r\n        // First update the output type with the initial assumption that we'll base it on the left input.\r\n        this.output._typeConnectionSource = this.left;\r\n\r\n        if (this.left.isConnected && this.right.isConnected) {\r\n            // Both inputs are connected, so we need to determine the output type based on the input types.\r\n            if (\r\n                this.left.type === NodeMaterialBlockConnectionPointTypes.Int ||\r\n                (this.left.type === NodeMaterialBlockConnectionPointTypes.Float && this.right.type !== NodeMaterialBlockConnectionPointTypes.Int)\r\n            ) {\r\n                this.output._typeConnectionSource = this.right;\r\n            }\r\n        } else if (this.left.isConnected !== this.right.isConnected) {\r\n            // Only one input is connected, so we need to determine the output type based on the connected input.\r\n            this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;\r\n        }\r\n\r\n        // Next update the accepted connection point types for the inputs based on the current input connection state.\r\n        if (this.left.isConnected || this.right.isConnected) {\r\n            for (const [first, second] of [\r\n                [this.left, this.right],\r\n                [this.right, this.left],\r\n            ]) {\r\n                // Always allow Ints and Floats.\r\n                first.acceptedConnectionPointTypes = [NodeMaterialBlockConnectionPointTypes.Int, NodeMaterialBlockConnectionPointTypes.Float];\r\n\r\n                if (second.isConnected) {\r\n                    // The same types as the connected input are always allowed.\r\n                    first.acceptedConnectionPointTypes.push(second.type);\r\n\r\n                    // If the other input is a scalar, then we also allow Vector/Color/Matrix types.\r\n                    if (second.type === NodeMaterialBlockConnectionPointTypes.Int || second.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n                        first.acceptedConnectionPointTypes.push(\r\n                            NodeMaterialBlockConnectionPointTypes.Vector2,\r\n                            NodeMaterialBlockConnectionPointTypes.Vector3,\r\n                            NodeMaterialBlockConnectionPointTypes.Vector4,\r\n                            NodeMaterialBlockConnectionPointTypes.Color3,\r\n                            NodeMaterialBlockConnectionPointTypes.Color4,\r\n                            NodeMaterialBlockConnectionPointTypes.Matrix\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        for (const observer of this._connectionObservers) {\r\n            observer.remove();\r\n        }\r\n        this._connectionObservers.length = 0;\r\n    }\r\n}\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { BaseMathBlock } from \"./baseMathBlock\";\r\n\r\n/**\r\n * Block used to multiply 2 values\r\n */\r\nexport class MultiplyBlock extends BaseMathBlock {\r\n    /**\r\n     * Creates a new MultiplyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MultiplyBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiplyBlock\", MultiplyBlock);\r\n", "import type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration.defines\";\r\nimport type { ColorGradient, FactorGradient, Color3Gradient, IValueGradient } from \"../Misc/gradients\";\r\nimport type { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { IParticleEmitterType } from \"./EmitterTypes/IParticleEmitterType\";\r\nimport type { PointParticleEmitter } from \"./EmitterTypes/pointParticleEmitter\";\r\nimport type { HemisphericParticleEmitter } from \"./EmitterTypes/hemisphericParticleEmitter\";\r\nimport type { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"./EmitterTypes/sphereParticleEmitter\";\r\nimport type { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"./EmitterTypes/cylinderParticleEmitter\";\r\nimport type { ConeDirectedParticleEmitter, ConeParticleEmitter } from \"./EmitterTypes/coneParticleEmitter\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * This represents the base class for particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class BaseParticleSystem implements IClipPlanesHolder {\r\n    /**\r\n     * Source color is added to the destination color without alpha affecting the result. Great for additive glow effects (fire, magic, lasers)\r\n     */\r\n    public static BLENDMODE_ONEONE = 0;\r\n    /**\r\n     * Blend current color and particle color using particles alpha. Same as Constants.ALPHA_COMBINE, the go-to for transparency. 100% alpha means source, 0% alpha means background. Glass, UI fade, smoke\r\n     */\r\n    public static BLENDMODE_STANDARD = 1;\r\n    /**\r\n     * Add current color and particle color multiplied by particles alpha\r\n     */\r\n    public static BLENDMODE_ADD = 2;\r\n    /**\r\n     * Multiply current color with particle color\r\n     */\r\n    public static BLENDMODE_MULTIPLY = 3;\r\n    /**\r\n     * Multiply current color with particle color then add current color and particle color multiplied by particles alpha\r\n     */\r\n    public static BLENDMODE_MULTIPLYADD = 4;\r\n    /**\r\n     * Subtracts source (particle) from destination (current color), leading to darker results\r\n     * - NOTE: Init as -1 so we can properly map all modes to Engine Const's (otherwise ALPHA_SUBTRACT will conflict with BLENDMODE_MULTIPLY since both use 3)\r\n     */\r\n    public static BLENDMODE_SUBTRACT = -1;\r\n\r\n    /**\r\n     * List of animations used by the particle system.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets the unique id of the particle system\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The id of the Particle system.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * The friendly name of the Particle system.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Snippet ID if the particle system was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * The rendering group used by the Particle system to chose when to render.\r\n     */\r\n    public renderingGroupId = 0;\r\n\r\n    /**\r\n     * The emitter represents the Mesh or position we are attaching the particle system to.\r\n     */\r\n    public emitter: Nullable<AbstractMesh | Vector3> = Vector3.Zero();\r\n\r\n    /**\r\n     * The maximum number of particles to emit per frame\r\n     */\r\n    public emitRate = 10;\r\n\r\n    /**\r\n     * If you want to launch only a few particles at once, that can be done, as well.\r\n     */\r\n    public manualEmitCount = -1;\r\n\r\n    /**\r\n     * The overall motion speed (0.01 is default update speed, faster updates = faster animation)\r\n     */\r\n    public updateSpeed = 0.01;\r\n\r\n    /** @internal */\r\n    public _targetStopDuration = 0;\r\n    /**\r\n     * The amount of time the particle system is running (depends of the overall update speed).\r\n     */\r\n    public get targetStopDuration() {\r\n        return this._targetStopDuration;\r\n    }\r\n\r\n    public set targetStopDuration(value: number) {\r\n        if (this._targetStopDuration === value) {\r\n            return;\r\n        }\r\n\r\n        this._targetStopDuration = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether the particle system will be disposed once it reaches the end of the animation.\r\n     */\r\n    public disposeOnStop = false;\r\n\r\n    /**\r\n     * Minimum power of emitting particles.\r\n     */\r\n    public minEmitPower = 1;\r\n    /**\r\n     * Maximum power of emitting particles.\r\n     */\r\n    public maxEmitPower = 1;\r\n\r\n    /**\r\n     * Minimum life time of emitting particles.\r\n     */\r\n    public minLifeTime = 1;\r\n    /**\r\n     * Maximum life time of emitting particles.\r\n     */\r\n    public maxLifeTime = 1;\r\n\r\n    /**\r\n     * Minimum Size of emitting particles.\r\n     */\r\n    public minSize = 1;\r\n    /**\r\n     * Maximum Size of emitting particles.\r\n     */\r\n    public maxSize = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on X axis.\r\n     */\r\n    public minScaleX = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on X axis.\r\n     */\r\n    public maxScaleX = 1;\r\n\r\n    /**\r\n     * Minimum scale of emitting particles on Y axis.\r\n     */\r\n    public minScaleY = 1;\r\n    /**\r\n     * Maximum scale of emitting particles on Y axis.\r\n     */\r\n    public maxScaleY = 1;\r\n\r\n    /**\r\n     * Gets or sets the minimal initial rotation in radians.\r\n     */\r\n    public minInitialRotation = 0;\r\n    /**\r\n     * Gets or sets the maximal initial rotation in radians.\r\n     */\r\n    public maxInitialRotation = 0;\r\n\r\n    /**\r\n     * Minimum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public minAngularSpeed = 0;\r\n    /**\r\n     * Maximum angular speed of emitting particles (Z-axis rotation for each particle).\r\n     */\r\n    public maxAngularSpeed = 0;\r\n\r\n    /**\r\n     * The texture used to render each particle. (this can be a spritesheet)\r\n     */\r\n    public particleTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * This can help using your own shader to render the particle system.\r\n     * The according effect will be created\r\n     */\r\n    public customShader: any = null;\r\n\r\n    /**\r\n     * By default particle system starts as soon as they are created. This prevents the\r\n     * automatic start to happen and let you decide when to start emitting particles.\r\n     */\r\n    public preventAutoStart: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this particle system will allow fog to be rendered on it (false by default)\r\n     */\r\n    public applyFog = false;\r\n\r\n    /** @internal */\r\n    _wasDispatched = false;\r\n\r\n    protected _rootUrl = \"\";\r\n    protected _noiseTexture: Nullable<ProceduralTexture>;\r\n\r\n    /**\r\n     * Returns true if the particle system was generated by a node particle system set\r\n     */\r\n    public get isNodeGenerated(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a texture used to add random noise to particle positions\r\n     */\r\n    public get noiseTexture(): Nullable<ProceduralTexture> {\r\n        return this._noiseTexture;\r\n    }\r\n\r\n    public set noiseTexture(value: Nullable<ProceduralTexture>) {\r\n        if (this._noiseTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._noiseTexture = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** Gets or sets the strength to apply to the noise value (default is (10, 10, 10)) */\r\n    public noiseStrength = new Vector3(10, 10, 10);\r\n\r\n    /**\r\n     * Callback triggered when the particle animation is ending.\r\n     */\r\n    public onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Blend mode use to render the particle\r\n     * For original blend modes which are exposed from ParticleSystem (OneOne, Standard, Add, Multiply, MultiplyAdd, and Subtract), use ParticleSystem.BLENDMODE_FOO\r\n     * For all other blend modes, use Engine Constants.ALPHA_FOO blend modes\r\n     */\r\n    public blendMode = BaseParticleSystem.BLENDMODE_ONEONE;\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /** Gets or sets a value indicating how many cycles (or frames) must be executed before first rendering (this value has to be set before starting the system). Default is 0 */\r\n    public preWarmCycles = 0;\r\n\r\n    /** Gets or sets a value indicating the time step multiplier to use in pre-warm mode (default is 1) */\r\n    public preWarmStepOffset = 1;\r\n\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the speed of the sprite loop (default is 1 meaning the animation will play once during the entire particle lifetime)\r\n     */\r\n    public spriteCellChangeSpeed = 1;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the first sprite cell to display\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public startSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled) defines the last sprite cell to display\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public endSpriteCellID = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use\r\n     */\r\n    public spriteCellWidth = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use\r\n     */\r\n    public spriteCellHeight = 0;\r\n    /**\r\n     * If using a spritesheet (isAnimationSheetEnabled), defines wether the sprite animation is looping\r\n     */\r\n    public spriteCellLoop = true;\r\n    /**\r\n     * This allows the system to random pick the start cell ID between startSpriteCellID and endSpriteCellID\r\n     */\r\n    public spriteRandomStartCell = false;\r\n\r\n    /** Gets or sets a Vector2 used to move the pivot (by default (0,0)) */\r\n    public translationPivot = new Vector2(0, 0);\r\n\r\n    protected _animationSheetEnabled = false;\r\n    /** @internal */\r\n    public get _isAnimationSheetEnabled() {\r\n        return this._animationSheetEnabled;\r\n    }\r\n\r\n    public set _isAnimationSheetEnabled(value: boolean) {\r\n        if (this._animationSheetEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._animationSheetEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that hosted animations (in the system.animations array) must be started when system.start() is called\r\n     */\r\n    public beginAnimationOnStart = false;\r\n\r\n    /**\r\n     * Gets or sets the frame to start the animation from when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationFrom = 0;\r\n\r\n    /**\r\n     * Gets or sets the frame to end the animation on when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationTo = 60;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations must loop when beginAnimationOnStart is true\r\n     */\r\n    public beginAnimationLoop = false;\r\n\r\n    /**\r\n     * Gets or sets a world offset applied to all particles\r\n     */\r\n    public worldOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets whether an animation sprite sheet is enabled or not on the particle system\r\n     */\r\n    public get isAnimationSheetEnabled(): boolean {\r\n        return this._isAnimationSheetEnabled;\r\n    }\r\n\r\n    public set isAnimationSheetEnabled(value: boolean) {\r\n        if (this._isAnimationSheetEnabled == value) {\r\n            return;\r\n        }\r\n\r\n        this._isAnimationSheetEnabled = value;\r\n\r\n        this._reset();\r\n    }\r\n\r\n    private _useLogarithmicDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.\r\n     */\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene()!.getEngine().getCaps().fragmentDepthSupported;\r\n    }\r\n\r\n    /**\r\n     * Get hosting scene\r\n     * @returns the scene\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * You can use gravity if you want to give an orientation to your particles.\r\n     */\r\n    public gravity = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _colorGradients: Nullable<Array<ColorGradient>> = null;\r\n    /** @internal */\r\n    public _sizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _lifeTimeGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _angularSpeedGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _velocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _limitVelocityGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _dragGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _emitRateGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _startSizeGradients: Nullable<Array<FactorGradient>> = null;\r\n    protected _rampGradients: Nullable<Array<Color3Gradient>> = null;\r\n    /** @internal */\r\n    public _colorRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n    /** @internal */\r\n    public _alphaRemapGradients: Nullable<Array<FactorGradient>> = null;\r\n\r\n    protected _hasTargetStopDurationDependantGradient() {\r\n        return (\r\n            (this._startSizeGradients && this._startSizeGradients.length > 0) ||\r\n            (this._emitRateGradients && this._emitRateGradients.length > 0) ||\r\n            (this._lifeTimeGradients && this._lifeTimeGradients.length > 0)\r\n        );\r\n    }\r\n\r\n    protected _setEngineBasedOnBlendMode(blendMode: number): void {\r\n        switch (blendMode) {\r\n            case BaseParticleSystem.BLENDMODE_MULTIPLYADD:\r\n                // Don't want to update engine since there is no equivalent engine alpha mode, instead it gets handled within particleSystem\r\n                return;\r\n            case BaseParticleSystem.BLENDMODE_ADD:\r\n                blendMode = Constants.ALPHA_ADD;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_ONEONE:\r\n                blendMode = Constants.ALPHA_ONEONE;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_STANDARD:\r\n                blendMode = Constants.ALPHA_COMBINE;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_MULTIPLY:\r\n                blendMode = Constants.ALPHA_MULTIPLY;\r\n                break;\r\n            case BaseParticleSystem.BLENDMODE_SUBTRACT:\r\n                blendMode = Constants.ALPHA_SUBTRACT;\r\n                break;\r\n            default:\r\n                // For all other blend modes that were added after the initial particleSystem implementation,\r\n                // the ParticleSystem.BLENDMODE_FOO are already mapped to the underlying Constants.ALPHA_FOO\r\n                break;\r\n        }\r\n        this._engine.setAlphaMode(blendMode);\r\n    }\r\n\r\n    /**\r\n     * Defines the delay in milliseconds before starting the system (0 by default)\r\n     */\r\n    public startDelay = 0;\r\n\r\n    /**\r\n     * Gets the current list of drag gradients.\r\n     * You must use addDragGradient and removeDragGradient to update this list\r\n     * @returns the list of drag gradients\r\n     */\r\n    public getDragGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._dragGradients;\r\n    }\r\n\r\n    /** Gets or sets a value indicating the damping to apply if the limit velocity factor is reached */\r\n    public limitVelocityDamping = 0.4;\r\n\r\n    /**\r\n     * Gets the current list of limit velocity gradients.\r\n     * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list\r\n     * @returns the list of limit velocity gradients\r\n     */\r\n    public getLimitVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._limitVelocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color gradients.\r\n     * You must use addColorGradient and removeColorGradient to update this list\r\n     * @returns the list of color gradients\r\n     */\r\n    public getColorGradients(): Nullable<Array<ColorGradient>> {\r\n        return this._colorGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of size gradients.\r\n     * You must use addSizeGradient and removeSizeGradient to update this list\r\n     * @returns the list of size gradients\r\n     */\r\n    public getSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._sizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of color remap gradients.\r\n     * You must use addColorRemapGradient and removeColorRemapGradient to update this list\r\n     * @returns the list of color remap gradients\r\n     */\r\n    public getColorRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._colorRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of alpha remap gradients.\r\n     * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list\r\n     * @returns the list of alpha remap gradients\r\n     */\r\n    public getAlphaRemapGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._alphaRemapGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of life time gradients.\r\n     * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list\r\n     * @returns the list of life time gradients\r\n     */\r\n    public getLifeTimeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._lifeTimeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of angular speed gradients.\r\n     * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list\r\n     * @returns the list of angular speed gradients\r\n     */\r\n    public getAngularSpeedGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._angularSpeedGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of velocity gradients.\r\n     * You must use addVelocityGradient and removeVelocityGradient to update this list\r\n     * @returns the list of velocity gradients\r\n     */\r\n    public getVelocityGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._velocityGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of start size gradients.\r\n     * You must use addStartSizeGradient and removeStartSizeGradient to update this list\r\n     * @returns the list of start size gradients\r\n     */\r\n    public getStartSizeGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._startSizeGradients;\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of emit rate gradients.\r\n     * You must use addEmitRateGradient and removeEmitRateGradient to update this list\r\n     * @returns the list of emit rate gradients\r\n     */\r\n    public getEmitRateGradients(): Nullable<Array<FactorGradient>> {\r\n        return this._emitRateGradients;\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction1(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction1;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction1(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction1) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction1 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get direction2(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).direction2;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set direction2(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).direction2) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).direction2 = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get minEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).minEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set minEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).minEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).minEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.\r\n     * This only works when particleEmitterTyps is a BoxParticleEmitter\r\n     */\r\n    public get maxEmitBox(): Vector3 {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            return (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox;\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    public set maxEmitBox(value: Vector3) {\r\n        if ((<BoxParticleEmitter>this.particleEmitterType).maxEmitBox) {\r\n            (<BoxParticleEmitter>this.particleEmitterType).maxEmitBox = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Random color of each particle after it has been emitted, between color1 and color2 vectors\r\n     */\r\n    public color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * Color the particle will have at the end of its lifetime\r\n     */\r\n    public colorDead = new Color4(0, 0, 0, 1.0);\r\n\r\n    /**\r\n     * An optional mask to filter some colors out of the texture, or filter a part of the alpha channel\r\n     */\r\n    public textureMask = new Color4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * The particle emitter type defines the emitter used by the particle system.\r\n     * It can be for example box, sphere, or cone...\r\n     */\r\n    public particleEmitterType: IParticleEmitterType;\r\n\r\n    /** @internal */\r\n    public _isSubEmitter = false;\r\n\r\n    /** @internal */\r\n    public _billboardMode = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Gets or sets the billboard mode to use when isBillboardBased = true.\r\n     * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED\r\n     */\r\n    public get billboardMode(): number {\r\n        return this._billboardMode;\r\n    }\r\n\r\n    public set billboardMode(value: number) {\r\n        if (this._billboardMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._billboardMode = value;\r\n        this._reset();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isBillboardBased = true;\r\n    /**\r\n     * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction\r\n     */\r\n    public get isBillboardBased(): boolean {\r\n        return this._isBillboardBased;\r\n    }\r\n\r\n    public set isBillboardBased(value: boolean) {\r\n        if (this._isBillboardBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isBillboardBased = value;\r\n        this._reset();\r\n    }\r\n\r\n    /**\r\n     * The scene the particle system belongs to.\r\n     */\r\n    protected _scene: Nullable<Scene>;\r\n\r\n    /**\r\n     * The engine the particle system belongs to.\r\n     */\r\n    protected _engine: AbstractEngine;\r\n\r\n    /**\r\n     * Local cache of defines for image processing.\r\n     */\r\n    protected _imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): Nullable<ImageProcessingConfiguration> {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: Nullable<ImageProcessingConfiguration>) {\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration && this._scene) {\r\n            this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    protected _reset() {}\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: Nullable<RawTexture>): BaseParticleSystem {\r\n        if (!gradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const valueGradient of gradients) {\r\n            if (valueGradient.gradient === gradient) {\r\n                gradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        if (texture) {\r\n            texture.dispose();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     */\r\n    public constructor(name: string) {\r\n        this.id = name;\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * Creates a Point Emitter for the particle system (emits directly from the emitter position)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     */\r\n    public createPointEmitter(direction1: Vector3, direction2: Vector3): PointParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\r\n     * @param radius The radius of the hemisphere to emit from\r\n     * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     */\r\n    public createHemisphericEmitter(radius = 1, radiusRange = 1): HemisphericParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\r\n     */\r\n    public createSphereEmitter(radius = 1, radiusRange = 1): SphereParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the sphere to emit from\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\r\n     */\r\n    public createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): SphereDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\r\n     * @param radius The radius of the emission cylinder\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\r\n     * @param directionRandomizer How much to randomize the particle direction [0-1]\r\n     */\r\n    public createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0): CylinderParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\r\n     * @param radius The radius of the cylinder to emit from\r\n     * @param height The height of the emission cylinder\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\r\n     */\r\n    public createDirectedCylinderEmitter(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        direction1 = new Vector3(0, 1.0, 0),\r\n        direction2 = new Vector3(0, 1.0, 0)\r\n    ): CylinderDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\r\n     * @param radius The radius of the cone to emit from\r\n     * @param angle The base angle of the cone\r\n     */\r\n    public createConeEmitter(radius = 1, angle = Math.PI / 4): ConeParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    public createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)): ConeDirectedParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\r\n     * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\r\n     * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\r\n     */\r\n    public createBoxEmitter(direction1: Vector3, direction2: Vector3, minEmitBox: Vector3, maxEmitBox: Vector3): BoxParticleEmitter {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.BaseParticleSystem\", BaseParticleSystem);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to expand a Color3/4 into 4 outputs (one for each component)\r\n */\r\nexport class ColorSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ColorSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputsAreExclusive = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ColorSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component (input)\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component (output)\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component (output)\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n    /**\r\n     * Gets the b component (output)\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n    /**\r\n     * Gets the a component (output)\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.rgba.isConnected ? this.rgba : this.rgbIn;\r\n\r\n        if (!input.isConnected) {\r\n            return;\r\n        }\r\n\r\n        const rgbOutput = this._outputs[0];\r\n        const rOutput = this._outputs[1];\r\n        const gOutput = this._outputs[2];\r\n        const bOutput = this._outputs[3];\r\n        const aOutput = this._outputs[4];\r\n\r\n        if (rgbOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(rgbOutput) + ` = ${input.associatedVariableName}.rgb;\\n`;\r\n        }\r\n        if (rOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(rOutput) + ` = ${input.associatedVariableName}.r;\\n`;\r\n        }\r\n        if (gOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(gOutput) + ` = ${input.associatedVariableName}.g;\\n`;\r\n        }\r\n        if (bOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(bOutput) + ` = ${input.associatedVariableName}.b;\\n`;\r\n        }\r\n        if (aOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(aOutput) + ` = ${input.associatedVariableName}.a;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorSplitterBlock\", ColorSplitterBlock);\r\n", "import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector4, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { RenderTargetTextureOptions } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\n\r\n/**\r\n * Options to create a procedural texture\r\n */\r\nexport interface IProceduralTextureCreationOptions extends RenderTargetTextureOptions {\r\n    /**\r\n     * Defines a fallback texture in case there were issues to create the custom texture\r\n     */\r\n    fallbackTexture?: Nullable<Texture>;\r\n    /**\r\n     * The shader language of the shader. (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Define the list of custom preprocessor defines used in the shader\r\n     */\r\n    public defines: string = \"\";\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: ThinTexture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _vectors4: { [key: string]: Vector4 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: AbstractEngine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n    private _options: IProceduralTextureCreationOptions;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> | IProceduralTextureCreationOptions = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\r\n            this._options = fallbackTexture;\r\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\r\n        } else {\r\n            this._options = {};\r\n            this._fallbackTexture = fallbackTexture;\r\n        }\r\n\r\n        this._shaderLanguage = this._options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            if (this._rtWrapper.is3D) {\r\n                this.setFloat(\"layer\", 0);\r\n                this.setInt(\"layerNum\", 0);\r\n            }\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return this.defines;\r\n    }\r\n\r\n    /**\r\n     * Executes a function when the texture will be ready to be drawn.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenReady(func: (texture: ProceduralTexture) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        const effect = this.getEffect();\r\n        if (effect) {\r\n            effect.executeWhenCompiled(() => {\r\n                func(this);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public override isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                shaders,\r\n                [VertexBuffer.PositionKind],\r\n                this._uniforms,\r\n                this._samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    this._rtWrapper?.dispose();\r\n                    this._rtWrapper = this._texture = null;\r\n\r\n                    if (this._fallbackTexture) {\r\n                        this._texture = this._fallbackTexture._texture;\r\n\r\n                        if (this._texture) {\r\n                            this._texture.incrementReferences();\r\n                        }\r\n                    }\r\n\r\n                    this._fallbackTextureUsed = true;\r\n                },\r\n                undefined,\r\n                this._shaderLanguage,\r\n                async () => {\r\n                    if (this._options.extraInitializationsAsync) {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        }\r\n                    } else {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await import(\"../../../ShadersWGSL/procedural.vertex\");\r\n                        } else {\r\n                            await import(\"../../../Shaders/procedural.vertex\");\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: ThinTexture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (const name in this._vectors4) {\r\n                this._drawWrapper.effect!.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, true);\r\n            }\r\n        } else {\r\n            let numLayers = 1;\r\n            if (this._rtWrapper.is3D) {\r\n                numLayers = this._rtWrapper.depth;\r\n            } else if (this._rtWrapper.is2DArray) {\r\n                numLayers = this._rtWrapper.layers;\r\n            }\r\n            for (let layer = 0; layer < numLayers; layer++) {\r\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\r\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\r\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\r\n                    for (const name in this._textures) {\r\n                        this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n                    }\r\n                }\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\r\n            }\r\n        }\r\n\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Trigonometry block\r\n */\r\nexport enum TrigonometryBlockOperations {\r\n    /** Cos */\r\n    Cos,\r\n    /** Sin */\r\n    Sin,\r\n    /** Abs */\r\n    Abs,\r\n    /** Exp */\r\n    Exp,\r\n    /** Exp2 */\r\n    Exp2,\r\n    /** Round */\r\n    Round,\r\n    /** Floor */\r\n    Floor,\r\n    /** Ceiling */\r\n    Ceiling,\r\n    /** Square root */\r\n    Sqrt,\r\n    /** Log */\r\n    Log,\r\n    /** Tangent */\r\n    Tan,\r\n    /** Arc tangent */\r\n    ArcTan,\r\n    /** Arc cosinus */\r\n    ArcCos,\r\n    /** Arc sinus */\r\n    ArcSin,\r\n    /** Fraction */\r\n    Fract,\r\n    /** Sign */\r\n    Sign,\r\n    /** To radians (from degrees) */\r\n    Radians,\r\n    /** To degrees (from radians) */\r\n    Degrees,\r\n    /** To Set a = b */\r\n    Set,\r\n}\r\n\r\n/**\r\n * Block used to apply trigonometry operation to floats\r\n */\r\nexport class TrigonometryBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the operation applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"Cos\", value: TrigonometryBlockOperations.Cos },\r\n            { label: \"Sin\", value: TrigonometryBlockOperations.Sin },\r\n            { label: \"Abs\", value: TrigonometryBlockOperations.Abs },\r\n            { label: \"Exp\", value: TrigonometryBlockOperations.Exp },\r\n            { label: \"Exp2\", value: TrigonometryBlockOperations.Exp2 },\r\n            { label: \"Round\", value: TrigonometryBlockOperations.Round },\r\n            { label: \"Floor\", value: TrigonometryBlockOperations.Floor },\r\n            { label: \"Ceiling\", value: TrigonometryBlockOperations.Ceiling },\r\n            { label: \"Sqrt\", value: TrigonometryBlockOperations.Sqrt },\r\n            { label: \"Log\", value: TrigonometryBlockOperations.Log },\r\n            { label: \"Tan\", value: TrigonometryBlockOperations.Tan },\r\n            { label: \"ArcTan\", value: TrigonometryBlockOperations.ArcTan },\r\n            { label: \"ArcCos\", value: TrigonometryBlockOperations.ArcCos },\r\n            { label: \"ArcSin\", value: TrigonometryBlockOperations.ArcSin },\r\n            { label: \"Fract\", value: TrigonometryBlockOperations.Fract },\r\n            { label: \"Sign\", value: TrigonometryBlockOperations.Sign },\r\n            { label: \"Radians\", value: TrigonometryBlockOperations.Radians },\r\n            { label: \"Degrees\", value: TrigonometryBlockOperations.Degrees },\r\n            { label: \"Set\", value: TrigonometryBlockOperations.Set },\r\n        ],\r\n    })\r\n    public operation = TrigonometryBlockOperations.Cos;\r\n\r\n    /**\r\n     * Creates a new TrigonometryBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TrigonometryBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        let operation = \"\";\r\n\r\n        switch (this.operation) {\r\n            case TrigonometryBlockOperations.Cos: {\r\n                operation = \"cos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sin: {\r\n                operation = \"sin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Abs: {\r\n                operation = \"abs\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp: {\r\n                operation = \"exp\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Exp2: {\r\n                operation = \"exp2\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Round: {\r\n                operation = \"round\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Floor: {\r\n                operation = \"floor\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Ceiling: {\r\n                operation = \"ceil\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sqrt: {\r\n                operation = \"sqrt\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Log: {\r\n                operation = \"log\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Tan: {\r\n                operation = \"tan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcTan: {\r\n                operation = \"atan\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcCos: {\r\n                operation = \"acos\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.ArcSin: {\r\n                operation = \"asin\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Fract: {\r\n                operation = \"fract\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Sign: {\r\n                operation = \"sign\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Radians: {\r\n                operation = \"radians\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Degrees: {\r\n                operation = \"degrees\";\r\n                break;\r\n            }\r\n            case TrigonometryBlockOperations.Set: {\r\n                operation = \"\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${operation}(${this.input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.operation = this.operation;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.operation = serializationObject.operation;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TrigonometryBlock\", TrigonometryBlock);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { SfeModeDefine } from \"./Blocks/Fragment/smartFilterFragmentOutputBlock\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Material } from \"../material\";\r\nimport type { TriPlanarBlock } from \"./Blocks/triPlanarBlock\";\r\nimport type { BiPlanarBlock } from \"./Blocks/biPlanarBlock\";\r\nimport type { PrePassRenderer } from \"../../Rendering/prePassRenderer\";\r\nimport type { PrePassTextureBlock } from \"./Blocks/Input/prePassTextureBlock\";\r\nimport type { PrePassOutputBlock } from \"./Blocks/Fragment/prePassOutputBlock\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./Blocks/Teleport/teleportOutBlock\";\r\nimport type { NodeMaterialTeleportInBlock } from \"./Blocks/Teleport/teleportInBlock\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { PrepareDefinesForCamera, PrepareDefinesForPrePass } from \"../materialHelper.functions\";\r\nimport { ImageProcessingDefinesMixin } from \"../imageProcessingConfiguration.defines\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { LoopBlock } from \"./Blocks/loopBlock\";\r\nimport { MaterialHelperGeometryRendering } from \"../materialHelper.geometryrendering\";\r\nimport { UVDefinesMixin } from \"../uv.defines\";\r\nimport { ImageProcessingMixin } from \"../imageProcessing\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URL to load node editor script from */\r\n    editorURL?: string;\r\n    /** Additional configuration for the NME */\r\n    nodeEditorConfig?: {\r\n        backgroundColor?: Color4;\r\n    };\r\n}\r\n\r\nclass NodeMaterialDefinesBase extends UVDefinesMixin(MaterialDefines) {}\r\n\r\n/** @internal */\r\nexport class NodeMaterialDefines extends ImageProcessingDefinesMixin(NodeMaterialDefinesBase) {\r\n    /** Normal */\r\n    public NORMAL = false;\r\n    /** Tangent */\r\n    public TANGENT = false;\r\n    /** Vertex color */\r\n    public VERTEXCOLOR_NME = false;\r\n\r\n    /** Prepass **/\r\n    public PREPASS = false;\r\n    /** Prepass normal */\r\n    public PREPASS_NORMAL = false;\r\n    /** Prepass normal index */\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    /** Prepass world normal */\r\n    public PREPASS_WORLD_NORMAL = false;\r\n    /** Prepass world normal index */\r\n    public PREPASS_WORLD_NORMAL_INDEX = -1;\r\n    /** Prepass position */\r\n    public PREPASS_POSITION = false;\r\n    /** Prepass position index */\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    /** Prepass local position */\r\n    public PREPASS_LOCAL_POSITION = false;\r\n    /** Prepass local position index */\r\n    public PREPASS_LOCAL_POSITION_INDEX = -1;\r\n    /** Prepass depth */\r\n    public PREPASS_DEPTH = false;\r\n    /** Prepass depth index */\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    /** Clip-space depth */\r\n    public PREPASS_SCREENSPACE_DEPTH = false;\r\n    /** Clip-space depth index */\r\n    public PREPASS_SCREENSPACE_DEPTH_INDEX = -1;\r\n    /** Scene MRT count */\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    /** Bones per mesh */\r\n    public BonesPerMesh = 0;\r\n    /** Using texture for bone storage */\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    /** Morph target position */\r\n    public MORPHTARGETS_POSITION = false;\r\n    /** Morph target normal */\r\n    public MORPHTARGETS_NORMAL = false;\r\n    /** Morph target tangent */\r\n    public MORPHTARGETS_TANGENT = false;\r\n    /** Morph target uv */\r\n    public MORPHTARGETS_UV = false;\r\n    /** Morph target uv2 */\r\n    public MORPHTARGETS_UV2 = false;\r\n    public MORPHTARGETS_COLOR = false;\r\n    /** Morph target support positions */\r\n    public MORPHTARGETTEXTURE_HASPOSITIONS = false;\r\n    /** Morph target support normals */\r\n    public MORPHTARGETTEXTURE_HASNORMALS = false;\r\n    /** Morph target support tangents */\r\n    public MORPHTARGETTEXTURE_HASTANGENTS = false;\r\n    /** Morph target support uvs */\r\n    public MORPHTARGETTEXTURE_HASUVS = false;\r\n    /** Morph target support uv2s */\r\n    public MORPHTARGETTEXTURE_HASUV2S = false;\r\n    public MORPHTARGETTEXTURE_HASCOLORS = false;\r\n    /** Number of morph influencers */\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    /** Using a texture to store morph target data */\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n    /** Camera is orthographic */\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    /** Camera is perspective */\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    public AREALIGHTSUPPORTED = true;\r\n\r\n    public AREALIGHTNOROUGHTNESS = true;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialDefines\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Set the value of a specific key\r\n     * @param name defines the name of the key to set\r\n     * @param value defines the value to set\r\n     * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing\r\n     */\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n    /** Defines shader language to use (default to GLSL) */\r\n    shaderLanguage: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * Blocks that manage a texture\r\n */\r\nexport type NodeMaterialTextureBlocks =\r\n    | TextureBlock\r\n    | ReflectionTextureBaseBlock\r\n    | RefractionBlock\r\n    | CurrentScreenBlock\r\n    | ParticleTextureBlock\r\n    | ImageSourceBlock\r\n    | TriPlanarBlock\r\n    | BiPlanarBlock\r\n    | PrePassTextureBlock;\r\n\r\nclass NodeMaterialBase extends ImageProcessingMixin(PushMaterial) {}\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends NodeMaterialBase {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n    private _buildIsInProgress = false;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeEditor/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    /** Gets or sets a boolean indicating that render target textures can be serialized */\r\n    public static AllowSerializationOfRenderTargetTextures = false;\r\n\r\n    /** Defines default shader language when no option is defined */\r\n    public static DefaultShaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /** If true, the node material will use GLSL if the engine is WebGL and WGSL if it's WebGPU. It takes priority over DefaultShaderLanguage if it's true */\r\n    public static UseNativeShaderLanguageOfEngine = false;\r\n\r\n    /**\r\n     * Checks if a block is a texture block\r\n     * @param block The block to check\r\n     * @returns True if the block is a texture block\r\n     */\r\n    public static _BlockIsTextureBlock(block: NodeMaterialBlock): block is NodeMaterialTextureBlocks {\r\n        return (\r\n            block.getClassName() === \"TextureBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBaseBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBlock\" ||\r\n            block.getClassName() === \"ReflectionBlock\" ||\r\n            block.getClassName() === \"RefractionBlock\" ||\r\n            block.getClassName() === \"CurrentScreenBlock\" ||\r\n            block.getClassName() === \"SmartFilterTextureBlock\" ||\r\n            block.getClassName() === \"ParticleTextureBlock\" ||\r\n            block.getClassName() === \"ImageSourceBlock\" ||\r\n            block.getClassName() === \"TriPlanarBlock\" ||\r\n            block.getClassName() === \"BiPlanarBlock\" ||\r\n            block.getClassName() === \"PrePassTextureBlock\"\r\n        );\r\n    }\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Gets whether the node material is currently building */\r\n    public get buildIsInProgress(): boolean {\r\n        return this._buildIsInProgress;\r\n    }\r\n\r\n    /** @internal */\r\n    public _useAdditionalColor = false;\r\n\r\n    public override set _glowModeEnabled(value: boolean) {\r\n        this._useAdditionalColor = value;\r\n    }\r\n\r\n    /** Get the inspector from bundle or global\r\n     * @returns the global NME\r\n     */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /** Gets or sets the active shader language */\r\n    public override get shaderLanguage(): ShaderLanguage {\r\n        return this._options?.shaderLanguage || NodeMaterial.DefaultShaderLanguage;\r\n    }\r\n\r\n    public override set shaderLanguage(value: ShaderLanguage) {\r\n        this._options.shaderLanguage = value;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Observable raised when an error is detected\r\n     */\r\n    public onBuildErrorObservable = new Observable<string>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks: NodeMaterialBlock[] = [];\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @internal\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        if (!NodeMaterial.UseNativeShaderLanguageOfEngine && options && options.shaderLanguage === ShaderLanguage.WGSL && !this.getScene().getEngine().isWebGPU) {\r\n            throw new Error(\"WebGPU shader language is only supported with WebGPU engine\");\r\n        }\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            shaderLanguage: NodeMaterial.DefaultShaderLanguage,\r\n            ...options,\r\n        };\r\n\r\n        if (NodeMaterial.UseNativeShaderLanguageOfEngine) {\r\n            this._options.shaderLanguage = this.getScene().getEngine().isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block using a predicate\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    public override get _supportGlowLayer() {\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.some((f) => (f as FragmentOutputBlock).additionalColor && (f as FragmentOutputBlock).additionalColor.isConnected)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _processInitializeOnLink(block: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n            nodesToProcessForOtherBuildState.push(block);\r\n        }\r\n        this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n    }\r\n\r\n    private _attachBlock(node: NodeMaterialBlock) {\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        this._sharedData.raiseBuildError(`Cannot have multiple blocks of type ${className} in the same NodeMaterial`);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        this._attachBlock(node);\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint && !connectedPoint._preventBubbleUp) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Loop\r\n        if (node.isLoop) {\r\n            // We need to keep the storage write block in the active blocks\r\n            const loopBlock = node as LoopBlock;\r\n            if (loopBlock.loopID.hasEndpoints) {\r\n                for (const endpoint of loopBlock.loopID.endpoints) {\r\n                    const block = endpoint.ownerBlock;\r\n                    if (block.outputs.length !== 0) {\r\n                        continue;\r\n                    }\r\n                    state._terminalBlocks.add(block); // Attach the storage write only\r\n                    this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        } else if (node.isTeleportOut) {\r\n            // Teleportation\r\n            const teleport = node as NodeMaterialTeleportOutBlock;\r\n            if (teleport.entryPoint) {\r\n                this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint && !connectedPoint._preventBubbleUp) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If this is a teleport out, we need to reset the connected block\r\n        if (node.isTeleportOut) {\r\n            const teleportOut = node as NodeMaterialTeleportOutBlock;\r\n            if (teleportOut.entryPoint) {\r\n                this._resetDualBlocks(teleportOut.entryPoint, id);\r\n            }\r\n        } else if (node.isLoop) {\r\n            // Loop\r\n            const loopBlock = node as LoopBlock;\r\n            if (loopBlock.loopID.hasEndpoints) {\r\n                for (const endpoint of loopBlock.loopID.endpoints) {\r\n                    const block = endpoint.ownerBlock;\r\n                    if (block.outputs.length !== 0) {\r\n                        continue;\r\n                    }\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = false) {\r\n        if (this._buildIsInProgress) {\r\n            Logger.Warn(\"Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.\");\r\n            return;\r\n        }\r\n        this._buildIsInProgress = true;\r\n        // First time?\r\n        if (!this._vertexCompilationState && !autoConfigure) {\r\n            autoConfigure = true;\r\n        }\r\n\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle || this._mode === NodeMaterialModes.SFE;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            this.onBuildErrorObservable.notifyObservers(\"You must define at least one vertexOutputNode\");\r\n            this._buildIsInProgress = false;\r\n            return;\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            this.onBuildErrorObservable.notifyObservers(\"You must define at least one fragmentOutputNode\");\r\n            this._buildIsInProgress = false;\r\n            return;\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        const needToPurgeList = this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive).length > 1;\r\n        let fragmentOutputNodes = this._fragmentOutputNodes;\r\n\r\n        if (needToPurgeList) {\r\n            // Get all but the final output nodes\r\n            fragmentOutputNodes = this._fragmentOutputNodes.filter((n) => !n._isFinalOutputAndActive);\r\n\r\n            // Get the first with precedence on\r\n            fragmentOutputNodes.push(this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive && n._hasPrecedence)[0]);\r\n        }\r\n\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.nodeMaterial = this;\r\n        this._sharedData.fragmentOutputNodes = fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Are blocks code ready?\r\n        let waitingNodeCount = 0;\r\n        for (const node of this.attachedBlocks) {\r\n            if (!node.codeIsReady) {\r\n                waitingNodeCount++;\r\n                node.onCodeIsReadyObservable.addOnce(() => {\r\n                    waitingNodeCount--;\r\n                    if (waitingNodeCount === 0) {\r\n                        this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (waitingNodeCount !== 0) {\r\n            return;\r\n        }\r\n\r\n        this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);\r\n    }\r\n\r\n    private _finishBuildProcess(verbose: boolean = false, updateBuildId = true, vertexNodes: NodeMaterialBlock[], fragmentNodes: NodeMaterialBlock[]) {\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        if (verbose) {\r\n            Logger.Log(\"Vertex shader:\");\r\n            Logger.Log(this._vertexCompilationState.compilationString);\r\n            Logger.Log(\"Fragment shader:\");\r\n            Logger.Log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        // Errors\r\n        const noError = this._sharedData.emitErrors();\r\n\r\n        this._buildIsInProgress = false;\r\n        if (noError) {\r\n            this._buildWasSuccessful = true;\r\n            this.onBuildObservable.notifyObservers(this);\r\n        }\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n\r\n        if (this.prePassTextureInputs.length) {\r\n            this.getScene().enablePrePassRenderer();\r\n        }\r\n        const prePassRenderer = this.getScene().prePassRenderer;\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an optimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n        const oldColor = defines[\"VERTEXCOLOR_NME\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n        defines[\"VERTEXCOLOR_NME\"] = hasVertexColors;\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(this.getScene(), defines, !oit);\r\n\r\n        MaterialHelperGeometryRendering.PrepareDefines(this.getScene().getEngine().currentRenderPassId, mesh, defines);\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldColor !== defines[\"VERTEXCOLOR_NME\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public override get isPrePassCapable(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Outputs written to the prepass\r\n     */\r\n    public get prePassTextureOutputs(): number[] {\r\n        const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === \"PrePassOutputBlock\") as PrePassOutputBlock;\r\n        const result = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\r\n        if (!prePassOutputBlock) {\r\n            return result;\r\n        }\r\n        // Cannot write to prepass if we alread read from prepass\r\n        if (this.prePassTextureInputs.length) {\r\n            return result;\r\n        }\r\n\r\n        if (prePassOutputBlock.viewDepth.isConnected) {\r\n            result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.screenDepth.isConnected) {\r\n            result.push(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.viewNormal.isConnected) {\r\n            result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.worldNormal.isConnected) {\r\n            result.push(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.worldPosition.isConnected) {\r\n            result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.localPosition.isConnected) {\r\n            result.push(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.reflectivity.isConnected) {\r\n            result.push(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.velocity.isConnected) {\r\n            result.push(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n        }\r\n\r\n        if (prePassOutputBlock.velocityLinear.isConnected) {\r\n            result.push(Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of prepass texture required\r\n     */\r\n    public get prePassTextureInputs(): number[] {\r\n        const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === \"PrePassTextureBlock\") as PrePassTextureBlock[];\r\n        const result = [] as number[];\r\n\r\n        for (const block of prePassTextureBlocks) {\r\n            if (block.position.isConnected && !result.includes(Constants.PREPASS_POSITION_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n            }\r\n            if (block.localPosition.isConnected && !result.includes(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE);\r\n            }\r\n            if (block.depth.isConnected && !result.includes(Constants.PREPASS_DEPTH_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            }\r\n            if (block.screenDepth.isConnected && !result.includes(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE);\r\n            }\r\n            if (block.normal.isConnected && !result.includes(Constants.PREPASS_NORMAL_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n            }\r\n            if (block.worldNormal.isConnected && !result.includes(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE)) {\r\n                result.push(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to set\r\n     * @returns true if the pre pass is needed\r\n     */\r\n    public override setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);\r\n\r\n        if (prePassRenderer && prePassTexturesRequired.length > 1) {\r\n            let cfg = prePassRenderer.getEffectConfiguration(\"nodeMaterial\");\r\n            if (!cfg) {\r\n                cfg = prePassRenderer.addEffectConfiguration({\r\n                    enabled: true,\r\n                    needsImageProcessing: false,\r\n                    name: \"nodeMaterial\",\r\n                    texturesRequired: [],\r\n                });\r\n            }\r\n            for (const prePassTexture of prePassTexturesRequired) {\r\n                if (!cfg.texturesRequired.includes(prePassTexture)) {\r\n                    cfg.texturesRequired.push(prePassTexture);\r\n                }\r\n            }\r\n            cfg.enabled = true;\r\n        }\r\n\r\n        // COLOR_TEXTURE is always required for prepass, length > 1 means\r\n        // we actually need to write to special prepass textures\r\n        return prePassTexturesRequired.length > 1;\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess && this.mode !== NodeMaterialModes.SFE) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(defines);\r\n\r\n        // If no vertex shader emitted, fallback to default postprocess vertex shader\r\n        const vertexCode = this._sharedData.checks.emitVertex ? this._vertexCompilationState._builtCompilationString : undefined;\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, vertexCode, this.shaderLanguage);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                vertexCode ? tempName : \"postprocess\",\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat,\r\n                this.shaderLanguage\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this.shaderLanguage\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        const refreshEffect = () => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        };\r\n\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            refreshEffect();\r\n        });\r\n\r\n        // This is needed if the procedural texture is not set to refresh automatically\r\n        this.onBuildObservable.add(() => {\r\n            refreshEffect();\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, undefined, this.shaderLanguage);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode, false);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem,\r\n                    this.shaderLanguage\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode, false);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, undefined, this.shaderLanguage);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * Use this material as the shadow depth wrapper of a target material\r\n     * @param targetMaterial defines the target material\r\n     */\r\n    public createAsShadowDepthWrapper(targetMaterial: Material) {\r\n        if (this.mode !== NodeMaterialModes.Material) {\r\n            Logger.Log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\r\n    }\r\n\r\n    private _processDefines(\r\n        defines: NodeMaterialDefines,\r\n        mesh?: AbstractMesh,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Global defines\r\n        const scene = this.getScene();\r\n        if (PrepareDefinesForCamera(scene, defines)) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Shared defines\r\n        for (const b of this._sharedData.blocksWithDefines) {\r\n            b.initializeDefines(defines);\r\n        }\r\n\r\n        for (const b of this._sharedData.blocksWithDefines) {\r\n            b.prepareDefines(defines, this, mesh, useInstances, subMesh);\r\n        }\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            for (const b of this._sharedData.repeatableContentBlocks) {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, defines, mesh);\r\n            }\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            for (const b of this._sharedData.dynamicUniformBlocks) {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            }\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            for (const u of this._fragmentCompilationState.uniforms) {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            for (const s of this._fragmentCompilationState.samplers) {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            }\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            for (const b of this._sharedData.blocksWithFallbacks) {\r\n                b.provideFallbacks(fallbacks, mesh);\r\n            }\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines || typeof subMesh.materialDefines === \"string\") {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(defines, mesh, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    multiTarget: defines.PREPASS,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                    shaderLanguage: this.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n        return `// Vertex shader\\n${this._vertexCompilationState.compilationString}\\n\\n// Fragment shader\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the fragment shader used by the engine for the current node graph\r\n     * @internal\r\n     */\r\n    public async _getProcessedFragmentAsync(): Promise<string> {\r\n        if (!this._buildWasSuccessful) {\r\n            this.build();\r\n        }\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        this._processDefines(defines);\r\n\r\n        let processingDefines = defines.toString();\r\n        if (this.mode === NodeMaterialModes.SFE) {\r\n            processingDefines += `#define ${SfeModeDefine}\\n`;\r\n        }\r\n\r\n        return await this._fragmentCompilationState.getProcessedShaderAsync(processingDefines);\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public override bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all texture blocks\r\n     * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\r\n     * @returns\r\n     */\r\n    public getAllTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        const textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            if (NodeMaterial._BlockIsTextureBlock(block)) {\r\n                textureBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        return textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n        this.onBuildErrorObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window.\r\n     * @param additionalConfig Define the configuration of the editor\r\n     */\r\n    private _createNodeEditor(additionalConfig?: any) {\r\n        const nodeEditorConfig: any = {\r\n            nodeMaterial: this,\r\n            ...additionalConfig,\r\n        };\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public async edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return await new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadBabylonScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor(config?.nodeEditorConfig);\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor(config?.nodeEditorConfig);\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes.length = 0;\r\n        this._fragmentOutputNodes.length = 0;\r\n        this.attachedBlocks.length = 0;\r\n        this._buildIsInProgress = false;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n        const textureUrl = Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png\");\r\n        currentScreen.texture = new Texture(textureUrl, this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public async loadAsync(url: string, rootUrl: string = \"\") {\r\n        return await NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Teleportation\r\n        if (rootNode.isTeleportOut) {\r\n            const block = rootNode as NodeMaterialTeleportOutBlock;\r\n            if (block.entryPoint) {\r\n                this._gatherBlocks(block.entryPoint, list);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\n`;\r\n        codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\n// Connections\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\n// Output nodes\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks defines an optional list of blocks to serialize\r\n     * @returns the serialized material object\r\n     */\r\n    public override serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     */\r\n    public parseSerializedObject(source: any, rootUrl: string = \"\", merge = false, urlRewriter?: (url: string) => string) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl, urlRewriter);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Reconnect teleportation\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isTeleportOut) {\r\n                const teleportOut = block as NodeMaterialTeleportOutBlock;\r\n                const id = teleportOut._tempEntryPointUniqueId;\r\n                if (id) {\r\n                    const source = map[id] as NodeMaterialTeleportInBlock;\r\n                    source.attachToEndpoint(teleportOut);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n                isCollapsed: boolean;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: { [key: number]: number } = {};\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        Material.ParseAlphaMode(source, this);\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @deprecated Please use the parseSerializedObject method instead\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        SerializationHelper.ParseProperties(source, this, this.getScene(), rootUrl);\r\n        this.parseSerializedObject(source, rootUrl, merge);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     * @returns the cloned material\r\n     */\r\n    public override clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Awaits for all the material textures to be ready before resolving the returned promise.\r\n     * @returns A promise that resolves when the textures are ready.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public whenTexturesReadyAsync(): Promise<void[]> {\r\n        // Ensures all textures are ready to render.\r\n        const textureReadyPromises: Promise<void>[] = [];\r\n        const activeTextures = this.getActiveTextures();\r\n        for (const texture of activeTextures) {\r\n            const internalTexture = texture.getInternalTexture();\r\n            if (internalTexture && !internalTexture.isReady) {\r\n                textureReadyPromises.push(\r\n                    new Promise((textureResolve, textureReject) => {\r\n                        internalTexture.onLoadedObservable.addOnce(() => {\r\n                            textureResolve();\r\n                        });\r\n                        internalTexture.onErrorObservable.addOnce((e) => {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            textureReject(e);\r\n                        });\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        return Promise.all(textureReadyPromises);\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param shaderLanguage defines the language to use (GLSL by default)\r\n     * @returns a new node material\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string = \"\", shaderLanguage = ShaderLanguage.GLSL): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene, { shaderLanguage: shaderLanguage }), source, scene, rootUrl);\r\n\r\n        nodeMaterial.parseSerializedObject(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param targetMaterial defines a material to use instead of creating a new one\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     * @param options defines options to be used with the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        name: string,\r\n        url: string,\r\n        scene: Scene,\r\n        rootUrl: string = \"\",\r\n        skipBuild: boolean = false,\r\n        targetMaterial?: NodeMaterial,\r\n        urlRewriter?: (url: string) => string,\r\n        options?: Partial<INodeMaterialOptions>\r\n    ): Promise<NodeMaterial> {\r\n        const material = targetMaterial ?? new NodeMaterial(name, scene, options);\r\n\r\n        const data = await scene._loadFileAsync(url);\r\n        const serializationObject = JSON.parse(data);\r\n        material.parseSerializedObject(serializationObject, rootUrl, undefined, urlRewriter);\r\n        if (!skipBuild) {\r\n            material.build();\r\n        }\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)\r\n     * @param urlRewriter defines a function used to rewrite urls\r\n     * @param options defines options to be used with the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public static ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scene: Scene = EngineStore.LastCreatedScene!,\r\n        rootUrl: string = \"\",\r\n        nodeMaterial?: NodeMaterial,\r\n        skipBuild: boolean = false,\r\n        waitForTextureReadyness: boolean = false,\r\n        urlRewriter?: (url: string) => string,\r\n        options?: Partial<INodeMaterialOptions>\r\n    ): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene, options), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.parseSerializedObject(serializationObject, undefined, undefined, urlRewriter);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        // We reset sideOrientation to default value\r\n                        nodeMaterial.sideOrientation = null;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeMaterial.build();\r\n                            }\r\n                        } catch (err) {\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(err);\r\n                        }\r\n\r\n                        if (waitForTextureReadyness) {\r\n                            nodeMaterial\r\n                                .whenTexturesReadyAsync()\r\n                                // eslint-disable-next-line github/no-then\r\n                                .then(() => {\r\n                                    resolve(nodeMaterial!);\r\n                                })\r\n                                // eslint-disable-next-line github/no-then\r\n                                .catch((err) => {\r\n                                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                    reject(err);\r\n                                });\r\n                        } else {\r\n                            resolve(nodeMaterial);\r\n                        }\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * Block used to provide an image for a TextureBlock\r\n */\r\nexport class ImageSourceBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageSourceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n\r\n        this.registerOutput(\"dimensions\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    public override bind(effect: Effect, _nodeMaterial: NodeMaterial) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setTexture(this._samplerName, this.texture);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ImageSourceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the dimension component\r\n     */\r\n    public get dimensions(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            this._samplerName = state._getFreeVariableName(this.name);\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (this.dimensions.isConnected) {\r\n            let affect: string = \"\";\r\n            if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                affect = `vec2f(textureDimensions(${this._samplerName}, 0).xy)`;\r\n            } else {\r\n                affect = `vec2(textureSize(${this._samplerName}, 0).xy)`;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(this.dimensions)} = ${affect};\\n`;\r\n        }\r\n\r\n        if (this._texture?._texture?.is2DArray) {\r\n            state._emit2DArraySampler(this._samplerName);\r\n        } else {\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode(ignoreTexture = false) {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture || ignoreTexture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(ignoreTexture = false): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (\r\n            !ignoreTexture &&\r\n            this.texture &&\r\n            (NodeMaterial.AllowSerializationOfRenderTargetTextures || !this.texture.isRenderTarget) &&\r\n            this.texture.getClassName() !== \"VideoTexture\"\r\n        ) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string, urlRewriter?: (url: string) => string) {\r\n        super._deserialize(serializationObject, scene, rootUrl, urlRewriter);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            if (serializationObject.texture.url !== undefined) {\r\n                if (serializationObject.texture.url.indexOf(\"data:\") === 0) {\r\n                    rootUrl = \"\";\r\n                } else if (urlRewriter) {\r\n                    serializationObject.texture.url = urlRewriter(serializationObject.texture.url);\r\n                    serializationObject.texture.name = serializationObject.texture.url;\r\n                }\r\n            }\r\n            if (serializationObject.texture.base64String || serializationObject.texture.url !== undefined) {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialConnectionPointDirection, type NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { RandomRange } from \"../../../../Maths/math.scalar.functions\";\r\nimport { RawTexture } from \"../../../Textures/rawTexture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { AbstractEngine } from \"../../../../Engines/abstractEngine\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { ImageSourceBlock } from \"../Dual/imageSourceBlock\";\r\nimport type { DepthSourceBlock } from \"../Dual/depthSourceBlock\";\r\n\r\n/**\r\n * Block used to evaluate screen spaceambient occlusion in a shader\r\n */\r\nexport class AmbientOcclusionBlock extends NodeMaterialBlock {\r\n    private _randomTexture: Texture;\r\n    private _randomSamplerName: string;\r\n\r\n    /**\r\n     * Defines the radius around the analyzed pixel used by the SSAO post-process\r\n     */\r\n    @editableInPropertyPage(\"radius\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0.0001,\r\n    })\r\n    public radius = 0.0001;\r\n\r\n    /**\r\n     * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel\r\n     * Must not be equal to fallOff and superior to fallOff.\r\n     */\r\n    @editableInPropertyPage(\"area\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0,\r\n    })\r\n    public area = 0.0075;\r\n\r\n    /**\r\n     * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel\r\n     * Must not be equal to area and inferior to area.\r\n     */\r\n    @editableInPropertyPage(\"fallOff\", PropertyTypeForEdition.Float, \"ADVANCED\", {\r\n        min: 0,\r\n    })\r\n    public fallOff = 0.000001;\r\n\r\n    /**\r\n     * Create a new AmbientOcclusionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\"screenSize\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"occlusion\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"AmbientOcclusionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the source component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the screenSize component\r\n     */\r\n    public get screenSize(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the occlusion output\r\n     */\r\n    public get occlusion(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        if (!this._randomTexture) {\r\n            this._createRandomTexture(effect.getEngine());\r\n        }\r\n\r\n        effect.setTexture(this._randomSamplerName, this._randomTexture);\r\n    }\r\n\r\n    private _createRandomTexture(engine: AbstractEngine): void {\r\n        const size = 512;\r\n\r\n        const data = new Uint8Array(size * size * 4);\r\n        for (let index = 0; index < data.length; ) {\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = Math.floor(Math.max(0.0, RandomRange(-1.0, 1.0)) * 255);\r\n            data[index++] = 255;\r\n        }\r\n\r\n        const texture = RawTexture.CreateRGBATexture(data, size, size, engine, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE);\r\n        texture.name = \"SSAORandomTexture\";\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        this._randomTexture = texture;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.source.connectedPoint) {\r\n            return this;\r\n        }\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n        const depthSource = this.source.connectedPoint!.ownerBlock as DepthSourceBlock;\r\n\r\n        const occlusion = this._outputs[0];\r\n        const screenSize = this.screenSize;\r\n\r\n        let functionString: string;\r\n\r\n        // Get view position from depth\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = `fn normalFromDepth(depth: f32, coords: vec2f, radius: f32) -> vec3f {\r\n                let offset1: vec2f = vec2f(0.0, radius);\r\n                let offset2: vec2f = vec2f(radius, 0.0);\r\n\r\n                let depth1: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset1, 0.0).r;\r\n                let depth2: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, coords + offset2, 0.0).r;\r\n\r\n                let p1: vec3f = vec3f(offset1, depth1 - depth);\r\n                let p2: vec3f = vec3f(offset2, depth2 - depth);\r\n\r\n                var normal: vec3f = cross(p1, p2);\r\n                normal.z = -normal.z;\r\n\r\n                return normalize(normal);\r\n            }\r\n            `;\r\n        } else {\r\n            functionString = `vec3 normalFromDepth(float depth, vec2 coords, float radius) {\r\n                vec2 offset1 = vec2(0.0, radius);\r\n                vec2 offset2 = vec2(radius, 0.0);\r\n\r\n                float depth1 = textureLod(${depthSource.samplerName}, coords + offset1, 0.0).r;\r\n                float depth2 = textureLod(${depthSource.samplerName}, coords + offset2, 0.0).r;\r\n\r\n                vec3 p1 = vec3(offset1, depth1 - depth);\r\n                vec3 p2 = vec3(offset2, depth2 - depth);\r\n\r\n                vec3 normal = cross(p1, p2);\r\n                normal.z = -normal.z;\r\n\r\n                return normalize(normal);\r\n            }\r\n            `;\r\n        }\r\n\r\n        state._emitFunction(\"normalFromDepth\", functionString, \"// normalFromDepth function\");\r\n\r\n        // Calculate ambient occlusion\r\n        this._randomSamplerName = state._getFreeVariableName(\"randomSampler\");\r\n\r\n        state._emit2DSampler(this._randomSamplerName);\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = `\r\n            const sampleSphere: array<vec3f, 16> = array<vec3f, 16>(\r\n                vec3f( 0.5381,  0.1856, -0.4319),\r\n                vec3f( 0.1379,  0.2486,  0.4430),\r\n                vec3f( 0.3371,  0.5679, -0.0057),\r\n                vec3f(-0.6999, -0.0451, -0.0019),\r\n                vec3f( 0.0689, -0.1598, -0.8547),\r\n                vec3f( 0.0560,  0.0069, -0.1843),\r\n                vec3f(-0.0146,  0.1402,  0.0762),\r\n                vec3f( 0.0100, -0.1924, -0.0344),\r\n                vec3f(-0.3577, -0.5301, -0.4358),\r\n                vec3f(-0.3169,  0.1063,  0.0158),\r\n                vec3f( 0.0103, -0.5869,  0.0046),\r\n                vec3f(-0.0897, -0.4940,  0.3287),\r\n                vec3f( 0.7119, -0.0154, -0.0918),\r\n                vec3f(-0.0533,  0.0596, -0.5411),\r\n                vec3f( 0.0352, -0.0631,  0.5460),\r\n                vec3f(-0.4776,  0.2847, -0.0271)\r\n            );\r\n\r\n            fn computeOcclusion(screenSize: vec2f) -> f32 {\r\n                let uv: vec2f = fragmentInputs.position.xy / screenSize;\r\n                let random: vec3f = normalize(textureSampleLevel(${this._randomSamplerName}, ${this._randomSamplerName}Sampler, uv * 4.0, 0.0).rgb);\r\n                let depth: f32 = textureSampleLevel(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, uv, 0.0).r;\r\n                let position: vec3f = vec3f(uv, depth);\r\n                let normal: vec3f = normalFromDepth(depth, uv, ${this.radius}f);\r\n\r\n                let radiusDepth: f32 = ${this.radius}f / depth;\r\n                var occlusion: f32 = 0.0;\r\n\r\n                var ray: vec3f;\r\n                var hemiRay: vec3f;\r\n                var occlusionDepth: f32;\r\n                var difference: f32;\r\n\r\n                for (var i: i32 = 0; i < 16; i++)\r\n                {\r\n                    ray = radiusDepth * reflect(sampleSphere[i], random);\r\n                    hemiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\n                    occlusionDepth = textureSample(${depthSource.samplerName}, ${depthSource.samplerName}Sampler, clamp(hemiRay.xy, vec2f(0.001, 0.001), vec2f(0.999, 0.999))).r;\r\n                    difference = depth - occlusionDepth;\r\n\r\n                    occlusion += step(${this.fallOff}f, difference) * (1.0 - smoothstep(${this.fallOff}f, ${this.area}f, difference));\r\n                }\r\n\r\n                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);\r\n            }\r\n            `;\r\n        } else {\r\n            functionString = `\r\n            const vec3 sampleSphere[16] = vec3[](\r\n                vec3( 0.5381,  0.1856, -0.4319),\r\n                vec3( 0.1379,  0.2486,  0.4430),\r\n                vec3( 0.3371,  0.5679, -0.0057),\r\n                vec3(-0.6999, -0.0451, -0.0019),\r\n                vec3( 0.0689, -0.1598, -0.8547),\r\n                vec3( 0.0560,  0.0069, -0.1843),\r\n                vec3(-0.0146,  0.1402,  0.0762),\r\n                vec3( 0.0100, -0.1924, -0.0344),\r\n                vec3(-0.3577, -0.5301, -0.4358),\r\n                vec3(-0.3169,  0.1063,  0.0158),\r\n                vec3( 0.0103, -0.5869,  0.0046),\r\n                vec3(-0.0897, -0.4940,  0.3287),\r\n                vec3( 0.7119, -0.0154, -0.0918),\r\n                vec3(-0.0533,  0.0596, -0.5411),\r\n                vec3( 0.0352, -0.0631,  0.5460),\r\n                vec3(-0.4776,  0.2847, -0.0271)\r\n            );\r\n\r\n            float computeOcclusion(vec2 screenSize) {\r\n                vec2 uv = gl_FragCoord.xy / screenSize;\r\n                vec3 random = normalize(textureLod(${this._randomSamplerName}, uv * 4., 0.0).rgb);\r\n                float depth = textureLod(${depthSource.samplerName}, uv, 0.0).r;              \r\n                vec3 position = vec3(uv, depth);\r\n                vec3 normal = normalFromDepth(depth, uv, ${this.radius} );\r\n\r\n                float radiusDepth = ${this.radius} / depth;\r\n                float occlusion = 0.0;\r\n\r\n                vec3 ray;\r\n                vec3 hemiRay;\r\n                float occlusionDepth;\r\n                float difference;\r\n\r\n                for (int i = 0; i < 16; i++)\r\n                {\r\n                    ray = radiusDepth * reflect(sampleSphere[i], random);\r\n                    hemiRay = position + sign(dot(ray, normal)) * ray;\r\n\r\n                    occlusionDepth = texture2D(${depthSource.samplerName}, clamp(hemiRay.xy, vec2(0.001, 0.001), vec2(0.999, 0.999))).r;\r\n                    difference = depth - occlusionDepth;\r\n\r\n                    occlusion += step(${this.fallOff}, difference) * (1.0 - smoothstep(${this.fallOff}, ${this.area}, difference));\r\n                }\r\n\r\n                return clamp(1.0 - occlusion / 16.0, 0.0, 1.0);\r\n            }\r\n            `;\r\n        }\r\n\r\n        state._emitFunction(\"computeOcclusion\", functionString, \"// computeOcclusion function\");\r\n\r\n        state.compilationString += state._declareOutput(occlusion) + ` = computeOcclusion(${screenSize.associatedVariableName});`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override dispose(): void {\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            this._randomTexture = null!;\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AmbientOcclusionBlock\", AmbientOcclusionBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport { GetFogState } from \"core/Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add support for scene fog\r\n */\r\nexport class FogBlock extends NodeMaterialBlock {\r\n    private _fogDistanceName: string;\r\n    private _fogParameters: string;\r\n\r\n    /**\r\n     * Create a new FogBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment, false);\r\n\r\n        // Vertex\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n\r\n        // Fragment\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"fogColor\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.input.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n        this.fogColor.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FogBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the fog color input component\r\n     */\r\n    public get fogColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await import(\"../../../../ShadersWGSL/ShadersInclude/fogFragmentDeclaration\");\r\n        } else {\r\n            await import(\"../../../../Shaders/ShadersInclude/fogFragmentDeclaration\");\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n        if (!this.fogColor.isConnected) {\r\n            let fogColorInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.FogColor && additionalFilteringInfo(b));\r\n\r\n            if (!fogColorInput) {\r\n                fogColorInput = new InputBlock(\"fogColor\", undefined, NodeMaterialBlockConnectionPointTypes.Color3);\r\n                fogColorInput.setAsSystemValue(NodeMaterialSystemValues.FogColor);\r\n            }\r\n            fogColorInput.output.connectTo(this.fogColor);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n        defines.setValue(\"FOG\", nodeMaterial.fogEnabled && GetFogState(mesh, scene));\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n        effect.setFloat4(this._fogParameters, scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n\r\n            let replaceStrings = [];\r\n            let prefix1 = \"\";\r\n            let prefix2 = \"\";\r\n\r\n            if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                replaceStrings = [\r\n                    { search: /fn CalcFogFactor\\(\\)/, replace: \"fn CalcFogFactor(vFogDistance: vec3f, vFogInfos: vec4f)\" },\r\n                    { search: /uniforms.vFogInfos/g, replace: \"vFogInfos\" },\r\n                    { search: /fragmentInputs.vFogDistance/g, replace: \"vFogDistance\" },\r\n                ];\r\n\r\n                prefix1 = \"fragmentInputs.\";\r\n                prefix2 = \"uniforms.\";\r\n            } else {\r\n                replaceStrings = [{ search: /float CalcFogFactor\\(\\)/, replace: \"float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)\" }];\r\n            }\r\n\r\n            state._emitFunctionFromInclude(\"fogFragmentDeclaration\", `//${this.name}`, {\r\n                removeUniforms: true,\r\n                removeVaryings: true,\r\n                removeIfDef: false,\r\n                replaceStrings: replaceStrings,\r\n            });\r\n\r\n            const tempFogVariablename = state._getFreeVariableName(\"fog\");\r\n            const color = this.input;\r\n            const fogColor = this.fogColor;\r\n            this._fogParameters = state._getFreeVariableName(\"fogParameters\");\r\n            const output = this._outputs[0];\r\n\r\n            state._emitUniformFromString(this._fogParameters, NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n            state.compilationString += `#ifdef FOG\\n`;\r\n            state.compilationString += `${state._declareLocalVar(tempFogVariablename, NodeMaterialBlockConnectionPointTypes.Float)} = CalcFogFactor(${prefix1}${this._fogDistanceName}, ${prefix2}${this._fogParameters});\\n`;\r\n            state.compilationString +=\r\n                state._declareOutput(output) +\r\n                ` = ${tempFogVariablename} * ${color.associatedVariableName}.rgb + (1.0 - ${tempFogVariablename}) * ${fogColor.associatedVariableName}.rgb;\\n`;\r\n            state.compilationString += `#else\\n${state._declareOutput(output)} =  ${color.associatedVariableName}.rgb;\\n`;\r\n            state.compilationString += `#endif\\n`;\r\n        } else {\r\n            const worldPos = this.worldPosition;\r\n            const view = this.view;\r\n            this._fogDistanceName = state._getFreeVariableName(\"vFogDistance\");\r\n            state._emitVaryingFromString(this._fogDistanceName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n            const prefix = state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\";\r\n            state.compilationString += `${prefix}${this._fogDistanceName} = (${view.associatedVariableName} * ${worldPos.associatedVariableName}).xyz;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FogBlock\", FogBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { Logger } from \"../../../../Misc/logger\";\r\nimport { BindLight, BindLights, PrepareDefinesForLight, PrepareDefinesForLights, PrepareUniformsAndSamplersForLight } from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to add light in the fragment shader\r\n */\r\nexport class LightBlock extends NodeMaterialBlock {\r\n    private _lightId: number = 0;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    private static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as LightBlock;\r\n\r\n        if (that.worldPosition.isConnected) {\r\n            that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\r\n            Logger.Error(\"The worldPosition input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        that._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    private _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    /**\r\n     * Create a new LightBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"LightBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness component\r\n     */\r\n    public get glossiness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness power component\r\n     */\r\n    public get glossPower(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse color component\r\n     */\r\n    public get diffuseColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color component\r\n     */\r\n    public get specularColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse output component\r\n     */\r\n    public get diffuseOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular output component\r\n     */\r\n    public get specularOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow output component\r\n     */\r\n    public get shadow(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n\r\n        state._excludeVariableName(\"vViewDepth\");\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/lightFragment\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/lightUboDeclaration\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/lightVxUboDeclaration\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/helperFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/lightsFragmentFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/shadowsFragmentFunctions\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/shadowsVertex\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/lightFragment\"),\r\n                import(\"../../../../Shaders/ShadersInclude/lightUboDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/lightVxUboDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/helperFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\"),\r\n                import(\"../../../../Shaders/ShadersInclude/shadowsVertex\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh || !defines._areLightsDirty) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            const state = {\r\n                needNormals: false,\r\n                needRebuild: false,\r\n                lightmapMode: false,\r\n                shadowEnabled: false,\r\n                specularEnabled: false,\r\n            };\r\n\r\n            PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\r\n\r\n            if (state.needRebuild) {\r\n                defines.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        state.samplers.push(\"areaLightsLTC1Sampler\");\r\n        state.samplers.push(\"areaLightsLTC2Sampler\");\r\n        for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\r\n            PrepareUniformsAndSamplersForLight(\r\n                lightIndex,\r\n                state.uniforms,\r\n                state.samplers,\r\n                defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n                uniformBuffers,\r\n                onlyUpdateBuffersList,\r\n                defines[\"IESLIGHTTEXTURE\" + lightIndex],\r\n                defines[\"CLUSTLIGHT\" + lightIndex]\r\n            );\r\n        }\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            BindLight(this.light, this._lightId, scene, effect, true);\r\n        }\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const worldPos = this.worldPosition;\r\n        const comments = `//${this.name}`;\r\n\r\n        // Declaration\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n            this._lightId = 0;\r\n\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        } else {\r\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\r\n            state.counters[\"lightCounter\"] = this._lightId;\r\n\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Inject code in vertex\r\n        const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\r\n\r\n        if (state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {\r\n            state.compilationString += (state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\") + `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName },\r\n                ],\r\n            });\r\n        } else {\r\n            state.compilationString += `${state._declareLocalVar(\"worldPos\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldPos.associatedVariableName};\\n`;\r\n            if (this.view.isConnected) {\r\n                state.compilationString += `${state._declareLocalVar(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix)} = ${this.view.associatedVariableName};\\n`;\r\n                state._emitVaryingFromString(\"vViewDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n                state.compilationString +=\r\n                    (state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\") +\r\n                    `vViewDepth = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;\\n`;\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n    }\r\n\r\n    private _injectUBODeclaration(state: NodeMaterialBuildState) {\r\n        const comments = `//${this.name}`;\r\n\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined,\r\n            });\r\n        } else {\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const isWGSL = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const addF = isWGSL ? \"f\" : \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state); // won't be executed if this.generateOnlyFragmentCode is true\r\n            return;\r\n        }\r\n\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        }\r\n        // Fragment\r\n        const accessor = isWGSL ? \"fragmentInputs.\" : \"\";\r\n        state.sharedData.forcedBindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        const worldPos = this.worldPosition;\r\n\r\n        let worldPosVariableName = worldPos.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode) {\r\n            worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\r\n            state._emitFunction(\"light_globalworldpos\", `${state._declareLocalVar(worldPosVariableName, NodeMaterialBlockConnectionPointTypes.Vector3, false, true)};\\n`, comments);\r\n            state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\n`;\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: `worldPos,${worldPos.associatedVariableName}`,\r\n            });\r\n        } else {\r\n            worldPosVariableName = accessor + \"v_\" + worldPosVariableName + \".xyz\";\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        let replaceString = { search: /vPositionW/g, replace: worldPosVariableName };\r\n\r\n        if (isWGSL) {\r\n            replaceString = { search: /fragmentInputs\\.vPositionW/g, replace: worldPosVariableName };\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\r\n            replaceStrings: [replaceString],\r\n        });\r\n\r\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\r\n            replaceStrings: [replaceString],\r\n        });\r\n\r\n        this._injectUBODeclaration(state);\r\n\r\n        // Code\r\n        if (this._lightId === 0) {\r\n            if (state._registerTempVariable(\"viewDirectionW\")) {\r\n                state.compilationString += `${state._declareLocalVar(\"viewDirectionW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\n`;\r\n            }\r\n            if (this.generateOnlyFragmentCode && this.view.isConnected) {\r\n                state.compilationString += `${state._declareLocalVar(\"vViewDepth\", NodeMaterialBlockConnectionPointTypes.Float)} = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;\\n`;\r\n            }\r\n\r\n            state.compilationString += isWGSL ? `var info: lightingInfo;\\n` : `lightingInfo info;\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float)} = 1.;\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"aggShadow\", NodeMaterialBlockConnectionPointTypes.Float)} = 0.;\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"numLights\", NodeMaterialBlockConnectionPointTypes.Float)} = 0.;\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${\r\n                this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"\r\n            };\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"diffuseBase\", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3${addF}(0., 0., 0.);\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"specularBase\", NodeMaterialBlockConnectionPointTypes.Vector3)}  = vec3${addF}(0., 0., 0.);\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"normalW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            let replaceString = [{ search: /vPositionW/g, replace: worldPosVariableName + \".xyz\" }];\r\n\r\n            if (isWGSL) {\r\n                replaceString = [\r\n                    { search: /fragmentInputs\\.vPositionW/g, replace: worldPosVariableName + \".xyz\" },\r\n                    { search: /uniforms\\.vReflectivityColor/g, replace: \"vReflectivityColor\" },\r\n                ];\r\n            }\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }, ...replaceString],\r\n            });\r\n        } else {\r\n            let substitutionVars = `vPositionW,${worldPosVariableName}.xyz`;\r\n\r\n            if (isWGSL) {\r\n                substitutionVars = `fragmentInputs.vPositionW,${worldPosVariableName}.xyz`;\r\n                if (this.generateOnlyFragmentCode) {\r\n                    substitutionVars += `,fragmentInputs.vViewDepth,vViewDepth`;\r\n                }\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: substitutionVars,\r\n            });\r\n        }\r\n\r\n        if (this._lightId === 0) {\r\n            state.compilationString += `aggShadow = aggShadow / numLights;\\n`;\r\n        }\r\n\r\n        const diffuseOutput = this.diffuseOutput;\r\n        const specularOutput = this.specularOutput;\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(diffuseOutput) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\n`;\r\n        if (specularOutput.hasEndpoints) {\r\n            state.compilationString +=\r\n                state._declareOutput(specularOutput) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\n`;\r\n        }\r\n\r\n        if (this.shadow.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.shadow) + ` = aggShadow;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport type { PrePassTextureBlock } from \"../Input/prePassTextureBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to read a texture from a sampler\r\n */\r\nexport class TextureBlock extends NodeMaterialBlock {\r\n    private _defineName: string;\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _transformedUVName: string;\r\n    private _textureTransformName: string;\r\n    private _textureInfoName: string;\r\n    private _mainUVName: string;\r\n    private _mainUVDefineName: string;\r\n    private _fragmentOnly: boolean;\r\n    private _imageSource: Nullable<ImageSourceBlock | PrePassTextureBlock>;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    private static _IsPrePassTextureBlock(block: Nullable<ImageSourceBlock | PrePassTextureBlock>): block is PrePassTextureBlock {\r\n        return block?.getClassName() === \"PrePassTextureBlock\";\r\n    }\r\n\r\n    private get _isSourcePrePass() {\r\n        return TextureBlock._IsPrePassTextureBlock(this._imageSource);\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        if (this._imageSource) {\r\n            if (!TextureBlock._IsPrePassTextureBlock(this._imageSource)) {\r\n                return this._imageSource.samplerName;\r\n            }\r\n            if (this.source.connectedPoint) {\r\n                return this._imageSource.getSamplerName(this.source.connectedPoint);\r\n            }\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return this.source.isConnected;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TextureBlock\r\n     * @param name defines the block name\r\n     * @param fragmentOnly\r\n     */\r\n    public constructor(name: string, fragmentOnly = false) {\r\n        super(name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._fragmentOnly = fragmentOnly;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\"layer\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"lod\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = !fragmentOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the layer input component\r\n     */\r\n    public get layer(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the LOD input component\r\n     */\r\n    public get lod(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    private _isTiedToFragment(input: NodeMaterialConnectionPoint) {\r\n        if (input.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (input.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (input.target === NodeMaterialBlockTargets.Neutral || input.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            const parentBlock = input.ownerBlock;\r\n\r\n            if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            for (const input of parentBlock.inputs) {\r\n                if (!input.isConnected) {\r\n                    continue;\r\n                }\r\n                if (this._isTiedToFragment(input.connectedPoint!)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _getEffectiveTarget() {\r\n        if (this._fragmentOnly) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\r\n        // But we need to detect uvs coming from fragment then\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this._isTiedToFragment(this.uv.connectedPoint!)) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.VertexAndFragment;\r\n    }\r\n\r\n    public override get target() {\r\n        return this._getEffectiveTarget();\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {}\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.uv.isConnected) {\r\n            if (material.mode === NodeMaterialModes.PostProcess) {\r\n                const uvInput = material.getBlockByPredicate((b) => b.name === \"uv\" && additionalFilteringInfo(b));\r\n\r\n                if (uvInput) {\r\n                    uvInput.connectTo(this);\r\n                }\r\n            } else if (material.mode !== NodeMaterialModes.ProceduralTexture) {\r\n                const attributeName = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\r\n\r\n                let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName && additionalFilteringInfo(b));\r\n\r\n                if (!uvInput) {\r\n                    uvInput = new InputBlock(\"uv\");\r\n                    uvInput.setAsAttribute(attributeName);\r\n                }\r\n                uvInput.output.connectTo(this.uv);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override initializeDefines(defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        if (this._mainUVDefineName !== undefined) {\r\n            defines.setValue(this._mainUVDefineName, false, true);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        if (!this.texture || !this.texture.getTextureMatrix) {\r\n            if (this._isMixed) {\r\n                defines.setValue(this._defineName, false, true);\r\n                defines.setValue(this._mainUVDefineName, true, true);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n\r\n        if (this._isMixed) {\r\n            if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\r\n                defines.setValue(this._defineName, true);\r\n                if (defines[this._mainUVDefineName] == undefined) {\r\n                    defines.setValue(this._mainUVDefineName, false, true);\r\n                }\r\n            } else {\r\n                defines.setValue(this._defineName, false, true);\r\n                defines.setValue(this._mainUVDefineName, true, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this._isSourcePrePass) {\r\n            return true;\r\n        }\r\n\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        if (this._isSourcePrePass) {\r\n            effect.setFloat(this._textureInfoName, 1);\r\n        }\r\n\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed) {\r\n            effect.setFloat(this._textureInfoName, this.texture.level);\r\n            effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\r\n        }\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    private get _isMixed() {\r\n        return this.target !== NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        // Inject code in vertex\r\n        this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\r\n        this._mainUVDefineName = \"VMAIN\" + uvInput.declarationVariableName.toUpperCase();\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.declarationVariableName;\r\n        this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\r\n        this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = this._textureInfoName;\r\n\r\n        state._emitVaryingFromString(this._transformedUVName, NodeMaterialBlockConnectionPointTypes.Vector2, this._defineName);\r\n        state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, this._mainUVDefineName);\r\n\r\n        state._emitUniformFromString(this._textureTransformName, NodeMaterialBlockConnectionPointTypes.Matrix, this._defineName);\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        state.compilationString += `#ifdef ${this._defineName}\\n`;\r\n        state.compilationString += `${state._getVaryingName(this._transformedUVName)} = ${vec2}(${this._textureTransformName} * ${vec4}(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\n`;\r\n\r\n        let automaticPrefix = \"\";\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            if (uvInput.isConnectedToInputBlock && uvInput.associatedVariableName.indexOf(\"vertexInputs.\") === -1) {\r\n                automaticPrefix = \"vertexInputs.\"; // Force the prefix\r\n            }\r\n        }\r\n\r\n        state.compilationString += `${state._getVaryingName(this._mainUVName)} = ${automaticPrefix}${uvInput.associatedVariableName}.xy;\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getUVW(uvName: string): string {\r\n        let coords = uvName;\r\n\r\n        const is2DArrayTexture = this._texture?._texture?.is2DArray ?? false;\r\n        const is3D = this._texture?._texture?.is3D ?? false;\r\n\r\n        if (is2DArrayTexture) {\r\n            const layerValue = this.layer.isConnected ? this.layer.associatedVariableName : \"0\";\r\n            coords = `vec3(${uvName}, ${layerValue})`;\r\n        } else if (is3D) {\r\n            const layerValue = this.layer.isConnected ? this.layer.associatedVariableName : \"0\";\r\n            coords = `vec3(${uvName}, ${layerValue})`;\r\n        }\r\n\r\n        return coords;\r\n    }\r\n\r\n    private _samplerFunc(state: NodeMaterialBuildState) {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return state.target === NodeMaterialBlockTargets.Vertex ? \"textureSampleLevel\" : \"textureSample\";\r\n        }\r\n        return this.lod.isConnected ? \"texture2DLodEXT\" : \"texture2D\";\r\n    }\r\n\r\n    private get _samplerLodSuffix() {\r\n        return this.lod.isConnected ? `, ${this.lod.associatedVariableName}` : \"\";\r\n    }\r\n\r\n    private _generateTextureSample(uv: string, state: NodeMaterialBuildState) {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            const isVertex = state.target === NodeMaterialBlockTargets.Vertex;\r\n            return `${this._samplerFunc(state)}(${this.samplerName},${this.samplerName + Constants.AUTOSAMPLERSUFFIX}, ${this._getUVW(uv)}${this._samplerLodSuffix}${isVertex ? \", 0\" : \"\"})`;\r\n        }\r\n        return `${this._samplerFunc(state)}(${this.samplerName}, ${this._getUVW(uv)}${this._samplerLodSuffix})`;\r\n    }\r\n\r\n    private _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        state.compilationString += `#ifdef ${this._defineName}\\n`;\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(state._getVaryingName(this._transformedUVName), state)};\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\n`;\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(this._mainUVName ? state._getVaryingName(this._mainUVName) : this.uv.associatedVariableName, state)}${this._samplerLodSuffix};\\n`;\r\n        state.compilationString += `#endif\\n`;\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            this._generateTextureLookup(state);\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(uvInput.associatedVariableName, state)}${this._samplerLodSuffix};\\n`;\r\n            return;\r\n        }\r\n\r\n        this._generateTextureLookup(state);\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = ${state._toLinearSpace(output)};\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            this._generateConversionCode(state, output, swizzle);\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            this._generateConversionCode(state, output, swizzle);\r\n            return;\r\n        }\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${(state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\") + this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment) {\r\n            this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n            this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n            this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n        }\r\n\r\n        if ((!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment) || (this._isMixed && state.target === NodeMaterialBlockTargets.Vertex)) {\r\n            if (!this._imageSource) {\r\n                const varName = state._getFreeVariableName(this.name);\r\n                this._samplerName = varName + \"Texture\";\r\n\r\n                if (this._texture?._texture?.is2DArray) {\r\n                    state._emit2DArraySampler(this._samplerName);\r\n                } else {\r\n                    state._emit2DSampler(this._samplerName);\r\n                }\r\n            }\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed && !this._imageSource) {\r\n            // Reexport the sampler\r\n            if (this._texture?._texture?.is2DArray) {\r\n                state._emit2DArraySampler(this._samplerName);\r\n            } else {\r\n                state._emit2DSampler(this._samplerName);\r\n            }\r\n        }\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (this._isMixed) {\r\n            state._emitUniformFromString(this._textureInfoName, NodeMaterialBlockConnectionPointTypes.Float);\r\n        }\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.fragmentOnly = this._fragmentOnly;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        if (\r\n            !this.hasImageSource &&\r\n            this.texture &&\r\n            (NodeMaterial.AllowSerializationOfRenderTargetTextures || !this.texture.isRenderTarget) &&\r\n            this.texture.getClassName() !== \"VideoTexture\"\r\n        ) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string, urlRewriter?: (url: string) => string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this._fragmentOnly = !!serializationObject.fragmentOnly;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            if (serializationObject.texture.url !== undefined) {\r\n                if (serializationObject.texture.url.indexOf(\"data:\") === 0) {\r\n                    rootUrl = \"\";\r\n                } else if (urlRewriter) {\r\n                    serializationObject.texture.url = urlRewriter(serializationObject.texture.url);\r\n                    serializationObject.texture.name = serializationObject.texture.url;\r\n                }\r\n            }\r\n            if (serializationObject.texture.base64String || serializationObject.texture.url !== undefined) {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TextureBlock\", TextureBlock);\r\n", "import { serialize, serializeAsMatrix, serializeAsVector3 } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\nimport \"../../Engines/AbstractEngine/abstractEngine.cubeTexture\";\r\n\r\n/**\r\n * Defines the available options when creating a cube texture\r\n */\r\nexport interface ICubeTextureCreationOptions {\r\n    /** Defines the suffixes add to the picture name in case six images are in use like _px.jpg */\r\n    extensions?: string[];\r\n\r\n    /** noMipmap defines if mipmaps should be created or not */\r\n    noMipmap?: boolean;\r\n\r\n    /** files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz */\r\n    files?: string[];\r\n\r\n    /** buffer to load instead of loading the data from the url */\r\n    buffer?: ArrayBufferView;\r\n\r\n    /** onLoad defines a callback triggered at the end of the file load if no errors occurred */\r\n    onLoad?: () => void;\r\n\r\n    /** onError defines a callback triggered in case of error during load */\r\n    onError?: (message?: string, exception?: any) => void;\r\n\r\n    /** format defines the internal format to use for the texture once loaded */\r\n    format?: number;\r\n\r\n    /** prefiltered defines whether or not the texture is created from prefiltered data */\r\n    prefiltered?: boolean;\r\n\r\n    /** forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name */\r\n    forcedExtension?: any;\r\n\r\n    /** createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary */\r\n    createPolynomials?: boolean;\r\n\r\n    /** lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness */\r\n    lodScale?: number;\r\n\r\n    /** lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness */\r\n    lodOffset?: number;\r\n\r\n    /** loaderOptions options to be passed to the loader */\r\n    loaderOptions?: any;\r\n\r\n    /** useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n}\r\n\r\n// The default scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\nconst DefaultLodScale = 0.8;\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number;\r\n    private _lodOffset: number;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    @serializeAsMatrix(\"textureMatrixRefraction\")\r\n    private _textureMatrixRefraction: Matrix = new Matrix();\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n    private _buffer: Nullable<ArrayBufferView> = null;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        for (const url of files) {\r\n            rootUrlKey += url;\r\n        }\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | AbstractEngine,\r\n        extensionsOrOptions: Nullable<string[] | ICubeTextureCreationOptions> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = DefaultLodScale,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n\r\n        let extensions: Nullable<string[]> = null;\r\n        let buffer: Nullable<ArrayBufferView> = null;\r\n\r\n        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {\r\n            extensions = extensionsOrOptions.extensions ?? null;\r\n            this._noMipmap = extensionsOrOptions.noMipmap ?? false;\r\n            files = extensionsOrOptions.files ?? null;\r\n            buffer = extensionsOrOptions.buffer ?? null;\r\n            this._format = extensionsOrOptions.format ?? Constants.TEXTUREFORMAT_RGBA;\r\n            prefiltered = extensionsOrOptions.prefiltered ?? false;\r\n            forcedExtension = extensionsOrOptions.forcedExtension ?? null;\r\n            this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;\r\n            this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;\r\n            this._lodOffset = extensionsOrOptions.lodOffset ?? 0;\r\n            this._loaderOptions = extensionsOrOptions.loaderOptions;\r\n            this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;\r\n            onLoad = extensionsOrOptions.onLoad ?? null;\r\n            onError = extensionsOrOptions.onError ?? null;\r\n        } else {\r\n            this._noMipmap = noMipmap;\r\n            this._format = format;\r\n            this._createPolynomials = createPolynomials;\r\n            extensions = extensionsOrOptions;\r\n            this._loaderOptions = loaderOptions;\r\n            this._useSRGBBuffer = useSRGBBuffer;\r\n            this._lodScale = lodScale;\r\n            this._lodOffset = lodOffset;\r\n        }\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param buffer the buffer to use instead of loading from the url\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension: Nullable<string> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null,\r\n        buffer: Nullable<ArrayBufferView> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        this._buffer = buffer;\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public override delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n\r\n        if (!this.getScene()?.useRightHandedSystem) {\r\n            return;\r\n        }\r\n\r\n        const scale = TmpVectors.Vector3[0];\r\n        const quat = TmpVectors.Quaternion[0];\r\n        const trans = TmpVectors.Vector3[1];\r\n\r\n        this._textureMatrix.decompose(scale, quat, trans);\r\n\r\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\r\n        quat.w *= -1;\r\n\r\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public override getRefractionTextureMatrix(): Matrix {\r\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer,\r\n                    this._buffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + (parsedTexture.url ?? parsedTexture.name),\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public override clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\n\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { SubMesh } from \"../../../..//Meshes/subMesh\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _defineCubicName: string;\r\n    /** @internal */\r\n    public _defineExplicitName: string;\r\n    /** @internal */\r\n    public _defineProjectionName: string;\r\n    /** @internal */\r\n    public _defineLocalCubicName: string;\r\n    /** @internal */\r\n    public _defineSphericalName: string;\r\n    /** @internal */\r\n    public _definePlanarName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularName: string;\r\n    /** @internal */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineSkyboxName: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _reflectionPositionName: string;\r\n    /** @internal */\r\n    public _reflectionSizeName: string;\r\n\r\n    protected _positionUVWName: string;\r\n    protected _directionWname: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @internal */\r\n    public _reflectionCoordsName: string;\r\n    /** @internal */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n    protected _worldPositionNameInFragmentOnlyMode: string;\r\n\r\n    protected _texture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<BaseTexture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    protected static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as ReflectionTextureBaseBlock;\r\n        return that._onGenerateOnlyFragmentCodeChanged();\r\n    }\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        this._setTarget();\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await import(\"../../../../ShadersWGSL/ShadersInclude/reflectionFunction\");\r\n        } else {\r\n            await import(\"../../../../Shaders/ShadersInclude/reflectionFunction\");\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Auto configure the node based on the existing material\r\n     * @param material defines the material to configure\r\n     * @param additionalFilteringInfo defines additional info to be used when filtering inputs (we might want to skip some non relevant blocks)\r\n     */\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === Constants.TEXTURE_EXPLICIT_MODE, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === Constants.TEXTURE_SKYBOX_MODE, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === Constants.TEXTURE_CUBIC_MODE || texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === Constants.TEXTURE_SPHERICAL_MODE, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === Constants.TEXTURE_PLANAR_MODE, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === Constants.TEXTURE_PROJECTION_MODE, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === Constants.TEXTURE_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, _subMesh?: SubMesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n\r\n        if ((<any>texture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>texture;\r\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return \"\";\r\n        }\r\n\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);\r\n\r\n        let code = \"\";\r\n\r\n        this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\r\n\r\n        const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {\r\n            if (this.generateOnlyFragmentCode) {\r\n                code += `${state._declareLocalVar(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.worldPosition.associatedVariableName};\\n`;\r\n            } else {\r\n                code += `${isWebGPU ? \"vertexOutputs.\" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\n`;\r\n            }\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWname = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, NodeMaterialBlockConnectionPointTypes.Vector3, this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\n`;\r\n            if (this.generateOnlyFragmentCode) {\r\n                code += `${state._declareLocalVar(this._positionUVWName, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.position.associatedVariableName}.xyz;\\n`;\r\n            } else {\r\n                code += `${isWebGPU ? \"vertexOutputs.\" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\n`;\r\n            }\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        if (\r\n            this.generateOnlyFragmentCode ||\r\n            state._emitVaryingFromString(\r\n                this._directionWname,\r\n                NodeMaterialBlockConnectionPointTypes.Vector3,\r\n                `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`\r\n            )\r\n        ) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\n`;\r\n            if (this.generateOnlyFragmentCode) {\r\n                code += `${state._declareLocalVar(this._directionWname, NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(vec3${state.fSuffix}(${this.world.associatedVariableName} * vec4${state.fSuffix}(${\r\n                    this.position.associatedVariableName\r\n                }.xyz, 0.0)));\\n`;\r\n            } else {\r\n                code += `${isWebGPU ? \"vertexOutputs.\" : \"\"}${this._directionWname} = normalize(vec3${state.fSuffix}(${this.world.associatedVariableName} * vec4${state.fSuffix}(${\r\n                    this.position.associatedVariableName\r\n                }.xyz, 0.0)));\\n`;\r\n            }\r\n            code += `#endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n        state._emitCubeSampler(this._cubeSamplerName, \"\", true);\r\n        state._samplerDeclaration += `#else\\n`;\r\n        state._emit2DSampler(this._2DSamplerName, \"\", true);\r\n        state._samplerDeclaration += `#endif\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [\r\n                { search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" },\r\n                { search: /fn computeReflectionCoords\\(worldPos: vec4f,worldNormal: vec3f\\)->vec3f/g, replace: \"fn DUMMYFUNC()\" },\r\n            ],\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n\r\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionPositionName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionSizeName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param state defines the build state\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(\r\n        state: NodeMaterialBuildState,\r\n        worldNormalVarName: string,\r\n        worldPos?: string,\r\n        onlyReflectionVector = false,\r\n        doNotEmitInvertZ = false\r\n    ): string {\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        const reflectionMatrix = (isWebGPU ? \"uniforms.\" : \"\") + this._reflectionMatrixName;\r\n        const direction = `normalize(${this._directionWname})`;\r\n        const positionUVW = `${this._positionUVWName}`;\r\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        const view = `${this.view.associatedVariableName}`;\r\n        const fragmentInputsPrefix = isWebGPU ? \"fragmentInputs.\" : \"\";\r\n\r\n        if (!worldPos) {\r\n            worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `${fragmentInputsPrefix}v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n               ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                ${state._declareLocalVar(this._reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3(0, 0, 0);\r\n            #endif\\n`;\r\n\r\n        if (!doNotEmitInvertZ) {\r\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\n`;\r\n        }\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    ${state._declareLocalVar(this._reflectionCoordsName, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._reflectionVectorName};\r\n                #else\r\n                    ${state._declareLocalVar(this._reflectionCoordsName, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param state defines the build state\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(state: NodeMaterialBuildState, lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        let colorType = NodeMaterialBlockConnectionPointTypes.Vector4;\r\n\r\n        if (swizzleLookupTexture.length === 3) {\r\n            colorType = NodeMaterialBlockConnectionPointTypes.Vector3;\r\n        }\r\n\r\n        let code = `${state._declareLocalVar(this._reflectionColorName, colorType)};\r\n            #ifdef ${this._define3DName}\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = ${state._generateTextureSampleCubeLOD(this._reflectionVectorName, this._cubeSamplerName, lodVarName)}${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = ${state._generateTextureSampleCube(this._reflectionVectorName, this._cubeSamplerName)}${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} =${state._generateTextureSampleLOD(this._reflectionCoordsName, this._2DSamplerName, lodVarName)}${swizzleLookupTexture};\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = ${state._generateTextureSample(this._reflectionCoordsName, this._2DSamplerName)}${swizzleLookupTexture};\\n`;\r\n        }\r\n\r\n        code += `#endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (const output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${state._declareOutput(output)} = ${varName}.${output.name};\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        if (this.texture.isCube) {\r\n            const forcedExtension = (this.texture as CubeTexture).forcedExtension;\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${\r\n                this.texture.noMipmap\r\n            }, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\n`;\r\n        } else {\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { ReflectionTextureBaseBlock } from \"./reflectionTextureBaseBlock\";\r\nimport type { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Block used to read a reflection texture from a sampler\r\n */\r\nexport class ReflectionTextureBlock extends ReflectionTextureBaseBlock {\r\n    protected override _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        if (this.position.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            Logger.Error(\"The position input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        if (this.worldPosition.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            Logger.Error(\"The worldPosition input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        this._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected override _setTarget(): void {\r\n        super._setTarget();\r\n        this.getInputByName(\"position\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment); // Flagging as fragment as the normal can be changed by fragment code\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReflectionTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        super.autoConfigure(material);\r\n\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.texture) {\r\n            state.compilationString += this.writeOutputs(state, `vec4${state.fSuffix}(0.)`);\r\n            return this;\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += this.handleVertexSide(state);\r\n            return this;\r\n        }\r\n\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.compilationString += this.handleVertexSide(state);\r\n        }\r\n\r\n        this.handleFragmentSideInits(state);\r\n\r\n        const normalWUnit = state._getFreeVariableName(\"normalWUnit\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(normalWUnit, NodeMaterialBlockConnectionPointTypes.Vector4)} = normalize(${this.worldNormal.associatedVariableName});\\n`;\r\n\r\n        state.compilationString += this.handleFragmentSideCodeReflectionCoords(state, normalWUnit);\r\n\r\n        state.compilationString += this.handleFragmentSideCodeReflectionColor(state, undefined, \"\");\r\n\r\n        state.compilationString += this.writeOutputs(state, this._reflectionColorName);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBlock\", ReflectionTextureBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\n/**\r\n * Block used to retrieve the depth (zbuffer) of the scene\r\n * @since 5.0.0\r\n */\r\nexport class SceneDepthBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    private _mainUVName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in non linear mode\r\n     */\r\n    @editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        embedded: true,\r\n        notifiers: {\r\n            activatePreviewCommand: true,\r\n            callback: (scene, block) => {\r\n                const sceneDepthBlock = block as SceneDepthBlock;\r\n                let retVal = false;\r\n                if (sceneDepthBlock.useNonLinearDepth) {\r\n                    sceneDepthBlock.storeCameraSpaceZ = false;\r\n                    retVal = true;\r\n                }\r\n                if (scene) {\r\n                    scene.disableDepthRenderer();\r\n                }\r\n                return retVal;\r\n            },\r\n        },\r\n    })\r\n    public useNonLinearDepth = false;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in camera space Z mode (if set, useNonLinearDepth has no effect)\r\n     */\r\n    @editableInPropertyPage(\"Store Camera space Z\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: {\r\n            activatePreviewCommand: true,\r\n            callback: (scene, block) => {\r\n                const sceneDepthBlock = block as SceneDepthBlock;\r\n                let retVal = false;\r\n                if (sceneDepthBlock.storeCameraSpaceZ) {\r\n                    sceneDepthBlock.useNonLinearDepth = false;\r\n                    retVal = true;\r\n                }\r\n                if (scene) {\r\n                    scene.disableDepthRenderer();\r\n                }\r\n                return retVal;\r\n            },\r\n        },\r\n    })\r\n    public storeCameraSpaceZ = false;\r\n\r\n    /**\r\n     * Defines if the depth renderer should be setup in full 32 bits float mode\r\n     */\r\n    @editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { activatePreviewCommand: true, callback: (scene) => scene?.disableDepthRenderer() },\r\n    })\r\n    public force32itsFloat = false;\r\n\r\n    /**\r\n     * Create a new SceneDepthBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[0]._prioritizeVertex = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SceneDepthBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth output component\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"textureSampler\");\r\n    }\r\n\r\n    public override get target() {\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _getTexture(scene: Scene): BaseTexture {\r\n        const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat, undefined, this.storeCameraSpaceZ);\r\n\r\n        return depthRenderer.getDepthMap();\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial) {\r\n        const texture = this._getTexture(nodeMaterial.getScene());\r\n\r\n        effect.setTexture(this._samplerName, texture);\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const uvInput = this.uv;\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            const uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(\r\n                    uvInput.associatedVariableName,\r\n                    uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3\r\n                        ? NodeMaterialBlockConnectionPointTypes.Vector3\r\n                        : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4\r\n                          ? NodeMaterialBlockConnectionPointTypes.Vector4\r\n                          : NodeMaterialBlockConnectionPointTypes.Vector2\r\n                );\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n\r\n        state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\", true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        const uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n            const textureReadFunc =\r\n                state.shaderLanguage === ShaderLanguage.GLSL\r\n                    ? `texture2D(${this._samplerName},`\r\n                    : `textureSampleLevel(${this._samplerName}, ${this._samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n            const complement = state.shaderLanguage === ShaderLanguage.GLSL ? \"\" : \", 0\";\r\n\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)}=  ${textureReadFunc} ${uvInput.associatedVariableName}.xy${complement});\\n`;\r\n            return;\r\n        }\r\n\r\n        const textureReadFunc =\r\n            state.shaderLanguage === ShaderLanguage.GLSL\r\n                ? `texture2D(${this._samplerName},`\r\n                : `textureSample(${this._samplerName}, ${this._samplerName + Constants.AUTOSAMPLERSUFFIX},`;\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName}.xy);\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};\\n`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            state._emit2DSampler(this._samplerName);\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, \"r\");\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useNonLinearDepth = this.useNonLinearDepth;\r\n        serializationObject.storeCameraSpaceZ = this.storeCameraSpaceZ;\r\n        serializationObject.force32itsFloat = this.force32itsFloat;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useNonLinearDepth = serializationObject.useNonLinearDepth;\r\n        this.storeCameraSpaceZ = !!serializationObject.storeCameraSpaceZ;\r\n        this.force32itsFloat = serializationObject.force32itsFloat;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);\r\n", "import { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\nimport { ImageSourceBlock } from \"./imageSourceBlock\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Texture } from \"../../../Textures/texture\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\n/**\r\n * Block used to provide an depth texture for a TextureBlock\r\n */\r\nexport class DepthSourceBlock extends ImageSourceBlock {\r\n    /**\r\n     * Creates a new DepthSourceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public override get texture(): Nullable<Texture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public override set texture(texture: Nullable<Texture>) {\r\n        // Do nothing, we always use the depth texture from the scene\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial) {\r\n        const scene = nodeMaterial.getScene();\r\n        const renderer = scene.enableDepthRenderer();\r\n\r\n        this._texture = renderer.getDepthMap();\r\n\r\n        super.bind(effect, nodeMaterial);\r\n    }\r\n\r\n    public override isReady() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DepthSourceBlock\";\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        return super._dumpPropertiesCode(true);\r\n    }\r\n\r\n    public override serialize(): any {\r\n        return super.serialize(true);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DepthSourceBlock\", DepthSourceBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { BindClipPlane } from \"../../../../Materials/clipPlaneMaterialHelper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * Block used to implement clip planes\r\n */\r\nexport class ClipPlanesBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ClipPlanesBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment, true);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ClipPlanesBlock\";\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vClipPlane\");\r\n        state._excludeVariableName(\"fClipDistance\");\r\n        state._excludeVariableName(\"vClipPlane2\");\r\n        state._excludeVariableName(\"fClipDistance2\");\r\n        state._excludeVariableName(\"vClipPlane3\");\r\n        state._excludeVariableName(\"fClipDistance3\");\r\n        state._excludeVariableName(\"vClipPlane4\");\r\n        state._excludeVariableName(\"fClipDistance4\");\r\n        state._excludeVariableName(\"vClipPlane5\");\r\n        state._excludeVariableName(\"fClipDistance5\");\r\n        state._excludeVariableName(\"vClipPlane6\");\r\n        state._excludeVariableName(\"fClipDistance6\");\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/clipPlaneFragment\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/clipPlaneVertex\"),\r\n                import(\"../../../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([\r\n                import(\"../../../../Shaders/ShadersInclude/clipPlaneFragment\"),\r\n                import(\"../../../../Shaders/ShadersInclude/clipPlaneFragmentDeclaration\"),\r\n                import(\"../../../../Shaders/ShadersInclude/clipPlaneVertex\"),\r\n                import(\"../../../../Shaders/ShadersInclude/clipPlaneVertexDeclaration\"),\r\n            ]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the worldPosition input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    public override get target() {\r\n        return NodeMaterialBlockTargets.VertexAndFragment;\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {}\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        const useClipPlane1 = (nodeMaterial.clipPlane ?? scene.clipPlane) ? true : false;\r\n        const useClipPlane2 = (nodeMaterial.clipPlane2 ?? scene.clipPlane2) ? true : false;\r\n        const useClipPlane3 = (nodeMaterial.clipPlane3 ?? scene.clipPlane3) ? true : false;\r\n        const useClipPlane4 = (nodeMaterial.clipPlane4 ?? scene.clipPlane4) ? true : false;\r\n        const useClipPlane5 = (nodeMaterial.clipPlane5 ?? scene.clipPlane5) ? true : false;\r\n        const useClipPlane6 = (nodeMaterial.clipPlane6 ?? scene.clipPlane6) ? true : false;\r\n\r\n        defines.setValue(\"CLIPPLANE\", useClipPlane1, true);\r\n        defines.setValue(\"CLIPPLANE2\", useClipPlane2, true);\r\n        defines.setValue(\"CLIPPLANE3\", useClipPlane3, true);\r\n        defines.setValue(\"CLIPPLANE4\", useClipPlane4, true);\r\n        defines.setValue(\"CLIPPLANE5\", useClipPlane5, true);\r\n        defines.setValue(\"CLIPPLANE6\", useClipPlane6, true);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        BindClipPlane(effect, nodeMaterial, scene);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const comments = `//${this.name}`;\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            const worldPos = this.worldPosition;\r\n\r\n            state._emitFunctionFromInclude(\"clipPlaneVertexDeclaration\", comments, {\r\n                replaceStrings: [{ search: /uniform vec4 vClipPlane\\d*;/g, replace: \"\" }],\r\n            });\r\n            state.compilationString += state._emitCodeFromInclude(\"clipPlaneVertex\", comments, {\r\n                replaceStrings: [{ search: /worldPos/g, replace: worldPos.associatedVariableName }],\r\n            });\r\n\r\n            state._emitUniformFromString(\"vClipPlane\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClipPlane2\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClipPlane3\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClipPlane4\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClipPlane5\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClipPlane6\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.bindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        state._emitFunctionFromInclude(\"clipPlaneFragmentDeclaration\", comments);\r\n        state.compilationString += state._emitCodeFromInclude(\"clipPlaneFragment\", comments);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ClipPlanesBlock\", ClipPlanesBlock);\r\n", "import type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\nimport { CurrentScreenBlock } from \"./currentScreenBlock\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { InputBlock } from \"../Input/inputBlock\";\nimport type { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\nimport type { NodeMaterial } from \"../../nodeMaterial\";\nimport type { Scene } from \"core/scene\";\nimport { SfeModeDefine } from \"../Fragment/smartFilterFragmentOutputBlock\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\nimport type { Nullable } from \"../../../../types\";\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\nimport { ImageSourceBlock } from \"./imageSourceBlock\";\n\n/**\n * Base block used for creating Smart Filter shader blocks for the SFE framework.\n * This block extends the functionality of CurrentScreenBlock, as both are used\n * to represent arbitrary 2D textures to compose, and work similarly.\n */\nexport class SmartFilterTextureBlock extends CurrentScreenBlock {\n    private _firstInit: boolean = true;\n\n    /**\n     * A boolean indicating whether this block should be the main input for the SFE pipeline.\n     * If true, it can be used in SFE for auto-disabling.\n     */\n    public isMainInput: boolean = false;\n\n    /**\n     * Gets the sampler name associated with this texture\n     */\n    public override get samplerName(): string {\n        if (this.source.connectedPoint) {\n            return (this.source.connectedPoint.ownerBlock as ImageSourceBlock).samplerName;\n        }\n        return this._samplerName;\n    }\n\n    /**\n     * Gets or sets the texture associated with this block\n     */\n    public override get texture(): Nullable<BaseTexture> {\n        if (this.source.connectedPoint) {\n            return (this.source.connectedPoint.ownerBlock as ImageSourceBlock).texture;\n        }\n        return this._texture;\n    }\n    public override set texture(value: Nullable<BaseTexture>) {\n        this._texture = value;\n    }\n\n    /**\n     * Create a new SmartFilterTextureBlock\n     * @param name defines the block name\n     */\n    public constructor(name: string) {\n        super(name);\n\n        this.registerInput(\n            \"source\",\n            NodeMaterialBlockConnectionPointTypes.Object,\n            true,\n            NodeMaterialBlockTargets.VertexAndFragment,\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\n        );\n    }\n\n    /**\n     * Gets the source input component\n     */\n    public get source(): NodeMaterialConnectionPoint {\n        return this._inputs[1];\n    }\n\n    /**\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n     */\n    public get hasImageSource(): boolean {\n        return this.source.isConnected;\n    }\n\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    public override getClassName() {\n        return \"SmartFilterTextureBlock\";\n    }\n\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    public override initialize(state: NodeMaterialBuildState) {\n        if (this._firstInit) {\n            this._samplerName = state._getFreeVariableName(this.name);\n            this._firstInit = false;\n        }\n    }\n\n    protected override _getMainUvName(state: NodeMaterialBuildState): string {\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\n            state.sharedData.raiseBuildError(\"SmartFilterTextureBlock: 'postprocess_uv' attribute from ScreenUVBlock is required.\");\n            return \"\";\n        }\n        return screenUv.associatedVariableName;\n    }\n\n    protected override _emitUvAndSampler(state: NodeMaterialBuildState): void {\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            // Wrap the varying in a define, as it won't be needed in SFE.\n            state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, SfeModeDefine, true);\n\n            if (!this.hasImageSource) {\n                // Append `// main` to denote this as the main input texture to composite\n                const annotation = this.isMainInput ? \"// main\" : undefined;\n                state._emit2DSampler(this._samplerName, undefined, undefined, annotation);\n            }\n        }\n    }\n\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\n        if (!this.uv.isConnected) {\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\" && additionalFilteringInfo(b));\n\n            if (!uvInput) {\n                uvInput = new InputBlock(\"uv\");\n                uvInput.setAsAttribute(\"postprocess_uv\");\n            }\n            uvInput.output.connectTo(this.uv);\n        }\n    }\n\n    public override _postBuildBlock(): void {\n        this._firstInit = true;\n    }\n\n    public override serialize(): any {\n        const serializationObject = super.serialize();\n        serializationObject.isMainInput = this.isMainInput;\n        return serializationObject;\n    }\n\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.isMainInput = serializationObject.isMainInput;\n    }\n}\n\nRegisterClass(\"BABYLON.SmartFilterTextureBlock\", SmartFilterTextureBlock);\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { Effect } from \"../../../../Materials/effect\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport { ImageSourceBlock } from \"../Dual/imageSourceBlock\";\r\n\r\n/**\r\n * Block used to read from prepass textures\r\n */\r\nexport class PrePassTextureBlock extends NodeMaterialBlock {\r\n    private _positionSamplerName: string;\r\n    private _localPositionSamplerName: string;\r\n    private _depthSamplerName: string;\r\n    private _screenSpaceDepthSamplerName: string;\r\n    private _normalSamplerName: string;\r\n    private _worldNormalSamplerName: string;\r\n\r\n    /**\r\n     * The texture associated with the node is the prepass texture\r\n     */\r\n    public get texture() {\r\n        return null;\r\n    }\r\n\r\n    public set texture(value: any) {\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Creates a new PrePassTextureBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (VertexAndFragment by default)\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.VertexAndFragment) {\r\n        super(name, target, false);\r\n\r\n        this.registerOutput(\r\n            \"position\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"position\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerOutput(\r\n            \"localPosition\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"localPosition\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerOutput(\r\n            \"depth\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"depth\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerOutput(\r\n            \"screenDepth\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"screenDepth\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerOutput(\r\n            \"normal\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"normal\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerOutput(\r\n            \"worldNormal\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"worldNormal\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the sampler name associated with the node connection point\r\n     * @param output defines the connection point to get the associated sampler name\r\n     * @returns\r\n     */\r\n    public getSamplerName(output: NodeMaterialConnectionPoint): string {\r\n        if (output === this._outputs[0]) {\r\n            return this._positionSamplerName;\r\n        }\r\n\r\n        if (output === this._outputs[1]) {\r\n            return this._localPositionSamplerName;\r\n        }\r\n\r\n        if (output === this._outputs[2]) {\r\n            return this._depthSamplerName;\r\n        }\r\n\r\n        if (output === this._outputs[3]) {\r\n            return this._screenSpaceDepthSamplerName;\r\n        }\r\n\r\n        if (output === this._outputs[4]) {\r\n            return this._normalSamplerName;\r\n        }\r\n\r\n        if (output === this._outputs[5]) {\r\n            return this._worldNormalSamplerName;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position texture\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the local position texture\r\n     */\r\n    public get localPosition(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the depth texture\r\n     */\r\n    public get depth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the screen depth texture\r\n     */\r\n    public get screenDepth(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal texture\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal texture\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get positionSamplerName(): string {\r\n        return this._positionSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get localPositionSamplerName(): string {\r\n        return this._localPositionSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get normalSamplerName(): string {\r\n        return this._normalSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get worldNormalSamplerName(): string {\r\n        return this._worldNormalSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get depthSamplerName(): string {\r\n        return this._depthSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get linearDepthSamplerName(): string {\r\n        return this._screenSpaceDepthSamplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PrePassTextureBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._positionSamplerName = \"prepassPositionSampler\";\r\n        this._depthSamplerName = \"prepassDepthSampler\";\r\n        this._normalSamplerName = \"prepassNormalSampler\";\r\n        this._worldNormalSamplerName = \"prepassWorldNormalSampler\";\r\n        this._localPositionSamplerName = \"prepassLocalPositionSampler\";\r\n        this._screenSpaceDepthSamplerName = \"prepassScreenSpaceDepthSampler\";\r\n\r\n        // Unique sampler names for every prepasstexture block\r\n        state.sharedData.variableNames.prepassPositionSampler = 0;\r\n        state.sharedData.variableNames.prepassDepthSampler = 0;\r\n        state.sharedData.variableNames.prepassNormalSampler = 0;\r\n        state.sharedData.variableNames.prepassWorldNormalSampler = 0;\r\n        state.sharedData.variableNames.prepassLocalPositionSampler = 0;\r\n        state.sharedData.variableNames.prepassScreenSpaceDepthSampler = 0;\r\n\r\n        // Declarations\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        if (this.position.isConnected) {\r\n            state._emit2DSampler(this._positionSamplerName);\r\n        }\r\n        if (this.depth.isConnected) {\r\n            state._emit2DSampler(this._depthSamplerName);\r\n        }\r\n        if (this.normal.isConnected) {\r\n            state._emit2DSampler(this._normalSamplerName);\r\n        }\r\n        if (this.worldNormal.isConnected) {\r\n            state._emit2DSampler(this._worldNormalSamplerName);\r\n        }\r\n        if (this.localPosition.isConnected) {\r\n            state._emit2DSampler(this._localPositionSamplerName);\r\n        }\r\n        if (this.screenDepth.isConnected) {\r\n            state._emit2DSampler(this._screenSpaceDepthSamplerName);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial) {\r\n        const scene = nodeMaterial.getScene();\r\n        const prePassRenderer = scene.enablePrePassRenderer();\r\n        if (!prePassRenderer) {\r\n            return;\r\n        }\r\n\r\n        const sceneRT = prePassRenderer.defaultRT;\r\n        if (!sceneRT.textures) {\r\n            return;\r\n        }\r\n\r\n        if (this.position.isConnected) {\r\n            effect.setTexture(this._positionSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_POSITION_TEXTURE_TYPE)]);\r\n        }\r\n        if (this.localPosition.isConnected) {\r\n            effect.setTexture(this._localPositionSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE)]);\r\n        }\r\n        if (this.depth.isConnected) {\r\n            effect.setTexture(this._depthSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE)]);\r\n        }\r\n        if (this.screenDepth.isConnected) {\r\n            effect.setTexture(this._screenSpaceDepthSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE)]);\r\n        }\r\n        if (this.normal.isConnected) {\r\n            effect.setTexture(this._normalSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE)]);\r\n        }\r\n        if (this.worldNormal.isConnected) {\r\n            effect.setTexture(this._worldNormalSamplerName, sceneRT.textures[prePassRenderer.getIndex(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE)]);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PrePassTextureBlock\", PrePassTextureBlock);\r\n", "import { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { InputBlock } from \"../Input/inputBlock\";\r\nimport type { NodeMaterialTeleportOutBlock } from \"./teleportOutBlock\";\r\n\r\n/**\r\n * Defines a block used to teleport a value to an endpoint\r\n */\r\nexport class NodeMaterialTeleportInBlock extends NodeMaterialBlock {\r\n    private _endpoints: NodeMaterialTeleportOutBlock[] = [];\r\n\r\n    /** Gets the list of attached endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public override get target() {\r\n        const input = this._inputs[0];\r\n        if (input.isConnected) {\r\n            const block = input.connectedPoint!.ownerBlock;\r\n            if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n                return block.target;\r\n            }\r\n\r\n            if (input.connectedPoint!.target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n                return input.connectedPoint!.target;\r\n            }\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Create a new NodeMaterialTeleportInBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NodeMaterialTeleportInBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * @returns a boolean indicating that this connection will be used in the fragment shader\r\n     */\r\n    public override isConnectedInFragmentShader() {\r\n        return this.endpoints.some((e) => e.output.isConnectedInFragmentShader);\r\n    }\r\n\r\n    /**\r\n     * Checks if the input is connected to a uniform input block\r\n     */\r\n    public get isConnectedToUniform() {\r\n        return this.input.isConnected && this.input.connectedPoint!.ownerBlock.isInput && (this.input.connectedPoint!.ownerBlock as InputBlock).isUniform;\r\n    }\r\n\r\n    public override _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = super._dumpCode(uniqueNames, alreadyDumped);\r\n\r\n        for (const endpoint of this.endpoints) {\r\n            if (alreadyDumped.indexOf(endpoint) === -1) {\r\n                codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public override isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const endpoint of this.endpoints) {\r\n            if (endpoint === block) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.isAnAncestorOf(block)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add an enpoint to this block\r\n     * @param endpoint define the endpoint to attach to\r\n     */\r\n    public attachToEndpoint(endpoint: NodeMaterialTeleportOutBlock) {\r\n        endpoint.detach();\r\n\r\n        this._endpoints.push(endpoint);\r\n        endpoint._entryPoint = this;\r\n        endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        endpoint._tempEntryPointUniqueId = null;\r\n        endpoint.name = \"> \" + this.name;\r\n\r\n        this._outputs = this._endpoints.map((e) => e.output);\r\n    }\r\n\r\n    /**\r\n     * Remove enpoint from this block\r\n     * @param endpoint define the endpoint to remove\r\n     */\r\n    public detachFromEndpoint(endpoint: NodeMaterialTeleportOutBlock) {\r\n        const index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index !== -1) {\r\n            this._endpoints.splice(index, 1);\r\n            endpoint._outputs[0]._typeConnectionSource = null;\r\n            endpoint._entryPoint = null;\r\n\r\n            this._outputs = this._endpoints.map((e) => e.output);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n\r\n        for (const endpoint of this._endpoints) {\r\n            this.detachFromEndpoint(endpoint);\r\n        }\r\n\r\n        this._endpoints = [];\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterialTeleportInBlock\", NodeMaterialTeleportInBlock);\r\n", "import type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { NodeMaterialTeleportInBlock } from \"./teleportInBlock\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\n\r\n/**\r\n * Defines a block used to receive a value from a teleport entry point\r\n */\r\nexport class NodeMaterialTeleportOutBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _entryPoint: Nullable<NodeMaterialTeleportInBlock> = null;\r\n    /** @internal */\r\n    public _tempEntryPointUniqueId: Nullable<number> = null;\r\n\r\n    /**\r\n     * Create a new TeleportOutBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n    }\r\n\r\n    /**\r\n     * Gets the entry point\r\n     */\r\n    public get entryPoint() {\r\n        return this._entryPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NodeMaterialTeleportOutBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public override get target() {\r\n        return this._entryPoint ? this._entryPoint.target : this._target;\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /** Detach from entry point */\r\n    public detach() {\r\n        if (!this._entryPoint) {\r\n            return;\r\n        }\r\n\r\n        this._entryPoint.detachFromEndpoint(this);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.entryPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.entryPoint.isConnectedToUniform) {\r\n            // We skip the build if the entry point is connected to a uniform\r\n            this.output.associatedVariableName = this.entryPoint.input.associatedVariableName;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += state._declareOutput(this.output) + ` = ${this.entryPoint.input.associatedVariableName};\\n`;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public override clone(scene: Scene, rootUrl: string = \"\") {\r\n        const clone = super.clone(scene, rootUrl);\r\n\r\n        if (this.entryPoint) {\r\n            this.entryPoint.attachToEndpoint(clone as NodeMaterialTeleportOutBlock);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    protected override _customBuildStep(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): void {\r\n        if (this.entryPoint) {\r\n            this.entryPoint.build(state, activeBlocks);\r\n        }\r\n    }\r\n\r\n    public override _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString: string = \"\";\r\n        if (this.entryPoint) {\r\n            if (alreadyDumped.indexOf(this.entryPoint) === -1) {\r\n                codeString += this.entryPoint._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        return codeString + super._dumpCode(uniqueNames, alreadyDumped);\r\n    }\r\n\r\n    public override _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = super._dumpCodeForOutputConnections(alreadyDumped);\r\n\r\n        if (this.entryPoint) {\r\n            codeString += this.entryPoint._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.entryPoint) {\r\n            codeString += `${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});\\n`;\r\n        }\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.entryPoint = this.entryPoint?.uniqueId ?? \"\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this._tempEntryPointUniqueId = serializationObject.entryPoint;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterialTeleportOutBlock\", NodeMaterialTeleportOutBlock);\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { BaseMathBlock } from \"./baseMathBlock\";\r\n\r\n/**\r\n * Block used to add 2 vectors\r\n */\r\nexport class AddBlock extends BaseMathBlock {\r\n    /**\r\n     * Creates a new AddBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"AddBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} + ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AddBlock\", AddBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to scale a vector by a float\r\n */\r\nexport class ScaleBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ScaleBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"factor\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ScaleBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the factor input component\r\n     */\r\n    public get factor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName} * ${this.factor.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScaleBlock\", ScaleBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to clamp a float\r\n */\r\nexport class ClampBlock extends NodeMaterialBlock {\r\n    /** Gets or sets the minimum range */\r\n    @editableInPropertyPage(\"Minimum\", PropertyTypeForEdition.Float, undefined, { embedded: true })\r\n    public minimum = 0.0;\r\n    /** Gets or sets the maximum range */\r\n    @editableInPropertyPage(\"Maximum\", PropertyTypeForEdition.Float, undefined, { embedded: true })\r\n    public maximum = 1.0;\r\n\r\n    /**\r\n     * Creates a new ClampBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ClampBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const cast = state.shaderLanguage === ShaderLanguage.WGSL ? state._getShaderType(this.value.type) : \"\";\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = clamp(${this.value.associatedVariableName}, ${cast}(${this._writeFloat(this.minimum)}), ${cast}(${this._writeFloat(this.maximum)}));\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.minimum = ${this.minimum};\\n`;\r\n\r\n        codeString += `${this._codeVariableName}.maximum = ${this.maximum};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.minimum = this.minimum;\r\n        serializationObject.maximum = this.maximum;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.minimum = serializationObject.minimum;\r\n        this.maximum = serializationObject.maximum;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ClampBlock\", ClampBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to apply a cross product between 2 vectors\r\n */\r\nexport class CrossBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new CrossBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CrossBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = cross(${this.left.associatedVariableName}.xyz, ${this.right.associatedVariableName}.xyz);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CrossBlock\", CrossBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\n\r\n/**\r\n * Custom block created from user-defined json\r\n */\r\nexport class CustomBlock extends NodeMaterialBlock {\r\n    private _options: any;\r\n    private _code: string;\r\n    private _inputSamplers: string[];\r\n\r\n    /**\r\n     * Gets or sets the options for this custom block\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: any) {\r\n        this._deserializeOptions(options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new CustomBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CustomBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        let code = this._code;\r\n\r\n        let functionName = this._options.functionName;\r\n\r\n        // Replace the TYPE_XXX placeholders (if any)\r\n        for (const input of this._inputs) {\r\n            const rexp = new RegExp(\"\\\\{TYPE_\" + input.name + \"\\\\}\", \"gm\");\r\n            const type = state._getGLType(input.type);\r\n            code = code.replace(rexp, type);\r\n            functionName = functionName.replace(rexp, type);\r\n        }\r\n        for (const output of this._outputs) {\r\n            const rexp = new RegExp(\"\\\\{TYPE_\" + output.name + \"\\\\}\", \"gm\");\r\n            const type = state._getGLType(output.type);\r\n            code = code.replace(rexp, type);\r\n            functionName = functionName.replace(rexp, type);\r\n        }\r\n\r\n        state._emitFunction(functionName, code, \"\");\r\n\r\n        // Declare the output variables\r\n        for (const output of this._outputs) {\r\n            state.compilationString += state._declareOutput(output) + \";\\n\";\r\n        }\r\n\r\n        // Generate the function call\r\n        state.compilationString += functionName + \"(\";\r\n\r\n        let hasInput = false;\r\n        for (let i = 0; i < this._inputs.length; i++) {\r\n            const input = this._inputs[i];\r\n            if (i > 0) {\r\n                state.compilationString += \", \";\r\n            }\r\n            if (this._inputSamplers && this._inputSamplers.indexOf(input.name) !== -1) {\r\n                state.compilationString += (input.connectedPoint?.ownerBlock as ImageSourceBlock)?.samplerName ?? input.associatedVariableName;\r\n            } else {\r\n                state.compilationString += input.associatedVariableName;\r\n            }\r\n            hasInput = true;\r\n        }\r\n\r\n        for (let i = 0; i < this._outputs.length; i++) {\r\n            const output = this._outputs[i];\r\n            if (i > 0 || hasInput) {\r\n                state.compilationString += \", \";\r\n            }\r\n            state.compilationString += output.associatedVariableName;\r\n        }\r\n\r\n        state.compilationString += \");\\n\";\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.options = ${JSON.stringify(this._options)};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.options = this._options;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this._deserializeOptions(serializationObject.options);\r\n\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n    }\r\n\r\n    private _deserializeOptions(options: any) {\r\n        this._options = options;\r\n        this._code = options.code.join(\"\\n\") + \"\\n\";\r\n        this.name = this.name || options.name;\r\n        this.target = (<any>NodeMaterialBlockTargets)[options.target];\r\n\r\n        if (options.inParameters) {\r\n            for (let i = 0; i < options.inParameters.length; i++) {\r\n                const input = options.inParameters[i];\r\n                const type = (<any>NodeMaterialBlockConnectionPointTypes)[input.type];\r\n                if (input.type === \"sampler2D\" || input.type === \"samplerCube\" || input.type === \"sampler2DArray\") {\r\n                    this._inputSamplers = this._inputSamplers || [];\r\n                    this._inputSamplers.push(input.name);\r\n                    this.registerInput(\r\n                        input.name,\r\n                        NodeMaterialBlockConnectionPointTypes.Object,\r\n                        true,\r\n                        NodeMaterialBlockTargets.VertexAndFragment,\r\n                        new NodeMaterialConnectionPointCustomObject(input.name, this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n                    );\r\n                } else {\r\n                    this.registerInput(input.name, type);\r\n                }\r\n\r\n                Object.defineProperty(this, input.name, {\r\n                    get: function () {\r\n                        return this._inputs[i];\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                });\r\n            }\r\n        }\r\n\r\n        if (options.outParameters) {\r\n            for (let i = 0; i < options.outParameters.length; i++) {\r\n                const output = options.outParameters[i];\r\n\r\n                this.registerOutput(output.name, (<any>NodeMaterialBlockConnectionPointTypes)[output.type]);\r\n\r\n                Object.defineProperty(this, output.name, {\r\n                    get: function () {\r\n                        return this._outputs[i];\r\n                    },\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                });\r\n\r\n                if (output.type === \"BasedOnInput\") {\r\n                    this._outputs[i]._typeConnectionSource = this._findInputByName(output.typeFromInput)![0];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (options.inLinkedConnectionTypes) {\r\n            for (const connection of options.inLinkedConnectionTypes) {\r\n                this._linkConnectionTypes(this._findInputByName(connection.input1)![1], this._findInputByName(connection.input2)![1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _findInputByName(name: string): Nullable<[NodeMaterialConnectionPoint, number]> {\r\n        if (!name) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._inputs.length; i++) {\r\n            if (this._inputs[i].name === name) {\r\n                return [this._inputs[i], i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CustomBlock\", CustomBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to apply a dot product between 2 vectors\r\n */\r\nexport class DotBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new DotBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._linkConnectionTypes(0, 1);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DotBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = dot(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DotBlock\", DotBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to normalize a vector\r\n */\r\nexport class NormalizeBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new NormalizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NormalizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const input = this._inputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = normalize(${input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalizeBlock\", NormalizeBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\n\r\n/**\r\n * Block used to create a Color3/4 out of individual inputs (one for each component)\r\n */\r\nexport class ColorMergerBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the swizzle for r (meaning which component to affect to the output.r)\r\n     */\r\n    public rSwizzle: \"r\" | \"g\" | \"b\" | \"a\" = \"r\";\r\n    /**\r\n     * Gets or sets the swizzle for g (meaning which component to affect to the output.g)\r\n     */\r\n    public gSwizzle: \"r\" | \"g\" | \"b\" | \"a\" = \"g\";\r\n    /**\r\n     * Gets or sets the swizzle for b (meaning which component to affect to the output.b)\r\n     */\r\n    public bSwizzle: \"r\" | \"g\" | \"b\" | \"a\" = \"b\";\r\n    /**\r\n     * Gets or sets the swizzle for a (meaning which component to affect to the output.a)\r\n     */\r\n    public aSwizzle: \"r\" | \"g\" | \"b\" | \"a\" = \"a\";\r\n\r\n    /**\r\n     * Create a new ColorMergerBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ColorMergerBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the r component (input)\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the g component (input)\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the b component (input)\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the a component (input)\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba component (output)\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb component (output)\r\n     * @deprecated Please use rgbOut instead.\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this.rgbOut;\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private _buildSwizzle(len: number) {\r\n        const swizzle = this.rSwizzle + this.gSwizzle + this.bSwizzle + this.aSwizzle;\r\n        return \".\" + swizzle.substring(0, len);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rInput = this.r;\r\n        const gInput = this.g;\r\n        const bInput = this.b;\r\n        const aInput = this.a;\r\n        const rgbInput = this.rgbIn;\r\n\r\n        const color4Output = this._outputs[0];\r\n        const color3Output = this._outputs[1];\r\n\r\n        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        if (rgbInput.isConnected) {\r\n            if (color4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(color4Output) +\r\n                    ` = ${vec4}(${rgbInput.associatedVariableName}, ${aInput.isConnected ? this._writeVariable(aInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (color3Output.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(color3Output) + ` = ${rgbInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\r\n            }\r\n        } else {\r\n            if (color4Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(color4Output) +\r\n                    ` = ${vec4}(${rInput.isConnected ? this._writeVariable(rInput) : \"0.0\"}, ${gInput.isConnected ? this._writeVariable(gInput) : \"0.0\"}, ${\r\n                        bInput.isConnected ? this._writeVariable(bInput) : \"0.0\"\r\n                    }, ${aInput.isConnected ? this._writeVariable(aInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\r\n            }\r\n\r\n            if (color3Output.hasEndpoints) {\r\n                state.compilationString +=\r\n                    state._declareOutput(color3Output) +\r\n                    ` = ${vec3}(${rInput.isConnected ? this._writeVariable(rInput) : \"0.0\"}, ${gInput.isConnected ? this._writeVariable(gInput) : \"0.0\"}, ${\r\n                        bInput.isConnected ? this._writeVariable(bInput) : \"0.0\"\r\n                    })${this._buildSwizzle(3)};\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.rSwizzle = this.rSwizzle;\r\n        serializationObject.gSwizzle = this.gSwizzle;\r\n        serializationObject.bSwizzle = this.bSwizzle;\r\n        serializationObject.aSwizzle = this.aSwizzle;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.rSwizzle = serializationObject.rSwizzle ?? \"r\";\r\n        this.gSwizzle = serializationObject.gSwizzle ?? \"g\";\r\n        this.bSwizzle = serializationObject.bSwizzle ?? \"b\";\r\n        this.aSwizzle = serializationObject.aSwizzle ?? \"a\";\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n        codeString += `${this._codeVariableName}.rSwizzle = \"${this.rSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.gSwizzle = \"${this.gSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.bSwizzle = \"${this.bSwizzle}\";\\n`;\r\n        codeString += `${this._codeVariableName}.aSwizzle = \"${this.aSwizzle}\";\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorMergerBlock\", ColorMergerBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to expand a Vector3/4 into 4 outputs (one for each component)\r\n */\r\nexport class VectorSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new VectorSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"xyzw\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"xyz \", NodeMaterialBlockConnectionPointTypes.Vector3, true);\r\n        this.registerInput(\"xy \", NodeMaterialBlockConnectionPointTypes.Vector2, true);\r\n\r\n        this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"xy\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"zw\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"z\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"w\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.inputsAreExclusive = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VectorSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the xyzw component (input)\r\n     */\r\n    public get xyzw(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (input)\r\n     */\r\n    public get xyzIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (input)\r\n     */\r\n    public get xyIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the xyz component (output)\r\n     */\r\n    public get xyzOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the xy component (output)\r\n     */\r\n    public get xyOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the zw component (output)\r\n     */\r\n    public get zw(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component (output)\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component (output)\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the z component (output)\r\n     */\r\n    public get z(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the w component (output)\r\n     */\r\n    public get w(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        switch (name) {\r\n            case \"xy \":\r\n                return \"xyIn\";\r\n            case \"xyz \":\r\n                return \"xyzIn\";\r\n            default:\r\n                return name;\r\n        }\r\n    }\r\n\r\n    protected override _outputRename(name: string) {\r\n        switch (name) {\r\n            case \"xy\":\r\n                return \"xyOut\";\r\n            case \"xyz\":\r\n                return \"xyzOut\";\r\n            default:\r\n                return name;\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this.xyzw.isConnected ? this.xyzw : this.xyzIn.isConnected ? this.xyzIn : this.xyIn;\r\n\r\n        const xyzOutput = this._outputs[0];\r\n        const xyOutput = this._outputs[1];\r\n        const zwOutput = this._outputs[2];\r\n        const xOutput = this._outputs[3];\r\n        const yOutput = this._outputs[4];\r\n        const zOutput = this._outputs[5];\r\n        const wOutput = this._outputs[6];\r\n\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        if (xyzOutput.hasEndpoints) {\r\n            if (input === this.xyIn) {\r\n                state.compilationString += state._declareOutput(xyzOutput) + ` = ${vec3}(${input.associatedVariableName}, 0.0);\\n`;\r\n            } else {\r\n                state.compilationString += state._declareOutput(xyzOutput) + ` = ${input.associatedVariableName}.xyz;\\n`;\r\n            }\r\n        }\r\n        if (zwOutput.hasEndpoints && this.xyzw.isConnected) {\r\n            state.compilationString += state._declareOutput(zwOutput) + ` = ${this.xyzw.associatedVariableName}.zw;\\n`;\r\n        }\r\n        if (xyOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(xyOutput) + ` = ${input.associatedVariableName}.xy;\\n`;\r\n        }\r\n        if (xOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(xOutput) + ` = ${input.associatedVariableName}.x;\\n`;\r\n        }\r\n        if (yOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(yOutput) + ` = ${input.associatedVariableName}.y;\\n`;\r\n        }\r\n        if (zOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(zOutput) + ` = ${input.associatedVariableName}.z;\\n`;\r\n        }\r\n        if (wOutput.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(wOutput) + ` = ${input.associatedVariableName}.w;\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VectorSplitterBlock\", VectorSplitterBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to lerp between 2 values\r\n */\r\nexport class LerpBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new LerpBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"gradient\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n        this._linkConnectionTypes(1, 2, true);\r\n\r\n        this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"LerpBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the gradient operand input component\r\n     */\r\n    public get gradient(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) + ` = mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LerpBlock\", LerpBlock);\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { BaseMathBlock } from \"./baseMathBlock\";\r\n\r\n/**\r\n * Block used to divide 2 vectors\r\n */\r\nexport class DivideBlock extends BaseMathBlock {\r\n    /**\r\n     * Creates a new DivideBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DivideBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} / ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DivideBlock\", DivideBlock);\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { BaseMathBlock } from \"./baseMathBlock\";\r\n\r\n/**\r\n * Block used to subtract 2 vectors\r\n */\r\nexport class SubtractBlock extends BaseMathBlock {\r\n    /**\r\n     * Creates a new SubtractBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SubtractBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} - ${this.right.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SubtractBlock\", SubtractBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to step a value\r\n */\r\nexport class StepBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new StepBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"edge\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"StepBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value operand input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the edge operand input component\r\n     */\r\n    public get edge(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = step(${this.edge.associatedVariableName}, ${this.value.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StepBlock\", StepBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the opposite (1 - x) of a value\r\n */\r\nexport class OneMinusBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new OneMinusBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._outputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"OneMinusBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = 1. - ${this.input.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.OneMinusBlock\", OneMinusBlock);\r\nRegisterClass(\"BABYLON.OppositeBlock\", OneMinusBlock); // Backward compatibility\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\n/**\r\n * Block used to get the view direction\r\n */\r\nexport class ViewDirectionBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ViewDirectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ViewDirectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) + ` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ViewDirectionBlock\", ViewDirectionBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\nimport type { NodeMaterial } from \"../nodeMaterial\";\r\n\r\nimport \"../../../Shaders/ShadersInclude/fresnelFunction\";\r\nimport { ViewDirectionBlock } from \"./viewDirectionBlock\";\r\n\r\n/**\r\n * Block used to compute fresnel value\r\n */\r\nexport class FresnelBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new FresnelBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"viewDirection\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"bias\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"power\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.registerOutput(\"fresnel\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"FresnelBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the view direction input component\r\n     */\r\n    public get viewDirection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the bias input component\r\n     */\r\n    public get bias(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get power(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the fresnel output component\r\n     */\r\n    public get fresnel(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial) {\r\n        if (!this.viewDirection.isConnected) {\r\n            const viewDirectionInput = new ViewDirectionBlock(\"View direction\");\r\n            viewDirectionInput.output.connectTo(this.viewDirection);\r\n            viewDirectionInput.autoConfigure(material);\r\n        }\r\n\r\n        if (!this.bias.isConnected) {\r\n            const biasInput = new InputBlock(\"bias\");\r\n            biasInput.value = 0;\r\n            biasInput.output.connectTo(this.bias);\r\n        }\r\n\r\n        if (!this.power.isConnected) {\r\n            const powerInput = new InputBlock(\"power\");\r\n            powerInput.value = 1;\r\n            powerInput.output.connectTo(this.power);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const comments = `//${this.name}`;\r\n\r\n        state._emitFunctionFromInclude(\"fresnelFunction\", comments, { removeIfDef: true });\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(this.fresnel) +\r\n            ` = computeFresnelTerm(${this.viewDirection.associatedVariableName}.xyz, ${this.worldNormal.associatedVariableName}.xyz, ${this.bias.associatedVariableName}, ${this.power.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FresnelBlock\", FresnelBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the max of 2 values\r\n */\r\nexport class MaxBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MaxBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MaxBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = max(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MaxBlock\", MaxBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the min of 2 values\r\n */\r\nexport class MinBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MinBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MinBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = min(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MinBlock\", MinBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the distance between 2 values\r\n */\r\nexport class DistanceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new DistanceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DistanceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = length(${this.left.associatedVariableName} - ${this.right.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DistanceBlock\", DistanceBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the length of a vector\r\n */\r\nexport class LengthBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new LengthBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"LengthBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = length(${this.value.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LengthBlock\", LengthBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get negative version of a value (i.e. x * -1)\r\n */\r\nexport class NegateBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new NegateBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NegateBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = -1.0 * ${this.value.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NegateBlock\", NegateBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the value of the first parameter raised to the power of the second\r\n */\r\nexport class PowBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new PowBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"power\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PowBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value operand input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the power operand input component\r\n     */\r\n    public get power(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = pow(max(${this.value.associatedVariableName}, 0.), ${this.power.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PowBlock\", PowBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\nimport \"../../../Shaders/ShadersInclude/helperFunctions\";\r\n\r\n/**\r\n * Block used to get a random number\r\n */\r\nexport class RandomNumberBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new RandomNumberBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector2 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"RandomNumberBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = getRand(${this.seed.associatedVariableName}.xy);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RandomNumberBlock\", RandomNumberBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * Block used to compute arc tangent of 2 values\r\n */\r\nexport class ArcTan2Block extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ArcTan2Block\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ArcTan2Block\";\r\n    }\r\n\r\n    /**\r\n     * Gets the x operand input component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the y operand input component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const func = state.shaderLanguage === ShaderLanguage.WGSL ? \"atan2\" : \"atan\";\r\n        state.compilationString += state._declareOutput(output) + ` = ${func}(${this.x.associatedVariableName}, ${this.y.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ArcTan2Block\", ArcTan2Block);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to smooth step a value\r\n */\r\nexport class SmoothStepBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new SmoothStepBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"edge0\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"edge1\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SmoothStepBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value operand input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the first edge operand input component\r\n     */\r\n    public get edge0(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the second edge operand input component\r\n     */\r\n    public get edge1(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const cast = state._getShaderType(this.value.type);\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = smoothstep(${cast}(${this.edge0.associatedVariableName}), ${cast}(${this.edge1.associatedVariableName}), ${this.value.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SmoothStepBlock\", SmoothStepBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the reciprocal (1 / x) of a value\r\n */\r\nexport class ReciprocalBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ReciprocalBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReciprocalBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        if (this.input.type === NodeMaterialBlockConnectionPointTypes.Matrix) {\r\n            state.compilationString += state._declareOutput(output) + ` = inverse(${this.input.associatedVariableName});\\n`;\r\n        } else {\r\n            state.compilationString += state._declareOutput(output) + ` = 1. / ${this.input.associatedVariableName};\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReciprocalBlock\", ReciprocalBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to replace a color by another one\r\n */\r\nexport class ReplaceColorBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ReplaceColorBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"reference\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"distance\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"replacement\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n        this._linkConnectionTypes(0, 3);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n        this._inputs[3].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReplaceColorBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the reference input component\r\n     */\r\n    public get reference(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the distance input component\r\n     */\r\n    public get distance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the replacement input component\r\n     */\r\n    public get replacement(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + `;\\n`;\r\n        state.compilationString += `if (length(${this.value.associatedVariableName} - ${this.reference.associatedVariableName}) < ${this.distance.associatedVariableName}) {\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = ${this.replacement.associatedVariableName};\\n`;\r\n        state.compilationString += `} else {\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = ${this.value.associatedVariableName};\\n`;\r\n        state.compilationString += `}\\n`;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReplaceColorBlock\", ReplaceColorBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to posterize a value\r\n * @see https://en.wikipedia.org/wiki/Posterization\r\n */\r\nexport class PosterizeBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new PosterizeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"steps\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PosterizeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the value input component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the steps input component\r\n     */\r\n    public get steps(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = floor(${this.value.associatedVariableName} / (1.0 / ${this.steps.associatedVariableName})) * (1.0 / ${this.steps.associatedVariableName});\\n`;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PosterizeBlock\", PosterizeBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Operations supported by the Wave block\r\n */\r\nexport const enum WaveBlockKind {\r\n    /** SawTooth */\r\n    SawTooth,\r\n    /** Square */\r\n    Square,\r\n    /** Triangle */\r\n    Triangle,\r\n}\r\n\r\n/**\r\n * Block used to apply wave operation to floats\r\n */\r\nexport class WaveBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the kibnd of wave to be applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Kind\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"SawTooth\", value: WaveBlockKind.SawTooth },\r\n            { label: \"Square\", value: WaveBlockKind.Square },\r\n            { label: \"Triangle\", value: WaveBlockKind.Triangle },\r\n        ],\r\n    })\r\n    public kind = WaveBlockKind.SawTooth;\r\n\r\n    /**\r\n     * Creates a new WaveBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"WaveBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        switch (this.kind) {\r\n            case WaveBlockKind.SawTooth: {\r\n                state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName});\\n`;\r\n                break;\r\n            }\r\n            case WaveBlockKind.Square: {\r\n                state.compilationString += state._declareOutput(output) + ` = 1.0 - 2.0 * round(fract(${this.input.associatedVariableName}));\\n`;\r\n                break;\r\n            }\r\n            case WaveBlockKind.Triangle: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) + ` = 2.0 * abs(2.0 * (${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName}))) - 1.0;\\n`;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.kind = this.kind;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.kind = serializationObject.kind;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WaveBlock\", WaveBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Color3 } from \"../../../Maths/math.color\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\n\r\n/**\r\n * Class used to store a color step for the GradientBlock\r\n */\r\nexport class GradientBlockColorStep {\r\n    private _step: number;\r\n    /**\r\n     * Gets value indicating which step this color is associated with (between 0 and 1)\r\n     */\r\n    public get step(): number {\r\n        return this._step;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating which step this color is associated with (between 0 and 1)\r\n     */\r\n    public set step(val: number) {\r\n        this._step = val;\r\n    }\r\n\r\n    private _color: Color3;\r\n\r\n    /**\r\n     * Gets the color associated with this step\r\n     */\r\n    public get color(): Color3 {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color associated with this step\r\n     */\r\n    public set color(val: Color3) {\r\n        this._color = val;\r\n    }\r\n\r\n    /**\r\n     * Creates a new GradientBlockColorStep\r\n     * @param step defines a value indicating which step this color is associated with (between 0 and 1)\r\n     * @param color defines the color associated with this step\r\n     */\r\n    public constructor(step: number, color: Color3) {\r\n        this.step = step;\r\n        this.color = color;\r\n    }\r\n}\r\n\r\n/**\r\n * Block used to return a color from a gradient based on an input value between 0 and 1\r\n */\r\nexport class GradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the list of color steps\r\n     */\r\n    public colorSteps: GradientBlockColorStep[] = [new GradientBlockColorStep(0, Color3.Black()), new GradientBlockColorStep(1.0, Color3.White())];\r\n\r\n    /** Gets an observable raised when the value is changed */\r\n    public onValueChangedObservable = new Observable<GradientBlock>();\r\n\r\n    /** calls observable when the value is changed*/\r\n    public colorStepsUpdated() {\r\n        this.onValueChangedObservable.notifyObservers(this);\r\n    }\r\n    /**\r\n     * Creates a new GradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"gradient\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Float |\r\n                NodeMaterialBlockConnectionPointTypes.Vector2 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"GradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the gradient input component\r\n     */\r\n    public get gradient(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _writeColorConstant(index: number, vec3: string) {\r\n        const step = this.colorSteps[index];\r\n        return `${vec3}(${step.color.r}, ${step.color.g}, ${step.color.b})`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        if (!this.colorSteps.length || !this.gradient.connectedPoint) {\r\n            state.compilationString += state._declareOutput(output) + ` = ${vec3}(0., 0., 0.);\\n`;\r\n            return;\r\n        }\r\n\r\n        const tempColor = state._getFreeVariableName(\"gradientTempColor\");\r\n        const tempPosition = state._getFreeVariableName(\"gradientTempPosition\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(tempColor, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._writeColorConstant(0, vec3)};\\n`;\r\n        state.compilationString += `${state._declareLocalVar(tempPosition, NodeMaterialBlockConnectionPointTypes.Float)};\\n`;\r\n\r\n        let gradientSource = this.gradient.associatedVariableName;\r\n\r\n        if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {\r\n            gradientSource += \".x\";\r\n        }\r\n\r\n        for (let index = 1; index < this.colorSteps.length; index++) {\r\n            const step = this.colorSteps[index];\r\n            const previousStep = this.colorSteps[index - 1];\r\n            state.compilationString += `${tempPosition} = clamp((${gradientSource} - ${state._emitFloat(previousStep.step)}) / (${state._emitFloat(\r\n                step.step\r\n            )} -  ${state._emitFloat(previousStep.step)}), 0.0, 1.0) * step(${state._emitFloat(index)}, ${state._emitFloat(this.colorSteps.length - 1)});\\n`;\r\n            state.compilationString += `${tempColor} = mix(${tempColor}, ${this._writeColorConstant(index, vec3)}, ${tempPosition});\\n`;\r\n        }\r\n        state.compilationString += state._declareOutput(output) + ` = ${tempColor};\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.colorSteps = [];\r\n\r\n        for (const step of this.colorSteps) {\r\n            serializationObject.colorSteps.push({\r\n                step: step.step,\r\n                color: {\r\n                    r: step.color.r,\r\n                    g: step.color.g,\r\n                    b: step.color.b,\r\n                },\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.colorSteps.length = 0;\r\n\r\n        for (const step of serializationObject.colorSteps) {\r\n            this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));\r\n        }\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.colorSteps = [];\\n`;\r\n\r\n        for (const colorStep of this.colorSteps) {\r\n            codeString += `${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${colorStep.step}, new BABYLON.Color3(${colorStep.color.r}, ${colorStep.color.g}, ${colorStep.color.b})));\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GradientBlock\", GradientBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to normalize lerp between 2 values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class NLerpBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new NLerpBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"gradient\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n        this._linkConnectionTypes(1, 2, true);\r\n\r\n        this._inputs[2].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NLerpBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the gradient operand input component\r\n     */\r\n    public get gradient(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = normalize(mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName}));\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NLerpBlock\", NLerpBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\nimport { ShaderLanguage } from \"../../../Materials/shaderLanguage\";\r\n\r\n/**\r\n * block used to Generate a Worley Noise 3D Noise Pattern\r\n */\r\n\r\n//  Source: https://github.com/Erkaman/glsl-worley\r\n//  Converted to BJS by Pryme8\r\n//\r\n//  Worley Noise 3D\r\n//  Return vec2 value range of -1.0->1.0, F1-F2 respectivly\r\n\r\nexport class WorleyNoise3DBlock extends NodeMaterialBlock {\r\n    /** Gets or sets a boolean indicating that normal should be inverted on X axis */\r\n    @editableInPropertyPage(\"Use Manhattan Distance\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: false } })\r\n    public manhattanDistance = false;\r\n\r\n    /**\r\n     * Creates a new WorleyNoise3DBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"jitter\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"WorleyNoise3DBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the jitter input component\r\n     */\r\n    public get jitter(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the x component\r\n     */\r\n    public get x(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the y component\r\n     */\r\n    public get y(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.seed.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this.output.hasEndpoints && !this.x.hasEndpoints && !this.y.hasEndpoints) {\r\n            return;\r\n        }\r\n\r\n        let functionString = `vec3 permute(vec3 x){\\n`;\r\n        functionString += `    return mod((34.0 * x + 1.0) * x, 289.0);\\n`;\r\n        functionString += `}\\n\\n`;\r\n\r\n        functionString += `vec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance){\\n`;\r\n        functionString += `    return [manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z)];\\n`;\r\n        functionString += `}\\n\\n`;\r\n\r\n        functionString += `vec2 worley(vec3 P, float jitter, bool manhattanDistance){\\n`;\r\n        functionString += `    float K = 0.142857142857; // 1/7\\n`;\r\n        functionString += `    float Ko = 0.428571428571; // 1/2-K/2\\n`;\r\n        functionString += `    float  K2 = 0.020408163265306; // 1/(7*7)\\n`;\r\n        functionString += `    float Kz = 0.166666666667; // 1/6\\n`;\r\n        functionString += `    float Kzo = 0.416666666667; // 1/2-1/6*2\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 Pi = mod(floor(P), 289.0);\\n`;\r\n        functionString += `    vec3 Pf = fract(P) - 0.5;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\\n`;\r\n        functionString += `    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\\n`;\r\n        functionString += `    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\\n`;\r\n        functionString += `    vec3 p1 = permute(p + Pi.y - 1.0);\\n`;\r\n        functionString += `    vec3 p2 = permute(p + Pi.y);\\n`;\r\n        functionString += `    vec3 p3 = permute(p + Pi.y + 1.0);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 p11 = permute(p1 + Pi.z - 1.0);\\n`;\r\n        functionString += `    vec3 p12 = permute(p1 + Pi.z);\\n`;\r\n        functionString += `    vec3 p13 = permute(p1 + Pi.z + 1.0);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 p21 = permute(p2 + Pi.z - 1.0);\\n`;\r\n        functionString += `    vec3 p22 = permute(p2 + Pi.z);\\n`;\r\n        functionString += `    vec3 p23 = permute(p2 + Pi.z + 1.0);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 p31 = permute(p3 + Pi.z - 1.0);\\n`;\r\n        functionString += `    vec3 p32 = permute(p3 + Pi.z);\\n`;\r\n        functionString += `    vec3 p33 = permute(p3 + Pi.z + 1.0);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox11 = fract(p11*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox12 = fract(p12*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox13 = fract(p13*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox21 = fract(p21*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox22 = fract(p22*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox23 = fract(p23*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox31 = fract(p31*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox32 = fract(p32*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 ox33 = fract(p33*K) - Ko;\\n`;\r\n        functionString += `    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\\n`;\r\n        functionString += `    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx11 = Pfx + jitter*ox11;\\n`;\r\n        functionString += `    vec3 dy11 = Pfy.x + jitter*oy11;\\n`;\r\n        functionString += `    vec3 dz11 = Pfz.x + jitter*oz11;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx12 = Pfx + jitter*ox12;\\n`;\r\n        functionString += `    vec3 dy12 = Pfy.x + jitter*oy12;\\n`;\r\n        functionString += `    vec3 dz12 = Pfz.y + jitter*oz12;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx13 = Pfx + jitter*ox13;\\n`;\r\n        functionString += `    vec3 dy13 = Pfy.x + jitter*oy13;\\n`;\r\n        functionString += `    vec3 dz13 = Pfz.z + jitter*oz13;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx21 = Pfx + jitter*ox21;\\n`;\r\n        functionString += `    vec3 dy21 = Pfy.y + jitter*oy21;\\n`;\r\n        functionString += `    vec3 dz21 = Pfz.x + jitter*oz21;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx22 = Pfx + jitter*ox22;\\n`;\r\n        functionString += `    vec3 dy22 = Pfy.y + jitter*oy22;\\n`;\r\n        functionString += `    vec3 dz22 = Pfz.y + jitter*oz22;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx23 = Pfx + jitter*ox23;\\n`;\r\n        functionString += `    vec3 dy23 = Pfy.y + jitter*oy23;\\n`;\r\n        functionString += `    vec3 dz23 = Pfz.z + jitter*oz23;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx31 = Pfx + jitter*ox31;\\n`;\r\n        functionString += `    vec3 dy31 = Pfy.z + jitter*oy31;\\n`;\r\n        functionString += `    vec3 dz31 = Pfz.x + jitter*oz31;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx32 = Pfx + jitter*ox32;\\n`;\r\n        functionString += `    vec3 dy32 = Pfy.z + jitter*oy32;\\n`;\r\n        functionString += `    vec3 dz32 = Pfz.y + jitter*oz32;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 dx33 = Pfx + jitter*ox33;\\n`;\r\n        functionString += `    vec3 dy33 = Pfy.z + jitter*oy33;\\n`;\r\n        functionString += `    vec3 dz33 = Pfz.z + jitter*oz33;\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d12 = dist(dx12, dy12, dz12, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\\n`;\r\n        functionString += `    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\\n`;\r\n        functionString += `\\n`;\r\n        functionString += `    vec3 d1a = min(d11, d12);\\n`;\r\n        functionString += `    d12 = max(d11, d12);\\n`;\r\n        functionString += `    d11 = min(d1a, d13); // Smallest now not in d12 or d13\\n`;\r\n        functionString += `    d13 = max(d1a, d13);\\n`;\r\n        functionString += `    d12 = min(d12, d13); // 2nd smallest now not in d13\\n`;\r\n        functionString += `    vec3 d2a = min(d21, d22);\\n`;\r\n        functionString += `    d22 = max(d21, d22);\\n`;\r\n        functionString += `    d21 = min(d2a, d23); // Smallest now not in d22 or d23\\n`;\r\n        functionString += `    d23 = max(d2a, d23);\\n`;\r\n        functionString += `    d22 = min(d22, d23); // 2nd smallest now not in d23\\n`;\r\n        functionString += `    vec3 d3a = min(d31, d32);\\n`;\r\n        functionString += `    d32 = max(d31, d32);\\n`;\r\n        functionString += `    d31 = min(d3a, d33); // Smallest now not in d32 or d33\\n`;\r\n        functionString += `    d33 = max(d3a, d33);\\n`;\r\n        functionString += `    d32 = min(d32, d33); // 2nd smallest now not in d33\\n`;\r\n        functionString += `    vec3 da = min(d11, d21);\\n`;\r\n        functionString += `    d21 = max(d11, d21);\\n`;\r\n        functionString += `    d11 = min(da, d31); // Smallest now in d11\\n`;\r\n        functionString += `    d31 = max(da, d31); // 2nd smallest now not in d31\\n`;\r\n        functionString += `    if (d11.x >= d11.y) { vec2 temp = d11.yx; d11.x = temp.x; d11.y = temp.y; }\\n`;\r\n        functionString += `    if (d11.x >= d11.z) { vec2 temp = d11.zx; d11.x = temp.x; d11.z = temp.y; }\\n`;\r\n        functionString += `    d12 = min(d12, d21); // 2nd smallest now not in d21\\n`;\r\n        functionString += `    d12 = min(d12, d22); // nor in d22\\n`;\r\n        functionString += `    d12 = min(d12, d31); // nor in d31\\n`;\r\n        functionString += `    d12 = min(d12, d32); // nor in d32\\n`;\r\n        functionString += `    vec2 temp2 = min(d11.yz, d12.xy); // nor in d12.yz\\n`;\r\n        functionString += `    d11.y = temp2.x;\\n`;\r\n        functionString += `    d11.z = temp2.y;\\n`;\r\n        functionString += `    d11.y = min(d11.y, d12.z); // Only two more to go\\n`;\r\n        functionString += `    d11.y = min(d11.y, d11.z); // Done! (Phew!)\\n`;\r\n        functionString += `    return sqrt(d11.xy); // F1, F2\\n`;\r\n        functionString += `}\\n\\n`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = state._babylonSLtoWGSL(functionString);\r\n        } else {\r\n            functionString = state._babylonSLtoGLSL(functionString);\r\n        }\r\n\r\n        state._emitFunction(\"worley3D\", functionString, \"// Worley3D\");\r\n\r\n        const tempVariable = state._getFreeVariableName(\"worleyTemp\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(tempVariable, NodeMaterialBlockConnectionPointTypes.Vector2)} = worley(${this.seed.associatedVariableName}, ${this.jitter.associatedVariableName}, ${this.manhattanDistance});\\n`;\r\n\r\n        if (this.output.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.output) + ` = ${tempVariable};\\n`;\r\n        }\r\n\r\n        if (this.x.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.x) + ` = ${tempVariable}.x;\\n`;\r\n        }\r\n\r\n        if (this.y.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.y) + ` = ${tempVariable}.y;\\n`;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Exposes the properties to the UI?\r\n     * @returns - boolean indicating if the block has properties or not\r\n     */\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.manhattanDistance = ${this.manhattanDistance};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n    /**\r\n     * Exposes the properties to the Serialize?\r\n     * @returns - a serialized object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.manhattanDistance = this.manhattanDistance;\r\n\r\n        return serializationObject;\r\n    }\r\n    /**\r\n     * Exposes the properties to the deserialize?\r\n     * @param serializationObject\r\n     * @param scene\r\n     * @param rootUrl\r\n     */\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.manhattanDistance = serializationObject.manhattanDistance;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WorleyNoise3DBlock\", WorleyNoise3DBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"../../../Materials/shaderLanguage\";\r\n/**\r\n * block used to Generate a Simplex Perlin 3d Noise Pattern\r\n */\r\n//\r\n//  Wombat\r\n//  An efficient texture-free GLSL procedural noise library\r\n//  Source: https://github.com/BrianSharpe/Wombat\r\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\r\n//\r\n//  I'm not one for copyrights.  Use the code however you wish.\r\n//  All I ask is that credit be given back to the blog or myself when appropriate.\r\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\r\n//  Thanks!\r\n//\r\n//  Brian Sharpe\r\n//  brisharpe CIRCLE_A yahoo DOT com\r\n//  http://briansharpe.wordpress.com\r\n//  https://github.com/BrianSharpe\r\n//\r\n//\r\n//  This is a modified version of Stefan Gustavson's and Ian McEwan's work at http://github.com/ashima/webgl-noise\r\n//  Modifications are...\r\n//  - faster random number generation\r\n//  - analytical final normalization\r\n//  - space scaled can have an approx feature size of 1.0\r\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\r\n//\r\n//  Converted to BJS by Pryme8\r\n//\r\n//  Simplex Perlin Noise 3D\r\n//  Return value range of -1.0->1.0\r\n//\r\nexport class SimplexPerlin3DBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new SimplexPerlin3DBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SimplexPerlin3DBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed operand input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.seed.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this._outputs[0].hasEndpoints) {\r\n            return;\r\n        }\r\n\r\n        let functionString = `const float SKEWFACTOR = 1.0/3.0;\\n`;\r\n        functionString += `const float UNSKEWFACTOR = 1.0/6.0;\\n`;\r\n        functionString += `const float SIMPLEX_CORNER_POS = 0.5;\\n`;\r\n        functionString += `const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;\\n`;\r\n        functionString += `float SimplexPerlin3D( vec3 source ){\\n`;\r\n        functionString += `    vec3 P = source;\\n`;\r\n        functionString += `    P.x = [P.x == 0. && P.y == 0. && P.z == 0. ? 0.00001 : P.x];\\n`;\r\n        functionString += `    P *= SIMPLEX_TETRAHADRON_HEIGHT;\\n`;\r\n        functionString += `    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );`;\r\n        functionString += `    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\\n`;\r\n        functionString += `    vec3 g = step(x0.yzx, x0.xyz);\\n`;\r\n        functionString += `    vec3 l = 1.0 - g;\\n`;\r\n        functionString += `    vec3 Pi_1 = min( g.xyz, l.zxy );\\n`;\r\n        functionString += `    vec3 Pi_2 = max( g.xyz, l.zxy );\\n`;\r\n        functionString += `    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\\n`;\r\n        functionString += `    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\\n`;\r\n        functionString += `    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\\n`;\r\n        functionString += `    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\\n`;\r\n        functionString += `    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\\n`;\r\n        functionString += `    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\\n`;\r\n        functionString += `    Pi = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\\n`;\r\n        functionString += `    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\\n`;\r\n        functionString += `    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\\n`;\r\n        functionString += `    Pt *= Pt;\\n`;\r\n        functionString += `    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\\n`;\r\n        functionString += `    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\\n`;\r\n        functionString += `    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\\n`;\r\n        functionString += `    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\\n`;\r\n        functionString += `    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\\n`;\r\n        functionString += `    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\\n`;\r\n        functionString += `    Pi_1 = [( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods];\\n`;\r\n        functionString += `    Pi_2 = [( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods];\\n`;\r\n        functionString += `    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\\n`;\r\n        functionString += `    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\\n`;\r\n        functionString += `    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\\n`;\r\n        functionString += `    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\\n`;\r\n        functionString += `    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\\n`;\r\n        functionString += `    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\\n`;\r\n        functionString += `    kernel_weights = max(0.5 - kernel_weights, vec4(0.));\\n`;\r\n        functionString += `    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\\n`;\r\n        functionString += `    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\\n`;\r\n        functionString += `}\\n`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = state._babylonSLtoWGSL(functionString);\r\n        } else {\r\n            functionString = state._babylonSLtoGLSL(functionString);\r\n        }\r\n\r\n        state._emitFunction(\"SimplexPerlin3D\", functionString, \"// SimplexPerlin3D\");\r\n        state.compilationString += state._declareOutput(this._outputs[0]) + ` = SimplexPerlin3D(${this.seed.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SimplexPerlin3DBlock\", SimplexPerlin3DBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to blend normals\r\n */\r\nexport class NormalBlendBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new NormalBlendBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"normalMap0\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"normalMap1\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NormalBlendBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the first input component\r\n     */\r\n    public get normalMap0(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the second input component\r\n     */\r\n    public get normalMap1(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const input0 = this._inputs[0];\r\n        const input1 = this._inputs[1];\r\n        const stepR = state._getFreeVariableName(\"stepR\");\r\n        const stepG = state._getFreeVariableName(\"stepG\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(stepR, NodeMaterialBlockConnectionPointTypes.Float)} = step(0.5, ${input0.associatedVariableName}.r);\\n`;\r\n        state.compilationString += `${state._declareLocalVar(stepG, NodeMaterialBlockConnectionPointTypes.Float)} = step(0.5, ${input0.associatedVariableName}.g);\\n`;\r\n        state.compilationString += state._declareOutput(output) + `;\\n`;\r\n        state.compilationString += `${output.associatedVariableName}.r = (1.0 - ${stepR}) * ${input0.associatedVariableName}.r * ${input1.associatedVariableName}.r * 2.0 + ${stepR} * (1.0 - (1.0 - ${input0.associatedVariableName}.r) * (1.0 - ${input1.associatedVariableName}.r) * 2.0);\\n`;\r\n        state.compilationString += `${output.associatedVariableName}.g = (1.0 - ${stepG}) * ${input0.associatedVariableName}.g * ${input1.associatedVariableName}.g * 2.0 + ${stepG} * (1.0 - (1.0 - ${input0.associatedVariableName}.g) * (1.0 - ${input1.associatedVariableName}.g) * 2.0);\\n`;\r\n        state.compilationString += `${output.associatedVariableName}.b = ${input0.associatedVariableName}.b * ${input1.associatedVariableName}.b;\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalBlendBlock\", NormalBlendBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\n\r\n/**\r\n * Block used to rotate a 2d vector by a given angle\r\n */\r\nexport class Rotate2dBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new Rotate2dBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"angle\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"Rotate2dBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input vector\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the input angle\r\n     */\r\n    public get angle(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.angle.isConnected) {\r\n            const angleInput = new InputBlock(\"angle\");\r\n            angleInput.value = 0;\r\n            angleInput.output.connectTo(this.angle);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const angle = this.angle;\r\n        const input = this.input;\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = vec2(cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.x - sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.y, sin(${angle.associatedVariableName}) * ${input.associatedVariableName}.x + cos(${angle.associatedVariableName}) * ${input.associatedVariableName}.y);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.Rotate2dBlock\", Rotate2dBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the reflected vector from a direction and a normal\r\n */\r\nexport class ReflectBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ReflectBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"incident\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReflectBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the incident component\r\n     */\r\n    public get incident(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = reflect(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz);\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectBlock\", ReflectBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to get the refracted vector from a direction and a normal\r\n */\r\nexport class RefractBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new RefractBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"incident\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"ior\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Vector3 |\r\n                NodeMaterialBlockConnectionPointTypes.Vector4 |\r\n                NodeMaterialBlockConnectionPointTypes.Color3 |\r\n                NodeMaterialBlockConnectionPointTypes.Color4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"RefractBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the incident component\r\n     */\r\n    public get incident(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the index of refraction component\r\n     */\r\n    public get ior(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = refract(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz, ${this.ior.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractBlock\", RefractBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used to desaturate a color\r\n */\r\nexport class DesaturateBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new DesaturateBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerInput(\"level\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"DesaturateBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color operand input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the level operand input component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const color = this.color;\r\n        const colorName = color.associatedVariableName;\r\n        const tempMin = state._getFreeVariableName(\"colorMin\");\r\n        const tempMax = state._getFreeVariableName(\"colorMax\");\r\n        const tempMerge = state._getFreeVariableName(\"colorMerge\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(tempMin, NodeMaterialBlockConnectionPointTypes.Float)} = min(min(${colorName}.x, ${colorName}.y), ${colorName}.z);\\n`;\r\n        state.compilationString += `${state._declareLocalVar(tempMax, NodeMaterialBlockConnectionPointTypes.Float)} = max(max(${colorName}.x, ${colorName}.y), ${colorName}.z);\\n`;\r\n        state.compilationString += `${state._declareLocalVar(tempMerge, NodeMaterialBlockConnectionPointTypes.Float)} = 0.5 * (${tempMin} + ${tempMax});\\n`;\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = mix(${colorName}, ${state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3)}(${tempMerge}, ${tempMerge}, ${tempMerge}), ${this.level.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DesaturateBlock\", DesaturateBlock);\r\n", "import type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst _environmentBRDFBase64Texture =\r\n    \"data:image/png;base64,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\";\r\n\r\n// Multiple-Scattering Sheen BRDF LUT from https://github.com/tizian/ltc-sheen\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst _environmentFuzzBRDFBase64Texture =\r\n    \"data:image/png;base64,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\";\r\n\r\nlet InstanceNumber = 0;\r\n\r\n/**\r\n * Internal function to load and setup BRDF textures\r\n * @param scene defines the hosting scene\r\n * @param textureData defines the base64 texture data\r\n * @param textureProperty defines the scene property name to store the texture\r\n * @param textureName defines the name for the texture\r\n * @returns the environment BRDF texture\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst loadBRDFTexture = (scene: Scene, textureData: string, textureProperty: string, textureName: string): BaseTexture => {\r\n    if (!(scene as any)[textureProperty]) {\r\n        // Forces Delayed Texture Loading to prevent undefined error whilst setting RGBD values.\r\n        const useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const previousState = scene._blockEntityCollection;\r\n        scene._blockEntityCollection = false;\r\n        const texture = Texture.CreateFromBase64String(textureData, textureName + InstanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);\r\n        scene._blockEntityCollection = previousState;\r\n        // BRDF Texture should not be cached here due to pre processing and redundant scene caches.\r\n        const texturesCache = scene.getEngine().getLoadedTexturesCache();\r\n        const index = texturesCache.indexOf(texture.getInternalTexture()!);\r\n        if (index !== -1) {\r\n            texturesCache.splice(index, 1);\r\n        }\r\n\r\n        texture.isRGBD = true;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        (scene as any)[textureProperty] = texture;\r\n\r\n        scene.useDelayedTextureLoading = useDelayedTextureLoading;\r\n\r\n        RGBDTextureTools.ExpandRGBDTexture(texture);\r\n\r\n        const observer = scene.getEngine().onContextRestoredObservable.add(() => {\r\n            texture.isRGBD = true;\r\n            /**\r\n             * Using scene.onBeforeRenderObservable instead of Tools.SetImmediate to check the texture's state of readiness allows us to check before any rendering occurs.\r\n             * When a context restore occurs, it gives ExpandRGBDTexture the ability to reset the state to false, preventing the texture from being used in any rendering.\r\n             * In WebGPU, not doing so would generate an error because ExpandRGBDTexture performs a _swapAndDie on the texture, which causes WebGPU caches to fail if the texture has already been used for rendering.\r\n             * Only when ExpandRGBDTexture has finished its work, the texture is ready to be used again.\r\n             */\r\n            const oo = scene.onBeforeRenderObservable.add(() => {\r\n                if (texture.isReady()) {\r\n                    scene.onBeforeRenderObservable.remove(oo);\r\n                    RGBDTextureTools.ExpandRGBDTexture(texture);\r\n                }\r\n            });\r\n        });\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            scene.getEngine().onContextRestoredObservable.remove(observer);\r\n        });\r\n    }\r\n\r\n    return (scene as any)[textureProperty];\r\n};\r\n\r\n/**\r\n * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n * @param scene defines the hosting scene\r\n * @returns the environment BRDF texture\r\n */\r\nexport const GetEnvironmentBRDFTexture = (scene: Scene): BaseTexture => {\r\n    return loadBRDFTexture(scene, _environmentBRDFBase64Texture, \"environmentBRDFTexture\", \"EnvironmentBRDFTexture\");\r\n};\r\n\r\n/**\r\n * Gets a default environment fuzz BRDF texture\r\n * @param scene defines the hosting scene\r\n * @returns the environment fuzz BRDF texture\r\n */\r\nexport const GetEnvironmentFuzzBRDFTexture = (scene: Scene): BaseTexture => {\r\n    return loadBRDFTexture(scene, _environmentFuzzBRDFBase64Texture, \"environmentFuzzBRDFTexture\", \"EnvironmentFuzzBRDFTexture\");\r\n};\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const BRDFTextureTools = {\r\n    /**\r\n     * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF\r\n     * @param scene defines the hosting scene\r\n     * @returns the environment BRDF texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GetEnvironmentBRDFTexture,\r\n\r\n    /**\r\n     * Gets a default environment fuzz BRDF texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the environment fuzz BRDF texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GetEnvironmentFuzzBRDFTexture,\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { serialize, expandToProperty } from \"../../Misc/decorators\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialBRDFDefines extends MaterialDefines {\r\n    BRDF_V_HEIGHT_CORRELATED = false;\r\n    MS_BRDF_ENERGY_CONSERVATION = false;\r\n    SPHERICAL_HARMONICS = false;\r\n    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;\r\n    MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;\r\n    LEGACY_SPECULAR_ENERGY_CONSERVATION = false;\r\n    BASE_DIFFUSE_MODEL = 0;\r\n    DIELECTRIC_SPECULAR_MODEL = 0;\r\n    CONDUCTOR_SPECULAR_MODEL = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the BRDF component of the PBR material\r\n */\r\nexport class PBRBRDFConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for the energy conservation.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value used for the Smith Visibility Height Correlated mode.\r\n     * This should only be changed to adapt to the type of texture in scene.environmentBRDFTexture.\r\n     */\r\n    public static DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;\r\n\r\n    /**\r\n     * Default value used for the IBL diffuse part.\r\n     * This can help switching back to the polynomials mode globally which is a tiny bit\r\n     * less GPU intensive at the drawback of a lower quality.\r\n     */\r\n    public static DEFAULT_USE_SPHERICAL_HARMONICS = true;\r\n\r\n    /**\r\n     * Default value used for activating energy conservation for the specular workflow.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     */\r\n    public static DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Default value for whether IBL irradiance is used to augment rough radiance.\r\n     * If activated, irradiance is blended into the radiance contribution when the material is rough.\r\n     * This better approximates raytracing results for rough surfaces.\r\n     */\r\n    public static DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;\r\n\r\n    /**\r\n     * Default value for whether the legacy specular energy conservation is used.\r\n     */\r\n    public static DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION = true;\r\n\r\n    /**\r\n     * Defines the default diffuse model used by the material.\r\n     */\r\n    public static DEFAULT_DIFFUSE_MODEL = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n\r\n    /**\r\n     * Defines the default dielectric specular model used by the material.\r\n     */\r\n    public static DEFAULT_DIELECTRIC_SPECULAR_MODEL: number = Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_GLTF;\r\n\r\n    /**\r\n     * Defines the default conductor specular model used by the material.\r\n     */\r\n    public static DEFAULT_CONDUCTOR_SPECULAR_MODEL: number = Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_GLTF;\r\n\r\n    private _useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;\r\n\r\n    private _useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses height smith correlated visibility term.\r\n     * If you intent to not use our default BRDF, you need to load a separate BRDF Texture for the PBR\r\n     * You can either load https://assets.babylonjs.com/environments/uncorrelatedBRDF.png\r\n     * or https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds to have more precision\r\n     * Not relying on height correlated will also disable energy conservation.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;\r\n\r\n    private _useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n    /**\r\n     * LEGACY Mode set to false\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     * The harmonics despite a tiny bigger cost has been proven to provide closer results\r\n     * to the ground truth.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;\r\n\r\n    private _useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the material uses energy conservation, when the specular workflow is active.\r\n     * If activated, the albedo color is multiplied with (1. - maxChannel(specular color)).\r\n     * If deactivated, a material is only physically plausible, when (albedo color + specular color) < 1.\r\n     * In the deactivated case, the material author has to ensure energy conservation, for a physically plausible rendering.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;\r\n\r\n    private _mixIblRadianceWithIrradiance = PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;\r\n    /**\r\n     * Defines if IBL irradiance is used to augment rough radiance.\r\n     * If activated, irradiance is blended into the radiance contribution when the material is rough.\r\n     * This better approximates raytracing results for rough surfaces.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public mixIblRadianceWithIrradiance = PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;\r\n\r\n    private _useLegacySpecularEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;\r\n    /**\r\n     * Defines if the legacy specular energy conservation is used.\r\n     * If activated, the specular color is multiplied with (1. - maxChannel(albedo color)).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public useLegacySpecularEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;\r\n\r\n    private _baseDiffuseModel: number = PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;\r\n    /**\r\n     * Defines the base diffuse roughness model of the material.\r\n     */\r\n    @serialize(\"baseDiffuseModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public baseDiffuseModel: number = PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;\r\n\r\n    private _dielectricSpecularModel: number = PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;\r\n    /**\r\n     * The material model to use for specular lighting of dielectric materials.\r\n     */\r\n    @serialize(\"dielectricSpecularModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public dielectricSpecularModel: number = PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;\r\n\r\n    private _conductorSpecularModel: number = PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;\r\n    /**\r\n     * The material model to use for specular lighting.\r\n     */\r\n    @serialize(\"conductorSpecularModel\")\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public conductorSpecularModel: number = PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRBRDF\", 90, new MaterialBRDFDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n        this._enable(true);\r\n    }\r\n\r\n    public override prepareDefines(defines: MaterialBRDFDefines): void {\r\n        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;\r\n        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;\r\n        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;\r\n        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;\r\n        defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;\r\n        defines.LEGACY_SPECULAR_ENERGY_CONSERVATION = this._useLegacySpecularEnergyConservation;\r\n        defines.BASE_DIFFUSE_MODEL = this._baseDiffuseModel;\r\n        defines.DIELECTRIC_SPECULAR_MODEL = this._dielectricSpecularModel;\r\n        defines.CONDUCTOR_SPECULAR_MODEL = this._conductorSpecularModel;\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRBRDFConfiguration\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialClearCoatDefines extends MaterialDefines {\r\n    public CLEARCOAT = false;\r\n    public CLEARCOAT_DEFAULTIOR = false;\r\n    public CLEARCOAT_TEXTURE = false;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n    public CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public CLEARCOAT_BUMP = false;\r\n    public CLEARCOAT_BUMPDIRECTUV = 0;\r\n    public CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n    public CLEARCOAT_REMAP_F0 = false;\r\n\r\n    public CLEARCOAT_TINT = false;\r\n    public CLEARCOAT_TINT_TEXTURE = false;\r\n    public CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n    public CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the clear coat component of the PBR material\r\n */\r\nexport class PBRClearCoatConfiguration extends MaterialPluginBase {\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.5;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the clear coat is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer roughness.\r\n     */\r\n    @serialize()\r\n    public roughness: number = 0;\r\n\r\n    private _indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n    /**\r\n     * Defines the index of refraction of the clear coat.\r\n     * This defaults to 1.5 corresponding to a 0.04 f0 or a 4% reflectance at normal incidence\r\n     * The default fits with a polyurethane material.\r\n     * Changing the default value is more performance intensive.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat values in a texture (red channel is intensity and green channel is roughness)\r\n     * If useRoughnessFromMainTexture is false, the green channel of texture is not used and the green channel of textureRoughness is used instead\r\n     * if textureRoughness is not empty, else no texture roughness is used\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the green channel of the texture property will be used for roughness (default: true)\r\n     * If false, the green channel from textureRoughness is used for roughness\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear coat roughness in a texture (green channel)\r\n     * Not used if useRoughnessFromMainTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _remapF0OnInterfaceChange = true;\r\n    /**\r\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public remapF0OnInterfaceChange = true;\r\n\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the clear coat specific bump texture.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _isTintEnabled = false;\r\n    /**\r\n     * Defines if the clear coat tint is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTintEnabled = false;\r\n\r\n    /**\r\n     * Defines the clear coat tint of the material.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the\r\n     * clear coat media.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer thickness.\r\n     * This is only use if tint is enabled\r\n     */\r\n    @serialize()\r\n    public tintThickness: number = 1;\r\n\r\n    private _tintTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the clear tint values in a texture.\r\n     * rgb is tint\r\n     * a is a thickness factor\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public tintTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRClearCoat\", 100, new MaterialClearCoatDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialClearCoatDefines, scene: Scene, engine: Engine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                    if (!this._tintTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialClearCoatDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.CLEARCOAT = true;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n            defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"CLEARCOAT_TEXTURE\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._textureRoughness, defines, \"CLEARCOAT_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n\r\n                    if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._bumpTexture, defines, \"CLEARCOAT_BUMP\");\r\n                    } else {\r\n                        defines.CLEARCOAT_BUMP = false;\r\n                    }\r\n\r\n                    defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n                    if (this._isTintEnabled) {\r\n                        defines.CLEARCOAT_TINT = true;\r\n                        if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                            PrepareDefinesForMergedUV(this._tintTexture, defines, \"CLEARCOAT_TINT_TEXTURE\");\r\n                            defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;\r\n                        } else {\r\n                            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                        }\r\n                    } else {\r\n                        defines.CLEARCOAT_TINT = false;\r\n                        defines.CLEARCOAT_TINT_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.CLEARCOAT = false;\r\n            defines.CLEARCOAT_TEXTURE = false;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;\r\n            defines.CLEARCOAT_BUMP = false;\r\n            defines.CLEARCOAT_TINT = false;\r\n            defines.CLEARCOAT_TINT_TEXTURE = false;\r\n            defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.CLEARCOAT_DEFAULTIOR = false;\r\n            defines.CLEARCOAT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n            defines.CLEARCOAT_BUMPDIRECTUV = 0;\r\n            defines.CLEARCOAT_REMAP_F0 = false;\r\n            defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;\r\n            defines.CLEARCOAT_TINT_GAMMATEXTURE = false;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialClearCoatDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        const disableBumpMap = this._material._disableBumpMap;\r\n        const invertNormalMapX = this._material._invertNormalMapX;\r\n        const invertNormalMapY = this._material._invertNormalMapY;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vClearCoatInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"clearCoat\");\r\n                }\r\n                if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    BindTextureMatrix(this._textureRoughness, uniformBuffer, \"clearCoatRoughness\");\r\n                }\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);\r\n                BindTextureMatrix(this._bumpTexture, uniformBuffer, \"clearCoatBump\");\r\n\r\n                if (scene._mirroredCameraPosition) {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? 1.0 : -1.0, invertNormalMapY ? 1.0 : -1.0);\r\n                } else {\r\n                    uniformBuffer.updateFloat2(\"vClearCoatTangentSpaceParams\", invertNormalMapX ? -1.0 : 1.0, invertNormalMapY ? -1.0 : 1.0);\r\n                }\r\n            }\r\n\r\n            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vClearCoatTintInfos\", this._tintTexture.coordinatesIndex, this._tintTexture.level);\r\n                BindTextureMatrix(this._tintTexture, uniformBuffer, \"clearCoatTint\");\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat2(\"vClearCoatParams\", this.intensity, this.roughness);\r\n\r\n            // Clear Coat Refraction params\r\n            const a = 1 - this._indexOfRefraction;\r\n            const b = 1 + this._indexOfRefraction;\r\n            const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\r\n            const eta = 1 / this._indexOfRefraction;\r\n            uniformBuffer.updateFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\r\n\r\n            if (this._isTintEnabled) {\r\n                uniformBuffer.updateFloat4(\"vClearCoatTintParams\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintThickness));\r\n                uniformBuffer.updateFloat(\"clearCoatColorAtDistance\", Math.max(0.00001, this.tintColorAtDistance));\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatRoughnessSampler\", this._textureRoughness);\r\n            }\r\n\r\n            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {\r\n                uniformBuffer.setTexture(\"clearCoatBumpSampler\", this._bumpTexture);\r\n            }\r\n\r\n            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {\r\n                uniformBuffer.setTexture(\"clearCoatTintSampler\", this._tintTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._tintTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture) {\r\n            activeTextures.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            animatables.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {\r\n            animatables.push(this._tintTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._tintTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRClearCoatConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialClearCoatDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.CLEARCOAT_BUMP) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_BUMP\");\r\n        }\r\n        if (defines.CLEARCOAT_TINT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT_TINT\");\r\n        }\r\n        if (defines.CLEARCOAT) {\r\n            fallbacks.addFallback(currentRank++, \"CLEARCOAT\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"clearCoatSampler\", \"clearCoatRoughnessSampler\", \"clearCoatBumpSampler\", \"clearCoatTintSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vClearCoatParams\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatRefractionParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vClearCoatInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"clearCoatRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatBumpInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vClearCoatTangentSpaceParams\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatBumpMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vClearCoatTintParams\", size: 4, type: \"vec4\" },\r\n                { name: \"clearCoatColorAtDistance\", size: 1, type: \"float\" },\r\n                { name: \"vClearCoatTintInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"clearCoatTintMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize, serializeAsTexture, expandToProperty } from \"../../Misc/decorators\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialIridescenceDefines extends MaterialDefines {\r\n    public IRIDESCENCE = false;\r\n    public IRIDESCENCE_TEXTURE = false;\r\n    public IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n    public IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n    public IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the iridescence (thin film) component of the PBR material\r\n */\r\nexport class PBRIridescenceConfiguration extends MaterialPluginBase {\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    /**\r\n     * The default minimum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 100 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMinimumThickness = 100;\r\n\r\n    /**\r\n     * The default maximum thickness of the thin-film layer given in nanometers (nm).\r\n     * Defaults to 400 nm.\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultMaximumThickness = 400;\r\n\r\n    /**\r\n     * The default index of refraction of the thin-film layer.\r\n     * Defaults to 1.3\r\n     * @internal\r\n     */\r\n    public static readonly _DefaultIndexOfRefraction = 1.3;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the iridescence is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the iridescence layer strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines the minimum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = PBRIridescenceConfiguration._DefaultMinimumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm). This will be the thickness used if not thickness texture has been set.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = PBRIridescenceConfiguration._DefaultMaximumThickness;\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin-film layer given in nanometers (nm).\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction: number = PBRIridescenceConfiguration._DefaultIndexOfRefraction;\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence intensity in a texture (red channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the iridescence thickness in a texture (green channel)\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRIridescence\", 110, new MaterialIridescenceDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialIridescenceDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialIridescenceDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.IRIDESCENCE = true;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"IRIDESCENCE_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"IRIDESCENCE_THICKNESS_TEXTURE\");\r\n                    } else {\r\n                        defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.IRIDESCENCE = false;\r\n            defines.IRIDESCENCE_TEXTURE = false;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;\r\n            defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;\r\n            defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vIridescenceInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._thicknessTexture?.coordinatesIndex ?? 0,\r\n                    this._thicknessTexture?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"iridescence\");\r\n                }\r\n                if (this._thicknessTexture) {\r\n                    BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"iridescenceThickness\");\r\n                }\r\n            }\r\n\r\n            // Clear Coat General params\r\n            uniformBuffer.updateFloat4(\"vIridescenceParams\", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceSampler\", this._texture);\r\n            }\r\n\r\n            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {\r\n                uniformBuffer.setTexture(\"iridescenceThicknessSampler\", this._thicknessTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._thicknessTexture?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRIridescenceConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialIridescenceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.IRIDESCENCE) {\r\n            fallbacks.addFallback(currentRank++, \"IRIDESCENCE\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"iridescenceSampler\", \"iridescenceThicknessSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vIridescenceParams\", size: 4, type: \"vec4\" },\r\n                { name: \"vIridescenceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"iridescenceMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"iridescenceThicknessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public ANISOTROPIC_LEGACY = false;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    /**\r\n     * Sets the anisotropy direction as an angle.\r\n     */\r\n    public set angle(value: number) {\r\n        this.direction.x = Math.cos(value);\r\n        this.direction.y = Math.sin(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy angle value in radians.\r\n     * @returns the anisotropy angle value in radians.\r\n     */\r\n    public get angle(): number {\r\n        return Math.atan2(this.direction.y, this.direction.x);\r\n    }\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _legacy = false;\r\n    /**\r\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public legacy: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsMiscDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsMiscDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (defines._areMiscDirty) {\r\n                defines.ANISOTROPIC_LEGACY = this._legacy;\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n            defines.ANISOTROPIC_LEGACY = false;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public override parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n\r\n        // Backward compatibility\r\n        if (source.legacy === undefined) {\r\n            this.legacy = true;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSheenDefines extends MaterialDefines {\r\n    public SHEEN = false;\r\n    public SHEEN_TEXTURE = false;\r\n    public SHEEN_GAMMATEXTURE = false;\r\n    public SHEEN_TEXTURE_ROUGHNESS = false;\r\n    public SHEEN_TEXTUREDIRECTUV = 0;\r\n    public SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n    public SHEEN_LINKWITHALBEDO = false;\r\n    public SHEEN_ROUGHNESS = false;\r\n    public SHEEN_ALBEDOSCALING = false;\r\n    public SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sheen component of the PBR material.\r\n */\r\nexport class PBRSheenConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    private _linkSheenWithAlbedo = false;\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkSheenWithAlbedo = false;\r\n\r\n    /**\r\n     * Defines the sheen intensity.\r\n     */\r\n    @serialize()\r\n    public intensity = 1;\r\n\r\n    /**\r\n     * Defines the sheen color.\r\n     */\r\n    @serializeAsColor3()\r\n    public color = Color3.White();\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _roughness: Nullable<number> = null;\r\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number> = null;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _albedoScaling = false;\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoScaling = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"Sheen\", 120, new MaterialSheenDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialSheenDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialSheenDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.SHEEN = true;\r\n            defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\r\n            defines.SHEEN_ROUGHNESS = this._roughness !== null;\r\n            defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\r\n                        defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.SHEEN = false;\r\n            defines.SHEEN_TEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n            defines.SHEEN_LINKWITHALBEDO = false;\r\n            defines.SHEEN_ROUGHNESS = false;\r\n            defines.SHEEN_ALBEDOSCALING = false;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.SHEEN_GAMMATEXTURE = false;\r\n            defines.SHEEN_TEXTUREDIRECTUV = 0;\r\n            defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialSheenDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\r\n                    \"vSheenInfos\",\r\n                    this._texture?.coordinatesIndex ?? 0,\r\n                    this._texture?.level ?? 0,\r\n                    this._textureRoughness?.coordinatesIndex ?? 0,\r\n                    this._textureRoughness?.level ?? 0\r\n                );\r\n                if (this._texture) {\r\n                    BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\r\n                }\r\n                if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\r\n                }\r\n            }\r\n\r\n            // Sheen\r\n            uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\r\n\r\n            if (this._roughness !== null) {\r\n                uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRSheenConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialSheenDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SHEEN) {\r\n            fallbacks.addFallback(currentRank++, \"SHEEN\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"sheenSampler\", \"sheenRoughnessSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vSheenColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSheenRoughness\", size: 1, type: \"float\" },\r\n                { name: \"vSheenInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"sheenMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"sheenRoughnessMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PBRBaseMaterial } from \"./pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n    public SS_SCATTERING = false;\r\n    public SS_DISPERSION = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n    public SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;\r\n    public SS_TRANSLUCENCY_LEGACY = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    /**\r\n     * Default value used for applyAlbedoAfterSubSurface.\r\n     *\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface properties (transmission, refraction, etc.). Default is false.\r\n     * Note however that the PBR calculation is wrong when this property is set to true, so only use it if you want to mimic the 7.0 behavior.\r\n     */\r\n    public static DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE = false;\r\n\r\n    /**\r\n     * Default value used for legacyTranslucency.\r\n     *\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface translucency. Default is false.\r\n     */\r\n    public static DEFAULT_LEGACY_TRANSLUCENCY = false;\r\n\r\n    protected override _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isDispersionEnabled = false;\r\n    /**\r\n     * Defines if dispersion is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isDispersionEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @internal */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines the Abbe number for the volume.\r\n     */\r\n    @serialize()\r\n    public dispersion = 0;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue (alpha if useGltfStyleTextures = true) channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue (alpha if useGltfStyleTextures = true) channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Defines the translucency tint of the material.\r\n     * If not set, the tint color will be used instead.\r\n     */\r\n    @serializeAsColor3()\r\n    public translucencyColor: Nullable<Color3> = null;\r\n\r\n    private _translucencyColorTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the translucency tint color of the material as a texture.\r\n     * This is multiplied against the translucency color to add variety and realism to the material.\r\n     * If translucencyColor is not set, the tint color will be used instead.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyColorTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _useGltfStyleTextures = true;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: the alpha (instead of blue) channel is the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = true;\r\n\r\n    /**\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface properties (transmission, refraction, etc.). Default is false.\r\n     * Note however that the PBR calculation is wrong when this property is set to true, so only use it if you want to mimic the 7.0 behavior.\r\n     */\r\n    @serialize()\r\n    public applyAlbedoAfterSubSurface = PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;\r\n\r\n    /**\r\n     * This property only exists for backward compatibility reasons.\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface translucency. Default is false.\r\n     */\r\n    @serialize()\r\n    public legacyTranslucency = PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY;\r\n\r\n    /**\r\n     * Keeping for backward compatibility... Should not be used anymore. It has been replaced by\r\n     * the property with the correct spelling.\r\n     * @see legacyTranslucency\r\n     */\r\n    public get legacyTransluceny(): boolean {\r\n        return this.legacyTranslucency;\r\n    }\r\n    public set legacyTransluceny(value: boolean) {\r\n        this.legacyTranslucency = value;\r\n    }\r\n\r\n    private _scene: Scene;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @internal */\r\n    public _markScenePrePassDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {\r\n                    if (!this._refractionIntensityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {\r\n                    if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {\r\n                    if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefinesBeforeAttributes(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_DISPERSION = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;\r\n            defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_DISPERSION = this._isDispersionEnabled;\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_TRANSLUCENCY_LEGACY = this.legacyTranslucency;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;\r\n            defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = this.applyAlbedoAfterSubSurface;\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {\r\n                        PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, \"SS_TRANSLUCENCYCOLOR_TEXTURE\");\r\n                        defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public override hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        // If min/max thickness is 0, avoid decompising to determine the scaled thickness (it's always zero).\r\n        if (this.maximumThickness === 0.0 && this.minimumThickness === 0.0) {\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", 0, 0);\r\n        } else {\r\n            subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n            const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyColorInfos\", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);\r\n                BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, \"translucencyColor\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Math.log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n            uniformBuffer.updateColor4(\"vTranslucencyColor\", this.translucencyColor ?? this.tintColor, 0);\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n\r\n            uniformBuffer.updateFloat(\"dispersion\", this.dispersion);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyColorSampler\", this._translucencyColorTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public override fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionIntensityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._translucencyColorTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n\r\n        if (this._refractionIntensityTexture) {\r\n            activeTextures.push(this._refractionIntensityTexture);\r\n        }\r\n\r\n        if (this._translucencyColorTexture) {\r\n            activeTextures.push(this._translucencyColorTexture);\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture) {\r\n            activeTextures.push(this._translucencyIntensityTexture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n\r\n        if (this._refractionIntensityTexture && this._refractionIntensityTexture.animations && this._refractionIntensityTexture.animations.length > 0) {\r\n            animatables.push(this._refractionIntensityTexture);\r\n        }\r\n\r\n        if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {\r\n            animatables.push(this._translucencyColorTexture);\r\n        }\r\n\r\n        if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {\r\n            animatables.push(this._translucencyIntensityTexture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionIntensityTexture) {\r\n                this._refractionIntensityTexture.dispose();\r\n            }\r\n\r\n            if (this._translucencyColorTexture) {\r\n                this._translucencyColorTexture.dispose();\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture) {\r\n                this._translucencyIntensityTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public override addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\r\n            \"thicknessSampler\",\r\n            \"refractionIntensitySampler\",\r\n            \"translucencyIntensitySampler\",\r\n            \"refractionSampler\",\r\n            \"refractionSamplerLow\",\r\n            \"refractionSamplerHigh\",\r\n            \"translucencyColorSampler\"\r\n        );\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n                { name: \"dispersion\", size: 1, type: \"float\" },\r\n\r\n                { name: \"vTranslucencyColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vTranslucencyColorInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"translucencyColorMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { expandToProperty } from \"../../Misc/decorators\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration\";\r\nimport { PrePassConfiguration } from \"../prePassConfiguration\";\r\nimport { Color3, TmpColors } from \"../../Maths/math.color\";\r\n\r\nimport { ImageProcessingDefinesMixin } from \"../../Materials/imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { IMaterialCompilationOptions, ICustomShaderNameResolveOptions } from \"../../Materials/material\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MaterialPluginEvent } from \"../materialPluginEvent\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\n\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\n\r\nimport \"../../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration\";\r\nimport { PBRIridescenceConfiguration } from \"./pbrIridescenceConfiguration\";\r\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration\";\r\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration\";\r\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration\";\r\nimport { DetailMapConfiguration } from \"../material.detailMapConfiguration\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindTextureMatrix,\r\n    BindIBLParameters,\r\n    BindIBLSamplers,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForIBL,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersList,\r\n    PrepareUniformsAndSamplersForIBL,\r\n    PrepareUniformLayoutForIBL,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { MaterialHelperGeometryRendering } from \"../materialHelper.geometryrendering\";\r\nimport { UVDefinesMixin } from \"../uv.defines\";\r\nimport { ImageProcessingMixin } from \"../imageProcessing\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\nclass PBRMaterialDefinesBase extends UVDefinesMixin(MaterialDefines) {}\r\n\r\n/**\r\n * Manages the defines for the PBR Material.\r\n * @internal\r\n */\r\nexport class PBRMaterialDefines extends ImageProcessingDefinesMixin(PBRMaterialDefinesBase) {\r\n    public PBR = true;\r\n\r\n    public NUM_SAMPLES = \"0\";\r\n    public REALTIME_FILTERING = false;\r\n    public IBL_CDF_FILTERING = false;\r\n\r\n    public ALBEDO = false;\r\n    public GAMMAALBEDO = false;\r\n    public ALBEDODIRECTUV = 0;\r\n    public VERTEXCOLOR = false;\r\n\r\n    public BASE_WEIGHT = false;\r\n    public BASE_WEIGHTDIRECTUV = 0;\r\n    public BASE_DIFFUSE_ROUGHNESS = false;\r\n    public BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;\r\n\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public AMBIENTINGRAYSCALE = false;\r\n\r\n    public OPACITY = false;\r\n    public VERTEXALPHA = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHABLEND = false;\r\n    public ALPHAFROMALBEDO = false;\r\n    public ALPHATESTVALUE = \"0.5\";\r\n    public SPECULAROVERALPHA = false;\r\n    public RADIANCEOVERALPHA = false;\r\n    public ALPHAFRESNEL = false;\r\n    public LINEARALPHAFRESNEL = false;\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public GAMMAEMISSIVE = false;\r\n\r\n    public REFLECTIVITY = false;\r\n    public REFLECTIVITY_GAMMA = false;\r\n    public REFLECTIVITYDIRECTUV = 0;\r\n    public SPECULARTERM = false;\r\n\r\n    public MICROSURFACEFROMREFLECTIVITYMAP = false;\r\n    public MICROSURFACEAUTOMATIC = false;\r\n    public LODBASEDMICROSFURACE = false;\r\n    public MICROSURFACEMAP = false;\r\n    public MICROSURFACEMAPDIRECTUV = 0;\r\n\r\n    public METALLICWORKFLOW = false;\r\n    public ROUGHNESSSTOREINMETALMAPALPHA = false;\r\n    public ROUGHNESSSTOREINMETALMAPGREEN = false;\r\n    public METALLNESSSTOREINMETALMAPBLUE = false;\r\n    public AOSTOREINMETALMAPRED = false;\r\n    public METALLIC_REFLECTANCE = false;\r\n    public METALLIC_REFLECTANCE_GAMMA = false;\r\n    public METALLIC_REFLECTANCEDIRECTUV = 0;\r\n    public METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;\r\n    public REFLECTANCE = false;\r\n    public REFLECTANCE_GAMMA = false;\r\n    public REFLECTANCEDIRECTUV = 0;\r\n\r\n    public ENVIRONMENTBRDF = false;\r\n    public ENVIRONMENTBRDF_RGBD = false;\r\n\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public NORMALXYSCALE = true;\r\n\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public GAMMALIGHTMAP = false;\r\n    public RGBDLIGHTMAP = false;\r\n\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public USESPHERICALFROMREFLECTIONMAP = false;\r\n    public USEIRRADIANCEMAP = false;\r\n    public USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n    public USESPHERICALINVERTEX = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public LINEARSPECULARREFLECTION = false;\r\n    public RADIANCEOCCLUSION = false;\r\n    public HORIZONOCCLUSION = false;\r\n\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_COLOR = false;\r\n    public PREPASS_COLOR_INDEX = -1;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO = false;\r\n    public PREPASS_ALBEDO_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_SCREENSPACE_DEPTH = false;\r\n    public PREPASS_SCREENSPACE_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH = false;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_WORLD_NORMAL = false;\r\n    public PREPASS_WORLD_NORMAL_INDEX = -1;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_LOCAL_POSITION = false;\r\n    public PREPASS_LOCAL_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_VELOCITY_LINEAR = false;\r\n    public PREPASS_VELOCITY_LINEAR_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n\r\n    public NONUNIFORMSCALING = false;\r\n\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_POSITION = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public MORPHTARGETS_UV2 = false;\r\n    public MORPHTARGETS_COLOR = false;\r\n    public MORPHTARGETTEXTURE_HASPOSITIONS = false;\r\n    public MORPHTARGETTEXTURE_HASNORMALS = false;\r\n    public MORPHTARGETTEXTURE_HASTANGENTS = false;\r\n    public MORPHTARGETTEXTURE_HASUVS = false;\r\n    public MORPHTARGETTEXTURE_HASUV2S = false;\r\n    public MORPHTARGETTEXTURE_HASCOLORS = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    public MULTIVIEW = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\r\n\r\n    public USEPHYSICALLIGHTFALLOFF = false;\r\n    public USEGLTFLIGHTFALLOFF = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public MIRRORED = false;\r\n    public SHADOWFLOAT = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n\r\n    public FORCENORMALFORWARD = false;\r\n\r\n    public SPECULARAA = false;\r\n\r\n    public UNLIT = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    public DEBUGMODE = 0;\r\n    public USE_VERTEX_PULLING = false;\r\n\r\n    public CLUSTLIGHT_SLICES = 0;\r\n    public CLUSTLIGHT_BATCH = 0;\r\n\r\n    /**\r\n     * Initializes the PBR Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Resets the PBR Material defines.\r\n     */\r\n    public override reset(): void {\r\n        super.reset();\r\n        this.ALPHATESTVALUE = \"0.5\";\r\n        this.PBR = true;\r\n        this.NORMALXYSCALE = true;\r\n    }\r\n}\r\n\r\nclass PBRBaseMaterialBase extends ImageProcessingMixin(PushMaterial) {}\r\n/**\r\n * The Physically based material base class of BJS.\r\n *\r\n * This offers the main features of a standard PBR material.\r\n * For more information, please refer to the documentation :\r\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\r\n * @see [WebGL](https://playground.babylonjs.com/#CGHTSM#1)\r\n * @see [WebGPU](https://playground.babylonjs.com/#CGHTSM#2)\r\n */\r\nexport abstract class PBRBaseMaterial extends PBRBaseMaterialBase {\r\n    /**\r\n     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\r\n\r\n    /**\r\n     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\r\n\r\n    /**\r\n     * Defines the default value of how much AO map is occluding the analytical lights\r\n     * (point spot...).\r\n     */\r\n    public static DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static override readonly LIGHTFALLOFF_PHYSICAL = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static override readonly LIGHTFALLOFF_GLTF = 1;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static override readonly LIGHTFALLOFF_STANDARD = 2;\r\n\r\n    /**\r\n     * Force all the PBR materials to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     * @internal\r\n     */\r\n    public _directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the emissive part of the material.\r\n     * This helps controlling the emissive effect without modifying the emissive color.\r\n     * @internal\r\n     */\r\n    public _emissiveIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     * @internal\r\n     */\r\n    public _environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     * @internal\r\n     */\r\n    public _specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\r\n     */\r\n    private _lightingInfos: Vector4 = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);\r\n\r\n    /**\r\n     * Debug Control allowing disabling the bump map on this material.\r\n     * @internal\r\n     */\r\n    public _disableBumpMap: boolean = false;\r\n\r\n    /**\r\n     * AKA Diffuse Texture in standard nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Base Weight texture (multiplier to the diffuse and metal lobes).\r\n     * @internal\r\n     */\r\n    public _baseWeightTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Base Diffuse Roughness texture (roughness of the diffuse lobe).\r\n     * @internal\r\n     */\r\n    public _baseDiffuseRoughnessTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Occlusion Texture Intensity in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _ambientTextureStrength: number = 1.0;\r\n\r\n    /**\r\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\r\n     * 1 means it completely occludes it\r\n     * 0 mean it has no impact\r\n     * @internal\r\n     */\r\n    public _ambientTextureImpactOnAnalyticalLights: number = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\r\n\r\n    /**\r\n     * Stores the alpha values in a texture.\r\n     * @internal\r\n     */\r\n    public _opacityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the reflection values in a texture.\r\n     * @internal\r\n     */\r\n    public _reflectionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the emissive values in a texture.\r\n     * @internal\r\n     */\r\n    public _emissiveTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * AKA Specular texture in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\r\n     * @internal\r\n     */\r\n    public _metallicTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Specifies the metallic scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the metalness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _metallic: Nullable<number> = null;\r\n\r\n    /**\r\n     * Specifies the roughness scalar of the metallic/roughness workflow.\r\n     * Can also be used to scale the roughness values of the metallic texture.\r\n     * @internal\r\n     */\r\n    public _roughness: Nullable<number> = null;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\r\n     * By default the indexOfrefraction is used to compute F0;\r\n     *\r\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\r\n     *\r\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\r\n     * F90 = metallicReflectanceColor;\r\n     * @internal\r\n     */\r\n    public _metallicF0Factor = 1;\r\n\r\n    /**\r\n     * In metallic workflow, specifies an F0 color.\r\n     * By default the F90 is always 1;\r\n     *\r\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\r\n     *\r\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\r\n     * F90 = metallicF0Factor;\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceColor = Color3.White();\r\n\r\n    /**\r\n     * Specifies that only the A channel from _metallicReflectanceTexture should be used.\r\n     * If false, both RGB and A channels will be used\r\n     * @internal\r\n     */\r\n    public _useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n\r\n    /**\r\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\r\n     * This is multiply against the scalar values defined in the material.\r\n     * @internal\r\n     */\r\n    public _metallicReflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Defines to store reflectanceColor in RGB\r\n     * This is multiplied against the scalar values defined in the material.\r\n     * If both _reflectanceTexture and _metallicReflectanceTexture textures are provided and _useOnlyMetallicFromMetallicReflectanceTexture\r\n     * is false, _metallicReflectanceTexture takes precedence and _reflectanceTexture is not used\r\n     * @internal\r\n     */\r\n    public _reflectanceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\r\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\r\n     * @internal\r\n     */\r\n    public _microSurfaceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores surface normal data used to displace a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _bumpTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Stores the pre-calculated light information of a mesh in a texture.\r\n     * @internal\r\n     */\r\n    public _lightmapTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * The color of a material in ambient lighting.\r\n     * @internal\r\n     */\r\n    public _ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Diffuse Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _albedoColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Base Weight (multiplier to the diffuse and metal lobes).\r\n     * @internal\r\n     */\r\n    public _baseWeight = 1;\r\n\r\n    /**\r\n     * Base Diffuse Roughness (roughness of the diffuse lobe).\r\n     * Can also be used to scale the corresponding texture.\r\n     * @internal\r\n     */\r\n    public _baseDiffuseRoughness: Nullable<number> = null;\r\n\r\n    /**\r\n     * AKA Specular Color in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _reflectivityColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is reflected from a material.\r\n     * @internal\r\n     */\r\n    public _reflectionColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * The color applied when light is emitted from a material.\r\n     * @internal\r\n     */\r\n    public _emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * AKA Glossiness in other nomenclature.\r\n     * @internal\r\n     */\r\n    public _microSurface = 0.9;\r\n\r\n    /**\r\n     * Specifies that the material will use the light map as a show map.\r\n     * @internal\r\n     */\r\n    public _useLightmapAsShadowmap = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     * @internal\r\n     */\r\n    public _useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     * @internal\r\n     */\r\n    public _useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\r\n     * @internal\r\n     */\r\n    public _useAlphaFromAlbedoTexture = false;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useSpecularOverAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useMicroSurfaceFromReflectivityMapAlpha = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureAlpha = true;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\r\n     * @internal\r\n     */\r\n    public _useMetallnessFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     * @internal\r\n     */\r\n    public _useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     * @internal\r\n     */\r\n    public _useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\r\n     * The material will try to infer what glossiness each pixel should be.\r\n     * @internal\r\n     */\r\n    public _useAutoMicroSurfaceFromReflectivityMap = false;\r\n\r\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     * @internal\r\n     */\r\n    public _lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     * @internal\r\n     */\r\n    public _useRadianceOverAlpha = true;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     * @internal\r\n     */\r\n    public _useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax mode.\r\n     * @internal\r\n     */\r\n    public _useParallax = false;\r\n\r\n    /**\r\n     * Allows using the bump map in parallax occlusion mode.\r\n     * @internal\r\n     */\r\n    public _useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     * @internal\r\n     */\r\n    public _parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     * @internal\r\n     */\r\n    public _disableLighting = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     * @internal\r\n     */\r\n    public _maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     * @internal\r\n     */\r\n    public _twoSidedLighting = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     * @internal\r\n     */\r\n    public _alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\r\n     * from cos theta and roughness:\r\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n     * @internal\r\n     */\r\n    public _environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     * @internal\r\n     */\r\n    public _forceIrradianceInFragment = false;\r\n\r\n    private _realTimeFiltering: boolean = false;\r\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\r\n    public get realTimeFiltering() {\r\n        return this._realTimeFiltering;\r\n    }\r\n    public set realTimeFiltering(b: boolean) {\r\n        this._realTimeFiltering = b;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private _realTimeFilteringQuality: number = Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\r\n    public get realTimeFilteringQuality(): number {\r\n        return this._realTimeFilteringQuality;\r\n    }\r\n    public set realTimeFilteringQuality(n: number) {\r\n        this._realTimeFilteringQuality = n;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public override get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     * @internal\r\n     */\r\n    public _forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     * @internal\r\n     */\r\n    public _enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * Stores the available render targets.\r\n     */\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /**\r\n     * Sets the global ambient color for the material used in lighting calculations.\r\n     */\r\n    private _globalAmbientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    private _unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    private _applyDecalMapAfterDetailMap = false;\r\n\r\n    private _debugMode = 0;\r\n\r\n    private _shadersLoaded = false;\r\n    private _breakShaderLoadedCheck = false;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public debugMode = 0;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to -1\r\n     */\r\n    public debugLimit = -1;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\r\n    public debugFactor = 1;\r\n\r\n    /**\r\n     * Defines the clear coat layer parameters for the material.\r\n     */\r\n    public readonly clearCoat: PBRClearCoatConfiguration;\r\n\r\n    /**\r\n     * Defines the iridescence layer parameters for the material.\r\n     */\r\n    public readonly iridescence: PBRIridescenceConfiguration;\r\n\r\n    /**\r\n     * Defines the anisotropic parameters for the material.\r\n     */\r\n    public readonly anisotropy: PBRAnisotropicConfiguration;\r\n\r\n    /**\r\n     * Defines the BRDF parameters for the material.\r\n     */\r\n    public readonly brdf: PBRBRDFConfiguration;\r\n\r\n    /**\r\n     * Defines the Sheen parameters for the material.\r\n     */\r\n    public readonly sheen: PBRSheenConfiguration;\r\n\r\n    /**\r\n     * Defines the SubSurface parameters for the material.\r\n     */\r\n    public readonly subSurface: PBRSubSurfaceConfiguration;\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap: DetailMapConfiguration;\r\n\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new PBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Scene, forceGLSL = false) {\r\n        super(name, scene, undefined, forceGLSL || PBRBaseMaterial.ForceGLSL);\r\n\r\n        this.brdf = new PBRBRDFConfiguration(this);\r\n        this.clearCoat = new PBRClearCoatConfiguration(this);\r\n        this.iridescence = new PBRIridescenceConfiguration(this);\r\n        this.anisotropy = new PBRAnisotropicConfiguration(this);\r\n        this.sheen = new PBRSheenConfiguration(this);\r\n        this.subSurface = new PBRSubSurfaceConfiguration(this);\r\n        this.detailMap = new DetailMapConfiguration(this);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public override get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * @returns the name of the material class.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PBRBaseMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected override get _disableAlphaBlending(): boolean {\r\n        return (\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE ||\r\n            this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST ||\r\n            this.subSurface?.disableAlphaBlending\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not this material should be rendered in alpha blend mode.\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not this material should be rendered in alpha test mode.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        if (this.subSurface?.disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromAlbedoTexture(): boolean {\r\n        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this._albedoTexture != null && this._albedoTexture.hasAlpha) || this._opacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * @returns the texture used for the alpha test.\r\n     */\r\n    public override getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._albedoTexture;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param mesh - BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\r\n     * @param useInstances - Specifies that instances should be used.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n        }\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._albedoTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    if (!this._baseWeightTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    if (!this._baseDiffuseRoughnessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    if (reflectionTexture.irradianceTexture) {\r\n                        if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        // Not ready until spherical are ready too.\r\n                        if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        if (!this._metallicTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else if (this._reflectivityTexture) {\r\n                        if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._reflectanceTexture) {\r\n                        if (!this._reflectanceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    // Bump texture cannot be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    // This is blocking.\r\n                    if (!this._environmentBRDFTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"] || defines[\"CLUSTLIGHT_BATCH\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            mesh.createNormals(true);\r\n            Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n        }\r\n\r\n        const previousEffect = subMesh.effect;\r\n        const lightDisposed = defines._areLightsDisposed;\r\n        let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);\r\n\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (effect) {\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n\r\n            // Use previous effect while new one is compiling\r\n            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                effect = previousEffect;\r\n                defines.markAsUnprocessed();\r\n\r\n                forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                if (lightDisposed) {\r\n                    // re register in case it takes more than one frame.\r\n                    defines._areLightsDisposed = true;\r\n                    return false;\r\n                }\r\n            } else {\r\n                scene.resetCachedMaterial();\r\n                subMesh.setEffect(effect, defines, this._materialContext);\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses metallic roughness workflow.\r\n     * @returns boolean specifying if the material uses metallic roughness workflow.\r\n     */\r\n    public isMetallicWorkflow(): boolean {\r\n        if (this._metallic != null || this._roughness != null || this._metallicTexture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _prepareEffect(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): Nullable<Effect> {\r\n        this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);\r\n\r\n        if (!defines.isDirty) {\r\n            return null;\r\n        }\r\n\r\n        defines.markAsProcessed();\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Fallbacks\r\n        const fallbacks = new EffectFallbacks();\r\n        let fallbackRank = 0;\r\n        if (defines.USESPHERICALINVERTEX) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\r\n        }\r\n\r\n        if (defines.FOG) {\r\n            fallbacks.addFallback(fallbackRank, \"FOG\");\r\n        }\r\n        if (defines.SPECULARAA) {\r\n            fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\r\n        }\r\n        if (defines.POINTSIZE) {\r\n            fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\r\n        }\r\n        if (defines.LOGARITHMICDEPTH) {\r\n            fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\r\n        }\r\n        if (defines.PARALLAX) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX\");\r\n        }\r\n        if (defines.PARALLAX_RHS) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX_RHS\");\r\n        }\r\n        if (defines.PARALLAXOCCLUSION) {\r\n            fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\r\n        }\r\n\r\n        if (defines.ENVIRONMENTBRDF) {\r\n            fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"TANGENT\");\r\n        }\r\n\r\n        if (defines.BUMP) {\r\n            fallbacks.addFallback(fallbackRank++, \"BUMP\");\r\n        }\r\n\r\n        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\r\n        }\r\n\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\r\n        }\r\n\r\n        if (defines.USEIRRADIANCEMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\r\n        }\r\n\r\n        if (defines.LIGHTMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\r\n        }\r\n\r\n        if (defines.NORMAL) {\r\n            fallbacks.addFallback(fallbackRank++, \"NORMAL\");\r\n        }\r\n\r\n        if (defines.AMBIENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\r\n        }\r\n\r\n        if (defines.EMISSIVE) {\r\n            fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\r\n        }\r\n\r\n        if (defines.MORPHTARGETS) {\r\n            fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\r\n        }\r\n\r\n        if (defines.MULTIVIEW) {\r\n            fallbacks.addFallback(0, \"MULTIVIEW\");\r\n        }\r\n\r\n        //Attributes\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        if (defines.NORMAL) {\r\n            attribs.push(VertexBuffer.NormalKind);\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            attribs.push(VertexBuffer.TangentKind);\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            if (defines[\"UV\" + i]) {\r\n                attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n            }\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n        PrepareAttributesForInstances(attribs, defines);\r\n        PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n        let shaderName = \"pbr\";\r\n\r\n        const uniforms = [\r\n            \"world\",\r\n            \"view\",\r\n            \"viewProjection\",\r\n            \"vEyePosition\",\r\n            \"vLightsType\",\r\n            \"vAmbientColor\",\r\n            \"vAlbedoColor\",\r\n            \"baseWeight\",\r\n            \"baseDiffuseRoughness\",\r\n            \"vReflectivityColor\",\r\n            \"vMetallicReflectanceFactors\",\r\n            \"vEmissiveColor\",\r\n            \"visibility\",\r\n            \"vFogInfos\",\r\n            \"vFogColor\",\r\n            \"pointSize\",\r\n            \"vAlbedoInfos\",\r\n            \"vBaseWeightInfos\",\r\n            \"vBaseDiffuseRoughnessInfos\",\r\n            \"vAmbientInfos\",\r\n            \"vOpacityInfos\",\r\n            \"vEmissiveInfos\",\r\n            \"vReflectivityInfos\",\r\n            \"vMetallicReflectanceInfos\",\r\n            \"vReflectanceInfos\",\r\n            \"vMicroSurfaceSamplerInfos\",\r\n            \"vBumpInfos\",\r\n            \"vLightmapInfos\",\r\n            \"mBones\",\r\n            \"albedoMatrix\",\r\n            \"baseWeightMatrix\",\r\n            \"baseDiffuseRoughnessMatrix\",\r\n            \"ambientMatrix\",\r\n            \"opacityMatrix\",\r\n            \"emissiveMatrix\",\r\n            \"reflectivityMatrix\",\r\n            \"normalMatrix\",\r\n            \"microSurfaceSamplerMatrix\",\r\n            \"bumpMatrix\",\r\n            \"lightmapMatrix\",\r\n            \"metallicReflectanceMatrix\",\r\n            \"reflectanceMatrix\",\r\n            \"vLightingIntensity\",\r\n            \"logarithmicDepthConstant\",\r\n            \"vTangentSpaceParams\",\r\n            \"boneTextureWidth\",\r\n            \"vDebugMode\",\r\n            \"morphTargetTextureInfo\",\r\n            \"morphTargetTextureIndices\",\r\n            \"cameraInfo\",\r\n        ];\r\n\r\n        const samplers = [\r\n            \"albedoSampler\",\r\n            \"baseWeightSampler\",\r\n            \"baseDiffuseRoughnessSampler\",\r\n            \"reflectivitySampler\",\r\n            \"ambientSampler\",\r\n            \"emissiveSampler\",\r\n            \"bumpSampler\",\r\n            \"lightmapSampler\",\r\n            \"opacitySampler\",\r\n            \"microSurfaceSampler\",\r\n            \"environmentBrdfSampler\",\r\n            \"boneSampler\",\r\n            \"metallicReflectanceSampler\",\r\n            \"reflectanceSampler\",\r\n            \"morphTargets\",\r\n            \"oitDepthSampler\",\r\n            \"oitFrontColorSampler\",\r\n            \"areaLightsLTC1Sampler\",\r\n            \"areaLightsLTC2Sampler\",\r\n        ];\r\n\r\n        PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);\r\n\r\n        const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n        this._eventInfo.fallbacks = fallbacks;\r\n        this._eventInfo.fallbackRank = fallbackRank;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.uniforms = uniforms;\r\n        this._eventInfo.attributes = attribs;\r\n        this._eventInfo.samplers = samplers;\r\n        this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n        this._eventInfo.customCode = undefined;\r\n        this._eventInfo.mesh = mesh;\r\n        this._eventInfo.indexParameters = indexParameters;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);\r\n\r\n        PrePassConfiguration.AddUniforms(uniforms);\r\n        PrePassConfiguration.AddSamplers(samplers);\r\n        AddClipPlaneUniforms(uniforms);\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n        }\r\n\r\n        PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n            uniformsNames: uniforms,\r\n            uniformBuffersNames: uniformBuffers,\r\n            samplers: samplers,\r\n            defines: defines,\r\n            maxSimultaneousLights: this._maxSimultaneousLights,\r\n        });\r\n\r\n        const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n        if (this.customShaderNameResolve) {\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n        }\r\n\r\n        const join = defines.toString();\r\n        const effect = engine.createEffect(\r\n            shaderName,\r\n            <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: onCompiled,\r\n                onError: onError,\r\n                indexParameters,\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                processCodeAfterIncludes: this._eventInfo.customCode,\r\n                multiTarget: defines.PREPASS,\r\n                shaderLanguage: this._shaderLanguage,\r\n                extraInitializationsAsync: this._shadersLoaded\r\n                    ? undefined\r\n                    : async () => {\r\n                          if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                              await Promise.all([import(\"../../ShadersWGSL/pbr.vertex\"), import(\"../../ShadersWGSL/pbr.fragment\")]);\r\n                          } else {\r\n                              await Promise.all([import(\"../../Shaders/pbr.vertex\"), import(\"../../Shaders/pbr.fragment\")]);\r\n                          }\r\n\r\n                          this._shadersLoaded = true;\r\n                      },\r\n            },\r\n            engine\r\n        );\r\n\r\n        this._eventInfo.customCode = undefined;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _prepareDefines(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: PBRMaterialDefines,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): void {\r\n        const useThinInstances = renderingMesh.hasThinInstances;\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);\r\n\r\n        // Textures\r\n        defines.METALLICWORKFLOW = this.isMetallicWorkflow();\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                defines.ALBEDODIRECTUV = 0;\r\n                defines.BASE_WEIGHTDIRECTUV = 0;\r\n                defines.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;\r\n                defines.AMBIENTDIRECTUV = 0;\r\n                defines.OPACITYDIRECTUV = 0;\r\n                defines.EMISSIVEDIRECTUV = 0;\r\n                defines.REFLECTIVITYDIRECTUV = 0;\r\n                defines.MICROSURFACEMAPDIRECTUV = 0;\r\n                defines.METALLIC_REFLECTANCEDIRECTUV = 0;\r\n                defines.REFLECTANCEDIRECTUV = 0;\r\n                defines.BUMPDIRECTUV = 0;\r\n                defines.LIGHTMAPDIRECTUV = 0;\r\n\r\n                if (engine.getCaps().textureLOD) {\r\n                    defines.LODBASEDMICROSFURACE = true;\r\n                }\r\n\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\r\n                    defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\r\n                } else {\r\n                    defines.ALBEDO = false;\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._baseWeightTexture, defines, \"BASE_WEIGHT\");\r\n                } else {\r\n                    defines.BASE_WEIGHT = false;\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._baseDiffuseRoughnessTexture, defines, \"BASE_DIFFUSE_ROUGHNESS\");\r\n                } else {\r\n                    defines.BASE_DIFFUSE_ROUGHNESS = false;\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                    defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                const reflectionTexture = this._getReflectionTexture();\r\n                const useSHInFragment: boolean =\r\n                    this._forceIrradianceInFragment ||\r\n                    this.realTimeFiltering ||\r\n                    this._twoSidedLighting ||\r\n                    engine.getCaps().maxVaryingVectors <= 8 ||\r\n                    this._baseDiffuseRoughnessTexture != null;\r\n                PrepareDefinesForIBL(scene, reflectionTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                    defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                    defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\r\n                    defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\r\n                        defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\r\n                        defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\r\n                        defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\r\n                        defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\r\n                        defines.REFLECTIVITY_GAMMA = false;\r\n                    } else if (this._reflectivityTexture) {\r\n                        PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\r\n                        defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\r\n                        defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\r\n                        defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;\r\n                    } else {\r\n                        defines.REFLECTIVITY = false;\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture || this._reflectanceTexture) {\r\n                        defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;\r\n                        if (this._metallicReflectanceTexture) {\r\n                            PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\r\n                            defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.METALLIC_REFLECTANCE = false;\r\n                        }\r\n                        if (\r\n                            this._reflectanceTexture &&\r\n                            (!this._metallicReflectanceTexture || (this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture))\r\n                        ) {\r\n                            PrepareDefinesForMergedUV(this._reflectanceTexture, defines, \"REFLECTANCE\");\r\n                            defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;\r\n                        } else {\r\n                            defines.REFLECTANCE = false;\r\n                        }\r\n                    } else {\r\n                        defines.METALLIC_REFLECTANCE = false;\r\n                        defines.REFLECTANCE = false;\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\r\n                    } else {\r\n                        defines.MICROSURFACEMAP = false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTIVITY = false;\r\n                    defines.MICROSURFACEMAP = false;\r\n                }\r\n\r\n                if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                    if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        defines.PARALLAX = true;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\r\n                    } else {\r\n                        defines.PARALLAX = false;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                    defines.OBJECTSPACE_NORMALMAP = false;\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.ENVIRONMENTBRDF = true;\r\n                    defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\r\n                } else {\r\n                    defines.ENVIRONMENTBRDF = false;\r\n                    defines.ENVIRONMENTBRDF_RGBD = false;\r\n                }\r\n\r\n                if (this._shouldUseAlphaFromAlbedoTexture()) {\r\n                    defines.ALPHAFROMALBEDO = true;\r\n                } else {\r\n                    defines.ALPHAFROMALBEDO = false;\r\n                }\r\n            }\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = true;\r\n            } else {\r\n                defines.USEPHYSICALLIGHTFALLOFF = true;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            }\r\n\r\n            defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\r\n\r\n            if (!this.backFaceCulling && this._twoSidedLighting) {\r\n                defines.TWOSIDEDLIGHTING = true;\r\n            } else {\r\n                defines.TWOSIDEDLIGHTING = false;\r\n            }\r\n\r\n            // We need it to not invert normals in two sided lighting mode (based on the winding of the face)\r\n            defines.MIRRORED = !!scene._mirroredCameraPosition;\r\n\r\n            defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\r\n        }\r\n\r\n        if (defines._areTexturesDirty || defines._areMiscDirty) {\r\n            defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\r\n            defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\r\n            defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        defines.FORCENORMALFORWARD = this._forceNormalForward;\r\n\r\n        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\r\n\r\n        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            PrepareDefinesForMisc(\r\n                mesh,\r\n                scene,\r\n                this._useLogarithmicDepth,\r\n                this.pointsCloud,\r\n                this.fogEnabled,\r\n                this.needAlphaTestingForMesh(mesh),\r\n                defines,\r\n                this._applyDecalMapAfterDetailMap,\r\n                this._useVertexPulling,\r\n                renderingMesh,\r\n                this._isVertexOutputInvariant\r\n            );\r\n            defines.UNLIT = this._unlit || ((this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n            defines.DEBUGMODE = this._debugMode;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh - Define the mesh we want to force the compilation for\r\n     * @param onCompiled - Define a callback triggered when the compilation completes\r\n     * @param options - Define the options used to create the compilation\r\n     */\r\n    public override forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n        const checkReady = () => {\r\n            if (this._breakShaderLoadedCheck) {\r\n                return;\r\n            }\r\n            const defines = new PBRMaterialDefines(this._eventInfo.defineNames);\r\n            const effect = this._prepareEffect(mesh, mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane)!;\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n            if (effect.isReady()) {\r\n                if (onCompiled) {\r\n                    onCompiled(this);\r\n                }\r\n            } else {\r\n                effect.onCompileObservable.add(() => {\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public override buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"vAlbedoInfos\", 2);\r\n        ubo.addUniform(\"vBaseWeightInfos\", 2);\r\n        ubo.addUniform(\"vBaseDiffuseRoughnessInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 4);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vReflectivityInfos\", 3);\r\n        ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n        ubo.addUniform(\"albedoMatrix\", 16);\r\n        ubo.addUniform(\"baseWeightMatrix\", 16);\r\n        ubo.addUniform(\"baseDiffuseRoughnessMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"reflectivityMatrix\", 16);\r\n        ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"vAlbedoColor\", 4);\r\n        ubo.addUniform(\"baseWeight\", 1);\r\n        ubo.addUniform(\"baseDiffuseRoughness\", 1);\r\n        ubo.addUniform(\"vLightingIntensity\", 4);\r\n\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"vReflectivityColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"vAmbientColor\", 3);\r\n\r\n        ubo.addUniform(\"vDebugMode\", 2);\r\n\r\n        ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\r\n        ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\r\n        ubo.addUniform(\"metallicReflectanceMatrix\", 16);\r\n        ubo.addUniform(\"vReflectanceInfos\", 2);\r\n        ubo.addUniform(\"reflectanceMatrix\", 16);\r\n\r\n        ubo.addUniform(\"cameraInfo\", 4);\r\n        PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh data.\r\n     * @param world - The world matrix.\r\n     * @param mesh - The BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <PBRMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);\r\n\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", camera.minZ, camera.maxZ, 0, 0);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", 0, 0, 0, 0);\r\n        }\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\r\n\r\n        let reflectionTexture: Nullable<BaseTexture> = null;\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            reflectionTexture = this._getReflectionTexture();\r\n\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\r\n                        BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\r\n                    }\r\n\r\n                    if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                        ubo.updateFloat2(\"vBaseWeightInfos\", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);\r\n                        BindTextureMatrix(this._baseWeightTexture, ubo, \"baseWeight\");\r\n                    }\r\n\r\n                    if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                        ubo.updateFloat2(\"vBaseDiffuseRoughnessInfos\", this._baseDiffuseRoughnessTexture.coordinatesIndex, this._baseDiffuseRoughnessTexture.level);\r\n                        BindTextureMatrix(this._baseDiffuseRoughnessTexture, ubo, \"baseDiffuseRoughness\");\r\n                    }\r\n\r\n                    if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                        ubo.updateFloat4(\r\n                            \"vAmbientInfos\",\r\n                            this._ambientTexture.coordinatesIndex,\r\n                            this._ambientTexture.level,\r\n                            this._ambientTextureStrength,\r\n                            this._ambientTextureImpactOnAnalyticalLights\r\n                        );\r\n                        BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (MaterialFlags.SpecularTextureEnabled) {\r\n                        if (this._metallicTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\r\n                            BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\r\n                        } else if (this._reflectivityTexture) {\r\n                            ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\r\n                            BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\r\n                        }\r\n\r\n                        if (this._metallicReflectanceTexture) {\r\n                            ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\r\n                            BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\r\n                        }\r\n\r\n                        if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                            ubo.updateFloat2(\"vReflectanceInfos\", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);\r\n                            BindTextureMatrix(this._reflectanceTexture, ubo, \"reflectance\");\r\n                        }\r\n\r\n                        if (this._microSurfaceTexture) {\r\n                            ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\r\n                            BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\r\n                        }\r\n                    }\r\n\r\n                    if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\r\n                        BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n\r\n                    BindIBLParameters(scene, defines, ubo, this._reflectionColor, reflectionTexture, this.realTimeFiltering, true, true, true, true, true);\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                // Colors\r\n                if (defines.METALLICWORKFLOW) {\r\n                    TmpColors.Color4[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\r\n                    TmpColors.Color4[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\r\n                    const ior = this.subSurface?._indexOfRefraction ?? 1.5;\r\n                    const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\r\n                    TmpColors.Color4[0].b = ior;\r\n                    // We are here deriving our default reflectance from a common value for none metallic surface.\r\n                    // Based of the schlick fresnel approximation model\r\n                    // for dielectrics.\r\n                    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\r\n                    TmpColors.Color4[0].a = f0;\r\n                    ubo.updateDirectColor4(\"vReflectivityColor\", TmpColors.Color4[0]);\r\n                    ubo.updateColor4(\"vMetallicReflectanceFactors\", this._metallicReflectanceColor, this._metallicF0Factor);\r\n                } else {\r\n                    ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\r\n                }\r\n\r\n                ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\r\n\r\n                if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\r\n                } else {\r\n                    ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\r\n                }\r\n\r\n                ubo.updateFloat(\"baseWeight\", this._baseWeight);\r\n                ubo.updateFloat(\"baseDiffuseRoughness\", this._baseDiffuseRoughness || 0.0);\r\n\r\n                // Misc\r\n                this._lightingInfos.x = this._directIntensity;\r\n                this._lightingInfos.y = this._emissiveIntensity;\r\n                this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\r\n                this._lightingInfos.w = this._specularIntensity;\r\n\r\n                ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\r\n\r\n                // Colors\r\n                scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\r\n\r\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n\r\n                ubo.updateFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    ubo.setTexture(\"albedoSampler\", this._albedoTexture);\r\n                }\r\n\r\n                if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {\r\n                    ubo.setTexture(\"baseWeightSampler\", this._baseWeightTexture);\r\n                }\r\n\r\n                if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {\r\n                    ubo.setTexture(\"baseDiffuseRoughnessSampler\", this._baseDiffuseRoughnessTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\r\n                    ubo.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    ubo.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                BindIBLSamplers(scene, defines, ubo, reflectionTexture, this.realTimeFiltering);\r\n\r\n                if (defines.ENVIRONMENTBRDF) {\r\n                    ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\r\n                }\r\n\r\n                if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\r\n                    ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\r\n                    ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (MaterialFlags.SpecularTextureEnabled) {\r\n                    if (this._metallicTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\r\n                    } else if (this._reflectivityTexture) {\r\n                        ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\r\n                    }\r\n\r\n                    if (this._metallicReflectanceTexture) {\r\n                        ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\r\n                    }\r\n\r\n                    if (this._reflectanceTexture && defines.REFLECTANCE) {\r\n                        ubo.setTexture(\"reflectanceSampler\", this._reflectanceTexture);\r\n                    }\r\n\r\n                    if (this._microSurfaceTexture) {\r\n                        ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\r\n                    ubo.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if (\r\n                (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\r\n                reflectionTexture ||\r\n                this.subSurface.refractionTexture ||\r\n                mesh.receiveShadows ||\r\n                defines.PREPASS ||\r\n                defines[\"CLUSTLIGHT_BATCH\"]\r\n            ) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                BindMorphTargetParameters(mesh, this._activeEffect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // image processing\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n\r\n            // Log. depth\r\n            BindLogDepth(defines, this._activeEffect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\r\n            results.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {\r\n            results.push(this._baseWeightTexture);\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture && this._baseDiffuseRoughnessTexture.animations && this._baseDiffuseRoughnessTexture.animations.length > 0) {\r\n            results.push(this._baseDiffuseRoughnessTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\r\n            results.push(this._metallicTexture);\r\n        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\r\n            results.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {\r\n            results.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {\r\n            results.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {\r\n            results.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for reflections.\r\n     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\r\n     */\r\n    private _getReflectionTexture(): Nullable<BaseTexture> {\r\n        if (this._reflectionTexture) {\r\n            return this._reflectionTexture;\r\n        }\r\n\r\n        return this.getScene().environmentTexture;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @returns - Array of BaseTextures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._albedoTexture) {\r\n            activeTextures.push(this._albedoTexture);\r\n        }\r\n\r\n        if (this._baseWeightTexture) {\r\n            activeTextures.push(this._baseWeightTexture);\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture) {\r\n            activeTextures.push(this._baseDiffuseRoughnessTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._reflectivityTexture) {\r\n            activeTextures.push(this._reflectivityTexture);\r\n        }\r\n\r\n        if (this._metallicTexture) {\r\n            activeTextures.push(this._metallicTexture);\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture) {\r\n            activeTextures.push(this._metallicReflectanceTexture);\r\n        }\r\n\r\n        if (this._reflectanceTexture) {\r\n            activeTextures.push(this._reflectanceTexture);\r\n        }\r\n\r\n        if (this._microSurfaceTexture) {\r\n            activeTextures.push(this._microSurfaceTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._albedoTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._baseWeightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._baseDiffuseRoughnessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectivityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._metallicReflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectanceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._microSurfaceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * It can't be sets when subsurface scattering of this material is disabled.\r\n     * When scene have ability to enable subsurface prepass effect, it will enable.\r\n     * @returns - If prepass is enabled or not.\r\n     */\r\n    public override setPrePassRenderer(): boolean {\r\n        if (!this.subSurface?.isScatteringEnabled) {\r\n            return false;\r\n        }\r\n\r\n        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\r\n        if (subSurfaceConfiguration) {\r\n            subSurfaceConfiguration.enabled = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeEffect - Forces the disposal of effects.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        this._breakShaderLoadedCheck = true;\r\n        if (forceDisposeTextures) {\r\n            if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\r\n                this._environmentBRDFTexture.dispose();\r\n            }\r\n\r\n            this._albedoTexture?.dispose();\r\n            this._baseWeightTexture?.dispose();\r\n            this._baseDiffuseRoughnessTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._metallicTexture?.dispose();\r\n            this._reflectivityTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._metallicReflectanceTexture?.dispose();\r\n            this._reflectanceTexture?.dispose();\r\n            this._microSurfaceTexture?.dispose();\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n}\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the sheen module of the PBR material\r\n */\r\nexport class SheenBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new SheenBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"sheen\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sheen\", this, NodeMaterialConnectionPointDirection.Output, SheenBlock, \"SheenBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @editableInPropertyPage(\"Albedo scaling\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: true } })\r\n    public albedoScaling: boolean = false;\r\n\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @editableInPropertyPage(\"Link sheen with albedo\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", { embedded: true, notifiers: { update: true } })\r\n    public linkSheenWithAlbedo: boolean = false;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"sheenOut\");\r\n        state._excludeVariableName(\"sheenMapData\");\r\n        state._excludeVariableName(\"vSheenColor\");\r\n        state._excludeVariableName(\"vSheenRoughness\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SheenBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the sheen object output component\r\n     */\r\n    public get sheen(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(\"SHEEN\", true);\r\n        defines.setValue(\"SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\r\n        defines.setValue(\"SHEEN_LINKWITHALBEDO\", this.linkSheenWithAlbedo, true);\r\n        defines.setValue(\"SHEEN_ROUGHNESS\", this.roughness.isConnected, true);\r\n        defines.setValue(\"SHEEN_ALBEDOSCALING\", this.albedoScaling, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @param state define the build state\r\n     * @returns the shader code\r\n     */\r\n    public getCode(reflectionBlock: Nullable<ReflectionBlock>, state: NodeMaterialBuildState): string {\r\n        let code = \"\";\r\n\r\n        const color = this.color.isConnected ? this.color.associatedVariableName : `vec3${state.fSuffix}(1.)`;\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.\";\r\n        const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\r\n        const texture = `vec4${state.fSuffix}(0.)`;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        code = `#ifdef SHEEN\r\n            ${isWebGPU ? \"var sheenOut: sheenOutParams\" : \"sheenOutParams sheenOut\"};\r\n\r\n            ${state._declareLocalVar(\"vSheenColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${color}, ${intensity});\r\n\r\n            sheenOut = sheenBlock(\r\n                vSheenColor\r\n            #ifdef SHEEN_ROUGHNESS\r\n                , ${roughness}\r\n            #endif\r\n                , roughness\r\n            #ifdef SHEEN_TEXTURE\r\n                , ${texture}\r\n                ${isWebGPU ? `, ${texture}Sampler` : \"\"}\r\n                , 1.0\r\n            #endif\r\n                , reflectanceF0\r\n            #ifdef SHEEN_LINKWITHALBEDO\r\n                , baseColor\r\n                , surfaceAlbedo\r\n            #endif\r\n            #ifdef ENVIRONMENTBRDF\r\n                , NdotV\r\n                , environmentBrdf\r\n            #endif\r\n            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\r\n                , AARoughnessFactors\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}${reflectionBlock?._vReflectionMicrosurfaceInfosName}\r\n                , ${reflectionBlock?._vReflectionInfosName}\r\n                , ${reflectionBlock?.reflectionColor}\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}vLightingIntensity\r\n                #ifdef ${reflectionBlock?._define3DName}\r\n                    , ${reflectionBlock?._cubeSamplerName}                                      \r\n                    ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                #else\r\n                    , ${reflectionBlock?._2DSamplerName}\r\n                    ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                #endif\r\n                , reflectionOut.reflectionCoords\r\n                , NdotVUnclamped\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${reflectionBlock?._define3DName}\r\n                        , ${reflectionBlock?._cubeSamplerName}                        \r\n                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                        , ${reflectionBlock?._cubeSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                    #else\r\n                        , ${reflectionBlock?._2DSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                        , ${reflectionBlock?._2DSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                    #endif\r\n                #endif\r\n                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(RADIANCEOCCLUSION)\r\n                    , seo\r\n                #endif\r\n                #if !defined(${reflectionBlock?._defineSkyboxName}) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(${reflectionBlock?._define3DName})\r\n                    , eho\r\n                #endif\r\n            #endif\r\n            );\r\n\r\n            #ifdef SHEEN_LINKWITHALBEDO\r\n                surfaceAlbedo = sheenOut.surfaceAlbedo;\r\n            #endif\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.albedoScaling = ${this.albedoScaling};\\n`;\r\n        codeString += `${this._codeVariableName}.linkSheenWithAlbedo = ${this.linkSheenWithAlbedo};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.albedoScaling = this.albedoScaling;\r\n        serializationObject.linkSheenWithAlbedo = this.linkSheenWithAlbedo;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.albedoScaling = serializationObject.albedoScaling;\r\n        this.linkSheenWithAlbedo = serializationObject.linkSheenWithAlbedo;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SheenBlock\", SheenBlock);\r\n", "import type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPositionConnectionPoint;\r\n        const worldNormal = this.worldNormalConnectionPoint;\r\n        const worldTangent = this.worldTangent;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            state.sharedData.raiseBuildError(`You must connect the 'uv' input of the ${this.name} block!`);\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const tbn = this.TBN;\r\n        if (tbn.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            ${isWebGPU ? \"var TBN\" : \"mat3 TBN\"} = ${tbn.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `${state._declareLocalVar(\"tbnNormal\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\r\n            code += `${state._declareLocalVar(\"tbnTangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            code += `${state._declareLocalVar(\"tbnBitangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\r\n            code += `${isWebGPU ? \"var vTBN\" : \"mat3 vTBN\"} = ${isWebGPU ? \"mat3x3f\" : \"mat3\"}(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                ${isWebGPU ? \"var TBN\" : \"mat3 TBN\"} = vTBN;\r\n            #else\r\n                ${isWebGPU ? \"var TBN\" : \"mat3 TBN\"} = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${\r\n                    uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"\r\n                }, vec2${state.fSuffix}(1., 1.));\r\n            #endif\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n        const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\r\n\r\n        code += `${isWebGPU ? \"var anisotropicOut: anisotropicOutParams\" : \"anisotropicOutParams anisotropicOut\"};\r\n            anisotropicOut = anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n                ${roughness},\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW\r\n            );\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n        defines.setValue(\"ANISOTROPIC_LEGACY\", !this.roughness.isConnected);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { ReflectionTextureBaseBlock } from \"../Dual/reflectionTextureBaseBlock\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../../../Meshes/subMesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the reflection module of the PBR material\r\n */\r\nexport class ReflectionBlock extends ReflectionTextureBaseBlock {\r\n    /** @internal */\r\n    public _defineLODReflectionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularReflection: string;\r\n    private _vEnvironmentIrradianceName: string;\r\n    /** @internal */\r\n    public _vReflectionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionFilteringInfoName: string;\r\n    private _scene: Scene;\r\n    private _iblIntensityName: string;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public cameraPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     */\r\n    @editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public useSphericalHarmonics: boolean = true;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public forceIrradianceInFragment: boolean = false;\r\n\r\n    protected override _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        if (this.position.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            Logger.Error(\"The position input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        this._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected override _setTarget(): void {\r\n        super._setTarget();\r\n        this.getInputByName(\"position\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        if (this.generateOnlyFragmentCode) {\r\n            this.forceIrradianceInFragment = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"reflection\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\")\r\n        );\r\n\r\n        this.position.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ReflectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this.worldPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this.worldNormalConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this.cameraPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection object output component\r\n     */\r\n    public get reflection(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\r\n     */\r\n    public get reflectionColor(): string {\r\n        return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\r\n    }\r\n\r\n    protected override _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        super.prepareDefines(defines);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n        const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"REFLECTION\", reflection, true);\r\n\r\n        if (!reflection) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);\r\n\r\n        defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\r\n        defines.setValue(\"GAMMAREFLECTION\", reflectionTexture.gammaSpace, true);\r\n        defines.setValue(\"RGBDREFLECTION\", reflectionTexture.isRGBD, true);\r\n\r\n        if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n            if (reflectionTexture.isCube) {\r\n                defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\r\n                defines.setValue(\"USEIRRADIANCEMAP\", false);\r\n                if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", false);\r\n                } else {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n\r\n        if (!reflectionTexture || !subMesh) {\r\n            return;\r\n        }\r\n\r\n        if (reflectionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, reflectionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, reflectionTexture);\r\n        }\r\n\r\n        effect.setFloat(this._iblIntensityName, this._scene.iblIntensity * reflectionTexture.level);\r\n\r\n        const width = reflectionTexture.getSize().width;\r\n\r\n        effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\r\n        effect.setFloat2(this._vReflectionFilteringInfoName, width, Math.log2(width));\r\n\r\n        const defines = subMesh.materialDefines as NodeMaterialDefines;\r\n\r\n        const polynomials = reflectionTexture.sphericalPolynomial;\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n            if (defines.SPHERICAL_HARMONICS) {\r\n                const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n            } else {\r\n                effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public override handleVertexSide(state: NodeMaterialBuildState): string {\r\n        let code = super.handleVertexSide(state);\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        const reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\r\n\r\n        this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\r\n\r\n        state._emitVaryingFromString(\r\n            this._vEnvironmentIrradianceName,\r\n            NodeMaterialBlockConnectionPointTypes.Vector3,\r\n            \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\"\r\n        );\r\n\r\n        state._emitUniformFromString(\"vSphericalL00\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL1_1\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL10\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL11\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_2\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_1\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL20\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL21\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL22\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\");\r\n\r\n        state._emitUniformFromString(\"vSphericalX\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalY\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZ\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXX_ZZ\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYY_ZZ\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZZ\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXY\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYZ\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZX\", NodeMaterialBlockConnectionPointTypes.Vector3, \"SPHERICAL_HARMONICS\", true);\r\n\r\n        code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\r\n                ${state._declareLocalVar(reflectionVectorName, NodeMaterialBlockConnectionPointTypes.Vector3)} = (${(isWebGPU ? \"uniforms.\" : \"\") + this._reflectionMatrixName} * vec4${state.fSuffix}(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;\r\n                #ifdef ${this._defineOppositeZ}\r\n                    ${reflectionVectorName}.z *= -1.0;\r\n                #endif\r\n                ${isWebGPU ? \"vertexOutputs.\" : \"\"}${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});\r\n            #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param normalVarName name of the existing variable corresponding to the normal\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, normalVarName: string): string {\r\n        let code = \"\";\r\n\r\n        this.handleFragmentSideInits(state);\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        if (!isWebGPU) {\r\n            state._emitFunction(\r\n                \"sampleReflection\",\r\n                `\r\n                #ifdef ${this._define3DName}\r\n                    #define sampleReflection(s, c) textureCube(s, c)\r\n                #else\r\n                    #define sampleReflection(s, c) texture2D(s, c)\r\n                #endif\\n`,\r\n                `//${this.name}`\r\n            );\r\n\r\n            state._emitFunction(\r\n                \"sampleReflectionLod\",\r\n                `\r\n                #ifdef ${this._define3DName}\r\n                    #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n                #else\r\n                    #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n                #endif\\n`,\r\n                `//${this.name}`\r\n            );\r\n        }\r\n\r\n        const computeReflectionCoordsFunc = isWebGPU\r\n            ? `\r\n            fn computeReflectionCoordsPBR(worldPos: vec4f, worldNormal: vec3f) -> vec3f {\r\n                ${this.handleFragmentSideCodeReflectionCoords(state, \"worldNormal\", \"worldPos\", true, true)}\r\n                return ${this._reflectionVectorName};\r\n            }\\n`\r\n            : `\r\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\r\n                ${this.handleFragmentSideCodeReflectionCoords(state, \"worldNormal\", \"worldPos\", true, true)}\r\n                return ${this._reflectionVectorName};\r\n            }\\n`;\r\n\r\n        state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, `//${this.name}`);\r\n\r\n        this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\r\n\r\n        this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vReflectionFilteringInfoName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        this._iblIntensityName = state._getFreeVariableName(\"iblIntensity\");\r\n\r\n        state._emitUniformFromString(this._iblIntensityName, NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        code += `#ifdef REFLECTION\r\n            ${state._declareLocalVar(this._vReflectionInfosName, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(${(isWebGPU ? \"uniforms.\" : \"\") + this._iblIntensityName}, 0.);\r\n\r\n            ${isWebGPU ? \"var reflectionOut: reflectionOutParams\" : \"reflectionOutParams reflectionOut\"};\r\n\r\n            reflectionOut = reflectionBlock(\r\n                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : (isWebGPU ? \"input.\" : \"\") + \"v_\" + this.worldPosition.associatedVariableName}.xyz\r\n                , ${normalVarName}\r\n                , alphaG\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + this._vReflectionMicrosurfaceInfosName}\r\n                , ${this._vReflectionInfosName}\r\n                , ${this.reflectionColor}\r\n            #ifdef ANISOTROPIC\r\n                ,anisotropicOut\r\n            #endif\r\n            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})\r\n                ,NdotVUnclamped\r\n            #endif\r\n            #ifdef ${this._defineLinearSpecularReflection}\r\n                , roughness\r\n            #endif\r\n            #ifdef ${this._define3DName}\r\n                , ${this._cubeSamplerName}\r\n                ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : \"\"}\r\n            #else\r\n                , ${this._2DSamplerName}\r\n                ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : \"\"}\r\n            #endif\r\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\r\n                , ${isWebGPU ? \"input.\" : \"\"}${this._vEnvironmentIrradianceName}\r\n            #endif\r\n            #if (defined(USESPHERICALFROMREFLECTIONMAP) && (!defined(NORMAL) || !defined(USESPHERICALINVERTEX))) || (defined(USEIRRADIANCEMAP) && defined(REFLECTIONMAP_3D))\r\n                    , ${this._reflectionMatrixName}\r\n            #endif\r\n            #ifdef USEIRRADIANCEMAP\r\n                , irradianceSampler         // ** not handled **\r\n                ${isWebGPU ? `, irradianceSamplerSampler` : \"\"}\r\n                #ifdef USE_IRRADIANCE_DOMINANT_DIRECTION\r\n                , vReflectionDominantDirection\r\n                #endif\r\n            #endif\r\n            #ifndef LODBASEDMICROSFURACE\r\n                #ifdef ${this._define3DName}\r\n                    , ${this._cubeSamplerName}\r\n                    ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : \"\"}\r\n                    , ${this._cubeSamplerName}\r\n                    ${isWebGPU ? `, ${this._cubeSamplerName}Sampler` : \"\"}\r\n                #else\r\n                    , ${this._2DSamplerName}\r\n                    ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : \"\"}\r\n                    , ${this._2DSamplerName}                    \r\n                    ${isWebGPU ? `, ${this._2DSamplerName}Sampler` : \"\"}\r\n                #endif\r\n            #endif\r\n            #ifdef REALTIME_FILTERING\r\n                , ${this._vReflectionFilteringInfoName}\r\n                #ifdef IBL_CDF_FILTERING\r\n                    , icdfSampler         // ** not handled **\r\n                    ${isWebGPU ? `, icdfSamplerSampler` : \"\"}\r\n                #endif\r\n            #endif\r\n            , viewDirectionW\r\n            , diffuseRoughness\r\n            , surfaceAlbedo\r\n            );\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\r\n            this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\\n`;\r\n        codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\r\n        serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\r\n        serializationObject.gammaSpace = this.texture?.gammaSpace ?? true;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\r\n        this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\r\n        if (this.texture) {\r\n            this.texture.gammaSpace = serializationObject.gammaSpace;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionBlock\", ReflectionBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { PBRMetallicRoughnessBlock } from \"./pbrMetallicRoughnessBlock\";\r\nimport type { PerturbNormalBlock } from \"../Fragment/perturbNormalBlock\";\r\nimport { PBRClearCoatConfiguration } from \"../../../PBR/pbrClearCoatConfiguration\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the clear coat module of the PBR material\r\n */\r\nexport class ClearCoatBlock extends NodeMaterialBlock {\r\n    private _scene: Scene;\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * Create a new ClearCoatBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintThickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.worldNormal.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n\r\n        this.registerOutput(\r\n            \"clearcoat\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock, \"ClearCoatBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\r\n     */\r\n    @editableInPropertyPage(\"Remap F0 on interface change\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true })\r\n    public remapF0OnInterfaceChange: boolean = true;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"clearcoatOut\");\r\n        state._excludeVariableName(\"vClearCoatParams\");\r\n        state._excludeVariableName(\"vClearCoatTintParams\");\r\n        state._excludeVariableName(\"vClearCoatRefractionParams\");\r\n        state._excludeVariableName(\"vClearCoatTangentSpaceParams\");\r\n        state._excludeVariableName(\"vGeometricNormaClearCoatW\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ClearCoatBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the ior input component\r\n     */\r\n    public get indexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the bump texture input component\r\n     */\r\n    public get normalMapColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint color input component\r\n     */\r\n    public get tintColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint \"at distance\" input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint thickness input component\r\n     */\r\n    public get tintThickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the world tangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[10];\r\n    }\r\n\r\n    /**\r\n     * Gets the clear coat object output component\r\n     */\r\n    public get clearcoat(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"ClearCoat intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(\"CLEARCOAT\", true);\r\n        defines.setValue(\"CLEARCOAT_TEXTURE\", false, true);\r\n        defines.setValue(\"CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\r\n        defines.setValue(\"CLEARCOAT_TINT\", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);\r\n        defines.setValue(\"CLEARCOAT_BUMP\", this.normalMapColor.isConnected, true);\r\n        defines.setValue(\r\n            \"CLEARCOAT_DEFAULTIOR\",\r\n            this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock!.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true,\r\n            true\r\n        );\r\n        defines.setValue(\"CLEARCOAT_REMAP_F0\", this.remapF0OnInterfaceChange, true);\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        // Clear Coat Refraction params\r\n        const indexOfRefraction = this.indexOfRefraction.connectInputBlock?.value ?? PBRClearCoatConfiguration._DefaultIndexOfRefraction;\r\n\r\n        const a = 1 - indexOfRefraction;\r\n        const b = 1 + indexOfRefraction;\r\n        const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\r\n        const eta = 1 / indexOfRefraction;\r\n\r\n        effect.setFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\r\n\r\n        // Clear Coat tangent space params\r\n        const mainPBRBlock = this.clearcoat.hasEndpoints ? (this.clearcoat.endpoints[0].ownerBlock as PBRMetallicRoughnessBlock) : null;\r\n        const perturbedNormalBlock = mainPBRBlock?.perturbedNormal.isConnected ? (mainPBRBlock.perturbedNormal.connectedPoint!.ownerBlock as PerturbNormalBlock) : null;\r\n\r\n        if (this._scene._mirroredCameraPosition) {\r\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? 1.0 : -1.0, perturbedNormalBlock?.invertY ? 1.0 : -1.0);\r\n        } else {\r\n            effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? -1.0 : 1.0, perturbedNormalBlock?.invertY ? -1.0 : 1.0);\r\n        }\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState, worldPositionVarName: string, worldNormalVarName: string) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const worldTangent = this.worldTangent;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        if (!isWebGPU) {\r\n            state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n        }\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const tbn = this.TBN;\r\n        if (tbn.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n                ${isWebGPU ? \"var TBN\" : \"mat3 TBN\"} = ${tbn.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `${state._declareLocalVar(\"tbnNormal\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldNormalVarName}.xyz);\\n`;\r\n            code += `${state._declareLocalVar(\"tbnTangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\r\n            code += `${state._declareLocalVar(\"tbnBitangent\", NodeMaterialBlockConnectionPointTypes.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\r\n            code += `${isWebGPU ? \"var vTBN\" : \"mat3 vTBN\"} = ${isWebGPU ? \"mat3x3f\" : \"mat3\"}(tbnTangent, tbnBitangent, tbnNormal);\\n`;\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /** @internal */\r\n    public static _GetInitializationCode(state: NodeMaterialBuildState, ccBlock: Nullable<ClearCoatBlock>): string {\r\n        let code = \"\";\r\n\r\n        const intensity = ccBlock?.intensity.isConnected ? ccBlock.intensity.associatedVariableName : \"1.\";\r\n        const roughness = ccBlock?.roughness.isConnected ? ccBlock.roughness.associatedVariableName : \"0.\";\r\n\r\n        const tintColor = ccBlock?.tintColor.isConnected ? ccBlock.tintColor.associatedVariableName : `vec3${state.fSuffix}(1.)`;\r\n        const tintThickness = ccBlock?.tintThickness.isConnected ? ccBlock.tintThickness.associatedVariableName : \"1.\";\r\n\r\n        code += `\r\n            #ifdef CLEARCOAT\r\n                ${state._declareLocalVar(\"vClearCoatParams\", NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(${intensity}, ${roughness});\r\n                ${state._declareLocalVar(\"vClearCoatTintParams\", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${tintColor}, ${tintThickness});\r\n            #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @param worldPosVarName name of the variable holding the world position\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)\r\n     * @param worldNormalVarName name of the variable holding the world normal\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(\r\n        state: NodeMaterialBuildState,\r\n        ccBlock: Nullable<ClearCoatBlock>,\r\n        reflectionBlock: Nullable<ReflectionBlock>,\r\n        worldPosVarName: string,\r\n        generateTBNSpace: boolean,\r\n        vTBNAvailable: boolean,\r\n        worldNormalVarName: string\r\n    ): string {\r\n        let code = \"\";\r\n\r\n        const normalMapColor = ccBlock?.normalMapColor.isConnected ? ccBlock.normalMapColor.associatedVariableName : `vec3${state.fSuffix}(0.)`;\r\n        const uv = ccBlock?.uv.isConnected ? ccBlock.uv.associatedVariableName : `vec2${state.fSuffix}(0.)`;\r\n\r\n        const tintAtDistance = ccBlock?.tintAtDistance.isConnected ? ccBlock.tintAtDistance.associatedVariableName : \"1.\";\r\n        const tintTexture = `vec4${state.fSuffix}(0.)`;\r\n\r\n        if (ccBlock) {\r\n            state._emitUniformFromString(\"vClearCoatRefractionParams\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n            state._emitUniformFromString(\"vClearCoatTangentSpaceParams\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n            const normalShading = ccBlock.worldNormal;\r\n            code += `${state._declareLocalVar(\"vGeometricNormaClearCoatW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\n`;\r\n        } else {\r\n            code += `${state._declareLocalVar(\"vGeometricNormaClearCoatW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = geometricNormalW;\\n`;\r\n        }\r\n\r\n        if (generateTBNSpace && ccBlock) {\r\n            code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);\r\n            vTBNAvailable = ccBlock.worldTangent.isConnected;\r\n        }\r\n\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        code += `${isWebGPU ? \"var clearcoatOut: clearcoatOutParams\" : \"clearcoatOutParams clearcoatOut\"};\r\n\r\n        #ifdef CLEARCOAT\r\n            clearcoatOut = clearcoatBlock(\r\n                ${worldPosVarName}.xyz\r\n                , vGeometricNormaClearCoatW\r\n                , viewDirectionW\r\n                , vClearCoatParams\r\n                , specularEnvironmentR0\r\n            #ifdef CLEARCOAT_TEXTURE\r\n                , vec2${state.fSuffix}(0.)\r\n            #endif\r\n            #ifdef CLEARCOAT_TINT\r\n                , vClearCoatTintParams\r\n                , ${tintAtDistance}\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}vClearCoatRefractionParams\r\n                #ifdef CLEARCOAT_TINT_TEXTURE\r\n                    , ${tintTexture}\r\n                #endif\r\n            #endif\r\n            #ifdef CLEARCOAT_BUMP\r\n                , vec2${state.fSuffix}(0., 1.)\r\n                , vec4${state.fSuffix}(${normalMapColor}, 0.)\r\n                , ${uv}\r\n                #if defined(${vTBNAvailable ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                    , vTBN\r\n                #else\r\n                    , ${isWebGPU ? \"uniforms.\" : \"\"}vClearCoatTangentSpaceParams\r\n                #endif\r\n                #ifdef OBJECTSPACE_NORMALMAP\r\n                    , normalMatrix\r\n                #endif\r\n            #endif\r\n            #if defined(FORCENORMALFORWARD) && defined(NORMAL)\r\n                , faceNormal\r\n            #endif\r\n            #ifdef REFLECTION\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}${reflectionBlock?._vReflectionMicrosurfaceInfosName}\r\n                , ${reflectionBlock?._vReflectionInfosName}\r\n                , ${reflectionBlock?.reflectionColor}\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}vLightingIntensity\r\n                #ifdef ${reflectionBlock?._define3DName}\r\n                    , ${reflectionBlock?._cubeSamplerName}       \r\n                    ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                #else\r\n                    , ${reflectionBlock?._2DSamplerName}       \r\n                    ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                #endif\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${reflectionBlock?._define3DName}\r\n                        , ${reflectionBlock?._cubeSamplerName}       \r\n                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                        , ${reflectionBlock?._cubeSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                    #else\r\n                        , ${reflectionBlock?._2DSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                        , ${reflectionBlock?._2DSamplerName}\r\n                        ${isWebGPU ? `, ${reflectionBlock?._2DSamplerName}Sampler` : \"\"}                        \r\n                    #endif\r\n                #endif\r\n            #endif\r\n            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\r\n                , (${state._generateTernary(\"1.\", \"-1.\", isWebGPU ? \"fragmentInputs.frontFacing\" : \"gl_FrontFacing\")})\r\n            #endif\r\n            );\r\n        #else\r\n            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, NodeMaterialBlockConnectionPointTypes.Float);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.remapF0OnInterfaceChange = serializationObject.remapF0OnInterfaceChange ?? true;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ClearCoatBlock\", ClearCoatBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { PBRIridescenceConfiguration } from \"../../../../Materials/PBR/pbrIridescenceConfiguration\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the iridescence module of the PBR material\r\n */\r\nexport class IridescenceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new IridescenceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"iridescence\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"iridescence\", this, NodeMaterialConnectionPointDirection.Output, IridescenceBlock, \"IridescenceBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"iridescenceOut\");\r\n        state._excludeVariableName(\"vIridescenceParams\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"IridescenceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the indexOfRefraction input component\r\n     */\r\n    public get indexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the thickness input component\r\n     */\r\n    public get thickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the iridescence object output component\r\n     */\r\n    public get iridescence(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Iridescence intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n\r\n            const indexOfRefractionInput = new InputBlock(\"Iridescence ior\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            indexOfRefractionInput.value = 1.3;\r\n            indexOfRefractionInput.output.connectTo(this.indexOfRefraction);\r\n\r\n            const thicknessInput = new InputBlock(\"Iridescence thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            thicknessInput.value = 400;\r\n            thicknessInput.output.connectTo(this.thickness);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        defines.setValue(\"IRIDESCENCE\", true, true);\r\n        defines.setValue(\"IRIDESCENCE_TEXTURE\", false, true);\r\n        defines.setValue(\"IRIDESCENCE_THICKNESS_TEXTURE\", false, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param iridescenceBlock instance of a IridescenceBlock or null if the code must be generated without an active iridescence module\r\n     * @param state defines the build state\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(iridescenceBlock: Nullable<IridescenceBlock>, state: NodeMaterialBuildState): string {\r\n        let code = \"\";\r\n\r\n        const intensityName = iridescenceBlock?.intensity.isConnected ? iridescenceBlock.intensity.associatedVariableName : \"1.\";\r\n        const indexOfRefraction = iridescenceBlock?.indexOfRefraction.isConnected\r\n            ? iridescenceBlock.indexOfRefraction.associatedVariableName\r\n            : PBRIridescenceConfiguration._DefaultIndexOfRefraction;\r\n        const thickness = iridescenceBlock?.thickness.isConnected ? iridescenceBlock.thickness.associatedVariableName : PBRIridescenceConfiguration._DefaultMaximumThickness;\r\n\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        code += `${isWebGPU ? \"var iridescenceOut: iridescenceOutParams\" : \"iridescenceOutParams iridescenceOut\"};\r\n\r\n        #ifdef IRIDESCENCE\r\n            iridescenceOut = iridescenceBlock(\r\n                vec4(${intensityName}, ${indexOfRefraction}, 1., ${thickness})\r\n                , NdotV\r\n                , specularEnvironmentR0\r\n                #ifdef CLEARCOAT\r\n                    , NdotVUnclamped\r\n                    , vClearCoatParams\r\n                #endif                \r\n            );\r\n\r\n            ${isWebGPU ? \"let\" : \"float\"} iridescenceIntensity = iridescenceOut.iridescenceIntensity;\r\n            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.bindableBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.IridescenceBlock\", IridescenceBlock);\r\n", "import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _refractionMatrixName: string;\r\n    /** @internal */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionInfosName: string;\r\n    /** @internal */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @internal */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public useThicknessAsDepth: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vRefractionPosition\");\r\n        state._excludeVariableName(\"vRefractionSize\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the volume index of refraction input component\r\n     */\r\n    public get volumeIndexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.intensity.isConnected) {\r\n            const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\r\n        defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", (<any>refractionTexture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat4(\r\n            this._vRefractionMicrosurfaceInfosName,\r\n            refractionTexture.getSize().width,\r\n            refractionTexture.lodGenerationScale,\r\n            refractionTexture.lodGenerationOffset,\r\n            1 / indexOfRefraction\r\n        );\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Math.log2(width));\r\n\r\n        if ((<any>refractionTexture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>refractionTexture;\r\n            effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        const code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (refractionTexture) {\r\n            state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\r\n            state._emitCubeSampler(this._cubeSamplerName, undefined, true);\r\n            state._samplerDeclaration += `#else\\n`;\r\n            state._emit2DSampler(this._2DSamplerName, undefined, true);\r\n            state._samplerDeclaration += `#endif\\n`;\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, NodeMaterialBlockConnectionPointTypes.Matrix);\r\n\r\n        if (state.shaderLanguage !== ShaderLanguage.WGSL) {\r\n            state._emitFunction(\r\n                \"sampleRefraction\",\r\n                `\r\n                #ifdef ${this._define3DName}\r\n                    #define sampleRefraction(s, c) textureCube(s, c)\r\n                #else\r\n                    #define sampleRefraction(s, c) texture2D(s, c)\r\n                #endif\\n`,\r\n                `//${this.name}`\r\n            );\r\n\r\n            state._emitFunction(\r\n                \"sampleRefractionLod\",\r\n                `\r\n                #ifdef ${this._define3DName}\r\n                    #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n                #else\r\n                    #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n                #endif\\n`,\r\n                `//${this.name}`\r\n            );\r\n        }\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        state._emitUniformFromString(\"vRefractionPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state._emitUniformFromString(\"vRefractionSize\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\n`;\r\n        codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n        serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n        this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { ReflectionBlock } from \"./reflectionBlock\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RefractionBlock } from \"./refractionBlock\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { PBRSubSurfaceConfiguration } from \"core/Materials/PBR/pbrSubSurfaceConfiguration\";\r\n\r\n/**\r\n * Block used to implement the sub surface module of the PBR material\r\n */\r\nexport class SubSurfaceBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new SubSurfaceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"translucencyIntensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"translucencyDiffusionDist\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\r\n            \"refraction\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Input, RefractionBlock, \"RefractionBlock\")\r\n        );\r\n        this.registerInput(\"dispersion\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"subsurface\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"subsurface\", this, NodeMaterialConnectionPointDirection.Output, SubSurfaceBlock, \"SubSurfaceBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Set it to true if your rendering in 8.0+ is different from that in 7 when you use sub-surface properties (transmission, refraction, etc.)\r\n     */\r\n    @editableInPropertyPage(\"Apply albedo after sub-surface\", PropertyTypeForEdition.Boolean, \"ADVANCED\")\r\n    public applyAlbedoAfterSubSurface: boolean = PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"subSurfaceOut\");\r\n        state._excludeVariableName(\"vThicknessParam\");\r\n        state._excludeVariableName(\"vTintColor\");\r\n        state._excludeVariableName(\"vTranslucencyColor\");\r\n        state._excludeVariableName(\"vSubSurfaceIntensity\");\r\n        state._excludeVariableName(\"dispersion\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SubSurfaceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the thickness component\r\n     */\r\n    public get thickness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint color input component\r\n     */\r\n    public get tintColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the translucency intensity input component\r\n     */\r\n    public get translucencyIntensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the translucency diffusion distance input component\r\n     */\r\n    public get translucencyDiffusionDist(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object parameters\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the dispersion input component\r\n     */\r\n    public get dispersion(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the sub surface object output component\r\n     */\r\n    public get subsurface(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.thickness.isConnected) {\r\n            const thicknessInput = new InputBlock(\"SubSurface thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            thicknessInput.value = 0;\r\n            thicknessInput.output.connectTo(this.thickness);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        const translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;\r\n\r\n        defines.setValue(\"SUBSURFACE\", translucencyEnabled || this.refraction.isConnected, true);\r\n        defines.setValue(\"SS_TRANSLUCENCY\", translucencyEnabled, true);\r\n        defines.setValue(\"SS_THICKNESSANDMASK_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_REFRACTIONINTENSITY_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_TRANSLUCENCYINTENSITY_TEXTURE\", false, true);\r\n        defines.setValue(\"SS_USE_GLTF_TEXTURES\", false, true);\r\n        defines.setValue(\"SS_DISPERSION\", this.dispersion.isConnected, true);\r\n        defines.setValue(\"SS_APPLY_ALBEDO_AFTER_SUBSURFACE\", this.applyAlbedoAfterSubSurface, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module\r\n     * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\r\n     * @param worldPosVarName name of the variable holding the world position\r\n     * @returns the shader code\r\n     */\r\n    public static GetCode(state: NodeMaterialBuildState, ssBlock: Nullable<SubSurfaceBlock>, reflectionBlock: Nullable<ReflectionBlock>, worldPosVarName: string): string {\r\n        let code = \"\";\r\n\r\n        const thickness = ssBlock?.thickness.isConnected ? ssBlock.thickness.associatedVariableName : \"0.\";\r\n        const tintColor = ssBlock?.tintColor.isConnected ? ssBlock.tintColor.associatedVariableName : \"vec3(1.)\";\r\n        const translucencyIntensity = ssBlock?.translucencyIntensity.isConnected ? ssBlock?.translucencyIntensity.associatedVariableName : \"1.\";\r\n        const translucencyDiffusionDistance = ssBlock?.translucencyDiffusionDist.isConnected ? ssBlock?.translucencyDiffusionDist.associatedVariableName : \"vec3(1.)\";\r\n\r\n        const refractionBlock: Nullable<RefractionBlock> = (ssBlock?.refraction.isConnected ? ssBlock?.refraction.connectedPoint?.ownerBlock : null) as Nullable<RefractionBlock>;\r\n\r\n        const refractionTintAtDistance = refractionBlock?.tintAtDistance.isConnected ? refractionBlock.tintAtDistance.associatedVariableName : \"1.\";\r\n        const refractionIntensity = refractionBlock?.intensity.isConnected ? refractionBlock.intensity.associatedVariableName : \"1.\";\r\n        const refractionView = refractionBlock?.view.isConnected ? refractionBlock.view.associatedVariableName : \"\";\r\n\r\n        const dispersion = ssBlock?.dispersion.isConnected ? ssBlock?.dispersion.associatedVariableName : \"0.0\";\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        code += refractionBlock?.getCode(state) ?? \"\";\r\n\r\n        code += `${isWebGPU ? \"var subSurfaceOut: subSurfaceOutParams\" : \"subSurfaceOutParams subSurfaceOut\"};\r\n\r\n        #ifdef SUBSURFACE\r\n            ${state._declareLocalVar(\"vThicknessParam\", NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${state.fSuffix}(0., ${thickness});\r\n            ${state._declareLocalVar(\"vTintColor\", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}(${tintColor}, ${refractionTintAtDistance});\r\n            ${state._declareLocalVar(\"vSubSurfaceIntensity\", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3(${refractionIntensity}, ${translucencyIntensity}, 0.);\r\n            ${state._declareLocalVar(\"dispersion\", NodeMaterialBlockConnectionPointTypes.Float)} = ${dispersion};\r\n            subSurfaceOut = subSurfaceBlock(\r\n                vSubSurfaceIntensity\r\n                , vThicknessParam\r\n                , vTintColor\r\n                , normalW\r\n            #ifdef LEGACY_SPECULAR_ENERGY_CONSERVATION\r\n        `;\r\n\r\n        code += isWebGPU\r\n            ? `, vec3f(max(colorSpecularEnvironmentReflectance.r, max(colorSpecularEnvironmentReflectance.g, colorSpecularEnvironmentReflectance.b)))/n`\r\n            : `, vec3(max(colorSpecularEnvironmentReflectance.r, max(colorSpecularEnvironmentReflectance.g, colorSpecularEnvironmentReflectance.b)))/n`;\r\n\r\n        code += `#else\r\n                , baseSpecularEnvironmentReflectance\r\n            #endif\r\n            #ifdef SS_THICKNESSANDMASK_TEXTURE\r\n                , vec4${state.fSuffix}(0.)\r\n            #endif\r\n            #ifdef REFLECTION\r\n                #ifdef SS_TRANSLUCENCY\r\n                    , ${(isWebGPU ? \"uniforms.\" : \"\") + reflectionBlock?._reflectionMatrixName}\r\n                    #ifdef USESPHERICALFROMREFLECTIONMAP\r\n                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\r\n                            , reflectionOut.irradianceVector\r\n                        #endif\r\n                        #if defined(REALTIME_FILTERING)\r\n                            , ${reflectionBlock?._cubeSamplerName}\r\n                            ${isWebGPU ? `, ${reflectionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                            , ${reflectionBlock?._vReflectionFilteringInfoName}\r\n                        #endif\r\n                        #endif\r\n                    #ifdef USEIRRADIANCEMAP\r\n                        , irradianceSampler\r\n                        ${isWebGPU ? `, irradianceSamplerSampler` : \"\"}\r\n                    #endif\r\n                #endif\r\n            #endif\r\n            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\r\n                , surfaceAlbedo\r\n            #endif\r\n            #ifdef SS_REFRACTION\r\n                , ${worldPosVarName}.xyz\r\n                , viewDirectionW\r\n                , ${refractionView}\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + (refractionBlock?._vRefractionInfosName ?? \"\")}\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + (refractionBlock?._refractionMatrixName ?? \"\")}\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + (refractionBlock?._vRefractionMicrosurfaceInfosName ?? \"\")}\r\n                , ${isWebGPU ? \"uniforms.\" : \"\"}vLightingIntensity\r\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\r\n                    , alpha\r\n                #endif\r\n                #ifdef ${refractionBlock?._defineLODRefractionAlpha ?? \"IGNORE\"}\r\n                    , NdotVUnclamped\r\n                #endif\r\n                #ifdef ${refractionBlock?._defineLinearSpecularRefraction ?? \"IGNORE\"}\r\n                    , roughness\r\n                #endif\r\n                , alphaG\r\n                #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\r\n                    , ${refractionBlock?._cubeSamplerName ?? \"\"}\r\n                    ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                #else\r\n                    , ${refractionBlock?._2DSamplerName ?? \"\"}\r\n                    ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                #endif\r\n                #ifndef LODBASEDMICROSFURACE\r\n                    #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\r\n                        , ${refractionBlock?._cubeSamplerName ?? \"\"}                        \r\n                        ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                        , ${refractionBlock?._cubeSamplerName ?? \"\"}                        \r\n                        ${isWebGPU ? `, ${refractionBlock?._cubeSamplerName}Sampler` : \"\"}\r\n                    #else\r\n                        , ${refractionBlock?._2DSamplerName ?? \"\"}\r\n                        ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                        , ${refractionBlock?._2DSamplerName ?? \"\"}\r\n                        ${isWebGPU ? `, ${refractionBlock?._2DSamplerName}Sampler` : \"\"}\r\n                    #endif\r\n                #endif\r\n                #ifdef ANISOTROPIC\r\n                    , anisotropicOut\r\n                #endif\r\n                #ifdef REALTIME_FILTERING\r\n                    , ${refractionBlock?._vRefractionFilteringInfoName ?? \"\"}\r\n                #endif\r\n                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\r\n                    , vRefractionPosition\r\n                    , vRefractionSize\r\n                #endif\r\n                #ifdef SS_DISPERSION\r\n                    , dispersion\r\n                #endif\r\n            #endif\r\n            #ifdef SS_TRANSLUCENCY\r\n                , ${translucencyDiffusionDistance}\r\n                , vTintColor\r\n                #ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\r\n                    , vec4${state.fSuffix}(0.)\r\n                #endif\r\n            #endif                \r\n            );\r\n\r\n            #ifdef SS_REFRACTION\r\n                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;\r\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\r\n                    alpha = subSurfaceOut.alpha;\r\n                #endif\r\n            #endif\r\n        #else\r\n            subSurfaceOut.specularEnvironmentReflectance = colorSpecularEnvironmentReflectance;\r\n        #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SubSurfaceBlock\", SubSurfaceBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { PBRBaseMaterial } from \"../../../PBR/pbrBaseMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { SheenBlock } from \"./sheenBlock\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport { GetEnvironmentBRDFTexture } from \"../../../../Misc/brdfTextureTools\";\r\nimport { MaterialFlags } from \"../../../materialFlags\";\r\nimport { AnisotropyBlock } from \"./anisotropyBlock\";\r\nimport { ReflectionBlock } from \"./reflectionBlock\";\r\nimport { ClearCoatBlock } from \"./clearCoatBlock\";\r\nimport { IridescenceBlock } from \"./iridescenceBlock\";\r\nimport { SubSurfaceBlock } from \"./subSurfaceBlock\";\r\nimport type { RefractionBlock } from \"./refractionBlock\";\r\nimport type { PerturbNormalBlock } from \"../Fragment/perturbNormalBlock\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport { Color3 } from \"../../../../Maths/math.color\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport {\r\n    BindLight,\r\n    BindLights,\r\n    PrepareDefinesForLight,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMultiview,\r\n    PrepareUniformsAndSamplersForLight,\r\n} from \"../../../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nconst MapOutputToVariable: { [name: string]: [string, string] } = {\r\n    ambientClr: [\"finalAmbient\", \"\"],\r\n    diffuseDir: [\"finalDiffuse\", \"\"],\r\n    specularDir: [\"finalSpecularScaled\", \"!defined(UNLIT) && defined(SPECULARTERM)\"],\r\n    clearcoatDir: [\"finalClearCoatScaled\", \"!defined(UNLIT) && defined(CLEARCOAT)\"],\r\n    sheenDir: [\"finalSheenScaled\", \"!defined(UNLIT) && defined(SHEEN)\"],\r\n    diffuseInd: [\"finalIrradiance\", \"!defined(UNLIT) && defined(REFLECTION)\"],\r\n    specularInd: [\"finalRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION)\"],\r\n    clearcoatInd: [\"clearcoatOut.finalClearCoatRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)\"],\r\n    sheenInd: [\"sheenOut.finalSheenRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)\"],\r\n    refraction: [\"subSurfaceOut.finalRefraction\", \"!defined(UNLIT) && defined(SS_REFRACTION)\"],\r\n    lighting: [\"finalColor.rgb\", \"\"],\r\n    shadow: [\"aggShadow\", \"\"],\r\n    alpha: [\"alpha\", \"\"],\r\n};\r\n\r\n/**\r\n * Block used to implement the PBR metallic/roughness model\r\n * @see https://playground.babylonjs.com/#D8AK3Z#80\r\n */\r\nexport class PBRMetallicRoughnessBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    private static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as PBRMetallicRoughnessBlock;\r\n\r\n        if (that.worldPosition.isConnected || that.worldNormal.isConnected) {\r\n            that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\r\n            Logger.Error(\"The worldPosition and worldNormal inputs must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        that._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    private _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        this.getInputByName(\"worldNormal\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    private _lightId: number;\r\n    private _scene: Scene;\r\n    private _environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n    private _environmentBrdfSamplerName: string;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private _vNormalWName: string;\r\n    private _invertNormalName: string;\r\n    private _metallicReflectanceColor: Color3 = Color3.White();\r\n    private _metallicF0Factor = 1;\r\n    private _vMetallicReflectanceFactorsName: string;\r\n    private _baseDiffuseRoughnessName: string;\r\n\r\n    /**\r\n     * Create a new ReflectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"perturbedNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"baseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"metallic\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"ambientOcc\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"opacity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"ambientColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\r\n            \"reflection\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Input, ReflectionBlock, \"ReflectionBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"clearcoat\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Input, ClearCoatBlock, \"ClearCoatBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"sheen\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sheen\", this, NodeMaterialConnectionPointDirection.Input, SheenBlock, \"SheenBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"subsurface\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"subsurface\", this, NodeMaterialConnectionPointDirection.Input, SubSurfaceBlock, \"SubSurfaceBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Input, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"iridescence\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"iridescence\", this, NodeMaterialConnectionPointDirection.Input, IridescenceBlock, \"IridescenceBlock\")\r\n        );\r\n\r\n        this.registerOutput(\"ambientClr\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"diffuseDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"clearcoatDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"sheenDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"diffuseInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"clearcoatInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"sheenInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"lighting\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\r\n    @editableInPropertyPage(\"Direct lights\", PropertyTypeForEdition.Float, \"INTENSITY\", { min: 0, max: 1, notifiers: { update: true } })\r\n    public directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     */\r\n    @editableInPropertyPage(\"Environment lights\", PropertyTypeForEdition.Float, \"INTENSITY\", { min: 0, max: 1, notifiers: { update: true } })\r\n    public environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * This is a special control allowing the reduction of the specular highlights coming from the\r\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\r\n     */\r\n    @editableInPropertyPage(\"Specular highlights\", PropertyTypeForEdition.Float, \"INTENSITY\", { min: 0, max: 1, notifiers: { update: true } })\r\n    public specularIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     */\r\n    @editableInPropertyPage(\"Light falloff\", PropertyTypeForEdition.List, \"LIGHTING & COLORS\", {\r\n        notifiers: { update: true },\r\n        options: [\r\n            { label: \"Physical\", value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL },\r\n            { label: \"GLTF\", value: PBRBaseMaterial.LIGHTFALLOFF_GLTF },\r\n            { label: \"Standard\", value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD },\r\n        ],\r\n    })\r\n    public lightFalloff = 0;\r\n\r\n    /**\r\n     * Specifies that alpha test should be used\r\n     */\r\n    @editableInPropertyPage(\"Alpha Testing\", PropertyTypeForEdition.Boolean, \"OPACITY\")\r\n    public useAlphaTest: boolean = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @editableInPropertyPage(\"Alpha CutOff\", PropertyTypeForEdition.Float, \"OPACITY\", { min: 0, max: 1, notifiers: { update: true } })\r\n    public alphaTestCutoff: number = 0.5;\r\n\r\n    /**\r\n     * Specifies that alpha blending should be used\r\n     */\r\n    @editableInPropertyPage(\"Alpha blending\", PropertyTypeForEdition.Boolean, \"OPACITY\")\r\n    public useAlphaBlending: boolean = false;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @editableInPropertyPage(\"Radiance over alpha\", PropertyTypeForEdition.Boolean, \"RENDERING\", { notifiers: { update: true } })\r\n    public useRadianceOverAlpha: boolean = true;\r\n\r\n    /**\r\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @editableInPropertyPage(\"Specular over alpha\", PropertyTypeForEdition.Boolean, \"RENDERING\", { notifiers: { update: true } })\r\n    public useSpecularOverAlpha: boolean = true;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the bump values.\r\n     */\r\n    @editableInPropertyPage(\"Specular anti-aliasing\", PropertyTypeForEdition.Boolean, \"RENDERING\", { notifiers: { update: true } })\r\n    public enableSpecularAntiAliasing: boolean = false;\r\n\r\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\r\n    @editableInPropertyPage(\"Realtime filtering\", PropertyTypeForEdition.Boolean, \"RENDERING\", { notifiers: { update: true } })\r\n    public realTimeFiltering: boolean = false;\r\n\r\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\r\n    @editableInPropertyPage(\"Realtime filtering quality\", PropertyTypeForEdition.List, \"RENDERING\", {\r\n        notifiers: { update: true },\r\n        options: [\r\n            { label: \"Low\", value: Constants.TEXTURE_FILTERING_QUALITY_LOW },\r\n            { label: \"Medium\", value: Constants.TEXTURE_FILTERING_QUALITY_MEDIUM },\r\n            { label: \"High\", value: Constants.TEXTURE_FILTERING_QUALITY_HIGH },\r\n        ],\r\n    })\r\n    public realTimeFilteringQuality = Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n\r\n    /**\r\n     * Base Diffuse Model\r\n     */\r\n    @editableInPropertyPage(\"Diffuse Model\", PropertyTypeForEdition.List, \"RENDERING\", {\r\n        notifiers: { update: true },\r\n        options: [\r\n            { label: \"Lambert\", value: Constants.MATERIAL_DIFFUSE_MODEL_LAMBERT },\r\n            { label: \"Burley\", value: Constants.MATERIAL_DIFFUSE_MODEL_BURLEY },\r\n            { label: \"Oren-Nayar\", value: Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR },\r\n            { label: \"Legacy\", value: Constants.MATERIAL_DIFFUSE_MODEL_LEGACY },\r\n        ],\r\n    })\r\n    public baseDiffuseModel = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n\r\n    /**\r\n     * Defines if the material uses energy conservation.\r\n     */\r\n    @editableInPropertyPage(\"Energy Conservation\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useEnergyConservation: boolean = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\r\n    @editableInPropertyPage(\"Radiance occlusion\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useRadianceOcclusion: boolean = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\r\n    @editableInPropertyPage(\"Horizon occlusion\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useHorizonOcclusion: boolean = true;\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    @editableInPropertyPage(\"Unlit\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public unlit: boolean = false;\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     */\r\n    @editableInPropertyPage(\"Force normal forward\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public forceNormalForward: boolean = false;\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: PBRMetallicRoughnessBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    /**\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\r\n    @editableInPropertyPage(\"Debug mode\", PropertyTypeForEdition.List, \"DEBUG\", {\r\n        notifiers: { update: true },\r\n        options: [\r\n            { label: \"None\", value: 0 },\r\n            // Geometry\r\n            { label: \"Normalized position\", value: 1 },\r\n            { label: \"Normals\", value: 2 },\r\n            { label: \"Tangents\", value: 3 },\r\n            { label: \"Bitangents\", value: 4 },\r\n            { label: \"Bump Normals\", value: 5 },\r\n            //{ label: \"UV1\", value: 6 },\r\n            //{ label: \"UV2\", value: 7 },\r\n            { label: \"ClearCoat Normals\", value: 8 },\r\n            { label: \"ClearCoat Tangents\", value: 9 },\r\n            { label: \"ClearCoat Bitangents\", value: 10 },\r\n            { label: \"Anisotropic Normals\", value: 11 },\r\n            { label: \"Anisotropic Tangents\", value: 12 },\r\n            { label: \"Anisotropic Bitangents\", value: 13 },\r\n            // Maps\r\n            //{ label: \"Emissive Map\", value: 23 },\r\n            //{ label: \"Light Map\", value: 24 },\r\n            // Env\r\n            { label: \"Env Refraction\", value: 40 },\r\n            { label: \"Env Reflection\", value: 41 },\r\n            { label: \"Env Clear Coat\", value: 42 },\r\n            // Lighting\r\n            { label: \"Direct Diffuse\", value: 50 },\r\n            { label: \"Direct Specular\", value: 51 },\r\n            { label: \"Direct Clear Coat\", value: 52 },\r\n            { label: \"Direct Sheen\", value: 53 },\r\n            { label: \"Env Irradiance\", value: 54 },\r\n            // Lighting Params\r\n            { label: \"Surface Albedo\", value: 60 },\r\n            { label: \"Reflectance 0\", value: 61 },\r\n            { label: \"Metallic\", value: 62 },\r\n            { label: \"Metallic F0\", value: 71 },\r\n            { label: \"Roughness\", value: 63 },\r\n            { label: \"AlphaG\", value: 64 },\r\n            { label: \"NdotV\", value: 65 },\r\n            { label: \"ClearCoat Color\", value: 66 },\r\n            { label: \"ClearCoat Roughness\", value: 67 },\r\n            { label: \"ClearCoat NdotV\", value: 68 },\r\n            { label: \"Transmittance\", value: 69 },\r\n            { label: \"Refraction Transmittance\", value: 70 },\r\n            // Misc\r\n            { label: \"SEO\", value: 80 },\r\n            { label: \"EHO\", value: 81 },\r\n            { label: \"Energy Factor\", value: 82 },\r\n            { label: \"Specular Reflectance\", value: 83 },\r\n            { label: \"Clear Coat Reflectance\", value: 84 },\r\n            { label: \"Sheen Reflectance\", value: 85 },\r\n            { label: \"Luminance Over Alpha\", value: 86 },\r\n            { label: \"Alpha\", value: 87 },\r\n            { label: \"Albedo color\", value: 88 },\r\n            { label: \"Ambient occlusion color\", value: 89 },\r\n        ],\r\n    })\r\n    public debugMode = 0;\r\n\r\n    /**\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to 0\r\n     */\r\n    @editableInPropertyPage(\"Split position\", PropertyTypeForEdition.Float, \"DEBUG\", { min: -1, max: 1, notifiers: { update: true } })\r\n    public debugLimit = 0;\r\n\r\n    /**\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\r\n    @editableInPropertyPage(\"Output factor\", PropertyTypeForEdition.Float, \"DEBUG\", { min: 0, max: 5, notifiers: { update: true } })\r\n    public debugFactor = 1;\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vLightingIntensity\");\r\n\r\n        state._excludeVariableName(\"geometricNormalW\");\r\n        state._excludeVariableName(\"normalW\");\r\n        state._excludeVariableName(\"faceNormal\");\r\n\r\n        state._excludeVariableName(\"albedoOpacityOut\");\r\n        state._excludeVariableName(\"surfaceAlbedo\");\r\n        state._excludeVariableName(\"alpha\");\r\n\r\n        state._excludeVariableName(\"aoOut\");\r\n\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"reflectivityOut\");\r\n        state._excludeVariableName(\"microSurface\");\r\n        state._excludeVariableName(\"roughness\");\r\n        state._excludeVariableName(\"vReflectivityColor\");\r\n\r\n        state._excludeVariableName(\"NdotVUnclamped\");\r\n        state._excludeVariableName(\"NdotV\");\r\n        state._excludeVariableName(\"alphaG\");\r\n        state._excludeVariableName(\"AARoughnessFactors\");\r\n        state._excludeVariableName(\"environmentBrdf\");\r\n        state._excludeVariableName(\"ambientMonochrome\");\r\n        state._excludeVariableName(\"seo\");\r\n        state._excludeVariableName(\"eho\");\r\n\r\n        state._excludeVariableName(\"environmentRadiance\");\r\n        state._excludeVariableName(\"irradianceVector\");\r\n        state._excludeVariableName(\"environmentIrradiance\");\r\n\r\n        state._excludeVariableName(\"diffuseBase\");\r\n        state._excludeVariableName(\"specularBase\");\r\n        state._excludeVariableName(\"preInfo\");\r\n        state._excludeVariableName(\"info\");\r\n        state._excludeVariableName(\"shadow\");\r\n\r\n        state._excludeVariableName(\"finalDiffuse\");\r\n        state._excludeVariableName(\"finalAmbient\");\r\n        state._excludeVariableName(\"ambientOcclusionForDirectDiffuse\");\r\n\r\n        state._excludeVariableName(\"finalColor\");\r\n\r\n        state._excludeVariableName(\"vClipSpacePosition\");\r\n        state._excludeVariableName(\"vDebugMode\");\r\n        state._excludeVariableName(\"vViewDepth\");\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync(state.shaderLanguage);\r\n    }\r\n\r\n    private async _initShaderSourceAsync(shaderLanguage: ShaderLanguage) {\r\n        this._codeIsReady = false;\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([import(\"../../../../ShadersWGSL/pbr.vertex\"), import(\"../../../../ShadersWGSL/pbr.fragment\")]);\r\n        } else {\r\n            await Promise.all([import(\"../../../../Shaders/pbr.vertex\"), import(\"../../../../Shaders/pbr.fragment\")]);\r\n        }\r\n\r\n        this._codeIsReady = true;\r\n        this.onCodeIsReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"PBRMetallicRoughnessBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix parameter\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera position input component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the perturbed normal input component\r\n     */\r\n    public get perturbedNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the base color input component\r\n     */\r\n    public get baseColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the metallic input component\r\n     */\r\n    public get metallic(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the roughness input component\r\n     */\r\n    public get roughness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient occlusion input component\r\n     */\r\n    public get ambientOcc(): NodeMaterialConnectionPoint {\r\n        return this._inputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the opacity input component\r\n     */\r\n    public get opacity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the index of refraction input component\r\n     */\r\n    public get indexOfRefraction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[10];\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient color input component\r\n     */\r\n    public get ambientColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[11];\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection object parameters\r\n     */\r\n    public get reflection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[12];\r\n    }\r\n\r\n    /**\r\n     * Gets the clear coat object parameters\r\n     */\r\n    public get clearcoat(): NodeMaterialConnectionPoint {\r\n        return this._inputs[13];\r\n    }\r\n\r\n    /**\r\n     * Gets the sheen object parameters\r\n     */\r\n    public get sheen(): NodeMaterialConnectionPoint {\r\n        return this._inputs[14];\r\n    }\r\n\r\n    /**\r\n     * Gets the sub surface object parameters\r\n     */\r\n    public get subsurface(): NodeMaterialConnectionPoint {\r\n        return this._inputs[15];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object parameters\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._inputs[16];\r\n    }\r\n\r\n    /**\r\n     * Gets the iridescence object parameters\r\n     */\r\n    public get iridescence(): NodeMaterialConnectionPoint {\r\n        return this._inputs[17];\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient output component\r\n     */\r\n    public get ambientClr(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse output component\r\n     */\r\n    public get diffuseDir(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular output component\r\n     */\r\n    public get specularDir(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the clear coat output component\r\n     */\r\n    public get clearcoatDir(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the sheen output component\r\n     */\r\n    public get sheenDir(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the indirect diffuse output component\r\n     */\r\n    public get diffuseInd(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the indirect specular output component\r\n     */\r\n    public get specularInd(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the indirect clear coat output component\r\n     */\r\n    public get clearcoatInd(): NodeMaterialConnectionPoint {\r\n        return this._outputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the indirect sheen output component\r\n     */\r\n    public get sheenInd(): NodeMaterialConnectionPoint {\r\n        return this._outputs[8];\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[9];\r\n    }\r\n\r\n    /**\r\n     * Gets the global lighting output component\r\n     */\r\n    public get lighting(): NodeMaterialConnectionPoint {\r\n        return this._outputs[10];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow output component\r\n     */\r\n    public get shadow(): NodeMaterialConnectionPoint {\r\n        return this._outputs[11];\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha output component\r\n     */\r\n    public get alpha(): NodeMaterialConnectionPoint {\r\n        return this._outputs[12];\r\n    }\r\n\r\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n\r\n        if (!this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        // General\r\n        defines.setValue(\"PBR\", true);\r\n        defines.setValue(\"METALLICWORKFLOW\", true);\r\n        defines.setValue(\"DEBUGMODE\", this.debugMode, true);\r\n        defines.setValue(\"DEBUGMODE_FORCERETURN\", true);\r\n        defines.setValue(\"NORMALXYSCALE\", true);\r\n        defines.setValue(\"BUMP\", this.perturbedNormal.isConnected, true);\r\n        defines.setValue(\"LODBASEDMICROSFURACE\", this._scene.getEngine().getCaps().textureLOD);\r\n\r\n        // Albedo & Opacity\r\n        defines.setValue(\"ALBEDO\", false, true);\r\n        defines.setValue(\"OPACITY\", this.opacity.isConnected, true);\r\n\r\n        // Ambient occlusion\r\n        defines.setValue(\"AMBIENT\", true, true);\r\n        defines.setValue(\"AMBIENTINGRAYSCALE\", false, true);\r\n\r\n        // Reflectivity\r\n        defines.setValue(\"REFLECTIVITY\", false, true);\r\n        defines.setValue(\"AOSTOREINMETALMAPRED\", false, true);\r\n        defines.setValue(\"METALLNESSSTOREINMETALMAPBLUE\", false, true);\r\n        defines.setValue(\"ROUGHNESSSTOREINMETALMAPALPHA\", false, true);\r\n        defines.setValue(\"ROUGHNESSSTOREINMETALMAPGREEN\", false, true);\r\n\r\n        // Lighting & colors\r\n        if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\r\n            defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", false);\r\n            defines.setValue(\"USEGLTFLIGHTFALLOFF\", false);\r\n        } else if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\r\n            defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", false);\r\n            defines.setValue(\"USEGLTFLIGHTFALLOFF\", true);\r\n        } else {\r\n            defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", true);\r\n            defines.setValue(\"USEGLTFLIGHTFALLOFF\", false);\r\n        }\r\n\r\n        // Transparency\r\n        const alphaTestCutOffString = this.alphaTestCutoff.toString();\r\n\r\n        defines.setValue(\"ALPHABLEND\", this.useAlphaBlending, true);\r\n        defines.setValue(\"ALPHAFROMALBEDO\", false, true);\r\n        defines.setValue(\"ALPHATEST\", this.useAlphaTest, true);\r\n        defines.setValue(\"ALPHATESTVALUE\", alphaTestCutOffString.indexOf(\".\") < 0 ? alphaTestCutOffString + \".\" : alphaTestCutOffString, true);\r\n        defines.setValue(\"OPACITYRGB\", false, true);\r\n\r\n        // Rendering\r\n        defines.setValue(\"RADIANCEOVERALPHA\", this.useRadianceOverAlpha, true);\r\n        defines.setValue(\"SPECULAROVERALPHA\", this.useSpecularOverAlpha, true);\r\n        defines.setValue(\"SPECULARAA\", this._scene.getEngine().getCaps().standardDerivatives && this.enableSpecularAntiAliasing, true);\r\n        defines.setValue(\"REALTIME_FILTERING\", this.realTimeFiltering, true);\r\n\r\n        const scene = mesh.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (engine._features.needTypeSuffixInShaderConstants) {\r\n            defines.setValue(\"NUM_SAMPLES\", this.realTimeFilteringQuality + \"u\", true);\r\n        } else {\r\n            defines.setValue(\"NUM_SAMPLES\", \"\" + this.realTimeFilteringQuality, true);\r\n        }\r\n\r\n        defines.setValue(\"BASE_DIFFUSE_MODEL\", this.baseDiffuseModel, true);\r\n\r\n        // Advanced\r\n        defines.setValue(\"BRDF_V_HEIGHT_CORRELATED\", true);\r\n        defines.setValue(\"LEGACY_SPECULAR_ENERGY_CONSERVATION\", true);\r\n        defines.setValue(\"MS_BRDF_ENERGY_CONSERVATION\", this.useEnergyConservation, true);\r\n        defines.setValue(\"RADIANCEOCCLUSION\", this.useRadianceOcclusion, true);\r\n        defines.setValue(\"HORIZONOCCLUSION\", this.useHorizonOcclusion, true);\r\n        defines.setValue(\"UNLIT\", this.unlit, true);\r\n        defines.setValue(\"FORCENORMALFORWARD\", this.forceNormalForward, true);\r\n\r\n        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n            defines.setValue(\"ENVIRONMENTBRDF\", true);\r\n            defines.setValue(\"ENVIRONMENTBRDF_RGBD\", this._environmentBRDFTexture.isRGBD, true);\r\n        } else {\r\n            defines.setValue(\"ENVIRONMENTBRDF\", false);\r\n            defines.setValue(\"ENVIRONMENTBRDF_RGBD\", false);\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        if (!defines._areLightsDirty) {\r\n            return;\r\n        }\r\n\r\n        if (!this.light) {\r\n            // Lights\r\n            PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\r\n            defines._needNormals = true;\r\n\r\n            // Multiview\r\n            PrepareDefinesForMultiview(scene, defines);\r\n        } else {\r\n            const state = {\r\n                needNormals: false,\r\n                needRebuild: false,\r\n                lightmapMode: false,\r\n                shadowEnabled: false,\r\n                specularEnabled: false,\r\n            };\r\n\r\n            PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\r\n\r\n            if (state.needRebuild) {\r\n                defines.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    public override updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\r\n            PrepareUniformsAndSamplersForLight(\r\n                lightIndex,\r\n                state.uniforms,\r\n                state.samplers,\r\n                defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n                uniformBuffers,\r\n                onlyUpdateBuffersList,\r\n                defines[\"IESLIGHTTEXTURE\" + lightIndex],\r\n                defines[\"CLUSTLIGHT\" + lightIndex]\r\n            );\r\n        }\r\n    }\r\n\r\n    public override isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (this._environmentBRDFTexture && !this._environmentBRDFTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\r\n            if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            BindLight(this.light, this._lightId, scene, effect, true);\r\n        }\r\n\r\n        effect.setTexture(this._environmentBrdfSamplerName, this._environmentBRDFTexture);\r\n\r\n        effect.setFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\r\n\r\n        const ambientScene = this._scene.ambientColor;\r\n\r\n        if (ambientScene) {\r\n            effect.setColor3(\"ambientFromScene\", ambientScene);\r\n        }\r\n\r\n        const invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);\r\n\r\n        effect.setFloat(this._invertNormalName, invertNormal ? -1 : 1);\r\n\r\n        effect.setFloat4(\"vLightingIntensity\", this.directIntensity, 1, this.environmentIntensity * this._scene.environmentIntensity, this.specularIntensity);\r\n\r\n        // reflectivity bindings\r\n        const metallicF90 = this._metallicF0Factor;\r\n\r\n        effect.setColor4(this._vMetallicReflectanceFactorsName, this._metallicReflectanceColor, metallicF90);\r\n\r\n        if (nodeMaterial.imageProcessingConfiguration) {\r\n            nodeMaterial.imageProcessingConfiguration.bind(effect);\r\n        }\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const worldPos = this.worldPosition;\r\n        const worldNormal = this.worldNormal;\r\n        const comments = `//${this.name}`;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        // Declaration\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n            this._lightId = 0;\r\n\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        } else {\r\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\r\n            state.counters[\"lightCounter\"] = this._lightId;\r\n\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Inject code in vertex\r\n        const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {\r\n            state.compilationString += (isWebGPU ? \"vertexOutputs.\" : \"\") + `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\r\n        }\r\n\r\n        const worldNormalVaryingName = \"v_\" + worldNormal.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldNormalVaryingName, NodeMaterialBlockConnectionPointTypes.Vector4)) {\r\n            state.compilationString += (isWebGPU ? \"vertexOutputs.\" : \"\") + `${worldNormalVaryingName} = ${worldNormal.associatedVariableName};\\n`;\r\n        }\r\n\r\n        const reflectionBlock = this.reflection.isConnected ? (this.reflection.connectedPoint?.ownerBlock as ReflectionBlock) : null;\r\n\r\n        if (reflectionBlock) {\r\n            reflectionBlock.viewConnectionPoint = this.view;\r\n        }\r\n\r\n        state.compilationString += reflectionBlock?.handleVertexSide(state) ?? \"\";\r\n\r\n        if (state._emitVaryingFromString(\"vClipSpacePosition\", NodeMaterialBlockConnectionPointTypes.Vector4, \"defined(IGNORE) || DEBUGMODE > 0\")) {\r\n            state._injectAtEnd += `#if DEBUGMODE > 0\\n`;\r\n            state._injectAtEnd += (isWebGPU ? \"vertexOutputs.\" : \"\") + `vClipSpacePosition = ${isWebGPU ? \"vertexOutputs.position\" : \"gl_Position\"};\\n`;\r\n            state._injectAtEnd += `#endif\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName },\r\n                ],\r\n            });\r\n        } else {\r\n            state.compilationString += `${state._declareLocalVar(\"worldPos\", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${worldPos.associatedVariableName};\\n`;\r\n            if (this.view.isConnected) {\r\n                state.compilationString += `${state._declareLocalVar(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix)} = ${this.view.associatedVariableName};\\n`;\r\n                state._emitVaryingFromString(\"vViewDepth\", NodeMaterialBlockConnectionPointTypes.Float);\r\n                state.compilationString +=\r\n                    (state.shaderLanguage === ShaderLanguage.WGSL ? \"vertexOutputs.\" : \"\") +\r\n                    `vViewDepth = (${this.view.associatedVariableName} * ${worldPos.associatedVariableName}).z;\\n`;\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n    }\r\n\r\n    private _getAlbedoOpacityCode(state: NodeMaterialBuildState): string {\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        let code = isWebGPU ? \"var albedoOpacityOut: albedoOpacityOutParams;\\n\" : `albedoOpacityOutParams albedoOpacityOut;\\n`;\r\n\r\n        const albedoColor = this.baseColor.isConnected ? this.baseColor.associatedVariableName : \"vec3(1.)\";\r\n        const opacity = this.opacity.isConnected ? this.opacity.associatedVariableName : \"1.\";\r\n\r\n        code += `albedoOpacityOut = albedoOpacityBlock(\r\n                vec4${state.fSuffix}(${albedoColor}, 1.)\r\n            #ifdef ALBEDO\r\n                ,vec4${state.fSuffix}(1.)\r\n                ,vec2${state.fSuffix}(1., 1.)\r\n            #endif\r\n                ,1. /* Base Weight */\r\n            #ifdef OPACITY\r\n                ,vec4${state.fSuffix}(${opacity})\r\n                ,vec2${state.fSuffix}(1., 1.)\r\n            #endif\r\n            );\r\n\r\n            ${state._declareLocalVar(\"surfaceAlbedo\", NodeMaterialBlockConnectionPointTypes.Vector3)} = albedoOpacityOut.surfaceAlbedo;\r\n            ${state._declareLocalVar(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float)} = albedoOpacityOut.alpha;\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    private _getAmbientOcclusionCode(state: NodeMaterialBuildState): string {\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        let code = isWebGPU ? \"var aoOut: ambientOcclusionOutParams;\\n\" : `ambientOcclusionOutParams aoOut;\\n`;\r\n\r\n        const ao = this.ambientOcc.isConnected ? this.ambientOcc.associatedVariableName : \"1.\";\r\n\r\n        code += `aoOut = ambientOcclusionBlock(\r\n            #ifdef AMBIENT\r\n                vec3${state.fSuffix}(${ao}),\r\n                vec4${state.fSuffix}(0., 1.0, 1.0, 0.)\r\n            #endif\r\n            );\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    private _getReflectivityCode(state: NodeMaterialBuildState): string {\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n        let code = isWebGPU ? \"var reflectivityOut: reflectivityOutParams;\\n\" : `reflectivityOutParams reflectivityOut;\\n`;\r\n        const aoIntensity = \"1.\";\r\n\r\n        this._vMetallicReflectanceFactorsName = state._getFreeVariableName(\"vMetallicReflectanceFactors\");\r\n        state._emitUniformFromString(this._vMetallicReflectanceFactorsName, NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._baseDiffuseRoughnessName = state._getFreeVariableName(\"baseDiffuseRoughness\");\r\n        state._emitUniformFromString(this._baseDiffuseRoughnessName, NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\r\n        const ior = this.indexOfRefraction.connectInputBlock?.value ?? 1.5;\r\n        // Based of the schlick fresnel approximation model\r\n        // for dielectrics.\r\n        const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\r\n\r\n        code += `${state._declareLocalVar(\"baseColor\", NodeMaterialBlockConnectionPointTypes.Vector3)} = surfaceAlbedo;\r\n            ${isWebGPU ? \"let\" : `vec4${state.fSuffix}`} vReflectivityColor = vec4${state.fSuffix}(${this.metallic.associatedVariableName}, ${this.roughness.associatedVariableName}, ${this.indexOfRefraction.associatedVariableName || \"1.5\"}, ${f0});\r\n            reflectivityOut = reflectivityBlock(\r\n                vReflectivityColor\r\n            #ifdef METALLICWORKFLOW\r\n                , surfaceAlbedo\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + this._vMetallicReflectanceFactorsName}\r\n            #endif\r\n                , ${(isWebGPU ? \"uniforms.\" : \"\") + this._baseDiffuseRoughnessName}\r\n            #ifdef BASE_DIFFUSE_ROUGHNESS\r\n                , 0.\r\n                , vec2${state.fSuffix}(0., 0.)\r\n            #endif\r\n            #ifdef REFLECTIVITY\r\n                , vec3${state.fSuffix}(0., 0., ${aoIntensity})\r\n                , vec4${state.fSuffix}(1.)\r\n            #endif\r\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)\r\n                , aoOut.ambientOcclusionColor\r\n            #endif\r\n            #ifdef MICROSURFACEMAP\r\n                , microSurfaceTexel <== not handled!\r\n            #endif\r\n            );\r\n\r\n            ${state._declareLocalVar(\"microSurface\", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.microSurface;\r\n            ${state._declareLocalVar(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.roughness;\r\n            ${state._declareLocalVar(\"diffuseRoughness\", NodeMaterialBlockConnectionPointTypes.Float)} = reflectivityOut.diffuseRoughness;\r\n\r\n            #ifdef METALLICWORKFLOW\r\n                surfaceAlbedo = reflectivityOut.surfaceAlbedo;\r\n            #endif\r\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\r\n                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;\r\n            #endif\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        this._scene = state.sharedData.scene;\r\n        const isWebGPU = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        if (!this._environmentBRDFTexture) {\r\n            this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this._scene);\r\n        }\r\n\r\n        const reflectionBlock = this.reflection.isConnected ? (this.reflection.connectedPoint?.ownerBlock as ReflectionBlock) : null;\r\n\r\n        if (reflectionBlock) {\r\n            // Need those variables to be setup when calling _injectVertexCode\r\n            reflectionBlock.worldPositionConnectionPoint = this.worldPosition;\r\n            reflectionBlock.cameraPositionConnectionPoint = this.cameraPosition;\r\n            reflectionBlock.worldNormalConnectionPoint = this.worldNormal;\r\n            reflectionBlock.viewConnectionPoint = this.view;\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n\r\n            return this;\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.forcedBindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.blockingBlocks.push(this);\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        }\r\n\r\n        const comments = `//${this.name}`;\r\n        const normalShading = this.perturbedNormal;\r\n\r\n        let worldPosVarName = this.worldPosition.associatedVariableName;\r\n        let worldPosVarName4 = this.worldPosition.associatedVariableName;\r\n        let worldNormalVarName = this.worldNormal.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode) {\r\n            worldPosVarName = state._getFreeVariableName(\"globalWorldPos\");\r\n            state._emitFunction(\"pbr_globalworldpos\", `${state._declareLocalVar(worldPosVarName, NodeMaterialBlockConnectionPointTypes.Vector3, false, true)};\\n`, comments);\r\n            state.compilationString += `${worldPosVarName} = ${this.worldPosition.associatedVariableName}.xyz;\\n`;\r\n\r\n            worldPosVarName4 = state._getFreeVariableName(\"globalWorldPos4\");\r\n            state._emitFunction(\"pbr_globalworldpos4\", `${state._declareLocalVar(worldPosVarName4, NodeMaterialBlockConnectionPointTypes.Vector4, false, true)};\\n`, comments);\r\n            state.compilationString += `${worldPosVarName4} = ${this.worldPosition.associatedVariableName};\\n`;\r\n\r\n            worldNormalVarName = state._getFreeVariableName(\"globalWorldNormal\");\r\n            state._emitFunction(\"pbr_globalworldnorm\", `${state._declareLocalVar(worldNormalVarName, NodeMaterialBlockConnectionPointTypes.Vector4, false, true)};\\n`, comments);\r\n            state.compilationString += `${worldNormalVarName} = ${this.worldNormal.associatedVariableName};\\n`;\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: `worldPos,${this.worldPosition.associatedVariableName}`,\r\n            });\r\n\r\n            state.compilationString += `#if DEBUGMODE > 0\\n`;\r\n            state.compilationString += `${state._declareLocalVar(\"vClipSpacePosition\", NodeMaterialBlockConnectionPointTypes.Vector4)} = vec4${state.fSuffix}((vec2${state.fSuffix}(${isWebGPU ? \"fragmentInputs.position\" : \"gl_FragCoord.xy\"}) / vec2${state.fSuffix}(1.0)) * 2.0 - 1.0, 0.0, 1.0);\\n`;\r\n            state.compilationString += `#endif\\n`;\r\n        } else {\r\n            worldPosVarName = (isWebGPU ? \"input.\" : \"\") + \"v_\" + worldPosVarName;\r\n            worldNormalVarName = (isWebGPU ? \"input.\" : \"\") + \"v_\" + worldNormalVarName;\r\n        }\r\n\r\n        this._environmentBrdfSamplerName = state._getFreeVariableName(\"environmentBrdfSampler\");\r\n\r\n        state._emit2DSampler(this._environmentBrdfSamplerName);\r\n\r\n        state.sharedData.hints.needAlphaBlending = state.sharedData.hints.needAlphaBlending || this.useAlphaBlending;\r\n        state.sharedData.hints.needAlphaTesting = state.sharedData.hints.needAlphaTesting || this.useAlphaTest;\r\n\r\n        state._emitExtension(\"lod\", \"#extension GL_EXT_shader_texture_lod : enable\", \"defined(LODBASEDMICROSFURACE)\");\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        state._emitUniformFromString(\"vDebugMode\", NodeMaterialBlockConnectionPointTypes.Vector2, \"defined(IGNORE) || DEBUGMODE > 0\");\r\n        state._emitUniformFromString(\"ambientFromScene\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        // Image processing uniforms\r\n        state.uniforms.push(\"exposureLinear\");\r\n        state.uniforms.push(\"contrast\");\r\n        state.uniforms.push(\"vInverseScreenSize\");\r\n        state.uniforms.push(\"vignetteSettings1\");\r\n        state.uniforms.push(\"vignetteSettings2\");\r\n        state.uniforms.push(\"vCameraColorCurveNegative\");\r\n        state.uniforms.push(\"vCameraColorCurveNeutral\");\r\n        state.uniforms.push(\"vCameraColorCurvePositive\");\r\n        state.uniforms.push(\"txColorTransform\");\r\n        state.uniforms.push(\"colorTransformSettings\");\r\n        state.uniforms.push(\"ditherIntensity\");\r\n\r\n        //\r\n        // Includes\r\n        //\r\n        if (!this.light) {\r\n            if (this.generateOnlyFragmentCode && this.view.isConnected) {\r\n                state.compilationString += `${state._declareLocalVar(\"vViewDepth\", NodeMaterialBlockConnectionPointTypes.Float)} = (${this.view.associatedVariableName} * ${worldPosVarName4}).z;\\n`;\r\n            }\r\n\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined,\r\n            });\r\n        } else {\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"importanceSampling\", comments);\r\n        state._emitFunctionFromInclude(\"pbrHelperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"pbrDirectLightingSetupFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"pbrDirectLightingFalloffFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"pbrBRDFFunctions\", comments, {\r\n            replaceStrings: [{ search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" }],\r\n        });\r\n        state._emitFunctionFromInclude(\"hdrFilteringFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"pbrDirectLightingFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"pbrIBLFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockAlbedoOpacity\", comments);\r\n        state._emitFunctionFromInclude(\"pbrBlockReflectivity\", comments);\r\n        state._emitFunctionFromInclude(\"pbrBlockAmbientOcclusion\", comments);\r\n        state._emitFunctionFromInclude(\"pbrBlockAlphaFresnel\", comments);\r\n        state._emitFunctionFromInclude(\"pbrBlockAnisotropic\", comments);\r\n\r\n        if (!isWebGPU) {\r\n            // In WebGPU, those functions are part of pbrDirectLightingFunctions\r\n            state._emitFunctionFromInclude(\"pbrClusteredLightingFunctions\", comments);\r\n        }\r\n\r\n        //\r\n        // code\r\n        //\r\n\r\n        state._emitUniformFromString(\"vLightingIntensity\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        if (reflectionBlock?.generateOnlyFragmentCode) {\r\n            state.compilationString += reflectionBlock.handleVertexSide(state);\r\n        }\r\n\r\n        // _____________________________ Geometry Information ____________________________\r\n        this._vNormalWName = state._getFreeVariableName(\"vNormalW\");\r\n\r\n        state.compilationString += `${state._declareLocalVar(this._vNormalWName, NodeMaterialBlockConnectionPointTypes.Vector4)} = normalize(${worldNormalVarName});\\n`;\r\n\r\n        if (state._registerTempVariable(\"viewDirectionW\")) {\r\n            state.compilationString += `${state._declareLocalVar(\"viewDirectionW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVarName}.xyz);\\n`;\r\n        }\r\n\r\n        state.compilationString += `${state._declareLocalVar(\"geometricNormalW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._vNormalWName}.xyz;\\n`;\r\n\r\n        state.compilationString += `${state._declareLocalVar(\"normalW\", NodeMaterialBlockConnectionPointTypes.Vector3)} = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\n`;\r\n\r\n        this._invertNormalName = state._getFreeVariableName(\"invertNormal\");\r\n\r\n        state._emitUniformFromString(this._invertNormalName, NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockNormalFinal\", comments, {\r\n            replaceStrings: [\r\n                { search: /vPositionW/g, replace: worldPosVarName + \".xyz\" },\r\n                { search: /vEyePosition.w/g, replace: this._invertNormalName },\r\n            ],\r\n        });\r\n\r\n        // _____________________________ Albedo & Opacity ______________________________\r\n        state.compilationString += this._getAlbedoOpacityCode(state);\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"depthPrePass\", comments);\r\n\r\n        // _____________________________ AO  _______________________________\r\n        state.compilationString += this._getAmbientOcclusionCode(state);\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockLightmapInit\", comments);\r\n\r\n        // _____________________________ UNLIT  _______________________________\r\n        state.compilationString += `#ifdef UNLIT\r\n                ${state._declareLocalVar(\"diffuseBase\", NodeMaterialBlockConnectionPointTypes.Vector3)} = vec3${state.fSuffix}(1., 1., 1.);\r\n            #else\\n`;\r\n\r\n        // _____________________________ Reflectivity _______________________________\r\n        state.compilationString += this._getReflectivityCode(state);\r\n\r\n        // _____________________________ Geometry info _________________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockGeometryInfo\", comments, {\r\n            replaceStrings: [\r\n                { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" },\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n            ],\r\n        });\r\n\r\n        // _____________________________ Anisotropy _______________________________________\r\n        const anisotropyBlock = this.anisotropy.isConnected ? (this.anisotropy.connectedPoint?.ownerBlock as AnisotropyBlock) : null;\r\n\r\n        if (anisotropyBlock) {\r\n            anisotropyBlock.worldPositionConnectionPoint = this.worldPosition;\r\n            anisotropyBlock.worldNormalConnectionPoint = this.worldNormal;\r\n\r\n            state.compilationString += anisotropyBlock.getCode(state, !this.perturbedNormal.isConnected);\r\n        }\r\n\r\n        // _____________________________ Reflection _______________________________________\r\n        if (reflectionBlock && reflectionBlock.hasTexture) {\r\n            state.compilationString += reflectionBlock.getCode(state, anisotropyBlock ? \"anisotropicOut.anisotropicNormal\" : \"normalW\");\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockReflection\", comments, {\r\n            replaceStrings: [\r\n                { search: /computeReflectionCoords/g, replace: \"computeReflectionCoordsPBR\" },\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n                { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\" },\r\n                { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\" },\r\n                { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" },\r\n                { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\" },\r\n                { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\" },\r\n                { search: /vReflectionFilteringInfo/g, replace: reflectionBlock?._vReflectionFilteringInfoName ?? \"vReflectionFilteringInfo\" },\r\n            ],\r\n        });\r\n\r\n        // ___________________ Compute Reflectance aka R0 F0 info _________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockReflectance0\", comments, {\r\n            replaceStrings: [{ search: /metallicReflectanceFactors/g, replace: (isWebGPU ? \"uniforms.\" : \"\") + this._vMetallicReflectanceFactorsName }],\r\n        });\r\n        // ________________________________ Sheen ______________________________\r\n        const sheenBlock = this.sheen.isConnected ? (this.sheen.connectedPoint?.ownerBlock as SheenBlock) : null;\r\n\r\n        if (sheenBlock) {\r\n            state.compilationString += sheenBlock.getCode(reflectionBlock, state);\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockSheen\", comments, {\r\n            replaceStrings: [\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n                { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" },\r\n                { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\" },\r\n                { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\" },\r\n            ],\r\n        });\r\n\r\n        // ____________________ Clear Coat Initialization Code _____________________\r\n        const clearcoatBlock = this.clearcoat.isConnected ? (this.clearcoat.connectedPoint?.ownerBlock as ClearCoatBlock) : null;\r\n\r\n        state.compilationString += ClearCoatBlock._GetInitializationCode(state, clearcoatBlock);\r\n\r\n        // _____________________________ Iridescence _______________________________\r\n        const iridescenceBlock = this.iridescence.isConnected ? (this.iridescence.connectedPoint?.ownerBlock as IridescenceBlock) : null;\r\n        state.compilationString += IridescenceBlock.GetCode(iridescenceBlock, state);\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockIridescence\", comments, {\r\n            replaceStrings: [],\r\n        });\r\n\r\n        // _____________________________ Clear Coat ____________________________\r\n        const generateTBNSpace = !this.perturbedNormal.isConnected && !this.anisotropy.isConnected;\r\n        const isTangentConnectedToPerturbNormal =\r\n            this.perturbedNormal.isConnected && (this.perturbedNormal.connectedPoint?.ownerBlock as PerturbNormalBlock).worldTangent?.isConnected;\r\n        const isTangentConnectedToAnisotropy = this.anisotropy.isConnected && (this.anisotropy.connectedPoint?.ownerBlock as AnisotropyBlock).worldTangent.isConnected;\r\n        let vTBNAvailable = isTangentConnectedToPerturbNormal || (!this.perturbedNormal.isConnected && isTangentConnectedToAnisotropy);\r\n\r\n        state.compilationString += ClearCoatBlock.GetCode(state, clearcoatBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName);\r\n\r\n        if (generateTBNSpace) {\r\n            vTBNAvailable = clearcoatBlock?.worldTangent.isConnected ?? false;\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockClearcoat\", comments, {\r\n            replaceStrings: [\r\n                { search: /computeReflectionCoords/g, replace: \"computeReflectionCoordsPBR\" },\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n                { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\" },\r\n                { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\" },\r\n                { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" },\r\n                { search: /LODINREFLECTIONALPHA/g, replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\" },\r\n                { search: /LINEARSPECULARREFLECTION/g, replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\" },\r\n                { search: /defined\\(TANGENT\\)/g, replace: vTBNAvailable ? \"defined(TANGENT)\" : \"defined(IGNORE)\" },\r\n            ],\r\n        });\r\n\r\n        // _________________________ Specular Environment Reflectance __________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockReflectance\", comments, {\r\n            replaceStrings: [\r\n                { search: /REFLECTIONMAP_SKYBOX/g, replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\" },\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n                { search: /uniforms\\.vReflectivityColor/g, replace: \"vReflectivityColor\" },\r\n            ],\r\n        });\r\n\r\n        // ___________________________________ SubSurface ______________________________________\r\n        const subsurfaceBlock = this.subsurface.isConnected ? (this.subsurface.connectedPoint?.ownerBlock as SubSurfaceBlock) : null;\r\n        const refractionBlock = this.subsurface.isConnected\r\n            ? ((this.subsurface.connectedPoint?.ownerBlock as SubSurfaceBlock).refraction.connectedPoint?.ownerBlock as RefractionBlock)\r\n            : null;\r\n\r\n        if (refractionBlock) {\r\n            refractionBlock.viewConnectionPoint = this.view;\r\n            refractionBlock.indexOfRefractionConnectionPoint = this.indexOfRefraction;\r\n        }\r\n\r\n        state.compilationString += SubSurfaceBlock.GetCode(state, subsurfaceBlock, reflectionBlock, worldPosVarName);\r\n\r\n        state._emitFunctionFromInclude(\"pbrBlockSubSurface\", comments, {\r\n            replaceStrings: [\r\n                { search: /REFLECTIONMAP_3D/g, replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\" },\r\n                { search: /REFLECTIONMAP_OPPOSITEZ/g, replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\" },\r\n                { search: /REFLECTIONMAP_PROJECTION/g, replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\" },\r\n                { search: /SS_REFRACTIONMAP_3D/g, replace: refractionBlock?._define3DName ?? \"SS_REFRACTIONMAP_3D\" },\r\n                { search: /SS_LODINREFRACTIONALPHA/g, replace: refractionBlock?._defineLODRefractionAlpha ?? \"SS_LODINREFRACTIONALPHA\" },\r\n                { search: /SS_LINEARSPECULARREFRACTION/g, replace: refractionBlock?._defineLinearSpecularRefraction ?? \"SS_LINEARSPECULARREFRACTION\" },\r\n                { search: /SS_REFRACTIONMAP_OPPOSITEZ/g, replace: refractionBlock?._defineOppositeZ ?? \"SS_REFRACTIONMAP_OPPOSITEZ\" },\r\n            ],\r\n        });\r\n\r\n        // _____________________________ Direct Lighting Info __________________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockDirectLighting\", comments);\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: new RegExp(`${isWebGPU ? \"fragmentInputs.\" : \"\"}vPositionW`, \"g\"), replace: worldPosVarName + \".xyz\" },\r\n                    { search: /uniforms\\.vReflectivityColor/g, replace: \"vReflectivityColor\" },\r\n                ],\r\n            });\r\n        } else {\r\n            let substitutionVars = `vPositionW,${worldPosVarName}.xyz`;\r\n\r\n            if (isWebGPU) {\r\n                substitutionVars = \"fragmentInputs.\" + substitutionVars;\r\n                if (this.generateOnlyFragmentCode) {\r\n                    substitutionVars += `,fragmentInputs.vViewDepth,vViewDepth`;\r\n                }\r\n            }\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: substitutionVars + \",uniforms.vReflectivityColor,vReflectivityColor\",\r\n            });\r\n        }\r\n\r\n        // _____________________________ Compute Final Lit Components ________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalLitComponents\", comments);\r\n\r\n        // _____________________________ UNLIT (2) ________________________\r\n        state.compilationString += `#endif\\n`; // UNLIT\r\n\r\n        // _____________________________ Compute Final Unlit Components ________________________\r\n        const aoColor = this.ambientColor.isConnected ? this.ambientColor.associatedVariableName : `vec3${state.fSuffix}(0., 0., 0.)`;\r\n\r\n        let aoDirectLightIntensity = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();\r\n\r\n        if (aoDirectLightIntensity.indexOf(\".\") === -1) {\r\n            aoDirectLightIntensity += \".\";\r\n        }\r\n\r\n        let replaceStrings = [\r\n            { search: /vec3 finalEmissive[\\s\\S]*?finalEmissive\\*=vLightingIntensity\\.y;/g, replace: \"\" },\r\n            { search: new RegExp(`${isWebGPU ? \"uniforms.\" : \"\"}vAmbientColor`, \"g\"), replace: aoColor + ` * ${isWebGPU ? \"uniforms.\" : \"\"}ambientFromScene` },\r\n            { search: new RegExp(`${isWebGPU ? \"uniforms.\" : \"\"}vAmbientInfos.w`, \"g\"), replace: aoDirectLightIntensity },\r\n        ];\r\n\r\n        if (isWebGPU) {\r\n            replaceStrings[0] = { search: /var finalEmissive[\\s\\S]*?finalEmissive\\*=uniforms.vLightingIntensity\\.y;/g, replace: \"\" };\r\n        }\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalUnlitComponents\", comments, {\r\n            replaceStrings: replaceStrings,\r\n        });\r\n\r\n        // _____________________________ Output Final Color Composition ________________________\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalColorComposition\", comments, {\r\n            replaceStrings: [{ search: /finalEmissive/g, replace: `vec3${state.fSuffix}(0.)` }],\r\n        });\r\n\r\n        // _____________________________ Apply image processing ________________________\r\n        if (isWebGPU) {\r\n            replaceStrings = [{ search: /mesh.visibility/g, replace: \"1.\" }];\r\n        } else {\r\n            replaceStrings = [{ search: /visibility/g, replace: \"1.\" }];\r\n        }\r\n\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrBlockImageProcessing\", comments, {\r\n            replaceStrings: replaceStrings,\r\n        });\r\n\r\n        // _____________________________ Generate debug code ________________________\r\n\r\n        const colorOutput = isWebGPU ? \"fragmentOutputs.color\" : \"gl_FragColor\";\r\n        replaceStrings = [\r\n            { search: new RegExp(`${isWebGPU ? \"fragmentInputs.\" : \"\"}vNormalW`, \"g\"), replace: this._vNormalWName },\r\n            { search: new RegExp(`${isWebGPU ? \"fragmentInputs.\" : \"\"}vPositionW`, \"g\"), replace: worldPosVarName },\r\n            { search: /uniforms\\.vReflectivityColor/g, replace: \"vReflectivityColor\" },\r\n            {\r\n                search: /albedoTexture\\.rgb;/g,\r\n                replace: `vec3${state.fSuffix}(1.);\\n${colorOutput}.rgb = toGammaSpace(${colorOutput}.rgb);\\n`,\r\n            },\r\n        ];\r\n        state.compilationString += state._emitCodeFromInclude(\"pbrDebug\", comments, {\r\n            replaceStrings: replaceStrings,\r\n        });\r\n\r\n        // _____________________________ Generate end points ________________________\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                const remap = MapOutputToVariable[output.name];\r\n                if (remap) {\r\n                    const [varName, conditions] = remap;\r\n                    if (conditions) {\r\n                        state.compilationString += `#if ${conditions}\\n`;\r\n                    }\r\n                    state.compilationString += `${state._declareOutput(output)} = ${varName};\\n`;\r\n                    if (conditions) {\r\n                        state.compilationString += `#else\\n`;\r\n                        state.compilationString += `${state._declareOutput(output)} = vec3${state.fSuffix}(0.);\\n`;\r\n                        state.compilationString += `#endif\\n`;\r\n                    }\r\n                } else {\r\n                    state.sharedData.raiseBuildError(`There's no remapping for the ${output.name} end point! No code generated`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.lightFalloff = ${this.lightFalloff};\\n`;\r\n        codeString += `${this._codeVariableName}.useAlphaTest = ${this.useAlphaTest};\\n`;\r\n        codeString += `${this._codeVariableName}.alphaTestCutoff = ${this.alphaTestCutoff};\\n`;\r\n        codeString += `${this._codeVariableName}.useAlphaBlending = ${this.useAlphaBlending};\\n`;\r\n        codeString += `${this._codeVariableName}.useRadianceOverAlpha = ${this.useRadianceOverAlpha};\\n`;\r\n        codeString += `${this._codeVariableName}.useSpecularOverAlpha = ${this.useSpecularOverAlpha};\\n`;\r\n        codeString += `${this._codeVariableName}.enableSpecularAntiAliasing = ${this.enableSpecularAntiAliasing};\\n`;\r\n        codeString += `${this._codeVariableName}.realTimeFiltering = ${this.realTimeFiltering};\\n`;\r\n        codeString += `${this._codeVariableName}.realTimeFilteringQuality = ${this.realTimeFilteringQuality};\\n`;\r\n        codeString += `${this._codeVariableName}.useEnergyConservation = ${this.useEnergyConservation};\\n`;\r\n        codeString += `${this._codeVariableName}.useRadianceOcclusion = ${this.useRadianceOcclusion};\\n`;\r\n        codeString += `${this._codeVariableName}.useHorizonOcclusion = ${this.useHorizonOcclusion};\\n`;\r\n        codeString += `${this._codeVariableName}.unlit = ${this.unlit};\\n`;\r\n        codeString += `${this._codeVariableName}.forceNormalForward = ${this.forceNormalForward};\\n`;\r\n        codeString += `${this._codeVariableName}.debugMode = ${this.debugMode};\\n`;\r\n        codeString += `${this._codeVariableName}.debugLimit = ${this.debugLimit};\\n`;\r\n        codeString += `${this._codeVariableName}.debugFactor = ${this.debugFactor};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        serializationObject.lightFalloff = this.lightFalloff;\r\n        serializationObject.useAlphaTest = this.useAlphaTest;\r\n        serializationObject.alphaTestCutoff = this.alphaTestCutoff;\r\n        serializationObject.useAlphaBlending = this.useAlphaBlending;\r\n        serializationObject.useRadianceOverAlpha = this.useRadianceOverAlpha;\r\n        serializationObject.useSpecularOverAlpha = this.useSpecularOverAlpha;\r\n        serializationObject.enableSpecularAntiAliasing = this.enableSpecularAntiAliasing;\r\n        serializationObject.realTimeFiltering = this.realTimeFiltering;\r\n        serializationObject.realTimeFilteringQuality = this.realTimeFilteringQuality;\r\n        serializationObject.useEnergyConservation = this.useEnergyConservation;\r\n        serializationObject.useRadianceOcclusion = this.useRadianceOcclusion;\r\n        serializationObject.useHorizonOcclusion = this.useHorizonOcclusion;\r\n        serializationObject.unlit = this.unlit;\r\n        serializationObject.forceNormalForward = this.forceNormalForward;\r\n        serializationObject.debugMode = this.debugMode;\r\n        serializationObject.debugLimit = this.debugLimit;\r\n        serializationObject.debugFactor = this.debugFactor;\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n\r\n        this.lightFalloff = serializationObject.lightFalloff ?? 0;\r\n        this.useAlphaTest = serializationObject.useAlphaTest;\r\n        this.alphaTestCutoff = serializationObject.alphaTestCutoff;\r\n        this.useAlphaBlending = serializationObject.useAlphaBlending;\r\n        this.useRadianceOverAlpha = serializationObject.useRadianceOverAlpha;\r\n        this.useSpecularOverAlpha = serializationObject.useSpecularOverAlpha;\r\n        this.enableSpecularAntiAliasing = serializationObject.enableSpecularAntiAliasing;\r\n        this.realTimeFiltering = !!serializationObject.realTimeFiltering;\r\n        this.realTimeFilteringQuality = serializationObject.realTimeFilteringQuality ?? Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n        this.useEnergyConservation = serializationObject.useEnergyConservation;\r\n        this.useRadianceOcclusion = serializationObject.useRadianceOcclusion;\r\n        this.useHorizonOcclusion = serializationObject.useHorizonOcclusion;\r\n        this.unlit = serializationObject.unlit;\r\n        this.forceNormalForward = !!serializationObject.forceNormalForward;\r\n        this.debugMode = serializationObject.debugMode;\r\n        this.debugLimit = serializationObject.debugLimit;\r\n        this.debugFactor = serializationObject.debugFactor;\r\n        this.generateOnlyFragmentCode = !!serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRMetallicRoughnessBlock\", PBRMetallicRoughnessBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n/**\r\n * Block used to compute value of one parameter modulo another\r\n */\r\nexport class ModBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ModBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"left\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"right\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        this._inputs[1].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ModBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the left operand input component\r\n     */\r\n    public get left(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right operand input component\r\n     */\r\n    public get right(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.GLSL) {\r\n            state.compilationString += state._declareOutput(output) + ` = mod(${this.left.associatedVariableName}, ${this.right.associatedVariableName});\\n`;\r\n        } else {\r\n            state.compilationString += state._declareOutput(output) + ` = (${this.left.associatedVariableName} % ${this.right.associatedVariableName});\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ModBlock\", ModBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\nimport { Vector4 } from \"../../../Maths/math.vector\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to build a matrix from 4 Vector4\r\n */\r\nexport class MatrixBuilderBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MatrixBuilder\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerInput(\"row3\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MatrixBuilder\";\r\n    }\r\n\r\n    /**\r\n     * Gets the row0 vector\r\n     */\r\n    public get row0(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the row1 vector\r\n     */\r\n    public get row1(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the row2 vector\r\n     */\r\n    public get row2(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the row3 vector\r\n     */\r\n    public get row3(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure() {\r\n        if (!this.row0.isConnected) {\r\n            const row0Input = new InputBlock(\"row0\");\r\n            row0Input.value = new Vector4(1, 0, 0, 0);\r\n            row0Input.output.connectTo(this.row0);\r\n        }\r\n\r\n        if (!this.row1.isConnected) {\r\n            const row1Input = new InputBlock(\"row1\");\r\n            row1Input.value = new Vector4(0, 1, 0, 0);\r\n            row1Input.output.connectTo(this.row1);\r\n        }\r\n\r\n        if (!this.row2.isConnected) {\r\n            const row2Input = new InputBlock(\"row2\");\r\n            row2Input.value = new Vector4(0, 0, 1, 0);\r\n            row2Input.output.connectTo(this.row2);\r\n        }\r\n\r\n        if (!this.row3.isConnected) {\r\n            const row3Input = new InputBlock(\"row3\");\r\n            row3Input.value = new Vector4(0, 0, 0, 1);\r\n            row3Input.output.connectTo(this.row3);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const row0 = this.row0;\r\n        const row1 = this.row1;\r\n        const row2 = this.row2;\r\n        const row3 = this.row3;\r\n\r\n        const mat4 = state.shaderLanguage === ShaderLanguage.WGSL ? \"mat4x4f\" : \"mat4\";\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(output) +\r\n            ` = ${mat4}(${row0.associatedVariableName}, ${row1.associatedVariableName}, ${row2.associatedVariableName}, ${row3.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MatrixBuilder\", MatrixBuilderBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\nimport type { NodeMaterial } from \"../nodeMaterial\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\n\r\n/**\r\n * Operations supported by the ConditionalBlock block\r\n */\r\nexport enum ConditionalBlockConditions {\r\n    /** Equal */\r\n    Equal,\r\n    /** NotEqual */\r\n    NotEqual,\r\n    /** LessThan */\r\n    LessThan,\r\n    /** GreaterThan */\r\n    GreaterThan,\r\n    /** LessOrEqual */\r\n    LessOrEqual,\r\n    /** GreaterOrEqual */\r\n    GreaterOrEqual,\r\n    /** Logical Exclusive OR */\r\n    Xor,\r\n    /** Logical Or */\r\n    Or,\r\n    /** Logical And */\r\n    And,\r\n}\r\n\r\n/**\r\n * Block used to apply conditional operation between floats\r\n * @since 5.0.0\r\n */\r\nexport class ConditionalBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the condition applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Condition\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"Equal\", value: ConditionalBlockConditions.Equal },\r\n            { label: \"NotEqual\", value: ConditionalBlockConditions.NotEqual },\r\n            { label: \"LessThan\", value: ConditionalBlockConditions.LessThan },\r\n            { label: \"GreaterThan\", value: ConditionalBlockConditions.GreaterThan },\r\n            { label: \"LessOrEqual\", value: ConditionalBlockConditions.LessOrEqual },\r\n            { label: \"GreaterOrEqual\", value: ConditionalBlockConditions.GreaterOrEqual },\r\n            { label: \"Xor\", value: ConditionalBlockConditions.Xor },\r\n            { label: \"And\", value: ConditionalBlockConditions.And },\r\n            { label: \"Or\", value: ConditionalBlockConditions.Or },\r\n        ],\r\n    })\r\n    public condition = ConditionalBlockConditions.LessThan;\r\n\r\n    /**\r\n     * Creates a new ConditionalBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"b\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"true\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"false\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._linkConnectionTypes(2, 3);\r\n        this._outputs[0]._typeConnectionSource = this._inputs[2];\r\n        this._outputs[0]._defaultConnectionPointType = NodeMaterialBlockConnectionPointTypes.Float;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ConditionalBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the first operand component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the second operand component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the value to return if condition is true\r\n     */\r\n    public get true(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the value to return if condition is false\r\n     */\r\n    public get false(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    public override autoConfigure(nodeMaterial: NodeMaterial) {\r\n        if (!this.true.isConnected) {\r\n            const minInput = (nodeMaterial.getBlockByPredicate((b) => b.isInput && (b as InputBlock).value === 1 && b.name === \"True\") as InputBlock) || new InputBlock(\"True\");\r\n            minInput.value = 1;\r\n            minInput.output.connectTo(this.true);\r\n        }\r\n\r\n        if (!this.false.isConnected) {\r\n            const maxInput = (nodeMaterial.getBlockByPredicate((b) => b.isInput && (b as InputBlock).value === 0 && b.name === \"False\") as InputBlock) || new InputBlock(\"False\");\r\n            maxInput.value = 0;\r\n            maxInput.output.connectTo(this.false);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n\r\n        const trueStatement = this.true.isConnected ? this.true.associatedVariableName : \"1.0\";\r\n        const falseStatement = this.false.isConnected ? this.false.associatedVariableName : \"0.0\";\r\n\r\n        switch (this.condition) {\r\n            case ConditionalBlockConditions.Equal: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} == ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.NotEqual: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} != ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.LessThan: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} < ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.LessOrEqual: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} <= ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.GreaterThan: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} > ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.GreaterOrEqual: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `${this.a.associatedVariableName} >= ${this.b.associatedVariableName}`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.Xor: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `(((${this.a.associatedVariableName} + ${this.b.associatedVariableName}) % 2.0) > 0.0)`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.Or: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `(min(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 1.0) > 0.0)`)};\\n`;\r\n                break;\r\n            }\r\n            case ConditionalBlockConditions.And: {\r\n                state.compilationString +=\r\n                    state._declareOutput(output) +\r\n                    ` = ${state._generateTernary(trueStatement, falseStatement, `(${this.a.associatedVariableName} * ${this.b.associatedVariableName} > 0.0)`)};\\n`;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.condition = this.condition;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.condition = serializationObject.condition;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString =\r\n            super._dumpPropertiesCode() + `${this._codeVariableName}.condition = BABYLON.ConditionalBlockConditions.${ConditionalBlockConditions[this.condition]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ConditionalBlock\", ConditionalBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ShaderLanguage } from \"../../../Materials/shaderLanguage\";\r\n/**\r\n * block used to Generate Fractal Brownian Motion Clouds\r\n */\r\nexport class CloudBlock extends NodeMaterialBlock {\r\n    /** Gets or sets the number of octaves */\r\n    @editableInPropertyPage(\"Octaves\", PropertyTypeForEdition.Int, undefined, { embedded: true })\r\n    public octaves = 6.0;\r\n\r\n    /**\r\n     * Creates a new CloudBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"chaos\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n        this.registerInput(\"offsetX\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"offsetY\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\"offsetZ\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CloudBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the chaos input component\r\n     */\r\n    public get chaos(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset X input component\r\n     */\r\n    public get offsetX(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset Y input component\r\n     */\r\n    public get offsetY(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset Z input component\r\n     */\r\n    public get offsetZ(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.seed.isConnected) {\r\n            return;\r\n        }\r\n\r\n        if (!this._outputs[0].hasEndpoints) {\r\n            return;\r\n        }\r\n\r\n        let functionString = `\r\n\r\n        float cloudRandom(float p) { \r\n            float temp = fract(p * 0.011); \r\n            temp *= temp + 7.5; \r\n            temp *= temp + temp; \r\n            return fract(temp); \r\n        }\r\n\r\n        // Based on Morgan McGuire @morgan3d\r\n        // https://www.shadertoy.com/view/4dS3Wd\r\n        float cloudNoise2(vec2 x, vec2 chaos) {\r\n            vec2 step = chaos * vec2(75., 120.) + vec2(75., 120.);\r\n\r\n            vec2 i = floor(x);\r\n            vec2 f = fract(x);\r\n\r\n            float n = dot(i, step);\r\n\r\n            vec2 u = f * f * (3.0 - 2.0 * f);\r\n            return mix(\r\n                    mix(cloudRandom(n + dot(step, vec2(0, 0))), cloudRandom(n + dot(step, vec2(1, 0))), u.x),\r\n                    mix(cloudRandom(n + dot(step, vec2(0, 1))), cloudRandom(n + dot(step, vec2(1, 1))), u.x),\r\n                    u.y\r\n                );\r\n        }\r\n\r\n        float cloudNoise3(vec3 x, vec3 chaos) {\r\n            vec3 step = chaos * vec3(60., 120., 75.) + vec3(60., 120., 75.);\r\n\r\n            vec3 i = floor(x);\r\n            vec3 f = fract(x);\r\n\r\n            float n = dot(i, step);\r\n\r\n            vec3 u = f * f * (3.0 - 2.0 * f);\r\n            return mix(mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 0))), cloudRandom(n + dot(step, vec3(1, 0, 0))), u.x),\r\n                           mix( cloudRandom(n + dot(step, vec3(0, 1, 0))), cloudRandom(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\r\n                       mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 1))), cloudRandom(n + dot(step, vec3(1, 0, 1))), u.x),\r\n                           mix( cloudRandom(n + dot(step, vec3(0, 1, 1))), cloudRandom(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\r\n        }`;\r\n\r\n        let fractalBrownianString = `\r\n        float fbm2(vec2 st, vec2 chaos) {\r\n            // Initial values\r\n            float value = 0.0;\r\n            float amplitude = .5;\r\n            float frequency = 0.;\r\n\r\n            // Loop of octaves\r\n            vec2 tempST = st;\r\n            for (int i = 0; i < OCTAVES; i++) {\r\n                value += amplitude * cloudNoise2(tempST, chaos);\r\n                tempST *= 2.0;\r\n                amplitude *= 0.5;\r\n            }\r\n            return value;\r\n        }\r\n\r\n        float fbm3(vec3 x, vec3 chaos) {\r\n            // Initial values\r\n            float value = 0.0;\r\n            float amplitude = 0.5;\r\n            vec3 tempX = x;\r\n            for (int i = 0; i < OCTAVES; i++) {\r\n                value += amplitude * cloudNoise3(tempX, chaos);\r\n                tempX = tempX * 2.0;\r\n                amplitude *= 0.5;\r\n            }\r\n            return value;\r\n        }`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = state._babylonSLtoWGSL(functionString);\r\n            fractalBrownianString = state._babylonSLtoWGSL(fractalBrownianString);\r\n        }\r\n\r\n        const fbmNewName = `fbm${this.octaves}`;\r\n        state._emitFunction(\"CloudBlockCode\", functionString, \"// CloudBlockCode\");\r\n        state._emitFunction(\r\n            \"CloudBlockCodeFBM\" + this.octaves,\r\n            fractalBrownianString.replace(/fbm/gi, fbmNewName).replace(/OCTAVES/gi, (this.octaves | 0).toString()),\r\n            \"// CloudBlockCode FBM\"\r\n        );\r\n\r\n        const localVariable = state._getFreeVariableName(\"st\");\r\n        const seedType = this.seed.connectedPoint?.type || NodeMaterialBlockConnectionPointTypes.Vector3;\r\n\r\n        state.compilationString += `${state._declareLocalVar(localVariable, seedType)} = ${this.seed.associatedVariableName};\\n`;\r\n        if (this.offsetX.isConnected) {\r\n            state.compilationString += `${localVariable}.x += 0.1 * ${this.offsetX.associatedVariableName};\\n`;\r\n        }\r\n        if (this.offsetY.isConnected) {\r\n            state.compilationString += `${localVariable}.y += 0.1 * ${this.offsetY.associatedVariableName};\\n`;\r\n        }\r\n        if (this.offsetZ.isConnected && seedType === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n            state.compilationString += `${localVariable}.z += 0.1 * ${this.offsetZ.associatedVariableName};\\n`;\r\n        }\r\n\r\n        let chaosValue = \"\";\r\n        if (this.chaos.isConnected) {\r\n            chaosValue = this.chaos.associatedVariableName;\r\n        } else {\r\n            const addF = state.fSuffix;\r\n            chaosValue = this.seed.connectedPoint?.type === NodeMaterialBlockConnectionPointTypes.Vector2 ? `vec2${addF}(0., 0.)` : `vec3${addF}(0., 0., 0.)`;\r\n        }\r\n\r\n        state.compilationString +=\r\n            state._declareOutput(this._outputs[0]) +\r\n            ` = ${fbmNewName}${this.seed.connectedPoint?.type === NodeMaterialBlockConnectionPointTypes.Vector2 ? \"2\" : \"3\"}(${localVariable}, ${chaosValue});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.octaves = ${this.octaves};\\n`;\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.octaves = this.octaves;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.octaves = serializationObject.octaves;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CloudBlock\", CloudBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * block used to Generate a Voronoi Noise Pattern\r\n */\r\nexport class VoronoiNoiseBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VoronoiNoiseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"density\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"cells\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"VoronoiNoiseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset input component\r\n     */\r\n    public get offset(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the density input component\r\n     */\r\n    public get density(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get cells(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.seed.isConnected) {\r\n            return;\r\n        }\r\n        // Adapted from https://www.shadertoy.com/view/MslGD8\r\n        let functionString = `vec2 voronoiRandom(vec2 p){\r\n            p = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\r\n            return fract(sin(p)*18.5453);\r\n        }\r\n        `;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = state._babylonSLtoWGSL(functionString);\r\n        }\r\n\r\n        state._emitFunction(\"voronoiRandom\", functionString, \"// Voronoi random generator\");\r\n\r\n        functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){\r\n            vec2 n = floor(seed * density);\r\n            vec2 f = fract(seed * density);\r\n            vec3 m = vec3( 8.0 );\r\n            for( int j=-1; j<=1; j++ ){\r\n                for( int i=-1; i<=1; i++ ){\r\n                    vec2  g = vec2( float(i), float(j) );\r\n                    vec2  o = voronoiRandom( n + g);\r\n                    vec2  r = g - f + (0.5+0.5*sin(offset+6.2831*o));\r\n                    float d = dot( r, r );\r\n                    if( d<m.x ){\r\n                        m = vec3( d, o );\r\n                        outValue = m.x;\r\n                        cells = m.y;\r\n                    }\r\n                }\r\n\t\t\t}\r\n        }\r\n        `;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            functionString = state._babylonSLtoWGSL(functionString);\r\n        } else {\r\n            functionString = state._babylonSLtoGLSL(functionString);\r\n        }\r\n\r\n        state._emitFunction(\"voronoi\", functionString, \"// Voronoi\");\r\n\r\n        const tempOutput = state._getFreeVariableName(\"tempOutput\");\r\n        const tempCells = state._getFreeVariableName(\"tempCells\");\r\n        const ref = state.shaderLanguage === ShaderLanguage.WGSL ? \"&\" : \"\";\r\n\r\n        state.compilationString += `${state._declareLocalVar(tempOutput, NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;\\n`;\r\n        state.compilationString += `${state._declareLocalVar(tempCells, NodeMaterialBlockConnectionPointTypes.Float)} = 0.0;\\n`;\r\n        state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${ref}${tempOutput}, ${ref}${tempCells});\\n`;\r\n\r\n        if (this.output.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.output) + ` = ${tempOutput};\\n`;\r\n        }\r\n\r\n        if (this.cells.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(this.cells) + ` = ${tempCells};\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VoronoiNoiseBlock\", VoronoiNoiseBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n/**\r\n * Block used as a pass through\r\n */\r\nexport class ElbowBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new ElbowBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ElbowBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public override get target() {\r\n        const input = this._inputs[0];\r\n        if (input.isConnected) {\r\n            const block = input.connectedPoint!.ownerBlock;\r\n            if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n                return block.target;\r\n            }\r\n\r\n            if (input.connectedPoint!.target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n                return input.connectedPoint!.target;\r\n            }\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    public override set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const input = this._inputs[0];\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${input.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ElbowBlock\", ElbowBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { NodeMaterial } from \"../nodeMaterial\";\r\nimport type { Effect } from \"../../effect\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Texture } from \"../../Textures/texture\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport \"../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\r\n */\r\nexport class TriPlanarBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    protected _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _textureInfoName: string;\r\n    private _imageSource: Nullable<ImageSourceBlock>;\r\n\r\n    /**\r\n     * Project the texture(s) for a better fit to a cube\r\n     */\r\n    @editableInPropertyPage(\"Project as cube\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { embedded: true, notifiers: { update: true } })\r\n    public projectAsCube: boolean = false;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the textureY associated with the node\r\n     */\r\n    public get textureY(): Nullable<Texture> {\r\n        if (this.sourceY.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the textureZ associated with the node\r\n     */\r\n    public get textureZ(): Nullable<Texture> {\r\n        if (this.sourceZ?.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _getImageSourceBlock(connectionPoint: Nullable<NodeMaterialConnectionPoint>): Nullable<ImageSourceBlock> {\r\n        return connectionPoint?.isConnected ? (connectionPoint.connectedPoint!.ownerBlock as ImageSourceBlock) : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        const imageSourceBlock = this._getImageSourceBlock(this.source);\r\n        if (imageSourceBlock) {\r\n            return imageSourceBlock.samplerName;\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerY name associated with this texture\r\n     */\r\n    public get samplerYName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerZ name associated with this texture\r\n     */\r\n    public get samplerZName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return this.source.isConnected;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TriPlanarBlock\r\n     * @param name defines the block name\r\n     * @param hideSourceZ defines a boolean indicating that normal Z should not be used (false by default)\r\n     */\r\n    public constructor(name: string, hideSourceZ = false) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"sourceY\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        if (!hideSourceZ) {\r\n            this.registerInput(\r\n                \"sourceZ\",\r\n                NodeMaterialBlockConnectionPointTypes.Object,\r\n                true,\r\n                NodeMaterialBlockTargets.VertexAndFragment,\r\n                new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n            );\r\n        }\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"TriPlanarBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the sharpness input component\r\n     */\r\n    public get sharpness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceY input component\r\n     */\r\n    public get sourceY(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceZ input component\r\n     */\r\n    public get sourceZ(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public override prepareDefines(defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n    }\r\n\r\n    public override isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloat(this._textureInfoName, this.texture.level);\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    private _samplerFunc(state: NodeMaterialBuildState) {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return \"textureSample\";\r\n        }\r\n        return \"texture2D\";\r\n    }\r\n\r\n    private _generateTextureSample(textureName: string, uv: string, state: NodeMaterialBuildState) {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `${this._samplerFunc(state)}(${textureName},${textureName + Constants.AUTOSAMPLERSUFFIX}, ${uv})`;\r\n        }\r\n        return `${this._samplerFunc(state)}(${textureName}, ${uv})`;\r\n    }\r\n\r\n    protected _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n        const samplerYName = this.samplerYName ?? samplerName;\r\n        const samplerZName = this.samplerZName ?? samplerName;\r\n\r\n        const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\r\n\r\n        const x = state._getFreeVariableName(\"x\");\r\n        const y = state._getFreeVariableName(\"y\");\r\n        const z = state._getFreeVariableName(\"z\");\r\n        const w = state._getFreeVariableName(\"w\");\r\n        const n = state._getFreeVariableName(\"n\");\r\n        const uvx = state._getFreeVariableName(\"uvx\");\r\n        const uvy = state._getFreeVariableName(\"uvy\");\r\n        const uvz = state._getFreeVariableName(\"uvz\");\r\n\r\n        state.compilationString += `\r\n            ${state._declareLocalVar(n, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this.normal.associatedVariableName}.xyz;\r\n\r\n            ${state._declareLocalVar(uvx, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.yz;\r\n            ${state._declareLocalVar(uvy, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.zx;\r\n            ${state._declareLocalVar(uvz, NodeMaterialBlockConnectionPointTypes.Vector2)} = ${this.position.associatedVariableName}.xy;\r\n        `;\r\n\r\n        if (this.projectAsCube) {\r\n            state.compilationString += `\r\n                ${uvx}.xy = ${uvx}.yx;\r\n\r\n                if (${n}.x >= 0.0) {\r\n                    ${uvx}.x = -${uvx}.x;\r\n                }\r\n                if (${n}.y < 0.0) {\r\n                    ${uvy}.y = -${uvy}.y;\r\n                }\r\n                if (${n}.z < 0.0) {\r\n                    ${uvz}.x = -${uvz}.x;\r\n                }\r\n            `;\r\n        }\r\n\r\n        const suffix = state.fSuffix;\r\n\r\n        state.compilationString += `\r\n            ${state._declareLocalVar(x, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerName, uvx, state)};\r\n            ${state._declareLocalVar(y, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerYName, uvy, state)};\r\n            ${state._declareLocalVar(z, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._generateTextureSample(samplerZName, uvz, state)};\r\n           \r\n            // blend weights\r\n            ${state._declareLocalVar(w, NodeMaterialBlockConnectionPointTypes.Vector3)} = pow(abs(${n}), vec3${suffix}(${sharpness}));\r\n\r\n            // blend and return\r\n            ${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \r\n        `;\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        let vecSpecifier = \"\";\r\n\r\n        if (\r\n            state.shaderLanguage === ShaderLanguage.WGSL &&\r\n            (output.type === NodeMaterialBlockConnectionPointTypes.Vector3 || output.type === NodeMaterialBlockConnectionPointTypes.Color3)\r\n        ) {\r\n            vecSpecifier = \"Vec3\";\r\n        }\r\n\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace${vecSpecifier}(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace${vecSpecifier}(${output.associatedVariableName});\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\"}${this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = (state.shaderLanguage === ShaderLanguage.WGSL ? \"uniforms.\" : \"\") + this._textureInfoName;\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        if (!this._imageSource) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Texture\");\r\n\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        // Declarations\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitUniformFromString(this._textureInfoName, NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this._generateTextureLookup(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\r\n        codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        serializationObject.projectAsCube = this.projectAsCube;\r\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n        this.projectAsCube = !!serializationObject.projectAsCube;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);\r\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { TriPlanarBlock } from \"./triPlanarBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport { ShaderLanguage } from \"../../../Materials/shaderLanguage\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\n/**\r\n * Block used to read a texture with triplanar mapping (see https://iquilezles.org/articles/biplanar/)\r\n */\r\nexport class BiPlanarBlock extends TriPlanarBlock {\r\n    /**\r\n     * Create a new BiPlanarBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"BiPlanarBlock\";\r\n    }\r\n\r\n    private _declareLocalVarAsVec3I(name: string, state: NodeMaterialBuildState): string {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `var ${name}: vec3<i32>`;\r\n        } else {\r\n            return `ivec3 ${name}`;\r\n        }\r\n    }\r\n\r\n    private _getTextureGrad(state: NodeMaterialBuildState, samplerName: string) {\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            return `textureSampleGrad(${samplerName},${samplerName + Constants.AUTOSAMPLERSUFFIX}`;\r\n        }\r\n\r\n        return `textureGrad(${samplerName}`;\r\n    }\r\n\r\n    protected override _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n        const samplerYName = this.samplerYName ?? this.samplerName;\r\n\r\n        const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\r\n\r\n        const dpdx = state._getFreeVariableName(\"dxValue\");\r\n        const dpdy = state._getFreeVariableName(\"dyValue\");\r\n        const n = state._getFreeVariableName(\"n\");\r\n        const ma = state._getFreeVariableName(\"ma\");\r\n        const mi = state._getFreeVariableName(\"mi\");\r\n        const me = state._getFreeVariableName(\"me\");\r\n        const x = state._getFreeVariableName(\"x\");\r\n        const y = state._getFreeVariableName(\"y\");\r\n        const w = state._getFreeVariableName(\"w\");\r\n\r\n        let ivec3 = \"ivec3\";\r\n        let dpdxFunc = \"dFdx\";\r\n        let dpdyFunc = \"dFdy\";\r\n        const suffix = state.fSuffix;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            ivec3 = \"vec3<i32>\";\r\n            dpdxFunc = \"dpdx\";\r\n            dpdyFunc = \"dpdy\";\r\n        }\r\n\r\n        state.compilationString += `\r\n            // grab coord derivatives for texturing\r\n            ${state._declareLocalVar(dpdx, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${dpdxFunc}(${this.position.associatedVariableName}.xyz);\r\n            ${state._declareLocalVar(dpdy, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${dpdyFunc}(${this.position.associatedVariableName}.xyz);\r\n            ${state._declareLocalVar(n, NodeMaterialBlockConnectionPointTypes.Vector3)} = abs(${this.normal.associatedVariableName}.xyz);\r\n        \r\n            // determine major axis (in x; yz are following axis)\r\n            ${this._declareLocalVarAsVec3I(ma, state)} = ${state._generateTernary(\r\n                `${ivec3}(0,1,2)`,\r\n                `${state._generateTernary(`${ivec3}(1,2,0)`, `${ivec3}(2,0,1)`, `(${n}.y>${n}.z)`)}`,\r\n                `(${n}.x>${n}.y && ${n}.x>${n}.z)`\r\n            )};                    \r\n\r\n            // determine minor axis (in x; yz are following axis)\r\n            ${this._declareLocalVarAsVec3I(mi, state)} =  ${state._generateTernary(\r\n                `${ivec3}(0,1,2)`,\r\n                `${state._generateTernary(`${ivec3}(1,2,0)`, `${ivec3}(2,0,1)`, `(${n}.y<${n}.z)`)}`,\r\n                `(${n}.x<${n}.y && ${n}.x<${n}.z)`\r\n            )};  \r\n                              \r\n            // determine median axis (in x;  yz are following axis)\r\n            ${this._declareLocalVarAsVec3I(me, state)} = ${ivec3}(3) - ${mi} - ${ma};\r\n            \r\n            // project+fetch\r\n            ${state._declareLocalVar(x, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._getTextureGrad(state, samplerName)}, vec2${suffix}(${this.position.associatedVariableName}[${ma}.y], ${this.position.associatedVariableName}[${ma}.z]), \r\n                                    vec2${suffix}(${dpdx}[${ma}.y],${dpdx}[${ma}.z]), \r\n                                    vec2${suffix}(${dpdy}[${ma}.y],${dpdy}[${ma}.z]));\r\n            ${state._declareLocalVar(y, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this._getTextureGrad(state, samplerYName)}, vec2${suffix}(${this.position.associatedVariableName}[${me}.y], ${this.position.associatedVariableName}[${me}.z]), \r\n                                    vec2${suffix}(${dpdx}[${me}.y],${dpdx}[${me}.z]),\r\n                                    vec2${suffix}(${dpdy}[${me}.y],${dpdy}[${me}.z]));\r\n            \r\n            // blend factors\r\n            ${state._declareLocalVar(w, NodeMaterialBlockConnectionPointTypes.Vector2)} = vec2${suffix}(${n}[${ma}.x],${n}[${me}.x]);\r\n            // make local support\r\n            ${w} = clamp( (${w}-0.5773)/(1.0-0.5773), vec2${suffix}(0.0), vec2${suffix}(1.0) );\r\n            // shape transition\r\n            ${w} = pow( ${w}, vec2${suffix}(${sharpness}/8.0) );\r\n            // blend and return\r\n            ${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = (${x}*${w}.x + ${y}*${w}.y) / (${w}.x + ${w}.y);\r\n        `;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BiPlanarBlock\", BiPlanarBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to compute the determinant of a matrix\r\n */\r\nexport class MatrixDeterminantBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MatrixDeterminantBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MatrixDeterminantBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input matrix\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this.output;\r\n        const input = this.input;\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = determinant(${input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MatrixDeterminantBlock\", MatrixDeterminantBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used to transpose a matrix\r\n */\r\nexport class MatrixTransposeBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MatrixTransposeBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MatrixTransposeBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input matrix\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this.output;\r\n        const input = this.input;\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = transpose(${input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MatrixTransposeBlock\", MatrixTransposeBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { InputBlock } from \"./Input/inputBlock\";\r\nimport { MorphTargetsBlock } from \"./Vertex/morphTargetsBlock\";\r\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nexport const enum MeshAttributeExistsBlockTypes {\r\n    None,\r\n    Normal,\r\n    Tangent,\r\n    VertexColor,\r\n    UV1,\r\n    UV2,\r\n    UV3,\r\n    UV4,\r\n    UV5,\r\n    UV6,\r\n}\r\n\r\n/**\r\n * Block used to check if Mesh attribute of specified type exists\r\n * and provide an alternative fallback input for to use in such case\r\n */\r\nexport class MeshAttributeExistsBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MeshAttributeExistsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"fallback\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._linkConnectionTypes(0, 1);\r\n\r\n        // Try to auto determine attributeType\r\n        this._inputs[0].onConnectionObservable.add((other) => {\r\n            if (this.attributeType) {\r\n                // But only if not already specified\r\n                return;\r\n            }\r\n            const sourceBlock = other.ownerBlock;\r\n            if (sourceBlock instanceof InputBlock && sourceBlock.isAttribute) {\r\n                switch (sourceBlock.name) {\r\n                    case \"color\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.VertexColor;\r\n                        break;\r\n                    case \"normal\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.Normal;\r\n                        break;\r\n                    case \"tangent\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.Tangent;\r\n                        break;\r\n                    case \"uv\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV1;\r\n                        break;\r\n                    case \"uv2\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV2;\r\n                        break;\r\n                    case \"uv3\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV3;\r\n                        break;\r\n                    case \"uv4\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV4;\r\n                        break;\r\n                    case \"uv5\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV5;\r\n                        break;\r\n                    case \"uv6\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV6;\r\n                        break;\r\n                }\r\n            } else if (sourceBlock instanceof MorphTargetsBlock) {\r\n                switch (this.input.connectedPoint?.name) {\r\n                    case \"normalOutput\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.Normal;\r\n                        break;\r\n                    case \"tangentOutput\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.Tangent;\r\n                        break;\r\n                    case \"uvOutput\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV1;\r\n                        break;\r\n                    case \"uv2Output\":\r\n                        this.attributeType = MeshAttributeExistsBlockTypes.UV2;\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MeshAttributeExistsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Defines which mesh attribute to use\r\n     */\r\n    @editableInPropertyPage(\"Attribute lookup\", PropertyTypeForEdition.List, undefined, {\r\n        notifiers: { update: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"(None)\", value: MeshAttributeExistsBlockTypes.None },\r\n            { label: \"Normal\", value: MeshAttributeExistsBlockTypes.Normal },\r\n            { label: \"Tangent\", value: MeshAttributeExistsBlockTypes.Tangent },\r\n            { label: \"Vertex Color\", value: MeshAttributeExistsBlockTypes.VertexColor },\r\n            { label: \"UV1\", value: MeshAttributeExistsBlockTypes.UV1 },\r\n            { label: \"UV2\", value: MeshAttributeExistsBlockTypes.UV2 },\r\n            { label: \"UV3\", value: MeshAttributeExistsBlockTypes.UV3 },\r\n            { label: \"UV4\", value: MeshAttributeExistsBlockTypes.UV4 },\r\n            { label: \"UV5\", value: MeshAttributeExistsBlockTypes.UV5 },\r\n            { label: \"UV6\", value: MeshAttributeExistsBlockTypes.UV6 },\r\n        ],\r\n    })\r\n    public attributeType = MeshAttributeExistsBlockTypes.None;\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the fallback component when speciefied attribute doesn't exist\r\n     */\r\n    public get fallback(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        let attributeDefine: null | string = null;\r\n        switch (this.attributeType) {\r\n            case MeshAttributeExistsBlockTypes.VertexColor:\r\n                attributeDefine = \"VERTEXCOLOR_NME\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.Normal:\r\n                attributeDefine = \"NORMAL\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.Tangent:\r\n                attributeDefine = \"TANGENT\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV1:\r\n                attributeDefine = \"UV1\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV2:\r\n                attributeDefine = \"UV2\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV3:\r\n                attributeDefine = \"UV3\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV4:\r\n                attributeDefine = \"UV4\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV5:\r\n                attributeDefine = \"UV5\";\r\n                break;\r\n            case MeshAttributeExistsBlockTypes.UV6:\r\n                attributeDefine = \"UV6\";\r\n                break;\r\n        }\r\n\r\n        const output = state._declareOutput(this.output);\r\n        if (attributeDefine) {\r\n            state.compilationString += `#ifdef ${attributeDefine}\\n`;\r\n        }\r\n\r\n        state.compilationString += `${output} = ${this.input.associatedVariableName};\\n`;\r\n\r\n        if (attributeDefine) {\r\n            state.compilationString += `#else\\n`;\r\n            state.compilationString += `${output} = ${this.fallback.associatedVariableName};\\n`;\r\n            state.compilationString += `#endif\\n`;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.attributeType = this.attributeType;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.attributeType = serializationObject.attributeType ?? MeshAttributeExistsBlockTypes.None;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.attributeType = ${this.attributeType};\\n`;\r\n\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MeshAttributeExistsBlock\", MeshAttributeExistsBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Types of curves supported by the Curve block\r\n */\r\nexport enum CurveBlockTypes {\r\n    /** EaseInSine */\r\n    EaseInSine,\r\n    /** EaseOutSine */\r\n    EaseOutSine,\r\n    /** EaseInOutSine */\r\n    EaseInOutSine,\r\n    /** EaseInQuad */\r\n    EaseInQuad,\r\n    /** EaseOutQuad */\r\n    EaseOutQuad,\r\n    /** EaseInOutQuad */\r\n    EaseInOutQuad,\r\n    /** EaseInCubic */\r\n    EaseInCubic,\r\n    /** EaseOutCubic */\r\n    EaseOutCubic,\r\n    /** EaseInOutCubic */\r\n    EaseInOutCubic,\r\n    /** EaseInQuart */\r\n    EaseInQuart,\r\n    /** EaseOutQuart */\r\n    EaseOutQuart,\r\n    /** EaseInOutQuart */\r\n    EaseInOutQuart,\r\n    /** EaseInQuint */\r\n    EaseInQuint,\r\n    /** EaseOutQuint */\r\n    EaseOutQuint,\r\n    /** EaseInOutQuint */\r\n    EaseInOutQuint,\r\n    /** EaseInExpo */\r\n    EaseInExpo,\r\n    /** EaseOutExpo */\r\n    EaseOutExpo,\r\n    /** EaseInOutExpo */\r\n    EaseInOutExpo,\r\n    /** EaseInCirc */\r\n    EaseInCirc,\r\n    /** EaseOutCirc */\r\n    EaseOutCirc,\r\n    /** EaseInOutCirc */\r\n    EaseInOutCirc,\r\n    /** EaseInBack */\r\n    EaseInBack,\r\n    /** EaseOutBack */\r\n    EaseOutBack,\r\n    /** EaseInOutBack */\r\n    EaseInOutBack,\r\n    /** EaseInElastic */\r\n    EaseInElastic,\r\n    /** EaseOutElastic */\r\n    EaseOutElastic,\r\n    /** EaseInOutElastic */\r\n    EaseInOutElastic,\r\n}\r\n\r\n/**\r\n * Block used to apply curve operation\r\n */\r\nexport class CurveBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets the type of the curve applied by the block\r\n     */\r\n    @editableInPropertyPage(\"Type\", PropertyTypeForEdition.List, \"ADVANCED\", {\r\n        notifiers: { rebuild: true },\r\n        embedded: true,\r\n        options: [\r\n            { label: \"EaseInSine\", value: CurveBlockTypes.EaseInSine },\r\n            { label: \"EaseOutSine\", value: CurveBlockTypes.EaseOutSine },\r\n            { label: \"EaseInOutSine\", value: CurveBlockTypes.EaseInOutSine },\r\n            { label: \"EaseInQuad\", value: CurveBlockTypes.EaseInQuad },\r\n            { label: \"EaseOutQuad\", value: CurveBlockTypes.EaseOutQuad },\r\n            { label: \"EaseInOutQuad\", value: CurveBlockTypes.EaseInOutQuad },\r\n            { label: \"EaseInCubic\", value: CurveBlockTypes.EaseInCubic },\r\n            { label: \"EaseOutCubic\", value: CurveBlockTypes.EaseOutCubic },\r\n            { label: \"EaseInOutCubic\", value: CurveBlockTypes.EaseInOutCubic },\r\n            { label: \"EaseInQuart\", value: CurveBlockTypes.EaseInQuart },\r\n            { label: \"EaseOutQuart\", value: CurveBlockTypes.EaseOutQuart },\r\n            { label: \"EaseInOutQuart\", value: CurveBlockTypes.EaseInOutQuart },\r\n            { label: \"EaseInQuint\", value: CurveBlockTypes.EaseInQuint },\r\n            { label: \"EaseOutQuint\", value: CurveBlockTypes.EaseOutQuint },\r\n            { label: \"EaseInOutQuint\", value: CurveBlockTypes.EaseInOutQuint },\r\n            { label: \"EaseInExpo\", value: CurveBlockTypes.EaseInExpo },\r\n            { label: \"EaseOutExpo\", value: CurveBlockTypes.EaseOutExpo },\r\n            { label: \"EaseInOutExpo\", value: CurveBlockTypes.EaseInOutExpo },\r\n            { label: \"EaseInCirc\", value: CurveBlockTypes.EaseInCirc },\r\n            { label: \"EaseOutCirc\", value: CurveBlockTypes.EaseOutCirc },\r\n            { label: \"EaseInOutCirc\", value: CurveBlockTypes.EaseInOutCirc },\r\n            { label: \"EaseInBack\", value: CurveBlockTypes.EaseInBack },\r\n            { label: \"EaseOutBack\", value: CurveBlockTypes.EaseOutBack },\r\n            { label: \"EaseInOutBack\", value: CurveBlockTypes.EaseInOutBack },\r\n            { label: \"EaseInElastic\", value: CurveBlockTypes.EaseInElastic },\r\n            { label: \"EaseOutElastic\", value: CurveBlockTypes.EaseOutElastic },\r\n            { label: \"EaseInOutElastic\", value: CurveBlockTypes.EaseInOutElastic },\r\n        ],\r\n    })\r\n    public type = CurveBlockTypes.EaseInOutSine;\r\n\r\n    /**\r\n     * Creates a new CurveBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Object);\r\n        this._inputs[0].excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Int);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"CurveBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _duplicateEntry(entry: string, component: string) {\r\n        return `ret.${component} = ${entry.replace(/VAL/g, \"v.\" + component)}`;\r\n    }\r\n\r\n    private _duplicateEntryDirect(entry: string) {\r\n        return `return ${entry.replace(/VAL/g, \"v\")}`;\r\n    }\r\n\r\n    private _duplicateVector(entry: string, inputType: string, isWGSL: boolean) {\r\n        if (inputType === \"float\" || inputType === \"f32\") {\r\n            return this._duplicateEntryDirect(entry);\r\n        }\r\n\r\n        const size = parseInt(inputType.replace(\"vec\", \"\"));\r\n        let code = isWGSL\r\n            ? `\r\n            var ret: vec${size}f = vec${size}f(0.0);\r\n        `\r\n            : `\r\n            vec${size} ret = vec${size}(0.0);\r\n        `;\r\n\r\n        for (let i = 1; i <= size; i++) {\r\n            code += this._duplicateEntry(entry, i === 1 ? \"x\" : i === 2 ? \"y\" : i === 3 ? \"z\" : \"w\") + \";\\n\";\r\n        }\r\n\r\n        code += \"return ret;\\n\";\r\n        return code;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        let registeredFunction = \"\";\r\n        let registeredFunctionName = \"\";\r\n\r\n        const inputType = state._getShaderType(this.input.type);\r\n        const isWGSL = state.shaderLanguage === ShaderLanguage.WGSL;\r\n\r\n        registeredFunctionName = CurveBlockTypes[this.type] + \"_\" + inputType.replace(\"<\", \"\").replace(\">\", \"\");\r\n\r\n        switch (this.type) {\r\n            case CurveBlockTypes.EaseInSine:\r\n                registeredFunction = `return 1.0 - cos((v * 3.1415) / 2.0)`;\r\n                break;\r\n            case CurveBlockTypes.EaseOutSine:\r\n                registeredFunction = `return sin((v * 3.1415) / 2.0)`;\r\n                break;\r\n            case CurveBlockTypes.EaseInOutSine:\r\n                registeredFunction = `return -(cos(v * 3.1415) - 1.0) / 2.0`;\r\n                break;\r\n            case CurveBlockTypes.EaseInQuad:\r\n                registeredFunction = `return v * v`;\r\n                break;\r\n            case CurveBlockTypes.EaseOutQuad:\r\n                registeredFunction = `return (1.0 - v) * (1.0 - v)`;\r\n                break;\r\n            case CurveBlockTypes.EaseInOutQuad: {\r\n                const entry = state._generateTernary(\"2.0 * VAL * VAL\", \"1.0 - pow(-2.0 * VAL + 2.0, 2.0) / 2.0\", \"VAL < 0.5\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInCubic:\r\n                registeredFunction = `return v * v * v`;\r\n                break;\r\n            case CurveBlockTypes.EaseOutCubic: {\r\n                const entry = \"1.0 - pow(1.0 - VAL, 3.0)\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutCubic: {\r\n                const entry = state._generateTernary(\"4.0 * VAL * VAL * VAL\", \"1.0 - pow(-2.0 * VAL + 2.0, 3.0) / 2.0\", \"VAL < 0.5\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInQuart:\r\n                registeredFunction = `return v * v * v * v`;\r\n                break;\r\n            case CurveBlockTypes.EaseOutQuart: {\r\n                const entry = \"1.0 - pow(1.0 - VAL, 4.0)\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutQuart: {\r\n                const entry = state._generateTernary(\"8.0 * VAL * VAL * VAL * VAL\", \"1.0 - pow(-2.0 * VAL + 2.0, 4.0) / 2.0\", \"VAL < 0.5\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInQuint:\r\n                registeredFunction = `return v * v * v * v * v`;\r\n                break;\r\n            case CurveBlockTypes.EaseOutQuint: {\r\n                const entry = \"1.0 - pow(1.0 - VAL, 5.0)\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutQuint: {\r\n                const entry = state._generateTernary(\"16.0 * VAL * VAL * VAL * VAL * VAL\", \"1.0 - pow(-2.0 * VAL + 2.0, 5.0) / 2.0\", \"VAL < 0.5\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInExpo: {\r\n                const entry = state._generateTernary(\"0.0\", \"pow(2.0, 10.0 * VAL - 10.0)\", \"VAL == 0.0\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseOutExpo: {\r\n                const entry = state._generateTernary(\"1.0\", \"1.0 - pow(2.0, -10.0 * VAL)\", \"VAL == 1.0\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutExpo: {\r\n                const entry = state._generateTernary(\r\n                    \"0.0\",\r\n                    state._generateTernary(\r\n                        \"1.0\",\r\n                        state._generateTernary(\"pow(2.0, 20.0 * VAL - 10.0) / 2.0\", \"(2.0 - pow(2.0, -20.0 * VAL + 10.0)) / 2.0\", \"VAL < 0.5\"),\r\n                        \"VAL == 1.0\"\r\n                    ),\r\n                    \"VAL == 0.0\"\r\n                );\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInCirc: {\r\n                const entry = \"1.0 - sqrt(1.0 - pow(VAL, 2.0))\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseOutCirc: {\r\n                const entry = \"sqrt(1.0 - pow(VAL - 1.0, 2.0))\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutCirc: {\r\n                const entry = state._generateTernary(\"(1.0 - sqrt(1.0 - pow(2.0 * VAL, 2.0))) / 2.0\", \"(sqrt(1.0 - pow(-2.0 * VAL + 2.0, 2.0)) + 1.0) / 2.0\", \"VAL < 0.5\");\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInBack: {\r\n                registeredFunction = \"return 2.70158 * v * v * v - 1.70158 * v * v\";\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseOutBack: {\r\n                const entry = \"2.70158 * pow(VAL - 1.0, 3.0) + 1.70158 * pow(VAL - 1.0, 2.0)\";\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutBack: {\r\n                const entry = state._generateTernary(\r\n                    \"(pow(2.0 * VAL, 2.0) * ((3.5949095) * 2.0 * VAL - 2.5949095)) / 2.0\",\r\n                    \"(pow(2.0 * VAL - 2.0, 2.0) * (3.5949095 * (VAL * 2.0 - 2.0) + 3.5949095) + 2.0) / 2.0\",\r\n                    \"VAL < 0.5\"\r\n                );\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInElastic: {\r\n                const entry = state._generateTernary(\r\n                    \"0.0\",\r\n                    state._generateTernary(\"1.0\", \"-pow(2.0, 10.0 * VAL - 10.0) * sin((VAL * 10.0 - 10.75) * ((2.0 * 3.1415) / 3.0))\", \"VAL == 1.0\"),\r\n                    \"VAL == 0.0\"\r\n                );\r\n\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseOutElastic: {\r\n                const entry = state._generateTernary(\r\n                    \"0.0\",\r\n                    state._generateTernary(\"1.0\", \"pow(2.0, -10.0 * VAL) * sin((VAL * 10.0 - 0.75) * ((2.0 * 3.1415) / 3.0)) + 1.0\", \"VAL == 1.0\"),\r\n                    \"VAL == 0.0\"\r\n                );\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n            case CurveBlockTypes.EaseInOutElastic: {\r\n                const entry = state._generateTernary(\r\n                    \"0.0\",\r\n                    state._generateTernary(\r\n                        \"1.0\",\r\n                        state._generateTernary(\r\n                            \"-(pow(2.0, 20.0 * VAL - 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0\",\r\n                            \"(pow(2.0, -20.0 * VAL + 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0 + 1.0\",\r\n                            \"VAL < 0.5\"\r\n                        ),\r\n                        \"VAL == 1.0\"\r\n                    ),\r\n                    \"VAL == 0.0\"\r\n                );\r\n\r\n                registeredFunction = this._duplicateVector(entry, inputType, isWGSL);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (isWGSL) {\r\n            state._emitFunction(registeredFunctionName, `fn ${registeredFunctionName}(v: ${inputType}) -> ${inputType}  {${registeredFunction};}\\n`, \"\");\r\n        } else {\r\n            state._emitFunction(registeredFunctionName, `${inputType} ${registeredFunctionName}(${inputType} v) {${registeredFunction};}\\n`, \"\");\r\n        }\r\n\r\n        state.compilationString += state._declareOutput(output) + ` = ${registeredFunctionName}(${this.input.associatedVariableName});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.curveType = this.type;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.type = serializationObject.curveType;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.type = BABYLON.CurveBlockTypes.${CurveBlockTypes[this.type]};\\n`;\r\n        return codeString;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CurveBlock\", CurveBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to apply rgb/hsl convertions\r\n */\r\nexport class ColorConverterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ColorConverterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n        this.registerInput(\"hsl \", NodeMaterialBlockConnectionPointTypes.Color3, true);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"hsl\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"ColorConverterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb value (input)\r\n     */\r\n    public get rgbIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the hsl value (input)\r\n     */\r\n    public get hslIn(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb value (output)\r\n     */\r\n    public get rgbOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the hsl value (output)\r\n     */\r\n    public get hslOut(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected override _inputRename(name: string) {\r\n        if (name === \"rgb \") {\r\n            return \"rgbIn\";\r\n        }\r\n        if (name === \"hsl \") {\r\n            return \"hslIn\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _outputRename(name: string) {\r\n        if (name === \"rgb\") {\r\n            return \"rgbOut\";\r\n        }\r\n        if (name === \"hsl\") {\r\n            return \"hslOut\";\r\n        }\r\n        return name;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const rgbInput = this.rgbIn;\r\n        const hslInput = this.hslIn;\r\n\r\n        const rbgOutput = this._outputs[0];\r\n        const hslOutput = this._outputs[1];\r\n\r\n        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n\r\n        let rgb2hsl = `\r\n            vec3 rgb2hsl(vec3 color) {\r\n                float r = color.r;\r\n                float g = color.g;\r\n                float b = color.b;\r\n\r\n                float maxc = max(r, max(g, b));\r\n                float minc = min(r, min(g, b));\r\n                float h = 0.0;\r\n                float s = 0.0;\r\n                float l = (maxc + minc) / 2.0;\r\n\r\n                if (maxc != minc) {\r\n                    float d = maxc - minc;\r\n                    if (l > 0.5) {\r\n                        s = d / (2.0 - maxc - minc);\r\n                    } else {\r\n                        s = d / (maxc + minc);\r\n                    }\r\n\r\n                    if (maxc == r) {\r\n                        float add = 0.0;\r\n                        if (g < b) {\r\n                            add = 6.0;\r\n                        }\r\n                        h = (g - b) / d + add;\r\n                    } else if (maxc == g) {\r\n                        h = (b - r) / d + 2.0;\r\n                    } else if (maxc == b) {\r\n                        h = (r - g) / d + 4.0;\r\n                    }\r\n                    h /= 6.0;\r\n                }\r\n\r\n                return vec3(h, s, l);\r\n            }`;\r\n\r\n        let hue2rgb = `\r\n            float hue2rgb(float p, float q, float tt) {\r\n                float t = tt;\r\n                if (t < 0.0) {\r\n                    t += 1.0;\r\n                }\r\n                if (t > 1.0) {\r\n                    t -= 1.0;\r\n                }\r\n                if (t < 1.0/6.0) {\r\n                    return p + (q - p) * 6.0 * t;\r\n                }\r\n                if (t < 1.0/2.0) {\r\n                    return q;\r\n                }\r\n                if (t < 2.0/3.0) {\r\n                    return p + (q - p) * (2.0/3.0 - t) * 6.0;\r\n                }\r\n                return p;\r\n            }`;\r\n\r\n        let hsl2rgb = `\r\n            vec3 hsl2rgb(vec3 hsl) {\r\n                float h = hsl.x;\r\n                float s = hsl.y;\r\n                float l = hsl.z;\r\n\r\n                float r;\r\n                float g;\r\n                float b;\r\n\r\n                if (s == 0.0) {\r\n                    // Achromatic (grey)\r\n                    r = l;\r\n                    g = l;\r\n                    b = l; \r\n                } else {\r\n                    float q;\r\n                \r\n                    if (l < 0.5) {\r\n                        q = l * (1.0 + s);\r\n                    } else {\r\n                        q = (l + s - l * s);\r\n                    }\r\n\r\n                    float p = 2.0 * l - q;\r\n\r\n                    r = hue2rgb(p, q, h + 1.0/3.0);\r\n                    g = hue2rgb(p, q, h);\r\n                    b = hue2rgb(p, q, h - 1.0/3.0);\r\n                }\r\n\r\n                return vec3(r, g, b);\r\n            }`;\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            rgb2hsl = state._babylonSLtoWGSL(rgb2hsl);\r\n            hue2rgb = state._babylonSLtoWGSL(hue2rgb);\r\n            hsl2rgb = state._babylonSLtoWGSL(hsl2rgb);\r\n        }\r\n\r\n        state._emitFunction(\"rgb2hsl\", rgb2hsl, \"\");\r\n        state._emitFunction(\"hue2rgb\", hue2rgb, \"\");\r\n        state._emitFunction(\"hsl2rgb\", hsl2rgb, \"\");\r\n\r\n        if (rgbInput.isConnected) {\r\n            if (rbgOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(rbgOutput) + ` = ${rgbInput.associatedVariableName};\\n`;\r\n            }\r\n\r\n            if (hslOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(hslOutput) + ` = rgb2hsl(${rgbInput.associatedVariableName});\\n`;\r\n            }\r\n        } else if (hslInput.isConnected) {\r\n            if (rbgOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(rbgOutput) + ` = hsl2rgb(${hslInput.associatedVariableName});\\n`;\r\n            }\r\n            if (hslOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(hslOutput) + ` = ${hslInput.associatedVariableName};\\n`;\r\n            }\r\n        } else {\r\n            if (rbgOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(rbgOutput) + ` =  ${vec3}(0.);\\n`;\r\n            }\r\n\r\n            if (hslOutput.hasEndpoints) {\r\n                state.compilationString += state._declareOutput(hslOutput) + ` =  ${vec3}(0.);\\n`;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorConverterBlock\", ColorConverterBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\n/**\r\n * Block used to repeat code\r\n */\r\nexport class LoopBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Gets or sets number of iterations\r\n     * Will be ignored if the iterations input is connected\r\n     */\r\n    @editableInPropertyPage(\"Iterations\", PropertyTypeForEdition.Int, undefined, { embedded: true })\r\n    public iterations = 4;\r\n\r\n    /**\r\n     * Creates a new LoopBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.registerInput(\"iterations\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.BasedOnInput);\r\n        this.registerOutput(\"index\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\r\n            \"loopID\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            undefined,\r\n            new NodeMaterialConnectionPointCustomObject(\"loopID\", this, NodeMaterialConnectionPointDirection.Output, LoopBlock, \"LoopBlock\")\r\n        );\r\n\r\n        this._outputs[0]._typeConnectionSource = this._inputs[0];\r\n        this._outputs[0]._forPostBuild = true;\r\n\r\n        this._outputs[2]._redirectedSource = this._inputs[0];\r\n\r\n        this._outputs[1]._preventBubbleUp = true;\r\n        this._outputs[2]._preventBubbleUp = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"LoopBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the main input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the iterations input component\r\n     */\r\n    public get iterationsInput(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the index component which will be incremented at each iteration\r\n     */\r\n    public get index(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the loop ID component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get loopID(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const output = this._outputs[0];\r\n        const index = this._outputs[1];\r\n\r\n        const indexName = state._getFreeVariableName(\"index\");\r\n\r\n        const decl = state.shaderLanguage === ShaderLanguage.WGSL ? \"var\" : \"int\";\r\n        const castFloat = state.shaderLanguage === ShaderLanguage.WGSL ? \"f32\" : \"float\";\r\n        const castInt = state.shaderLanguage === ShaderLanguage.WGSL ? \"i32\" : \"int\";\r\n\r\n        // Declare storage variable and store initial value\r\n        state.compilationString += state._declareOutput(output) + ` = ${this.input.associatedVariableName};\\n`;\r\n\r\n        // Iterations\r\n        const iterations = this.iterationsInput.isConnected ? `${castInt}(${this.iterationsInput.associatedVariableName})` : this.iterations;\r\n\r\n        // Loop\r\n        state.compilationString += `for (${decl} ${indexName} = 0; ${indexName} < ${iterations}; ${indexName}++){\\n`;\r\n        state.compilationString += `${state._declareOutput(index)} = ${castFloat}(${indexName});\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _postBuildBlock(state: NodeMaterialBuildState) {\r\n        super._postBuildBlock(state);\r\n\r\n        state.compilationString += `}\\n`;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected override _dumpPropertiesCode() {\r\n        return super._dumpPropertiesCode() + `${this._codeVariableName}.iterations = ${this.iterations};\\n`;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.iterations = this.iterations;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.iterations = serializationObject.iterations;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LoopBlock\", LoopBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialConnectionPointDirection, type NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { LoopBlock } from \"./loopBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\n/**\r\n * Block used to read from a variable within a loop\r\n */\r\nexport class StorageReadBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new StorageReadBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\r\n            \"loopID\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            false,\r\n            undefined,\r\n            new NodeMaterialConnectionPointCustomObject(\"loopID\", this, NodeMaterialConnectionPointDirection.Input, LoopBlock, \"LoopBlock\")\r\n        );\r\n        this.registerOutput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n\r\n        this._outputs[0]._linkedConnectionSource = this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"StorageReadBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the loop link component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get loopID(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the value component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const value = this.value;\r\n\r\n        if (!this.loopID.isConnected) {\r\n            return this;\r\n        }\r\n\r\n        const loopBlock = this.loopID.connectedPoint!.ownerBlock as LoopBlock;\r\n\r\n        state.compilationString += state._declareOutput(value) + ` = ${loopBlock.output.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StorageReadBlock\", StorageReadBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialConnectionPointDirection, type NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { LoopBlock } from \"./loopBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\n/**\r\n * Block used to write to a variable within a loop\r\n */\r\nexport class StorageWriteBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new StorageWriteBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\r\n            \"loopID\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            false,\r\n            undefined,\r\n            new NodeMaterialConnectionPointCustomObject(\"loopID\", this, NodeMaterialConnectionPointDirection.Input, LoopBlock, \"LoopBlock\")\r\n        );\r\n        this.registerInput(\"value\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n\r\n        this._linkConnectionTypes(0, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"StorageWriteBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the loop link component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get loopID(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the value component\r\n     */\r\n    public get value(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader\r\n     * @returns true if connected in fragment shader\r\n     */\r\n    public override isConnectedInFragmentShader() {\r\n        if (!this.loopID.isConnected) {\r\n            return false;\r\n        }\r\n        const loopBlock = this.loopID.connectedPoint!.ownerBlock as LoopBlock;\r\n\r\n        return loopBlock.output.isConnectedInFragmentShader;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const value = this.value;\r\n\r\n        if (!this.loopID.isConnected) {\r\n            return this;\r\n        }\r\n\r\n        const loopBlock = this.loopID.connectedPoint!.ownerBlock as LoopBlock;\r\n\r\n        state.compilationString += `${loopBlock.output.associatedVariableName} = ${value.associatedVariableName};\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StorageWriteBlock\", StorageWriteBlock);\r\n", "import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used to split a matrix into Vector4\r\n */\r\nexport class MatrixSplitterBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new MatrixSplitterBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Matrix);\r\n        this.registerOutput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"row3\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"col0\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"col1\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"col2\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"col3\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"MatrixSplitterBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the input component\r\n     */\r\n    public get input(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the row0 output vector\r\n     */\r\n    public get row0(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the row1 output vector\r\n     */\r\n    public get row1(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the row2 output vector\r\n     */\r\n    public get row2(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the row3 output vector\r\n     */\r\n    public get row3(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the col0 output vector\r\n     */\r\n    public get col0(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the col1 output vector\r\n     */\r\n    public get col1(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the col2 output vector\r\n     */\r\n    public get col2(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the col3 output vector\r\n     */\r\n    public get col3(): NodeMaterialConnectionPoint {\r\n        return this._outputs[7];\r\n    }\r\n\r\n    private _exportColumn(state: NodeMaterialBuildState, col: NodeMaterialConnectionPoint, input: string, columnIndex: number) {\r\n        const vec4 = state.shaderLanguage === ShaderLanguage.WGSL ? \"vec4f\" : \"vec4\";\r\n        state.compilationString +=\r\n            state._declareOutput(col) + ` = ${vec4}(${input}[0][${columnIndex}], ${input}[1][${columnIndex}], ${input}[2][${columnIndex}], ${input}[3][${columnIndex}]);\\n`;\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        const input = this._inputs[0].associatedVariableName;\r\n\r\n        const row0 = this.row0;\r\n        const row1 = this.row1;\r\n        const row2 = this.row2;\r\n        const row3 = this.row3;\r\n        const col0 = this.col0;\r\n        const col1 = this.col1;\r\n        const col2 = this.col2;\r\n        const col3 = this.col3;\r\n\r\n        if (row0.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(row0) + ` = ${input}[0];\\n`;\r\n        }\r\n        if (row1.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(row1) + ` = ${input}[1];\\n`;\r\n        }\r\n        if (row2.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(row2) + ` = ${input}[2];\\n`;\r\n        }\r\n        if (row3.hasEndpoints) {\r\n            state.compilationString += state._declareOutput(row3) + ` = ${input}[3];\\n`;\r\n        }\r\n\r\n        if (col0.hasEndpoints) {\r\n            this._exportColumn(state, col0, input, 0);\r\n        }\r\n        if (col1.hasEndpoints) {\r\n            this._exportColumn(state, col1, input, 1);\r\n        }\r\n        if (col2.hasEndpoints) {\r\n            this._exportColumn(state, col2, input, 2);\r\n        }\r\n        if (col3.hasEndpoints) {\r\n            this._exportColumn(state, col3, input, 3);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MatrixSplitterBlock\", MatrixSplitterBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { VertexBuffer } from \"core/Meshes/buffer\";\r\nimport type { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\n\r\n/**\r\n * Block used for the Gaussian Splatting\r\n */\r\nexport class GaussianSplattingBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new GaussianSplattingBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"splatPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"splatScale\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"projection\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerOutput(\"splatVertex\", NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockTargets.Vertex);\r\n        this.registerOutput(\"SH\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Vertex);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"GaussianSplattingBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get splatPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the scale input component\r\n     */\r\n    public get splatScale(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the View matrix input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the View matrix input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the projection matrix input component\r\n     */\r\n    public get projection(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the splatVertex output component\r\n     */\r\n    public get splatVertex(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the SH output contribution\r\n     */\r\n    public get SH(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"focal\");\r\n        state._excludeVariableName(\"invViewport\");\r\n        state._excludeVariableName(\"kernelSize\");\r\n        state._excludeVariableName(\"eyePosition\");\r\n    }\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param defines defines the material defines to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param mesh defines the mesh to be rendered\r\n     */\r\n    public override prepareDefines(defines: NodeMaterialDefines, nodeMaterial: NodeMaterial, mesh?: AbstractMesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if (mesh.getClassName() == \"GaussianSplattingMesh\") {\r\n            defines.setValue(\"SH_DEGREE\", (<GaussianSplattingMesh>mesh).shDegree, true);\r\n        }\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            return;\r\n        }\r\n\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"gaussianSplattingVertexDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"gaussianSplatting\", comments);\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitUniformFromString(\"focal\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        state._emitUniformFromString(\"invViewport\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        state._emitUniformFromString(\"kernelSize\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        state._emitUniformFromString(\"eyePosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state._emitUniformFromString(\"viewDirectionFactor\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        state.attributes.push(VertexBuffer.PositionKind);\r\n        state.attributes.push(\"splatIndex0\");\r\n        state.attributes.push(\"splatIndex1\");\r\n        state.attributes.push(\"splatIndex2\");\r\n        state.attributes.push(\"splatIndex3\");\r\n        state.sharedData.nodeMaterial.backFaceCulling = false;\r\n\r\n        const splatPosition = this.splatPosition;\r\n        const splatScale = this.splatScale;\r\n        const world = this.world;\r\n        const view = this.view;\r\n        const projection = this.projection;\r\n        const output = this.splatVertex;\r\n        const sh = this.SH;\r\n\r\n        const addF = state.fSuffix;\r\n        let splatScaleParameter = `vec2${addF}(1.,1.)`;\r\n        if (splatScale.isConnected) {\r\n            splatScaleParameter = splatScale.associatedVariableName;\r\n        }\r\n\r\n        let input = \"position\";\r\n        let uniforms = \"\";\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            input = \"input.position\";\r\n            uniforms = \", uniforms.focal, uniforms.invViewport, uniforms.kernelSize\";\r\n        }\r\n        if (this.SH.isConnected) {\r\n            state.compilationString += `#if SH_DEGREE > 0\\n`;\r\n\r\n            if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n                state.compilationString += `let worldRot: mat3x3f =  mat3x3f(${world.associatedVariableName}[0].xyz, ${world.associatedVariableName}[1].xyz, ${world.associatedVariableName}[2].xyz);`;\r\n                state.compilationString += `let normWorldRot: mat3x3f = inverseMat3(worldRot);`;\r\n                state.compilationString += `var dir: vec3f = normalize(normWorldRot * (${splatPosition.associatedVariableName}.xyz - uniforms.eyePosition));\\n`;\r\n                state.compilationString += `dir *= uniforms.viewDirectionFactor;\\n`;\r\n            } else {\r\n                state.compilationString += `mat3 worldRot = mat3(${world.associatedVariableName});`;\r\n                state.compilationString += `mat3 normWorldRot = inverseMat3(worldRot);`;\r\n                state.compilationString += `vec3 dir = normalize(normWorldRot * (${splatPosition.associatedVariableName}.xyz - eyePosition));\\n`;\r\n                state.compilationString += `dir *= viewDirectionFactor;\\n`;\r\n            }\r\n\r\n            state.compilationString += `${state._declareOutput(sh)} = computeSH(splat, dir);\\n`;\r\n            state.compilationString += `#else\\n`;\r\n            state.compilationString += `${state._declareOutput(sh)} = vec3${addF}(0.,0.,0.);\\n`;\r\n            state.compilationString += `#endif;\\n`;\r\n        } else {\r\n            state.compilationString += `${state._declareOutput(sh)} = vec3${addF}(0.,0.,0.);`;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(output)} = gaussianSplatting(${input}.xy, ${splatPosition.associatedVariableName}, ${splatScaleParameter}, covA, covB, ${world.associatedVariableName}, ${view.associatedVariableName}, ${projection.associatedVariableName}${uniforms});\\n`;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingBlock\", GaussianSplattingBlock);\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Material } from \"./material\";\r\nimport type { IEffectCreationOptions } from \"./effect\";\r\nimport { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Node } from \"../node\";\r\nimport type { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n/**\r\n * Options to be used when creating a shadow depth material\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface IIOptionShadowDepthMaterial {\r\n    /** Variables in the vertex shader code that need to have their names remapped.\r\n     * The format is: [\"var_name\", \"var_remapped_name\", \"var_name\", \"var_remapped_name\", ...]\r\n     * \"var_name\" should be either: worldPos or vNormalW\r\n     * So, if the variable holding the world position in your vertex shader is not named worldPos, you must tell the system\r\n     * the name to use instead by using: [\"worldPos\", \"myWorldPosVar\"] assuming the variable is named myWorldPosVar in your code.\r\n     * If the normal must also be remapped: [\"worldPos\", \"myWorldPosVar\", \"vNormalW\", \"myWorldNormal\"]\r\n     */\r\n    remappedVariables?: string[];\r\n\r\n    /** Set standalone to true if the base material wrapped by ShadowDepthMaterial is not used for a regular object but for depth shadow generation only */\r\n    standalone?: boolean;\r\n\r\n    /** Set doNotInjectCode if the specific shadow map generation code is already implemented by the material. That will prevent this code to be injected twice by ShadowDepthWrapper */\r\n    doNotInjectCode?: boolean;\r\n}\r\n\r\nclass MapMap<Ka, Kb, V> {\r\n    readonly mm = new Map<Ka, Map<Kb, V>>();\r\n\r\n    get(a: Ka, b: Kb): V | undefined {\r\n        const m = this.mm.get(a);\r\n        if (m !== undefined) {\r\n            return m.get(b);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    set(a: Ka, b: Kb, v: V): void {\r\n        let m = this.mm.get(a);\r\n        if (m === undefined) {\r\n            this.mm.set(a, (m = new Map()));\r\n        }\r\n        m.set(b, v);\r\n    }\r\n}\r\n\r\n/**\r\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\r\n */\r\nexport class ShadowDepthWrapper {\r\n    private _scene: Scene;\r\n    private _options?: IIOptionShadowDepthMaterial;\r\n    private _baseMaterial: Material;\r\n    private _onEffectCreatedObserver: Nullable<Observer<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n    private _subMeshToEffect: Map<Nullable<SubMesh>, [Effect, number]>;\r\n    private _subMeshToDepthWrapper: MapMap<\r\n        Nullable<SubMesh>,\r\n        ShadowGenerator,\r\n        { drawWrapper: Array<Nullable<DrawWrapper>>; mainDrawWrapper: DrawWrapper; depthDefines: string; token: string }\r\n    >; // key is (subMesh + shadowGenerator)\r\n    private _meshes: Map<AbstractMesh, Nullable<Observer<Node>>>;\r\n\r\n    /** Gets the standalone status of the wrapper */\r\n    public get standalone(): boolean {\r\n        return this._options?.standalone ?? false;\r\n    }\r\n\r\n    /** Gets the base material the wrapper is built upon */\r\n    public get baseMaterial(): Material {\r\n        return this._baseMaterial;\r\n    }\r\n\r\n    /** Gets the doNotInjectCode status of the wrapper */\r\n    public get doNotInjectCode(): boolean {\r\n        return this._options?.doNotInjectCode ?? false;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new shadow depth wrapper.\r\n     * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\r\n     * generate the shadow depth map. For more information, please refer to the documentation:\r\n     * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n     * @param baseMaterial Material to wrap\r\n     * @param scene Define the scene the material belongs to\r\n     * @param options Options used to create the wrapper\r\n     */\r\n    constructor(baseMaterial: Material, scene?: Scene, options?: IIOptionShadowDepthMaterial) {\r\n        this._baseMaterial = baseMaterial;\r\n        this._scene = scene ?? <Scene>EngineStore.LastCreatedScene;\r\n        this._options = options;\r\n\r\n        this._subMeshToEffect = new Map();\r\n        this._subMeshToDepthWrapper = new MapMap();\r\n        this._meshes = new Map();\r\n\r\n        // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\r\n        // to create the depth effect later on\r\n        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params: { effect: Effect; subMesh: Nullable<SubMesh> }) => {\r\n            const mesh = params.subMesh?.getMesh();\r\n\r\n            if (mesh && !this._meshes.has(mesh)) {\r\n                // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\r\n                this._meshes.set(\r\n                    mesh,\r\n                    mesh.onDisposeObservable.add((mesh: Node) => {\r\n                        const iterator = this._subMeshToEffect.keys();\r\n                        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                            const subMesh = key.value;\r\n                            if (subMesh?.getMesh() === (mesh as AbstractMesh)) {\r\n                                this._subMeshToEffect.delete(subMesh);\r\n                                this._deleteDepthWrapperEffect(subMesh);\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {\r\n                this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);\r\n                this._deleteDepthWrapperEffect(params.subMesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _deleteDepthWrapperEffect(subMesh: Nullable<SubMesh>): void {\r\n        const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);\r\n        if (depthWrapperEntries) {\r\n            // find and release the previous depth effect\r\n            depthWrapperEntries.forEach((depthWrapper) => {\r\n                depthWrapper.mainDrawWrapper.effect?.dispose();\r\n            });\r\n            this._subMeshToDepthWrapper.mm.delete(subMesh); // trigger a depth effect recreation\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the effect to use to generate the depth map\r\n     * @param subMesh subMesh to get the effect for\r\n     * @param shadowGenerator shadow generator to get the effect for\r\n     * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from\r\n     * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\r\n     */\r\n    public getEffect(subMesh: Nullable<SubMesh>, shadowGenerator: ShadowGenerator, passIdForDrawWrapper: number): Nullable<DrawWrapper> {\r\n        const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);\r\n        if (!entry) {\r\n            return null;\r\n        }\r\n        let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];\r\n        if (!drawWrapper) {\r\n            drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());\r\n            drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used for depth rendering\r\n     * @param subMesh submesh to check\r\n     * @param defines the list of defines to take into account when checking the effect\r\n     * @param shadowGenerator combined with subMesh, it defines the effect to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, useInstances: boolean, passIdForDrawWrapper: number): boolean {\r\n        if (this.standalone) {\r\n            // will ensure the effect is (re)created for the base material\r\n            if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources\r\n     */\r\n    public dispose(): void {\r\n        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\r\n        this._onEffectCreatedObserver = null;\r\n\r\n        const iterator = this._meshes.entries();\r\n        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\r\n            const [mesh, observer] = entry.value;\r\n\r\n            mesh.onDisposeObservable.remove(observer);\r\n        }\r\n    }\r\n\r\n    private _makeEffect(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, passIdForDrawWrapper: number): Nullable<Effect> {\r\n        const engine = this._scene.getEngine();\r\n        const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);\r\n\r\n        if (!origEffectAndRenderPassId) {\r\n            return null;\r\n        }\r\n\r\n        const [origEffect, origRenderPassId] = origEffectAndRenderPassId;\r\n\r\n        if (!origEffect.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);\r\n        if (!params) {\r\n            const mainDrawWrapper = new DrawWrapper(engine);\r\n            mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;\r\n\r\n            params = {\r\n                drawWrapper: [],\r\n                mainDrawWrapper,\r\n                depthDefines: \"\",\r\n                token: RandomGUID(),\r\n            };\r\n            params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;\r\n            this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (params.mainDrawWrapper.effect) {\r\n            if (join === params.depthDefines) {\r\n                // we already created the depth effect and it is still up to date for this submesh + shadow generator\r\n                return params.mainDrawWrapper.effect;\r\n            }\r\n        }\r\n\r\n        params.depthDefines = join;\r\n\r\n        const uniforms = origEffect.getUniformNames().slice();\r\n\r\n        // the depth effect is either out of date or has not been created yet\r\n        let vertexCode = origEffect.vertexSourceCodeBeforeMigration,\r\n            fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;\r\n\r\n        if (!vertexCode && !fragmentCode) {\r\n            return null;\r\n        }\r\n\r\n        if (!this.doNotInjectCode) {\r\n            // Declare the shadow map includes\r\n            const vertexNormalBiasCode =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapVertexNormalBias>`,\r\n                vertexMetricCode =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapVertexMetric>`,\r\n                fragmentSoftTransparentShadow =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapFragmentSoftTransparentShadow>`,\r\n                fragmentBlockCode = `#include<shadowMapFragment>`,\r\n                vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;\r\n\r\n            // vertex code\r\n            if (origEffect.shaderLanguage === ShaderLanguage.GLSL) {\r\n                vertexCode = vertexCode.replace(/void\\s+?main/g, `\\n${vertexExtraDeclartion}\\nvoid main`);\r\n            } else {\r\n                vertexCode = vertexCode.replace(/@vertex/g, `\\n${vertexExtraDeclartion}\\n@vertex`);\r\n            }\r\n            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\r\n\r\n            if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\r\n                vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\r\n            } else {\r\n                vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\n}\");\r\n            }\r\n            vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\r\n\r\n            // fragment code\r\n            const hasLocationForSoftTransparentShadow =\r\n                fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\r\n            const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\r\n\r\n            let fragmentCodeToInjectAtEnd = \"\";\r\n\r\n            if (!hasLocationForSoftTransparentShadow) {\r\n                fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\n\";\r\n            } else {\r\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\r\n            }\r\n\r\n            fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentExtraDeclaration\"] + \"\\nvoid main\");\r\n\r\n            if (hasLocationForFragment) {\r\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\r\n            } else {\r\n                fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\n\";\r\n            }\r\n            if (fragmentCodeToInjectAtEnd) {\r\n                fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\r\n            }\r\n\r\n            uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\r\n        }\r\n\r\n        params.mainDrawWrapper.effect = engine.createEffect(\r\n            {\r\n                vertexSource: vertexCode,\r\n                fragmentSource: fragmentCode,\r\n                vertexToken: params.token,\r\n                fragmentToken: params.token,\r\n            },\r\n            <IEffectCreationOptions>{\r\n                attributes: origEffect.getAttributesNames(),\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: origEffect.getUniformBuffersNames(),\r\n                samplers: origEffect.getSamplers(),\r\n                defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\r\n                indexParameters: origEffect.getIndexParameters(),\r\n                shaderLanguage: origEffect.shaderLanguage,\r\n            },\r\n            engine\r\n        );\r\n\r\n        for (let id = 0; id < params.drawWrapper.length; ++id) {\r\n            if (id !== passIdForDrawWrapper) {\r\n                params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);\r\n            }\r\n        }\r\n        return params.mainDrawWrapper.effect;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec4 vColor;void main(void) {float A=-dot(vPosition,vPosition);\n#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1\nfloat alpha=exp(A)*vColor.a;if (A<-4.) discard;\n#else\nif (A<-1.) discard;\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\n\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\nuniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec2 vPosition;varying vec4 vColor;\n#include<gaussianSplatting>\nvoid main(void) {float splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPosGS=world*vec4(splat.center.xyz,1.0);vPosition=position.xy;vColor=splat.color;gl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,world,view,projection);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration\";\n\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `#include<gaussianSplattingFragmentDeclaration>\n#include<shadowMapFragmentExtraDeclaration>\nvarying vPosition: vec2f;varying vColor: vec4f;fn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;\n#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1\nif (A<-4.) {discard;}\n#else\nif (A<-1.) {discard;}\n#endif\nreturn vec4f(inColor.rgb,alpha);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);\n#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1\nvar alpha : f32=fragmentOutputs.color.a;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShaderWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\n\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;varying vPosition: vec2f;varying vColor: vec4f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShaderWGSL = { name, shader };\n", "import type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport type { GaussianSplattingMesh } from \"../../Meshes\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { ShadowDepthWrapper } from \"../../Materials/shadowDepthWrapper\";\r\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\r\n\r\nimport \"../../Shaders/gaussianSplatting.fragment\";\r\nimport \"../../Shaders/gaussianSplatting.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\r\nimport \"../../Shaders/gaussianSplattingDepth.fragment\";\r\nimport \"../../Shaders/gaussianSplattingDepth.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplattingDepth.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplattingDepth.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\r\n    public FOG = false;\r\n    public THIN_INSTANCES = true;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public SH_DEGREE = 0;\r\n    public COMPENSATION = false;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * GaussianSplattingMaterial material used to render Gaussian Splatting\r\n * @experimental\r\n */\r\nexport class GaussianSplattingMaterial extends PushMaterial {\r\n    /**\r\n     * Instantiates a Gaussian Splatting Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.backFaceCulling = false;\r\n        this.shadowDepthWrapper = GaussianSplattingMaterial._MakeGaussianSplattingShadowDepthWrapper(scene!, this.shaderLanguage);\r\n    }\r\n\r\n    /**\r\n     * Point spread function (default 0.3). Can be overriden per GS material\r\n     */\r\n    public static KernelSize: number = 0.3;\r\n\r\n    /**\r\n     * Compensation\r\n     */\r\n    public static Compensation: boolean = false;\r\n\r\n    /**\r\n     * Point spread function (default 0.3). Can be overriden per GS material, otherwise, using default static `KernelSize` value\r\n     */\r\n    public kernelSize = GaussianSplattingMaterial.KernelSize;\r\n    private _compensation = GaussianSplattingMaterial.Compensation;\r\n\r\n    // set to true when material defines are dirty\r\n    private _isDirty = false;\r\n\r\n    /**\r\n     * Set compensation default value is `GaussianSplattingMaterial.Compensation`\r\n     */\r\n    public set compensation(value: boolean) {\r\n        this._isDirty = this._isDirty != value;\r\n        this._compensation = value;\r\n    }\r\n\r\n    /**\r\n     * Get compensation\r\n     */\r\n    public get compensation(): boolean {\r\n        return this._compensation;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns false\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns true\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected static _Attribs = [VertexBuffer.PositionKind, \"splatIndex0\", \"splatIndex1\", \"splatIndex2\", \"splatIndex3\"];\r\n    protected static _Samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\r\n    protected static _UniformBuffers = [\"Scene\", \"Mesh\"];\r\n    protected static _Uniforms = [\r\n        \"world\",\r\n        \"view\",\r\n        \"projection\",\r\n        \"vFogInfos\",\r\n        \"vFogColor\",\r\n        \"logarithmicDepthConstant\",\r\n        \"invViewport\",\r\n        \"dataTextureSize\",\r\n        \"focal\",\r\n        \"eyePosition\",\r\n        \"kernelSize\",\r\n        \"viewDirectionFactor\",\r\n    ];\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const useInstances = true;\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n        let defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (defines && this._isDirty) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(\r\n            mesh,\r\n            scene,\r\n            this._useLogarithmicDepth,\r\n            this.pointsCloud,\r\n            this.fogEnabled,\r\n            false,\r\n            defines,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this._isVertexOutputInvariant\r\n        );\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, false);\r\n\r\n        // SH is disabled for webGL1\r\n        if (engine.version > 1 || engine.isWebGPU) {\r\n            defines[\"SH_DEGREE\"] = gsMesh.shDegree;\r\n        }\r\n\r\n        // Compensation\r\n        const splatMaterial = gsMesh.material as GaussianSplattingMaterial;\r\n        defines[\"COMPENSATION\"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : GaussianSplattingMaterial.Compensation;\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            PrepareAttributesForInstances(GaussianSplattingMaterial._Attribs, defines);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: GaussianSplattingMaterial._Uniforms,\r\n                uniformBuffersNames: GaussianSplattingMaterial._UniformBuffers,\r\n                samplers: GaussianSplattingMaterial._Samplers,\r\n                defines: defines,\r\n            });\r\n\r\n            AddClipPlaneUniforms(GaussianSplattingMaterial._Uniforms);\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"gaussianSplatting\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: GaussianSplattingMaterial._Attribs,\r\n                    uniformsNames: GaussianSplattingMaterial._Uniforms,\r\n                    uniformBuffersNames: GaussianSplattingMaterial._UniformBuffers,\r\n                    samplers: GaussianSplattingMaterial._Samplers,\r\n                    defines: join,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: {},\r\n                    shaderLanguage: this._shaderLanguage,\r\n                    extraInitializationsAsync: async () => {\r\n                        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\r\n                        }\r\n                    },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n        this._isDirty = false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind material effect for a specific Gaussian Splatting mesh\r\n     * @param mesh Gaussian splatting mesh\r\n     * @param effect Splatting material or node material\r\n     * @param scene scene that contains mesh and camera used for rendering\r\n     */\r\n    public static BindEffect(mesh: Mesh, effect: Effect, scene: Scene): void {\r\n        const engine = scene.getEngine();\r\n        const camera = scene.activeCamera;\r\n\r\n        const renderWidth = engine.getRenderWidth();\r\n        const renderHeight = engine.getRenderHeight();\r\n\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n        const gsMaterial = gsMesh.material as GaussianSplattingMaterial;\r\n\r\n        // check if rigcamera, get number of rigs\r\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\r\n\r\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\r\n\r\n        let focal = 1000;\r\n\r\n        if (camera) {\r\n            /*\r\n            more explicit version:\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            const FovY = Math.atan(1.0 / t) * 2.0;\r\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\r\n            Using a shorter version here to not have tan(atan) and 2.0 factor\r\n            */\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\r\n                focal = (renderHeight * t) / 2.0;\r\n            } else {\r\n                focal = (renderWidth * t) / 2.0;\r\n            }\r\n        }\r\n\r\n        effect.setFloat2(\"focal\", focal, focal);\r\n        effect.setVector3(\"viewDirectionFactor\", gsMesh.viewDirectionFactor);\r\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\r\n        scene.bindEyePosition(effect, \"eyePosition\", true);\r\n\r\n        if (gsMesh.covariancesATexture) {\r\n            const textureSize = gsMesh.covariancesATexture.getSize();\r\n\r\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n\r\n            if (gsMesh.shTextures) {\r\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\r\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Bind data\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            this.bindView(effect);\r\n            this.bindViewProjection(effect);\r\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, effect);\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth) {\r\n            BindLogDepth(defines, effect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    protected static _MakeGaussianSplattingShadowDepthWrapper(scene: Scene, shaderLanguage: ShaderLanguage): ShadowDepthWrapper {\r\n        const shaderMaterial = new ShaderMaterial(\r\n            \"gaussianSplattingDepth\",\r\n            scene,\r\n            {\r\n                vertex: \"gaussianSplattingDepth\",\r\n                fragment: \"gaussianSplattingDepth\",\r\n            },\r\n            {\r\n                attributes: GaussianSplattingMaterial._Attribs,\r\n                uniforms: GaussianSplattingMaterial._Uniforms,\r\n                samplers: GaussianSplattingMaterial._Samplers,\r\n                uniformBuffers: GaussianSplattingMaterial._UniformBuffers,\r\n                shaderLanguage: shaderLanguage,\r\n            }\r\n        );\r\n\r\n        const shadowDepthWrapper = new ShadowDepthWrapper(shaderMaterial, scene, {\r\n            standalone: true,\r\n        });\r\n\r\n        shaderMaterial.onBindObservable.add((mesh: AbstractMesh) => {\r\n            const effect = shaderMaterial.getEffect()!;\r\n            const gsMaterial = mesh.material as GaussianSplattingMaterial;\r\n            const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n            shaderMaterial.bindView(effect);\r\n            shaderMaterial.bindViewProjection(effect);\r\n\r\n            const shadowmapWidth = scene.getEngine().getRenderWidth();\r\n            const shadowmapHeight = scene.getEngine().getRenderHeight();\r\n            effect.setFloat2(\"invViewport\", 1 / shadowmapWidth, 1 / shadowmapHeight);\r\n\r\n            const projection = scene.getProjectionMatrix();\r\n            const t = projection.m[5];\r\n            const focal = (shadowmapWidth * t) / 2.0;\r\n\r\n            effect.setFloat2(\"focal\", focal, focal);\r\n            effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\r\n\r\n            if (gsMesh.covariancesATexture) {\r\n                const textureSize = gsMesh.covariancesATexture.getSize();\r\n                effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n                effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n                effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n                effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n                effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n            }\r\n        });\r\n\r\n        return shadowDepthWrapper;\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public override clone(name: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"GaussianSplattingMaterial\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a Gaussian Splatting material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated GaussianSplattingMaterial.\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Effect } from \"core/Materials/effect\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used for Reading components of the Gaussian Splatting\r\n */\r\nexport class SplatReaderBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new SplatReaderBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"splatIndex\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerOutput(\"splatPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Vertex);\r\n        this.registerOutput(\"splatColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Vertex);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"SplatReaderBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the splat index input component\r\n     */\r\n    public get splatIndex(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the splatPosition output component\r\n     */\r\n    public get splatPosition(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the splatColor output component\r\n     */\r\n    public get splatColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"covA\");\r\n        state._excludeVariableName(\"covB\");\r\n        state._excludeVariableName(\"vPosition\");\r\n        state._excludeVariableName(\"covariancesATexture\");\r\n        state._excludeVariableName(\"covariancesBTexture\");\r\n        state._excludeVariableName(\"centersTexture\");\r\n        state._excludeVariableName(\"colorsTexture\");\r\n        state._excludeVariableName(\"dataTextureSize\");\r\n    }\r\n\r\n    public override bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n        const scene = mesh.getScene();\r\n        GaussianSplattingMaterial.BindEffect(mesh, effect, scene);\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            return;\r\n        }\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Emit code\r\n        const comments = `//${this.name}`;\r\n        state._emit2DSampler(\"covariancesATexture\");\r\n        state._emit2DSampler(\"covariancesBTexture\");\r\n        state._emit2DSampler(\"centersTexture\");\r\n        state._emit2DSampler(\"colorsTexture\");\r\n        state._emit2DSampler(\"shTexture0\", \"SH_DEGREE > 0\", undefined, undefined, true, \"highp\");\r\n        state._emit2DSampler(\"shTexture1\", \"SH_DEGREE > 0\", undefined, undefined, true, \"highp\");\r\n        state._emit2DSampler(\"shTexture2\", \"SH_DEGREE > 0\", undefined, undefined, true, \"highp\");\r\n\r\n        state._emitFunctionFromInclude(\"gaussianSplattingVertexDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"gaussianSplatting\", comments);\r\n        state._emitVaryingFromString(\"vPosition\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        state._emitUniformFromString(\"dataTextureSize\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        const splatPosition = this.splatPosition;\r\n        const splatColor = this.splatColor;\r\n\r\n        const splatVariablename = state._getFreeVariableName(\"splat\");\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `let splatIndex: f32 = getSplatIndex(i32(input.position.z + 0.5), input.splatIndex0, input.splatIndex1, input.splatIndex2, input.splatIndex3);`;\r\n            state.compilationString += `var ${splatVariablename}: Splat = readSplat(splatIndex, uniforms.dataTextureSize);\\n`;\r\n            state.compilationString += `var covA: vec3f = splat.covA.xyz; var covB: vec3f = vec3f(splat.covA.w, splat.covB.xy);\\n`;\r\n            state.compilationString += \"vertexOutputs.vPosition = input.position.xy;\\n\";\r\n        } else {\r\n            state.compilationString += `float splatIndex = getSplatIndex(int(position.z + 0.5));`;\r\n            state.compilationString += `Splat ${splatVariablename} = readSplat(splatIndex);\\n`;\r\n            state.compilationString += `vec3 covA = splat.covA.xyz; vec3 covB = vec3(splat.covA.w, splat.covB.xy);\\n`;\r\n            state.compilationString += \"vPosition = position.xy;\\n\";\r\n        }\r\n        state.compilationString += `${state._declareOutput(splatPosition)} = ${splatVariablename}.center.xyz;\\n`;\r\n        state.compilationString += `${state._declareOutput(splatColor)} = ${splatVariablename}.color;\\n`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SplatReaderBlock\", SplatReaderBlock);\r\n", "import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\n/**\r\n * Block used for the Gaussian Splatting Fragment part\r\n */\r\nexport class GaussianBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new GaussianBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"splatColor\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"GaussianBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get splatColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha output component\r\n     */\r\n    public get alpha(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public override initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"vPosition\");\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        // Emit code\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"clipPlaneFragmentDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"logDepthDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"fogFragmentDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"gaussianSplattingFragmentDeclaration\", comments);\r\n        state._emitVaryingFromString(\"vPosition\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n\r\n        const tempSplatColor = state._getFreeVariableName(\"tempSplatColor\");\r\n        const color = this.splatColor;\r\n        const rgba = this._outputs[0];\r\n        const rgb = this._outputs[1];\r\n        const alpha = this._outputs[2];\r\n\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            state.compilationString += `let ${tempSplatColor}:vec4f = gaussianColor(${color.associatedVariableName}, input.vPosition);\\n`;\r\n        } else {\r\n            state.compilationString += `vec4 ${tempSplatColor} = gaussianColor(${color.associatedVariableName});\\n`;\r\n        }\r\n\r\n        state.compilationString += `${state._declareOutput(rgba)} = ${tempSplatColor}.rgba;`;\r\n        state.compilationString += `${state._declareOutput(rgb)} = ${tempSplatColor}.rgb;`;\r\n        state.compilationString += `${state._declareOutput(alpha)} = ${tempSplatColor}.a;`;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianBlock\", GaussianBlock);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"gaussianSplattingVertexDeclaration\";\nconst shader = `attribute position: vec3f;attribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexDeclarationWGSL = { name, shader };\n", "import type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"core/Decorators/nodeDecorator\";\r\n\r\n/**\r\n * Block used to render intermediate debug values\r\n * Please note that the node needs to be active to be generated in the shader\r\n * Only one DebugBlock should be active at a time\r\n */\r\nexport class NodeMaterialDebugBlock extends NodeMaterialBlock {\r\n    private _isActive = false;\r\n\r\n    /** Gets or sets a boolean indicating if we want to render alpha when using a rgba input*/\r\n    @editableInPropertyPage(\"Render Alpha\", PropertyTypeForEdition.Boolean, undefined)\r\n    public renderAlpha = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the block is active\r\n     */\r\n    public get isActive(): boolean {\r\n        return this._isActive && this.debug.isConnected;\r\n    }\r\n\r\n    public set isActive(value: boolean) {\r\n        if (this._isActive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isActive = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeMaterialDebugBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment, true, true);\r\n\r\n        this.registerInput(\"debug\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\r\n\r\n        this.debug.excludedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Matrix);\r\n    }\r\n\r\n    /** @internal */\r\n    public override get _isFinalOutputAndActive() {\r\n        return this.isActive;\r\n    }\r\n\r\n    /** @internal */\r\n    public override get _hasPrecedence() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba input component\r\n     */\r\n    public get debug(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public override getClassName() {\r\n        return \"NodeMaterialDebugBlock\";\r\n    }\r\n\r\n    protected override _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this._isActive) {\r\n            return this;\r\n        }\r\n\r\n        let outputString = \"gl_FragColor\";\r\n        if (state.shaderLanguage === ShaderLanguage.WGSL) {\r\n            outputString = \"fragmentOutputs.color\";\r\n        }\r\n\r\n        const debug = this.debug;\r\n        if (!debug.connectedPoint) {\r\n            return this;\r\n        }\r\n\r\n        if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\r\n            state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, ${debug.associatedVariableName}, ${debug.associatedVariableName}, 1.0);\\n`;\r\n        } else if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector2) {\r\n            state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, 0., 1.0);\\n`;\r\n        } else if (debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color3 || debug.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n            state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}, 1.0);\\n`;\r\n        } else if (this.renderAlpha) {\r\n            state.compilationString += `${outputString}  =${debug.associatedVariableName};\\n`;\r\n        } else {\r\n            state.compilationString += `${outputString}  = vec4${state.fSuffix}(${debug.associatedVariableName}.rgb, 1.0);\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.isActive = this._isActive;\r\n        serializationObject.renderAlpha = this.renderAlpha;\r\n        return serializationObject;\r\n    }\r\n\r\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.isActive = serializationObject.isActive;\r\n        this.renderAlpha = serializationObject.renderAlpha;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterialDebugBlock\", NodeMaterialDebugBlock);\r\n"],
  "mappings": "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,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;;AAElB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D,OAAO;AACH,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D;AAEA,UAAM,cAAc,YAAY,gBAAgB,aAAa;AAE7D,UAAM,eAAe,MAAM,qBAAqB,YAAY;AAE5D,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,cAAc,sCAAsC,OAAO,CAAC,aAAa,KAAK,KAAK,sBAAsB,KAAK,KAAK,OAAO,sBAAsB,KAAK,KAAK,iBAAiB;;AAEhO,QAAI,KAAK,OAAO,cAAc;AAC1B,YAAM,qBAAqB,MAAM,eAAe,KAAK,MAAM,IAAI,MAAM,YAAY;;IACrF;AAEA,QAAI,KAAK,EAAE,cAAc;AACrB,YAAM,qBAAqB,MAAM,eAAe,KAAK,CAAC,IAAI,MAAM,YAAY;;IAChF;AAEA,QAAI,KAAK,EAAE,cAAc;AACrB,YAAM,qBAAqB,MAAM,eAAe,KAAK,CAAC,IAAI,MAAM,YAAY;;IAChF;AACA,WAAO;EACX;;;;;EAKmB,sBAAmB;AAClC,UAAM,aAAa,MAAM,oBAAmB,IAAK,GAAG,KAAK,iBAAiB,wBAAwB,KAAK,iBAAiB;;AAExH,WAAO;EACX;;;;;EAKgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,oBAAoB,KAAK;AAE7C,WAAO;EACX;;;;;;;EAOgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,oBAAoB,oBAAoB;EACjD;;AAvRO,WAAA;EADN,uBAAuB,0BAAwB,GAAkC,cAAc,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,MAAK,EAAE,CAAE;;AA2RpJ,cAAc,8BAA8B,kBAAkB;;;AC1QxD,IAAO,uBAAP,cAAoC,kBAAiB;;;;;EAKvD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAC5C,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,eAAe,UAAU,sCAAsC,KAAK;EAC7E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB;IACJ;AAEA,QAAI,CAAC,KAAK,SAAS,CAAC,EAAE,cAAc;AAChC;IACJ;AAEA,QAAI,iBAAiB;;AACrB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAClB,sBAAkB;;AAElB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D,OAAO;AACH,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D;AAEA,UAAM,cAAc,mBAAmB,gBAAgB,oBAAoB;AAC3E,UAAM,qBAAqB,MAAM,eAAe,KAAK,SAAS,CAAC,CAAC,IAAI,sBAAsB,KAAK,KAAK,sBAAsB;;AAE1H,WAAO;EACX;;AAGJ,cAAc,gCAAgC,oBAAoB;;;AClI5D,IAAO,mBAAP,cAAgC,kBAAiB;;;;;EAKnD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,cAAc,sCAAsC,UAAU;AACjF,SAAK,cAAc,cAAc,sCAAsC,UAAU;AACjF,SAAK,eAAe,UAAU,sCAAsC,OAAO;AAE3E,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,SAClC,sCAAsC,SACtC,sCAAsC,UACtC,sCAAsC,OAAO;AAGrD,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,SAClC,sCAAsC,SACtC,sCAAsC,UACtC,sCAAsC,OAAO;EAEzD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,SAAS,KAAK,QAAQ,CAAC;AAC7B,UAAM,SAAS,KAAK,QAAQ,CAAC;AAC7B,UAAM,QAAQ,MAAM,qBAAqB,OAAO;AAChD,UAAM,QAAQ,MAAM,qBAAqB,OAAO;AAEhD,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,OAAO,sCAAsC,KAAK,CAAC,gBAAgB,OAAO,sBAAsB;;AACrJ,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,OAAO,sCAAsC,KAAK,CAAC,gBAAgB,OAAO,sBAAsB;;AACrJ,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI;;AAC1D,UAAM,qBAAqB,GAAG,OAAO,sBAAsB,eAAe,KAAK,OAAO,OAAO,sBAAsB,QAAQ,OAAO,sBAAsB,cAAc,KAAK,oBAAoB,OAAO,sBAAsB,gBAAgB,OAAO,sBAAsB;;AACzQ,UAAM,qBAAqB,GAAG,OAAO,sBAAsB,eAAe,KAAK,OAAO,OAAO,sBAAsB,QAAQ,OAAO,sBAAsB,cAAc,KAAK,oBAAoB,OAAO,sBAAsB,gBAAgB,OAAO,sBAAsB;;AACzQ,UAAM,qBAAqB,GAAG,OAAO,sBAAsB,QAAQ,OAAO,sBAAsB,QAAQ,OAAO,sBAAsB;;AAErI,WAAO;EACX;;AAGJ,cAAc,4BAA4B,gBAAgB;;;AC1EpD,IAAO,gBAAP,cAA6B,kBAAiB;;;;;EAKhD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,OAAO;AACzE,SAAK,cAAc,SAAS,sCAAsC,KAAK;AACvE,SAAK,eAAe,UAAU,sCAAsC,OAAO;EAC/E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,gBAAa;AACzB,QAAI,CAAC,KAAK,MAAM,aAAa;AACzB,YAAM,aAAa,IAAI,WAAW,OAAO;AACzC,iBAAW,QAAQ;AACnB,iBAAW,OAAO,UAAU,KAAK,KAAK;IAC1C;EACJ;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,KAAK;AAEnB,UAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,eAAe,MAAM,sBAAsB,OAAO,MAAM,sBAAsB,YAAY,MAAM,sBAAsB,OAAO,MAAM,sBAAsB,WAAW,MAAM,sBAAsB,OAAO,MAAM,sBAAsB,YAAY,MAAM,sBAAsB,OAAO,MAAM,sBAAsB;;AAElT,WAAO;EACX;;AAGJ,cAAc,yBAAyB,aAAa;;;ACnE9C,IAAO,eAAP,cAA4B,kBAAiB;;;;;EAK/C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,YAAY,sCAAsC,UAAU;AAC/E,SAAK,cAAc,UAAU,sCAAsC,UAAU;AAC7E,SAAK,eAAe,UAAU,sCAAsC,OAAO;AAE3E,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,UAClC,sCAAsC,UACtC,sCAAsC,SACtC,sCAAsC,MAAM;AAEpD,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,UAClC,sCAAsC,UACtC,sCAAsC,SACtC,sCAAsC,MAAM;EAExD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,cAAc,KAAK,SAAS,sBAAsB,SAAS,KAAK,OAAO,sBAAsB;;AAEvJ,WAAO;EACX;;AAGJ,cAAc,wBAAwB,YAAY;;;AClE5C,IAAO,eAAP,cAA4B,kBAAiB;;;;;EAK/C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,YAAY,sCAAsC,UAAU;AAC/E,SAAK,cAAc,UAAU,sCAAsC,UAAU;AAC7E,SAAK,cAAc,OAAO,sCAAsC,KAAK;AACrE,SAAK,eAAe,UAAU,sCAAsC,OAAO;AAE3E,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,UAClC,sCAAsC,UACtC,sCAAsC,SACtC,sCAAsC,MAAM;AAEpD,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,UAClC,sCAAsC,UACtC,sCAAsC,SACtC,sCAAsC,MAAM;EAExD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,MAAG;AACV,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,UAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,cAAc,KAAK,SAAS,sBAAsB,SAAS,KAAK,OAAO,sBAAsB,SAAS,KAAK,IAAI,sBAAsB;;AAEzI,WAAO;EACX;;AAGJ,cAAc,wBAAwB,YAAY;;;AC5E5C,IAAO,kBAAP,cAA+B,kBAAiB;;;;;EAKlD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,MAAM;AACxE,SAAK,cAAc,SAAS,sCAAsC,KAAK;AACvE,SAAK,eAAe,UAAU,sCAAsC,MAAM;EAC9E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,QAAQ,KAAK;AACnB,UAAM,YAAY,MAAM;AACxB,UAAM,UAAU,MAAM,qBAAqB,UAAU;AACrD,UAAM,UAAU,MAAM,qBAAqB,UAAU;AACrD,UAAM,YAAY,MAAM,qBAAqB,YAAY;AAEzD,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,SAAS,sCAAsC,KAAK,CAAC,cAAc,SAAS,OAAO,SAAS,QAAQ,SAAS;;AAClK,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,SAAS,sCAAsC,KAAK,CAAC,cAAc,SAAS,OAAO,SAAS,QAAQ,SAAS;;AAClK,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,WAAW,sCAAsC,KAAK,CAAC,aAAa,OAAO,MAAM,OAAO;;AAC7I,UAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,UAAU,SAAS,KAAK,MAAM,eAAe,sCAAsC,OAAO,CAAC,IAAI,SAAS,KAAK,SAAS,KAAK,SAAS,MAAM,KAAK,MAAM,sBAAsB;;AAE/K,WAAO;EACX;;AAGJ,cAAc,2BAA2B,eAAe;;;AClExD,IAAM,gCACF;AAIJ,IAAM,oCACF;AAEJ,IAAI,iBAAiB;AAWrB,IAAM,kBAAkB,CAAC,OAAc,aAAqB,iBAAyB,gBAAoC;AACrH,MAAI,CAAE,MAAc,eAAe,GAAG;AAElC,UAAM,2BAA2B,MAAM;AACvC,UAAM,2BAA2B;AAEjC,UAAM,gBAAgB,MAAM;AAC5B,UAAM,yBAAyB;AAC/B,UAAM,UAAU,QAAQ,uBAAuB,aAAa,cAAc,kBAAkB,OAAO,MAAM,OAAO,QAAQ,qBAAqB;AAC7I,UAAM,yBAAyB;AAE/B,UAAM,gBAAgB,MAAM,UAAS,EAAG,uBAAsB;AAC9D,UAAM,QAAQ,cAAc,QAAQ,QAAQ,mBAAkB,CAAG;AACjE,QAAI,UAAU,IAAI;AACd,oBAAc,OAAO,OAAO,CAAC;IACjC;AAEA,YAAQ,SAAS;AACjB,YAAQ,QAAQ,QAAQ;AACxB,YAAQ,QAAQ,QAAQ;AACvB,UAAc,eAAe,IAAI;AAElC,UAAM,2BAA2B;AAEjC,qBAAiB,kBAAkB,OAAO;AAE1C,UAAM,WAAW,MAAM,UAAS,EAAG,4BAA4B,IAAI,MAAK;AACpE,cAAQ,SAAS;AAOjB,YAAM,KAAK,MAAM,yBAAyB,IAAI,MAAK;AAC/C,YAAI,QAAQ,QAAO,GAAI;AACnB,gBAAM,yBAAyB,OAAO,EAAE;AACxC,2BAAiB,kBAAkB,OAAO;QAC9C;MACJ,CAAC;IACL,CAAC;AAED,UAAM,oBAAoB,IAAI,MAAK;AAC/B,YAAM,UAAS,EAAG,4BAA4B,OAAO,QAAQ;IACjE,CAAC;EACL;AAEA,SAAQ,MAAc,eAAe;AACzC;AAOO,IAAM,4BAA4B,CAAC,UAA6B;AACnE,SAAO,gBAAgB,OAAO,+BAA+B,0BAA0B,wBAAwB;AACnH;AAOO,IAAM,gCAAgC,CAAC,UAA6B;AACvE,SAAO,gBAAgB,OAAO,mCAAmC,8BAA8B,4BAA4B;AAC/H;AAKO,IAAM,mBAAmB;;;;;;;EAO5B;;;;;;;EAQA;;;;ACrGE,IAAO,sBAAP,cAAmC,gBAAe;EAAxD,cAAA;;AACI,SAAA,2BAA2B;AAC3B,SAAA,8BAA8B;AAC9B,SAAA,sBAAsB;AACtB,SAAA,0CAA0C;AAC1C,SAAA,mCAAmC;AACnC,SAAA,sCAAsC;AACtC,SAAA,qBAAqB;AACrB,SAAA,4BAA4B;AAC5B,SAAA,2BAA2B;EAC/B;;AAKM,IAAO,uBAAP,MAAO,8BAA6B,mBAAkB;;EAiJjD,+BAA4B;AAC/B,SAAK,qCAAoC;EAC7C;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,WAAW,IAAI,IAAI,oBAAmB,GAAI,eAAe;AAxGrE,SAAA,yBAAyB,sBAAqB;AAM/C,SAAA,wBAAwB,sBAAqB;AAE5C,SAAA,sCAAsC,sBAAqB;AAW5D,SAAA,qCAAqC,sBAAqB;AAEzD,SAAA,yBAAyB,sBAAqB;AAU/C,SAAA,wBAAwB,sBAAqB;AAE5C,SAAA,gDAAgD,sBAAqB;AAStE,SAAA,+CAA+C,sBAAqB;AAEnE,SAAA,gCAAgC,sBAAqB;AAQtD,SAAA,+BAA+B,sBAAqB;AAEnD,SAAA,uCAAuC,sBAAqB;AAO7D,SAAA,sCAAsC,sBAAqB;AAE1D,SAAA,oBAA4B,sBAAqB;AAMlD,SAAA,mBAA2B,sBAAqB;AAE/C,SAAA,2BAAmC,sBAAqB;AAMzD,SAAA,0BAAkC,sBAAqB;AAEtD,SAAA,0BAAkC,sBAAqB;AAMxD,SAAA,yBAAiC,sBAAqB;AAqBzD,SAAK,uCAAuC,SAAS,gBAAgB,EAAA;AACrE,SAAK,QAAQ,IAAI;EACrB;EAEgB,eAAe,SAA4B;AACvD,YAAQ,2BAA2B,KAAK;AACxC,YAAQ,8BAA8B,KAAK,0BAA0B,KAAK;AAC1E,YAAQ,sBAAsB,KAAK;AACnC,YAAQ,0CAA0C,KAAK;AACvD,YAAQ,mCAAmC,KAAK;AAChD,YAAQ,sCAAsC,KAAK;AACnD,YAAQ,qBAAqB,KAAK;AAClC,YAAQ,4BAA4B,KAAK;AACzC,YAAQ,2BAA2B,KAAK;EAC5C;EAEgB,eAAY;AACxB,WAAO;EACX;;AA7Kc,qBAAA,kCAAkC;AAMlC,qBAAA,iDAAiD;AAOjD,qBAAA,kCAAkC;AAOlC,qBAAA,4DAA4D;AAO5D,qBAAA,2CAA2C;AAK3C,qBAAA,kDAAkD;AAKlD,qBAAA,wBAAwB;AAKxB,qBAAA,oCAA4C;AAK5C,qBAAA,mCAA2C;AAQlD,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AAczC,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AAazC,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AAYzC,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AAWzC,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AAUzC,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;AASzC,WAAA;EAFN,UAAU,kBAAkB;EAC5B,iBAAiB,8BAA8B;;AASzC,WAAA;EAFN,UAAU,yBAAyB;EACnC,iBAAiB,8BAA8B;;AASzC,WAAA;EAFN,UAAU,wBAAwB;EAClC,iBAAiB,8BAA8B;;;;AC7I9C,IAAO,2BAAP,cAAwC,gBAAe;EAA7D,cAAA;;AACW,SAAA,YAAY;AACZ,SAAA,uBAAuB;AACvB,SAAA,oBAAoB;AACpB,SAAA,8BAA8B;AAC9B,SAAA,4BAA4B;AAC5B,SAAA,sCAAsC;AACtC,SAAA,iBAAiB;AACjB,SAAA,yBAAyB;AACzB,SAAA,2CAA2C;AAC3C,SAAA,qBAAqB;AAErB,SAAA,iBAAiB;AACjB,SAAA,yBAAyB;AACzB,SAAA,iCAAiC;AACjC,SAAA,8BAA8B;EACzC;;AAKM,IAAO,4BAAP,MAAO,mCAAkC,mBAAkB;;EAiItD,mCAAgC;AACnC,SAAK,QAAQ,KAAK,UAAU;AAC5B,SAAK,yCAAwC;EACjD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,gBAAgB,KAAK,IAAI,yBAAwB,GAAI,eAAe;AArIhF,SAAA,aAAa;AAMd,SAAA,YAAY;AAMZ,SAAA,YAAoB;AAMpB,SAAA,YAAoB;AAEnB,SAAA,qBAAqB,2BAA0B;AAShD,SAAA,oBAAoB,2BAA0B;AAE7C,SAAA,WAAkC;AAQnC,SAAA,UAAiC;AAEhC,SAAA,+BAA+B;AAOhC,SAAA,8BAA8B;AAE7B,SAAA,oBAA2C;AAO5C,SAAA,mBAA0C;AAEzC,SAAA,4BAA4B;AAM7B,SAAA,2BAA2B;AAE1B,SAAA,eAAsC;AAMvC,SAAA,cAAqC;AAEpC,SAAA,iBAAiB;AAMlB,SAAA,gBAAgB;AAOhB,SAAA,YAAY,OAAO,MAAK;AAQxB,SAAA,sBAAsB;AAOtB,SAAA,gBAAwB;AAEvB,SAAA,eAAsC;AAQvC,SAAA,cAAqC;AAsBxC,SAAK,2CAA2C,SAAS,gBAAgB,CAAA;EAC7E;EAEgB,kBAAkB,SAAmC,OAAc,QAAc;AAC7F,QAAI,CAAC,KAAK,YAAY;AAClB,aAAO;IACX;AAEA,UAAM,iBAAiB,KAAK,UAAU;AACtC,QAAI,QAAQ,mBAAmB;AAC3B,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,YAAY,cAAc,yBAAyB;AACxD,cAAI,CAAC,KAAK,SAAS,qBAAoB,GAAI;AACvC,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,cAAI,CAAC,KAAK,kBAAkB,qBAAoB,GAAI;AAChD,mBAAO;UACX;QACJ;AAEA,YAAI,OAAO,QAAO,EAAG,uBAAuB,KAAK,gBAAgB,cAAc,+BAA+B,CAAC,gBAAgB;AAE3H,cAAI,CAAC,KAAK,aAAa,QAAO,GAAI;AAC9B,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,kBAAkB,KAAK,gBAAgB,cAAc,6BAA6B;AACvF,cAAI,CAAC,KAAK,aAAa,qBAAoB,GAAI;AAC3C,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,+BAA+B,SAAmC,OAAY;AAC1F,QAAI,KAAK,YAAY;AACjB,cAAQ,YAAY;AACpB,cAAQ,2CAA2C,KAAK;AACxD,cAAQ,qBAAqB,KAAK;AAElC,UAAI,QAAQ,mBAAmB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,YAAY,cAAc,yBAAyB;AACxD,sCAA0B,KAAK,UAAU,SAAS,mBAAmB;UACzE,OAAO;AACH,oBAAQ,oBAAoB;UAChC;AAEA,cAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,sCAA0B,KAAK,mBAAmB,SAAS,6BAA6B;UAC5F,OAAO;AACH,oBAAQ,8BAA8B;UAC1C;AAEA,cAAI,KAAK,gBAAgB,cAAc,6BAA6B;AAChE,sCAA0B,KAAK,cAAc,SAAS,gBAAgB;UAC1E,OAAO;AACH,oBAAQ,iBAAiB;UAC7B;AAEA,kBAAQ,uBAAuB,KAAK,uBAAuB,2BAA0B;AAErF,cAAI,KAAK,gBAAgB;AACrB,oBAAQ,iBAAiB;AACzB,gBAAI,KAAK,gBAAgB,cAAc,6BAA6B;AAChE,wCAA0B,KAAK,cAAc,SAAS,wBAAwB;AAC9E,sBAAQ,8BAA8B,KAAK,aAAa;YAC5D,OAAO;AACH,sBAAQ,yBAAyB;YACrC;UACJ,OAAO;AACH,oBAAQ,iBAAiB;AACzB,oBAAQ,yBAAyB;UACrC;QACJ;MACJ;IACJ,OAAO;AACH,cAAQ,YAAY;AACpB,cAAQ,oBAAoB;AAC5B,cAAQ,8BAA8B;AACtC,cAAQ,iBAAiB;AACzB,cAAQ,iBAAiB;AACzB,cAAQ,yBAAyB;AACjC,cAAQ,2CAA2C;AACnD,cAAQ,uBAAuB;AAC/B,cAAQ,4BAA4B;AACpC,cAAQ,sCAAsC;AAC9C,cAAQ,yBAAyB;AACjC,cAAQ,qBAAqB;AAC7B,cAAQ,iCAAiC;AACzC,cAAQ,8BAA8B;IAC1C;EACJ;EAEgB,eAAe,eAA8B,OAAc,QAAgB,SAAgB;AACvG,QAAI,CAAC,KAAK,YAAY;AAClB;IACJ;AAEA,UAAM,UAAU,QAAQ;AAExB,UAAM,WAAW,KAAK,UAAU;AAEhC,UAAM,iBAAiB,KAAK,UAAU;AACtC,UAAM,mBAAmB,KAAK,UAAU;AACxC,UAAM,mBAAmB,KAAK,UAAU;AAExC,QAAI,CAAC,cAAc,UAAU,CAAC,YAAY,CAAC,cAAc,QAAQ;AAC7D,WAAK,KAAK,YAAY,KAAK,sBAAsB,cAAc,yBAAyB;AACpF,sBAAc,aACV,mBACA,KAAK,UAAU,oBAAoB,GACnC,KAAK,UAAU,SAAS,GACxB,KAAK,mBAAmB,oBAAoB,GAC5C,KAAK,mBAAmB,SAAS,CAAC;AAEtC,YAAI,KAAK,UAAU;AACf,4BAAkB,KAAK,UAAU,eAAe,WAAW;QAC/D;AACA,YAAI,KAAK,qBAAqB,CAAC,QAAQ,0CAA0C;AAC7E,4BAAkB,KAAK,mBAAmB,eAAe,oBAAoB;QACjF;MACJ;AAEA,UAAI,KAAK,gBAAgB,OAAO,QAAO,EAAG,uBAAuB,cAAc,2BAA2B,CAAC,gBAAgB;AACvH,sBAAc,aAAa,uBAAuB,KAAK,aAAa,kBAAkB,KAAK,aAAa,KAAK;AAC7G,0BAAkB,KAAK,cAAc,eAAe,eAAe;AAEnE,YAAI,MAAM,yBAAyB;AAC/B,wBAAc,aAAa,gCAAgC,mBAAmB,IAAM,IAAM,mBAAmB,IAAM,EAAI;QAC3H,OAAO;AACH,wBAAc,aAAa,gCAAgC,mBAAmB,KAAO,GAAK,mBAAmB,KAAO,CAAG;QAC3H;MACJ;AAEA,UAAI,KAAK,gBAAgB,cAAc,6BAA6B;AAChE,sBAAc,aAAa,uBAAuB,KAAK,aAAa,kBAAkB,KAAK,aAAa,KAAK;AAC7G,0BAAkB,KAAK,cAAc,eAAe,eAAe;MACvE;AAGA,oBAAc,aAAa,oBAAoB,KAAK,WAAW,KAAK,SAAS;AAG7E,YAAM,IAAI,IAAI,KAAK;AACnB,YAAM,IAAI,IAAI,KAAK;AACnB,YAAM,KAAK,KAAK,IAAI,CAAC,IAAI,GAAG,CAAC;AAC7B,YAAM,MAAM,IAAI,KAAK;AACrB,oBAAc,aAAa,8BAA8B,IAAI,KAAK,GAAG,CAAC;AAEtE,UAAI,KAAK,gBAAgB;AACrB,sBAAc,aAAa,wBAAwB,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,IAAI,MAAS,KAAK,aAAa,CAAC;AAC9I,sBAAc,YAAY,4BAA4B,KAAK,IAAI,MAAS,KAAK,mBAAmB,CAAC;MACrG;IACJ;AAGA,QAAI,MAAM,iBAAiB;AACvB,UAAI,KAAK,YAAY,cAAc,yBAAyB;AACxD,sBAAc,WAAW,oBAAoB,KAAK,QAAQ;MAC9D;AAEA,UAAI,KAAK,qBAAqB,CAAC,QAAQ,4CAA4C,cAAc,yBAAyB;AACtH,sBAAc,WAAW,6BAA6B,KAAK,iBAAiB;MAChF;AAEA,UAAI,KAAK,gBAAgB,OAAO,QAAO,EAAG,uBAAuB,cAAc,+BAA+B,CAAC,gBAAgB;AAC3H,sBAAc,WAAW,wBAAwB,KAAK,YAAY;MACtE;AAEA,UAAI,KAAK,kBAAkB,KAAK,gBAAgB,cAAc,6BAA6B;AACvF,sBAAc,WAAW,wBAAwB,KAAK,YAAY;MACtE;IACJ;EACJ;EAEgB,WAAW,SAAoB;AAC3C,QAAI,KAAK,aAAa,SAAS;AAC3B,aAAO;IACX;AAEA,QAAI,KAAK,sBAAsB,SAAS;AACpC,aAAO;IACX;AAEA,QAAI,KAAK,iBAAiB,SAAS;AAC/B,aAAO;IACX;AAEA,QAAI,KAAK,iBAAiB,SAAS;AAC/B,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,kBAAkB,gBAA6B;AAC3D,QAAI,KAAK,UAAU;AACf,qBAAe,KAAK,KAAK,QAAQ;IACrC;AAEA,QAAI,KAAK,mBAAmB;AACxB,qBAAe,KAAK,KAAK,iBAAiB;IAC9C;AAEA,QAAI,KAAK,cAAc;AACnB,qBAAe,KAAK,KAAK,YAAY;IACzC;AAEA,QAAI,KAAK,cAAc;AACnB,qBAAe,KAAK,KAAK,YAAY;IACzC;EACJ;EAEgB,eAAe,aAA0B;AACrD,QAAI,KAAK,YAAY,KAAK,SAAS,cAAc,KAAK,SAAS,WAAW,SAAS,GAAG;AAClF,kBAAY,KAAK,KAAK,QAAQ;IAClC;AAEA,QAAI,KAAK,qBAAqB,KAAK,kBAAkB,cAAc,KAAK,kBAAkB,WAAW,SAAS,GAAG;AAC7G,kBAAY,KAAK,KAAK,iBAAiB;IAC3C;AAEA,QAAI,KAAK,gBAAgB,KAAK,aAAa,cAAc,KAAK,aAAa,WAAW,SAAS,GAAG;AAC9F,kBAAY,KAAK,KAAK,YAAY;IACtC;AAEA,QAAI,KAAK,gBAAgB,KAAK,aAAa,cAAc,KAAK,aAAa,WAAW,SAAS,GAAG;AAC9F,kBAAY,KAAK,KAAK,YAAY;IACtC;EACJ;EAEgB,QAAQ,sBAA8B;AAClD,QAAI,sBAAsB;AACtB,WAAK,UAAU,QAAO;AACtB,WAAK,mBAAmB,QAAO;AAC/B,WAAK,cAAc,QAAO;AAC1B,WAAK,cAAc,QAAO;IAC9B;EACJ;EAEgB,eAAY;AACxB,WAAO;EACX;EAEgB,aAAa,SAAmC,WAA4B,aAAmB;AAC3G,QAAI,QAAQ,gBAAgB;AACxB,gBAAU,YAAY,eAAe,gBAAgB;IACzD;AACA,QAAI,QAAQ,gBAAgB;AACxB,gBAAU,YAAY,eAAe,gBAAgB;IACzD;AACA,QAAI,QAAQ,WAAW;AACnB,gBAAU,YAAY,eAAe,WAAW;IACpD;AACA,WAAO;EACX;EAEgB,YAAY,UAAkB;AAC1C,aAAS,KAAK,oBAAoB,6BAA6B,wBAAwB,sBAAsB;EACjH;EAEgB,cAAW;AACvB,WAAO;MACH,KAAK;QACD,EAAE,MAAM,oBAAoB,MAAM,GAAG,MAAM,OAAM;QACjD,EAAE,MAAM,8BAA8B,MAAM,GAAG,MAAM,OAAM;QAC3D,EAAE,MAAM,mBAAmB,MAAM,GAAG,MAAM,OAAM;QAChD,EAAE,MAAM,mBAAmB,MAAM,IAAI,MAAM,OAAM;QACjD,EAAE,MAAM,4BAA4B,MAAM,IAAI,MAAM,OAAM;QAC1D,EAAE,MAAM,uBAAuB,MAAM,GAAG,MAAM,OAAM;QACpD,EAAE,MAAM,gCAAgC,MAAM,GAAG,MAAM,OAAM;QAC7D,EAAE,MAAM,uBAAuB,MAAM,IAAI,MAAM,OAAM;QACrD,EAAE,MAAM,wBAAwB,MAAM,GAAG,MAAM,OAAM;QACrD,EAAE,MAAM,4BAA4B,MAAM,GAAG,MAAM,QAAO;QAC1D,EAAE,MAAM,uBAAuB,MAAM,GAAG,MAAM,OAAM;QACpD,EAAE,MAAM,uBAAuB,MAAM,IAAI,MAAM,OAAM;;;EAGjE;;AAvauB,0BAAA,4BAA4B;AAQ5C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAO7C,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAYH,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAW7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAQ7C,WAAA;EADN,kBAAiB;;AASX,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,UAAS;;AAWH,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;;;AClJlD,IAAO,6BAAP,cAA0C,gBAAe;EAA/D,cAAA;;AACW,SAAA,cAAc;AACd,SAAA,sBAAsB;AACtB,SAAA,8BAA8B;AAC9B,SAAA,gCAAgC;AAChC,SAAA,wCAAwC;EACnD;;AAKM,IAAO,8BAAP,MAAO,qCAAoC,mBAAkB;;EA4ExD,mCAAgC;AACnC,SAAK,QAAQ,KAAK,UAAU;AAC5B,SAAK,yCAAwC;EACjD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,kBAAkB,KAAK,IAAI,2BAA0B,GAAI,eAAe;AAlEpF,SAAA,aAAa;AAMd,SAAA,YAAY;AAMZ,SAAA,YAAoB;AAMpB,SAAA,mBAA2B,6BAA4B;AAMvD,SAAA,mBAA2B,6BAA4B;AAMvD,SAAA,oBAA4B,6BAA4B;AAEvD,SAAA,WAAkC;AAMnC,SAAA,UAAiC;AAEhC,SAAA,oBAA2C;AAM5C,SAAA,mBAA0C;AAsB7C,SAAK,2CAA2C,SAAS,gBAAgB,CAAA;EAC7E;EAEgB,kBAAkB,SAAqC,OAAY;AAC/E,QAAI,CAAC,KAAK,YAAY;AAClB,aAAO;IACX;AAEA,QAAI,QAAQ,mBAAmB;AAC3B,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,cAAI,CAAC,KAAK,SAAS,qBAAoB,GAAI;AACvC,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,qBAAqB,cAAc,2BAA2B;AACnE,cAAI,CAAC,KAAK,kBAAkB,qBAAoB,GAAI;AAChD,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,+BAA+B,SAAqC,OAAY;AAC5F,QAAI,KAAK,YAAY;AACjB,cAAQ,cAAc;AAEtB,UAAI,QAAQ,mBAAmB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,sCAA0B,KAAK,UAAU,SAAS,qBAAqB;UAC3E,OAAO;AACH,oBAAQ,sBAAsB;UAClC;AAEA,cAAI,KAAK,qBAAqB,cAAc,2BAA2B;AACnE,sCAA0B,KAAK,mBAAmB,SAAS,+BAA+B;UAC9F,OAAO;AACH,oBAAQ,gCAAgC;UAC5C;QACJ;MACJ;IACJ,OAAO;AACH,cAAQ,cAAc;AACtB,cAAQ,sBAAsB;AAC9B,cAAQ,gCAAgC;AACxC,cAAQ,8BAA8B;AACtC,cAAQ,wCAAwC;IACpD;EACJ;EAEgB,eAAe,eAA8B,OAAY;AACrE,QAAI,CAAC,KAAK,YAAY;AAClB;IACJ;AAEA,UAAM,WAAW,KAAK,UAAU;AAEhC,QAAI,CAAC,cAAc,UAAU,CAAC,YAAY,CAAC,cAAc,QAAQ;AAC7D,WAAK,KAAK,YAAY,KAAK,sBAAsB,cAAc,2BAA2B;AACtF,sBAAc,aACV,qBACA,KAAK,UAAU,oBAAoB,GACnC,KAAK,UAAU,SAAS,GACxB,KAAK,mBAAmB,oBAAoB,GAC5C,KAAK,mBAAmB,SAAS,CAAC;AAEtC,YAAI,KAAK,UAAU;AACf,4BAAkB,KAAK,UAAU,eAAe,aAAa;QACjE;AACA,YAAI,KAAK,mBAAmB;AACxB,4BAAkB,KAAK,mBAAmB,eAAe,sBAAsB;QACnF;MACJ;AAGA,oBAAc,aAAa,sBAAsB,KAAK,WAAW,KAAK,mBAAmB,KAAK,kBAAkB,KAAK,gBAAgB;IACzI;AAGA,QAAI,MAAM,iBAAiB;AACvB,UAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,sBAAc,WAAW,sBAAsB,KAAK,QAAQ;MAChE;AAEA,UAAI,KAAK,qBAAqB,cAAc,2BAA2B;AACnE,sBAAc,WAAW,+BAA+B,KAAK,iBAAiB;MAClF;IACJ;EACJ;EAEgB,WAAW,SAAoB;AAC3C,QAAI,KAAK,aAAa,SAAS;AAC3B,aAAO;IACX;AAEA,QAAI,KAAK,sBAAsB,SAAS;AACpC,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,kBAAkB,gBAA6B;AAC3D,QAAI,KAAK,UAAU;AACf,qBAAe,KAAK,KAAK,QAAQ;IACrC;AAEA,QAAI,KAAK,mBAAmB;AACxB,qBAAe,KAAK,KAAK,iBAAiB;IAC9C;EACJ;EAEgB,eAAe,aAA0B;AACrD,QAAI,KAAK,YAAY,KAAK,SAAS,cAAc,KAAK,SAAS,WAAW,SAAS,GAAG;AAClF,kBAAY,KAAK,KAAK,QAAQ;IAClC;AAEA,QAAI,KAAK,qBAAqB,KAAK,kBAAkB,cAAc,KAAK,kBAAkB,WAAW,SAAS,GAAG;AAC7G,kBAAY,KAAK,KAAK,iBAAiB;IAC3C;EACJ;EAEgB,QAAQ,sBAA8B;AAClD,QAAI,sBAAsB;AACtB,WAAK,UAAU,QAAO;AACtB,WAAK,mBAAmB,QAAO;IACnC;EACJ;EAEgB,eAAY;AACxB,WAAO;EACX;EAEgB,aAAa,SAAqC,WAA4B,aAAmB;AAC7G,QAAI,QAAQ,aAAa;AACrB,gBAAU,YAAY,eAAe,aAAa;IACtD;AACA,WAAO;EACX;EAEgB,YAAY,UAAkB;AAC1C,aAAS,KAAK,sBAAsB,6BAA6B;EACrE;EAEgB,cAAW;AACvB,WAAO;MACH,KAAK;QACD,EAAE,MAAM,sBAAsB,MAAM,GAAG,MAAM,OAAM;QACnD,EAAE,MAAM,qBAAqB,MAAM,GAAG,MAAM,OAAM;QAClD,EAAE,MAAM,qBAAqB,MAAM,IAAI,MAAM,OAAM;QACnD,EAAE,MAAM,8BAA8B,MAAM,IAAI,MAAM,OAAM;;;EAGxE;;AAlPuB,4BAAA,2BAA2B;AAO3B,4BAAA,2BAA2B;AAO3B,4BAAA,4BAA4B;AAQ5C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAO7C,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AASH,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;;;AC7ElD,IAAO,6BAAP,cAA0C,gBAAe;EAA/D,cAAA;;AACW,SAAA,cAAc;AACd,SAAA,sBAAsB;AACtB,SAAA,8BAA8B;AAC9B,SAAA,qBAAqB;AACrB,SAAA,UAAU;EACrB;;AAKM,IAAO,8BAAP,cAA2C,mBAAkB;;;;EAyB/D,IAAW,MAAM,OAAa;AAC1B,SAAK,UAAU,IAAI,KAAK,IAAI,KAAK;AACjC,SAAK,UAAU,IAAI,KAAK,IAAI,KAAK;EACrC;;;;;EAMA,IAAW,QAAK;AACZ,WAAO,KAAK,MAAM,KAAK,UAAU,GAAG,KAAK,UAAU,CAAC;EACxD;;EAwBO,mCAAgC;AACnC,SAAK,QAAQ,KAAK,UAAU;AAC5B,SAAK,yCAAwC;EACjD;;EAMO,+BAA4B;AAC/B,SAAK,QAAQ,KAAK,UAAU;AAC5B,SAAK,qCAAoC;EAC7C;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,kBAAkB,KAAK,IAAI,2BAA0B,GAAI,eAAe;AAlFpF,SAAA,aAAa;AAMd,SAAA,YAAY;AAMZ,SAAA,YAAoB;AAOpB,SAAA,YAAY,IAAI,QAAQ,GAAG,CAAC;AAkB3B,SAAA,WAAkC;AAQnC,SAAA,UAAiC;AAEhC,SAAA,UAAU;AAMX,SAAA,SAAkB;AA+BrB,SAAK,2CAA2C,SAAS,gBAAgB,CAAA;AACzE,SAAK,uCAAuC,SAAS,gBAAgB,EAAA;EACzE;EAEgB,kBAAkB,SAAqC,OAAY;AAC/E,QAAI,CAAC,KAAK,YAAY;AAClB,aAAO;IACX;AAEA,QAAI,QAAQ,mBAAmB;AAC3B,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,cAAI,CAAC,KAAK,SAAS,qBAAoB,GAAI;AACvC,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,+BAA+B,SAAqC,OAAc,MAAkB;AAChH,QAAI,KAAK,YAAY;AACjB,cAAQ,cAAc,KAAK;AAC3B,UAAI,KAAK,cAAc,CAAC,KAAK,sBAAsB,aAAa,WAAW,GAAG;AAC1E,gBAAQ,WAAW;AACnB,gBAAQ,UAAU;MACtB;AAEA,UAAI,QAAQ,mBAAmB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,sCAA0B,KAAK,UAAU,SAAS,qBAAqB;UAC3E,OAAO;AACH,oBAAQ,sBAAsB;UAClC;QACJ;MACJ;AAEA,UAAI,QAAQ,eAAe;AACvB,gBAAQ,qBAAqB,KAAK;MACtC;IACJ,OAAO;AACH,cAAQ,cAAc;AACtB,cAAQ,sBAAsB;AAC9B,cAAQ,8BAA8B;AACtC,cAAQ,qBAAqB;IACjC;EACJ;EAEgB,eAAe,eAA8B,OAAY;AACrE,QAAI,CAAC,KAAK,YAAY;AAClB;IACJ;AAEA,UAAM,WAAW,KAAK,UAAU;AAEhC,QAAI,CAAC,cAAc,UAAU,CAAC,YAAY,CAAC,cAAc,QAAQ;AAC7D,UAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,sBAAc,aAAa,oBAAoB,KAAK,SAAS,kBAAkB,KAAK,SAAS,KAAK;AAClG,0BAAkB,KAAK,UAAU,eAAe,YAAY;MAChE;AAGA,oBAAc,aAAa,eAAe,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,SAAS;IAChG;AAGA,QAAI,MAAM,iBAAiB;AACvB,UAAI,KAAK,YAAY,cAAc,2BAA2B;AAC1D,sBAAc,WAAW,qBAAqB,KAAK,QAAQ;MAC/D;IACJ;EACJ;EAEgB,WAAW,SAAoB;AAC3C,QAAI,KAAK,aAAa,SAAS;AAC3B,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,kBAAkB,gBAA6B;AAC3D,QAAI,KAAK,UAAU;AACf,qBAAe,KAAK,KAAK,QAAQ;IACrC;EACJ;EAEgB,eAAe,aAA0B;AACrD,QAAI,KAAK,YAAY,KAAK,SAAS,cAAc,KAAK,SAAS,WAAW,SAAS,GAAG;AAClF,kBAAY,KAAK,KAAK,QAAQ;IAClC;EACJ;EAEgB,QAAQ,sBAA8B;AAClD,QAAI,sBAAsB;AACtB,UAAI,KAAK,UAAU;AACf,aAAK,SAAS,QAAO;MACzB;IACJ;EACJ;EAEgB,eAAY;AACxB,WAAO;EACX;EAEgB,aAAa,SAAqC,WAA4B,aAAmB;AAC7G,QAAI,QAAQ,aAAa;AACrB,gBAAU,YAAY,eAAe,aAAa;IACtD;AACA,WAAO;EACX;EAEgB,YAAY,UAAkB;AAC1C,aAAS,KAAK,mBAAmB;EACrC;EAEgB,cAAW;AACvB,WAAO;MACH,KAAK;QACD,EAAE,MAAM,eAAe,MAAM,GAAG,MAAM,OAAM;QAC5C,EAAE,MAAM,oBAAoB,MAAM,GAAG,MAAM,OAAM;QACjD,EAAE,MAAM,oBAAoB,MAAM,IAAI,MAAM,OAAM;;;EAG9D;;;;;;;EAQgB,MAAM,QAAa,OAAc,SAAe;AAC5D,UAAM,MAAM,QAAQ,OAAO,OAAO;AAGlC,QAAI,OAAO,WAAW,QAAW;AAC7B,WAAK,SAAS;IAClB;EACJ;;AA5NO,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAO7C,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,mBAAkB;;AA2BZ,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,8BAA8B;;;;AChE9C,IAAO,uBAAP,cAAoC,gBAAe;EAAzD,cAAA;;AACW,SAAA,QAAQ;AACR,SAAA,gBAAgB;AAChB,SAAA,qBAAqB;AACrB,SAAA,0BAA0B;AAC1B,SAAA,wBAAwB;AACxB,SAAA,kCAAkC;AAClC,SAAA,uBAAuB;AACvB,SAAA,kBAAkB;AAClB,SAAA,sBAAsB;AACtB,SAAA,uCAAuC;EAClD;;AAKM,IAAO,wBAAP,cAAqC,mBAAkB;;EAkFlD,mCAAgC;AACnC,SAAK,QAAQ,KAAK,UAAU;AAC5B,SAAK,yCAAwC;EACjD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,SAAS,KAAK,IAAI,qBAAoB,GAAI,eAAe;AA/FrE,SAAA,aAAa;AAMd,SAAA,YAAY;AAEX,SAAA,uBAAuB;AAMxB,SAAA,sBAAsB;AAMtB,SAAA,YAAY;AAMZ,SAAA,QAAQ,OAAO,MAAK;AAEnB,SAAA,WAAkC;AASnC,SAAA,UAAiC;AAEhC,SAAA,+BAA+B;AAOhC,SAAA,8BAA8B;AAE7B,SAAA,aAA+B;AAQhC,SAAA,YAA8B;AAE7B,SAAA,oBAA2C;AAO5C,SAAA,mBAA0C;AAEzC,SAAA,iBAAiB;AAQlB,SAAA,gBAAgB;AAsBnB,SAAK,2CAA2C,SAAS,gBAAgB,CAAA;EAC7E;EAEgB,kBAAkB,SAA+B,OAAY;AACzE,QAAI,CAAC,KAAK,YAAY;AAClB,aAAO;IACX;AAEA,QAAI,QAAQ,mBAAmB;AAC3B,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,YAAY,cAAc,qBAAqB;AACpD,cAAI,CAAC,KAAK,SAAS,qBAAoB,GAAI;AACvC,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,qBAAqB,cAAc,qBAAqB;AAC7D,cAAI,CAAC,KAAK,kBAAkB,qBAAoB,GAAI;AAChD,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,+BAA+B,SAA+B,OAAY;AACtF,QAAI,KAAK,YAAY;AACjB,cAAQ,QAAQ;AAChB,cAAQ,uBAAuB,KAAK;AACpC,cAAQ,kBAAkB,KAAK,eAAe;AAC9C,cAAQ,sBAAsB,KAAK;AACnC,cAAQ,uCAAuC,KAAK;AAEpD,UAAI,QAAQ,mBAAmB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,YAAY,cAAc,qBAAqB;AACpD,sCAA0B,KAAK,UAAU,SAAS,eAAe;AACjE,oBAAQ,qBAAqB,KAAK,SAAS;UAC/C,OAAO;AACH,oBAAQ,gBAAgB;UAC5B;AAEA,cAAI,KAAK,qBAAqB,cAAc,qBAAqB;AAC7D,sCAA0B,KAAK,mBAAmB,SAAS,yBAAyB;UACxF,OAAO;AACH,oBAAQ,0BAA0B;UACtC;QACJ;MACJ;IACJ,OAAO;AACH,cAAQ,QAAQ;AAChB,cAAQ,gBAAgB;AACxB,cAAQ,0BAA0B;AAClC,cAAQ,uBAAuB;AAC/B,cAAQ,kBAAkB;AAC1B,cAAQ,sBAAsB;AAC9B,cAAQ,uCAAuC;AAC/C,cAAQ,qBAAqB;AAC7B,cAAQ,wBAAwB;AAChC,cAAQ,kCAAkC;IAC9C;EACJ;EAEgB,eAAe,eAA8B,OAAc,QAAgB,SAAgB;AACvG,QAAI,CAAC,KAAK,YAAY;AAClB;IACJ;AAEA,UAAM,UAAU,QAAQ;AAExB,UAAM,WAAW,KAAK,UAAU;AAEhC,QAAI,CAAC,cAAc,UAAU,CAAC,YAAY,CAAC,cAAc,QAAQ;AAC7D,WAAK,KAAK,YAAY,KAAK,sBAAsB,cAAc,qBAAqB;AAChF,sBAAc,aACV,eACA,KAAK,UAAU,oBAAoB,GACnC,KAAK,UAAU,SAAS,GACxB,KAAK,mBAAmB,oBAAoB,GAC5C,KAAK,mBAAmB,SAAS,CAAC;AAEtC,YAAI,KAAK,UAAU;AACf,4BAAkB,KAAK,UAAU,eAAe,OAAO;QAC3D;AACA,YAAI,KAAK,qBAAqB,CAAC,QAAQ,sCAAsC;AACzE,4BAAkB,KAAK,mBAAmB,eAAe,gBAAgB;QAC7E;MACJ;AAGA,oBAAc,aAAa,eAAe,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG,KAAK,SAAS;AAElG,UAAI,KAAK,eAAe,MAAM;AAC1B,sBAAc,YAAY,mBAAmB,KAAK,UAAU;MAChE;IACJ;AAGA,QAAI,MAAM,iBAAiB;AACvB,UAAI,KAAK,YAAY,cAAc,qBAAqB;AACpD,sBAAc,WAAW,gBAAgB,KAAK,QAAQ;MAC1D;AAEA,UAAI,KAAK,qBAAqB,CAAC,QAAQ,wCAAwC,cAAc,qBAAqB;AAC9G,sBAAc,WAAW,yBAAyB,KAAK,iBAAiB;MAC5E;IACJ;EACJ;EAEgB,WAAW,SAAoB;AAC3C,QAAI,KAAK,aAAa,SAAS;AAC3B,aAAO;IACX;AAEA,QAAI,KAAK,sBAAsB,SAAS;AACpC,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,kBAAkB,gBAA6B;AAC3D,QAAI,KAAK,UAAU;AACf,qBAAe,KAAK,KAAK,QAAQ;IACrC;AAEA,QAAI,KAAK,mBAAmB;AACxB,qBAAe,KAAK,KAAK,iBAAiB;IAC9C;EACJ;EAEgB,eAAe,aAA0B;AACrD,QAAI,KAAK,YAAY,KAAK,SAAS,cAAc,KAAK,SAAS,WAAW,SAAS,GAAG;AAClF,kBAAY,KAAK,KAAK,QAAQ;IAClC;AAEA,QAAI,KAAK,qBAAqB,KAAK,kBAAkB,cAAc,KAAK,kBAAkB,WAAW,SAAS,GAAG;AAC7G,kBAAY,KAAK,KAAK,iBAAiB;IAC3C;EACJ;EAEgB,QAAQ,sBAA8B;AAClD,QAAI,sBAAsB;AACtB,WAAK,UAAU,QAAO;AACtB,WAAK,mBAAmB,QAAO;IACnC;EACJ;EAEgB,eAAY;AACxB,WAAO;EACX;EAEgB,aAAa,SAA+B,WAA4B,aAAmB;AACvG,QAAI,QAAQ,OAAO;AACf,gBAAU,YAAY,eAAe,OAAO;IAChD;AACA,WAAO;EACX;EAEgB,YAAY,UAAkB;AAC1C,aAAS,KAAK,gBAAgB,uBAAuB;EACzD;EAEgB,cAAW;AACvB,WAAO;MACH,KAAK;QACD,EAAE,MAAM,eAAe,MAAM,GAAG,MAAM,OAAM;QAC5C,EAAE,MAAM,mBAAmB,MAAM,GAAG,MAAM,QAAO;QACjD,EAAE,MAAM,eAAe,MAAM,GAAG,MAAM,OAAM;QAC5C,EAAE,MAAM,eAAe,MAAM,IAAI,MAAM,OAAM;QAC7C,EAAE,MAAM,wBAAwB,MAAM,IAAI,MAAM,OAAM;;;EAGlE;;AA1QO,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAO7C,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,kBAAiB;;AAYX,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAW7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAW7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;;;ACvFlD,IAAO,4BAAP,cAAyC,gBAAe;EAA9D,cAAA;;AACW,SAAA,aAAa;AAEb,SAAA,gBAAgB;AAChB,SAAA,6CAA6C;AAC7C,SAAA,kBAAkB;AAClB,SAAA,+CAA+C;AAC/C,SAAA,gBAAgB;AAChB,SAAA,gBAAgB;AAEhB,SAAA,8BAA8B;AAC9B,SAAA,sCAAsC;AACtC,SAAA,mBAAmB;AACnB,SAAA,iCAAiC;AACjC,SAAA,yCAAyC;AACzC,SAAA,mCAAmC;AACnC,SAAA,2CAA2C;AAC3C,SAAA,+BAA+B;AAC/B,SAAA,uCAAuC;AACvC,SAAA,qCAAqC;AAErC,SAAA,sBAAsB;AACtB,SAAA,6BAA6B;AAC7B,SAAA,0BAA0B;AAC1B,SAAA,qBAAqB;AACrB,SAAA,oBAAoB;AACpB,SAAA,8BAA8B;AAC9B,SAAA,kCAAkC;AAClC,SAAA,6BAA6B;AAC7B,SAAA,+BAA+B;AAC/B,SAAA,mCAAmC;AACnC,SAAA,4BAA4B;AAE5B,SAAA,uBAAuB;AACvB,SAAA,mCAAmC;AACnC,SAAA,yBAAyB;EACpC;;AAKM,IAAO,6BAAP,MAAO,oCAAmC,mBAAkB;;;;;EA2D9D,IAAW,6BAA0B;AACjC,QAAI,CAAC,KAAK,OAAO,yBAAyB;AACtC,aAAO;IACX;AAEA,WAAO,KAAK,OAAO,wBAAwB,yBAAyB,KAAK,gCAAgC;EAC7G;EAEA,IAAW,2BAA2B,GAAmB;AACrD,QAAI,CAAC,KAAK,OAAO,2BAA0B,GAAI;AAE3C;IACJ;AAGA,QAAI,GAAG;AACH,WAAK,mCAAmC,KAAK,OAAO,wBAAyB,oBAAoB,CAAC;IACtG;EACJ;;;;;;;;EA2EA,IAAW,0BAAuB;AAC9B,QAAI,KAAK,4BAA4B,GAAK;AACtC,aAAO,KAAK;IAChB;AACA,WAAO,KAAK;EAChB;EACA,IAAW,wBAAwB,OAAa;AAC5C,QAAI,SAAS,GAAK;AACd,WAAK,2BAA2B;IACpC,OAAO;AACH,WAAK,2BAA2B;IACpC;EACJ;;;;;;EA+IA,IAAW,oBAAiB;AACxB,WAAO,KAAK;EAChB;EACA,IAAW,kBAAkB,OAAc;AACvC,SAAK,qBAAqB;EAC9B;;EASO,mCAAgC;AACnC,SAAK,QAAQ,KAAK,wBAAwB,KAAK,0BAA0B,KAAK,oBAAoB;AAClG,SAAK,yCAAwC;EACjD;;EAEO,yBAAsB;AACzB,SAAK,QAAQ,KAAK,wBAAwB,KAAK,0BAA0B,KAAK,oBAAoB;AAClG,SAAK,yCAAwC;AAC7C,SAAK,+BAA8B;EACvC;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEA,YAAY,UAA2B,kBAAkB,MAAI;AACzD,UAAM,UAAU,iBAAiB,KAAK,IAAI,0BAAyB,GAAI,eAAe;AAjUlF,SAAA,uBAAuB;AAMxB,SAAA,sBAAsB;AAErB,SAAA,yBAAyB;AAM1B,SAAA,wBAAwB;AAEvB,SAAA,uBAAuB;AAMxB,SAAA,sBAAsB;AAErB,SAAA,uBAAuB;AAMxB,SAAA,sBAAsB;AAGrB,SAAA,mCAAmC;AAgCpC,SAAA,sBAA8B;AAQ9B,SAAA,wBAAgC;AAMhC,SAAA,4BAAqC;AAMrC,SAAA,8BAAuC;AAEtC,SAAA,oBAA2C;AAU5C,SAAA,mBAA0C;AAEzC,SAAA,qBAA4C;AAM7C,SAAA,oBAA2C;AAG3C,SAAA,qBAAqB;AAWrB,SAAA,oBAAoB;AAGnB,SAAA,2BAA2B;AAwB3B,SAAA,qBAAqB;AAMtB,SAAA,oBAAoB;AAGpB,SAAA,kCAAkC;AAOlC,SAAA,iCAAiC;AAOjC,SAAA,mBAA2B;AAM3B,SAAA,mBAA2B;AAM3B,SAAA,sBAAsB;AAOtB,SAAA,YAAY,OAAO,MAAK;AAOxB,SAAA,sBAAsB;AAMtB,SAAA,aAAa;AAOb,SAAA,oBAAoB,OAAO,MAAK;AAE/B,SAAA,+BAA+B;AAShC,SAAA,8BAAuC;AAEtC,SAAA,8BAAqD;AAOtD,SAAA,6BAAoD;AAEnD,SAAA,gCAAuD;AAOxD,SAAA,+BAAsD;AAOtD,SAAA,oBAAsC;AAErC,SAAA,4BAAmD;AAQpD,SAAA,2BAAkD;AAEjD,SAAA,wBAAwB;AASzB,SAAA,uBAAgC;AAQhC,SAAA,6BAA6B,4BAA2B;AAOxD,SAAA,qBAAqB,4BAA2B;AA2CnD,SAAK,SAAS,SAAS,SAAQ;AAC/B,SAAK,yBAAyB;AAE9B,SAAK,2CAA2C,SAAS,gBAAgB,CAAA;AACzE,SAAK,iCAAiC,SAAS,gBAAgB,EAAA;EACnE;EAEgB,kBAAkB,SAAoC,OAAY;AAC9E,QAAI,CAAC,KAAK,wBAAwB,CAAC,KAAK,0BAA0B,CAAC,KAAK,sBAAsB;AAC1F,aAAO;IACX;AAEA,QAAI,QAAQ,mBAAmB;AAC3B,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,cAAI,CAAC,KAAK,kBAAkB,qBAAoB,GAAI;AAChD,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,+BAA+B,cAAc,mCAAmC;AACrF,cAAI,CAAC,KAAK,4BAA4B,qBAAoB,GAAI;AAC1D,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,6BAA6B,cAAc,iCAAiC;AACjF,cAAI,CAAC,KAAK,0BAA0B,qBAAoB,GAAI;AACxD,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,iCAAiC,cAAc,qCAAqC;AACzF,cAAI,CAAC,KAAK,8BAA8B,qBAAoB,GAAI;AAC5D,mBAAO;UACX;QACJ;AAEA,cAAM,oBAAoB,KAAK,sBAAsB,KAAK;AAC1D,YAAI,qBAAqB,cAAc,0BAA0B;AAC7D,cAAI,CAAC,kBAAkB,qBAAoB,GAAI;AAC3C,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,+BAA+B,SAAoC,OAAY;AAC3F,QAAI,CAAC,KAAK,wBAAwB,CAAC,KAAK,0BAA0B,CAAC,KAAK,sBAAsB;AAC1F,cAAQ,aAAa;AACrB,cAAQ,gBAAgB;AACxB,cAAQ,kBAAkB;AAC1B,cAAQ,gBAAgB;AACxB,cAAQ,gBAAgB;AACxB,cAAQ,6CAA6C;AACrD,cAAQ,+CAA+C;AACvD,cAAQ,8BAA8B;AACtC,cAAQ,sCAAsC;AAC9C,cAAQ,mBAAmB;AAC3B,cAAQ,iCAAiC;AACzC,cAAQ,yCAAyC;AACjD,cAAQ,mCAAmC;AAC3C,cAAQ,2CAA2C;AACnD,cAAQ,sBAAsB;AAC9B,cAAQ,6BAA6B;AACrC,cAAQ,0BAA0B;AAClC,cAAQ,qBAAqB;AAC7B,cAAQ,oBAAoB;AAC5B,cAAQ,8BAA8B;AACtC,cAAQ,kCAAkC;AAC1C,cAAQ,6BAA6B;AACrC,cAAQ,+BAA+B;AACvC,cAAQ,mCAAmC;AAC3C,cAAQ,4BAA4B;AACpC,cAAQ,uBAAuB;AAC/B,cAAQ,+BAA+B;AACvC,cAAQ,uCAAuC;AAC/C,cAAQ,qCAAqC;AAC7C,cAAQ,mCAAmC;AAC3C;IACJ;AAEA,QAAI,QAAQ,mBAAmB;AAC3B,cAAQ,aAAa;AAErB,cAAQ,gBAAgB,KAAK;AAC7B,cAAQ,kBAAkB,KAAK;AAC/B,cAAQ,+CAA+C;AACvD,cAAQ,yBAAyB,KAAK;AACtC,cAAQ,gBAAgB,KAAK;AAC7B,cAAQ,8BAA8B;AACtC,cAAQ,iCAAiC;AACzC,cAAQ,mCAAmC;AAC3C,cAAQ,mBAAmB;AAC3B,cAAQ,uBAAuB;AAC/B,cAAQ,gBAAgB;AACxB,cAAQ,6CAA6C;AACrD,cAAQ,sBAAsB;AAC9B,cAAQ,qBAAqB;AAC7B,cAAQ,oBAAoB;AAC5B,cAAQ,8BAA8B;AACtC,cAAQ,6BAA6B;AACrC,cAAQ,0BAA0B;AAClC,cAAQ,kCAAkC;AAC1C,cAAQ,6BAA6B;AACrC,cAAQ,+BAA+B;AACvC,cAAQ,mCAAmC;AAC3C,cAAQ,4BAA4B;AACpC,cAAQ,+BAA+B;AACvC,cAAQ,mCAAmC,KAAK;AAEhD,UAAI,QAAQ,mBAAmB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,sCAA0B,KAAK,mBAAmB,SAAS,6BAA6B;UAC5F;AAEA,cAAI,KAAK,+BAA+B,cAAc,mCAAmC;AACrF,sCAA0B,KAAK,6BAA6B,SAAS,gCAAgC;UACzG;AAEA,cAAI,KAAK,iCAAiC,cAAc,qCAAqC;AACzF,sCAA0B,KAAK,+BAA+B,SAAS,kCAAkC;UAC7G;AAEA,cAAI,KAAK,6BAA6B,cAAc,iCAAiC;AACjF,sCAA0B,KAAK,2BAA2B,SAAS,8BAA8B;AACjG,oBAAQ,qCAAqC,KAAK,0BAA0B;UAChF;QACJ;MACJ;AAEA,cAAQ,mBAAmB,KAAK,mBAAmB,KAAK,qBAAqB;AAC7E,cAAQ,uBAAuB,KAAK;AACpC,cAAQ,6CAA6C,KAAK,gCAAgC,CAAC,KAAK;AAChG,cAAQ,+CAA+C,KAAK,gCAAgC,CAAC,KAAK;AAElG,UAAI,KAAK,sBAAsB;AAC3B,YAAI,MAAM,iBAAiB;AACvB,gBAAM,oBAAoB,KAAK,sBAAsB,KAAK;AAC1D,cAAI,qBAAqB,cAAc,0BAA0B;AAC7D,oBAAQ,gBAAgB;AACxB,oBAAQ,sBAAsB,kBAAkB;AAChD,oBAAQ,qBAAqB,kBAAkB;AAC/C,oBAAQ,oBAAoB,kBAAkB;AAC9C,oBAAQ,8BAA8B,kBAAkB;AACxD,oBAAQ,6BAA6B,KAAK,OAAO,wBAAwB,kBAAkB,SAAS,CAAC,kBAAkB,UAAU,kBAAkB;AACnJ,oBAAQ,0BAA0B,kBAAkB;AACpD,oBAAQ,kCAAkC,KAAK;AAC/C,oBAAQ,6BAA6B,KAAK;AAC1C,oBAAQ,mCAAmC,kBAAkB,UAAgB,kBAAmB;AAChG,oBAAQ,4BAA4B,KAAK;UAC7C;QACJ;MACJ;AAEA,UAAI,KAAK,wBAAwB;AAC7B,gBAAQ,+BAA+B,KAAK;MAChD;IACJ;EACJ;;;;;;;;EASgB,mBAAmB,eAA8B,OAAc,QAAgB,SAAgB;AAC3G,QAAI,CAAC,KAAK,wBAAwB,CAAC,KAAK,0BAA0B,CAAC,KAAK,sBAAsB;AAC1F;IACJ;AAGA,QAAI,KAAK,qBAAqB,KAAO,KAAK,qBAAqB,GAAK;AAChE,oBAAc,aAAa,mBAAmB,GAAG,CAAC;IACtD,OAAO;AACH,cAAQ,iBAAgB,EAAG,eAAc,EAAG,UAAU,WAAW,QAAQ,CAAC,CAAC;AAC3E,YAAM,iBAAiB,KAAK,IAAI,KAAK,IAAI,WAAW,QAAQ,CAAC,EAAE,CAAC,GAAG,KAAK,IAAI,WAAW,QAAQ,CAAC,EAAE,CAAC,GAAG,KAAK,IAAI,WAAW,QAAQ,CAAC,EAAE,CAAC,CAAC;AACvI,oBAAc,aAAa,mBAAmB,KAAK,mBAAmB,iBAAiB,KAAK,mBAAmB,KAAK,oBAAoB,cAAc;IAC1J;EACJ;EAEgB,eAAe,eAA8B,OAAc,QAAgB,SAAgB;AACvG,QAAI,CAAC,KAAK,wBAAwB,CAAC,KAAK,0BAA0B,CAAC,KAAK,sBAAsB;AAC1F;IACJ;AAEA,UAAM,UAAU,QAAQ;AAExB,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,oBAAoB,KAAK,UAAU;AACzC,UAAM,uBAAuB,QAAQ;AAErC,UAAM,oBAAoB,KAAK,sBAAsB,KAAK;AAE1D,QAAI,CAAC,cAAc,UAAU,CAAC,YAAY,CAAC,cAAc,QAAQ;AAC7D,UAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,sBAAc,aAAa,mBAAmB,KAAK,kBAAkB,kBAAkB,KAAK,kBAAkB,KAAK;AACnH,0BAAkB,KAAK,mBAAmB,eAAe,WAAW;MACxE;AAEA,UAAI,KAAK,+BAA+B,cAAc,qCAAqC,QAAQ,gCAAgC;AAC/H,sBAAc,aAAa,6BAA6B,KAAK,4BAA4B,kBAAkB,KAAK,4BAA4B,KAAK;AACjJ,0BAAkB,KAAK,6BAA6B,eAAe,qBAAqB;MAC5F;AAEA,UAAI,KAAK,6BAA6B,cAAc,mCAAmC,QAAQ,8BAA8B;AACzH,sBAAc,aAAa,2BAA2B,KAAK,0BAA0B,kBAAkB,KAAK,0BAA0B,KAAK;AAC3I,0BAAkB,KAAK,2BAA2B,eAAe,mBAAmB;MACxF;AAEA,UAAI,KAAK,iCAAiC,cAAc,uCAAuC,QAAQ,kCAAkC;AACrI,sBAAc,aAAa,+BAA+B,KAAK,8BAA8B,kBAAkB,KAAK,8BAA8B,KAAK;AACvJ,0BAAkB,KAAK,+BAA+B,eAAe,uBAAuB;MAChG;AAEA,UAAI,qBAAqB,cAAc,0BAA0B;AAC7D,sBAAc,aAAa,oBAAoB,kBAAkB,2BAA0B,CAAE;AAE7F,YAAI,QAAQ;AACZ,YAAI,CAAC,kBAAkB,QAAQ;AAC3B,cAAU,kBAAmB,OAAO;AAChC,oBAAc,kBAAmB;UACrC;QACJ;AAEA,cAAM,QAAQ,kBAAkB,QAAO,EAAG;AAC1C,cAAM,gBAAgB,KAAK;AAC3B,sBAAc,aAAa,oBAAoB,kBAAkB,OAAO,IAAI,eAAe,OAAO,KAAK,qBAAqB,KAAK,CAAC;AAClI,sBAAc,aACV,gCACA,OACA,kBAAkB,oBAClB,kBAAkB,qBAClB,IAAM,KAAK,iBAAiB;AAGhC,YAAI,mBAAmB;AACnB,wBAAc,aAAa,4BAA4B,OAAO,KAAK,KAAK,KAAK,CAAC;QAClF;AAEA,YAAU,kBAAmB,iBAAiB;AAC1C,gBAAM,cAA2B;AAEjC,wBAAc,cAAc,uBAAuB,YAAY,mBAAmB;AAClF,wBAAc,cAAc,mBAAmB,YAAY,eAAe;QAC9E;MACJ;AAEA,UAAI,KAAK,sBAAsB;AAC3B,sBAAc,YAAY,8BAA8B,KAAK,gCAAgC;MACjG;AACA,oBAAc,aAAa,sBAAsB,KAAK,iBAAiB;AAEvE,oBAAc,aAAa,cAAc,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,UAAU,GAAG,KAAK,IAAI,MAAS,KAAK,mBAAmB,CAAC;AAC1I,oBAAc,aAAa,sBAAsB,KAAK,qBAAqB,KAAK,WAAW,CAAC;AAE5F,oBAAc,aAAa,wBAAwB,KAAK,qBAAqB,KAAK,uBAAuB,CAAC;AAE1G,oBAAc,YAAY,cAAc,KAAK,UAAU;IAC3D;AAGA,QAAI,MAAM,iBAAiB;AACvB,UAAI,KAAK,qBAAqB,cAAc,yBAAyB;AACjE,sBAAc,WAAW,oBAAoB,KAAK,iBAAiB;MACvE;AAEA,UAAI,KAAK,+BAA+B,cAAc,qCAAqC,QAAQ,gCAAgC;AAC/H,sBAAc,WAAW,8BAA8B,KAAK,2BAA2B;MAC3F;AAEA,UAAI,KAAK,iCAAiC,cAAc,uCAAuC,QAAQ,kCAAkC;AACrI,sBAAc,WAAW,gCAAgC,KAAK,6BAA6B;MAC/F;AAEA,UAAI,KAAK,6BAA6B,cAAc,mCAAmC,QAAQ,8BAA8B;AACzH,sBAAc,WAAW,4BAA4B,KAAK,yBAAyB;MACvF;AAEA,UAAI,qBAAqB,cAAc,0BAA0B;AAC7D,YAAI,sBAAsB;AACtB,wBAAc,WAAW,qBAAqB,iBAAiB;QACnE,OAAO;AACH,wBAAc,WAAW,qBAAqB,kBAAkB,kBAAkB,iBAAiB;AACnG,wBAAc,WAAW,wBAAwB,kBAAkB,kBAAkB,iBAAiB;AACtG,wBAAc,WAAW,yBAAyB,kBAAkB,mBAAmB,iBAAiB;QAC5G;MACJ;IACJ;EACJ;;;;;;;EAQQ,sBAAsB,OAAY;AACtC,QAAI,KAAK,oBAAoB;AACzB,aAAO,KAAK;IAChB;AAEA,QAAI,KAAK,sBAAsB;AAC3B,aAAO,MAAM;IACjB;AAEA,WAAO;EACX;;;;EAKA,IAAW,uBAAoB;AAC3B,WAAO,KAAK,wBAAwB,KAAK;EAC7C;;;;;EAMgB,yBAAyB,eAA8C;AACnF,QAAI,cAAc,4BAA4B,KAAK,sBAAsB,KAAK,mBAAmB,gBAAgB;AAC7G,oBAAc,KAA0B,KAAK,kBAAkB;IACnE;EACJ;EAEgB,WAAW,SAAoB;AAC3C,QAAI,KAAK,sBAAsB,SAAS;AACpC,aAAO;IACX;AAEA,QAAI,KAAK,uBAAuB,SAAS;AACrC,aAAO;IACX;AAEA,QAAI,KAAK,gCAAgC,SAAS;AAC9C,aAAO;IACX;AAEA,QAAI,KAAK,kCAAkC,SAAS;AAChD,aAAO;IACX;AAEA,QAAI,KAAK,8BAA8B,SAAS;AAC5C,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,0BAAuB;AACnC,QAAI,cAAc,4BAA4B,KAAK,sBAAsB,KAAK,mBAAmB,gBAAgB;AAC7G,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,kBAAkB,gBAA6B;AAC3D,QAAI,KAAK,mBAAmB;AACxB,qBAAe,KAAK,KAAK,iBAAiB;IAC9C;AAEA,QAAI,KAAK,oBAAoB;AACzB,qBAAe,KAAK,KAAK,kBAAkB;IAC/C;AAEA,QAAI,KAAK,6BAA6B;AAClC,qBAAe,KAAK,KAAK,2BAA2B;IACxD;AAEA,QAAI,KAAK,2BAA2B;AAChC,qBAAe,KAAK,KAAK,yBAAyB;IACtD;AAEA,QAAI,KAAK,+BAA+B;AACpC,qBAAe,KAAK,KAAK,6BAA6B;IAC1D;EACJ;EAEgB,eAAe,aAA0B;AACrD,QAAI,KAAK,qBAAqB,KAAK,kBAAkB,cAAc,KAAK,kBAAkB,WAAW,SAAS,GAAG;AAC7G,kBAAY,KAAK,KAAK,iBAAiB;IAC3C;AAEA,QAAI,KAAK,sBAAsB,KAAK,mBAAmB,cAAc,KAAK,mBAAmB,WAAW,SAAS,GAAG;AAChH,kBAAY,KAAK,KAAK,kBAAkB;IAC5C;AAEA,QAAI,KAAK,+BAA+B,KAAK,4BAA4B,cAAc,KAAK,4BAA4B,WAAW,SAAS,GAAG;AAC3I,kBAAY,KAAK,KAAK,2BAA2B;IACrD;AAEA,QAAI,KAAK,6BAA6B,KAAK,0BAA0B,cAAc,KAAK,0BAA0B,WAAW,SAAS,GAAG;AACrI,kBAAY,KAAK,KAAK,yBAAyB;IACnD;AAEA,QAAI,KAAK,iCAAiC,KAAK,8BAA8B,cAAc,KAAK,8BAA8B,WAAW,SAAS,GAAG;AACjJ,kBAAY,KAAK,KAAK,6BAA6B;IACvD;EACJ;EAEgB,QAAQ,sBAA8B;AAClD,QAAI,sBAAsB;AACtB,UAAI,KAAK,mBAAmB;AACxB,aAAK,kBAAkB,QAAO;MAClC;AAEA,UAAI,KAAK,oBAAoB;AACzB,aAAK,mBAAmB,QAAO;MACnC;AAEA,UAAI,KAAK,6BAA6B;AAClC,aAAK,4BAA4B,QAAO;MAC5C;AAEA,UAAI,KAAK,2BAA2B;AAChC,aAAK,0BAA0B,QAAO;MAC1C;AAEA,UAAI,KAAK,+BAA+B;AACpC,aAAK,8BAA8B,QAAO;MAC9C;IACJ;EACJ;EAEgB,eAAY;AACxB,WAAO;EACX;EAEgB,aAAa,SAAoC,WAA4B,aAAmB;AAC5G,QAAI,QAAQ,eAAe;AACvB,gBAAU,YAAY,eAAe,eAAe;IACxD;AACA,QAAI,QAAQ,iBAAiB;AACzB,gBAAU,YAAY,eAAe,iBAAiB;IAC1D;AACA,WAAO;EACX;EAEgB,YAAY,UAAkB;AAC1C,aAAS,KACL,oBACA,8BACA,gCACA,qBACA,wBACA,yBACA,0BAA0B;EAElC;EAEgB,cAAW;AACvB,WAAO;MACH,KAAK;QACD,EAAE,MAAM,gCAAgC,MAAM,GAAG,MAAM,OAAM;QAC7D,EAAE,MAAM,4BAA4B,MAAM,GAAG,MAAM,OAAM;QACzD,EAAE,MAAM,+BAA+B,MAAM,GAAG,MAAM,OAAM;QAC5D,EAAE,MAAM,oBAAoB,MAAM,GAAG,MAAM,OAAM;QACjD,EAAE,MAAM,oBAAoB,MAAM,IAAI,MAAM,OAAM;QAClD,EAAE,MAAM,mBAAmB,MAAM,GAAG,MAAM,OAAM;QAChD,EAAE,MAAM,6BAA6B,MAAM,GAAG,MAAM,OAAM;QAC1D,EAAE,MAAM,mBAAmB,MAAM,IAAI,MAAM,OAAM;QACjD,EAAE,MAAM,6BAA6B,MAAM,IAAI,MAAM,OAAM;QAC3D,EAAE,MAAM,+BAA+B,MAAM,IAAI,MAAM,OAAM;QAC7D,EAAE,MAAM,mBAAmB,MAAM,GAAG,MAAM,OAAM;QAChD,EAAE,MAAM,sBAAsB,MAAM,GAAG,MAAM,OAAM;QACnD,EAAE,MAAM,cAAc,MAAM,GAAG,MAAM,OAAM;QAC3C,EAAE,MAAM,wBAAwB,MAAM,GAAG,MAAM,OAAM;QACrD,EAAE,MAAM,uBAAuB,MAAM,GAAG,MAAM,OAAM;QACpD,EAAE,MAAM,mBAAmB,MAAM,GAAG,MAAM,OAAM;QAChD,EAAE,MAAM,8BAA8B,MAAM,GAAG,MAAM,QAAO;QAC5D,EAAE,MAAM,cAAc,MAAM,GAAG,MAAM,QAAO;QAE5C,EAAE,MAAM,sBAAsB,MAAM,GAAG,MAAM,OAAM;QACnD,EAAE,MAAM,2BAA2B,MAAM,GAAG,MAAM,OAAM;QACxD,EAAE,MAAM,2BAA2B,MAAM,IAAI,MAAM,OAAM;;;EAGrE;;AApzBc,2BAAA,uCAAuC;AAQvC,2BAAA,8BAA8B;AAUrC,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,UAAS;EACT,iBAAiB,wBAAwB;;AAIlC,WAAA;EADP,UAAS;;AAiCH,WAAA;EADN,UAAS;;AASH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAaH,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAS7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAe7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAI5C,WAAA;EADP,UAAS;;AAWV,WAAA;EADC,iBAAiB,kCAAkC;;AAqB7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAW7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAQ7C,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,kBAAiB;;AAQX,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,kBAAiB;;AAYX,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAU7C,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAQ7C,WAAA;EADN,kBAAiB;;AAWX,WAAA;EAFN,mBAAkB;EAClB,iBAAiB,kCAAkC;;AAY7C,WAAA;EAFN,UAAS;EACT,iBAAiB,kCAAkC;;AAS7C,WAAA;EADN,UAAS;;AAQH,WAAA;EADN,UAAS;;;;ACnSd,IAAMC,6BAA4B,EAAE,QAAQ,MAA2B,SAAS,KAAoC;AAEpH,IAAM,yBAAN,cAAqC,eAAe,eAAe,EAAC;;AAM9D,IAAO,qBAAP,cAAkC,4BAA4B,sBAAsB,EAAC;;;;;EAiNvF,YAAY,oBAAuE;AAC/E,UAAM,kBAAkB;AAjNrB,SAAA,MAAM;AAEN,SAAA,cAAc;AACd,SAAA,qBAAqB;AACrB,SAAA,oBAAoB;AAEpB,SAAA,SAAS;AACT,SAAA,cAAc;AACd,SAAA,iBAAiB;AACjB,SAAA,cAAc;AAEd,SAAA,cAAc;AACd,SAAA,sBAAsB;AACtB,SAAA,yBAAyB;AACzB,SAAA,iCAAiC;AAEjC,SAAA,iCAAiC;AAEjC,SAAA,UAAU;AACV,SAAA,kBAAkB;AAClB,SAAA,qBAAqB;AAErB,SAAA,UAAU;AACV,SAAA,cAAc;AACd,SAAA,kBAAkB;AAClB,SAAA,aAAa;AACb,SAAA,YAAY;AACZ,SAAA,eAAe;AACf,SAAA,aAAa;AACb,SAAA,kBAAkB;AAClB,SAAA,iBAAiB;AACjB,SAAA,oBAAoB;AACpB,SAAA,oBAAoB;AACpB,SAAA,eAAe;AACf,SAAA,qBAAqB;AACrB,SAAA,mBAAmB;AAEnB,SAAA,WAAW;AACX,SAAA,mBAAmB;AACnB,SAAA,gBAAgB;AAEhB,SAAA,eAAe;AACf,SAAA,qBAAqB;AACrB,SAAA,uBAAuB;AACvB,SAAA,eAAe;AAEf,SAAA,kCAAkC;AAClC,SAAA,wBAAwB;AACxB,SAAA,uBAAuB;AACvB,SAAA,kBAAkB;AAClB,SAAA,0BAA0B;AAE1B,SAAA,mBAAmB;AACnB,SAAA,gCAAgC;AAChC,SAAA,gCAAgC;AAChC,SAAA,gCAAgC;AAChC,SAAA,uBAAuB;AACvB,SAAA,uBAAuB;AACvB,SAAA,6BAA6B;AAC7B,SAAA,+BAA+B;AAC/B,SAAA,sCAAsC;AACtC,SAAA,cAAc;AACd,SAAA,oBAAoB;AACpB,SAAA,sBAAsB;AAEtB,SAAA,kBAAkB;AAClB,SAAA,uBAAuB;AAEvB,SAAA,SAAS;AACT,SAAA,UAAU;AACV,SAAA,OAAO;AACP,SAAA,eAAe;AACf,SAAA,wBAAwB;AACxB,SAAA,WAAW;AACX,SAAA,eAAe;AACf,SAAA,oBAAoB;AACpB,SAAA,gBAAgB;AAEhB,SAAA,WAAW;AACX,SAAA,mBAAmB;AACnB,SAAA,yBAAyB;AACzB,SAAA,gBAAgB;AAChB,SAAA,eAAe;AAEf,SAAA,aAAa;AACb,SAAA,mBAAmB;AACnB,SAAA,0BAA0B;AAC1B,SAAA,uBAAuB;AACvB,SAAA,sBAAsB;AACtB,SAAA,gCAAgC;AAChC,SAAA,2BAA2B;AAC3B,SAAA,uBAAuB;AACvB,SAAA,yBAAyB;AACzB,SAAA,gCAAgC;AAChC,SAAA,sCAAsC;AACtC,SAAA,8CAA8C;AAC9C,SAAA,iBAAiB;AACjB,SAAA,gCAAgC;AAChC,SAAA,mBAAmB;AACnB,SAAA,oCAAoC;AACpC,SAAA,uBAAuB;AACvB,SAAA,0BAA0B;AAC1B,SAAA,uBAAuB;AACvB,SAAA,kBAAkB;AAClB,SAAA,iBAAiB;AACjB,SAAA,2BAA2B;AAC3B,SAAA,oBAAoB;AACpB,SAAA,mBAAmB;AAEnB,SAAA,YAAY;AACZ,SAAA,iBAAiB;AACjB,SAAA,iBAAiB;AAEjB,SAAA,UAAU;AACV,SAAA,gBAAgB;AAChB,SAAA,sBAAsB;AACtB,SAAA,qBAAqB;AACrB,SAAA,2BAA2B;AAC3B,SAAA,iBAAiB;AACjB,SAAA,uBAAuB;AACvB,SAAA,sBAAsB;AACtB,SAAA,4BAA4B;AAC5B,SAAA,gBAAgB;AAChB,SAAA,sBAAsB;AACtB,SAAA,4BAA4B;AAC5B,SAAA,kCAAkC;AAClC,SAAA,gCAAgC;AAChC,SAAA,sCAAsC;AACtC,SAAA,iBAAiB;AACjB,SAAA,uBAAuB;AACvB,SAAA,4BAA4B;AAC5B,SAAA,uBAAuB;AACvB,SAAA,6BAA6B;AAC7B,SAAA,mBAAmB;AACnB,SAAA,yBAAyB;AACzB,SAAA,yBAAyB;AACzB,SAAA,+BAA+B;AAC/B,SAAA,mBAAmB;AACnB,SAAA,yBAAyB;AACzB,SAAA,0BAA0B;AAC1B,SAAA,gCAAgC;AAChC,SAAA,uBAAuB;AACvB,SAAA,6BAA6B;AAC7B,SAAA,kBAAkB;AAElB,SAAA,uBAAuB;AACvB,SAAA,eAAe;AACf,SAAA,cAAc;AACd,SAAA,yBAAyB;AAEzB,SAAA,oBAAoB;AAEpB,SAAA,eAAe;AACf,SAAA,wBAAwB;AACxB,SAAA,sBAAsB;AACtB,SAAA,uBAAuB;AACvB,SAAA,kBAAkB;AAClB,SAAA,mBAAmB;AACnB,SAAA,qBAAqB;AACrB,SAAA,kCAAkC;AAClC,SAAA,gCAAgC;AAChC,SAAA,iCAAiC;AACjC,SAAA,4BAA4B;AAC5B,SAAA,6BAA6B;AAC7B,SAAA,+BAA+B;AAC/B,SAAA,wBAAwB;AACxB,SAAA,uBAAuB;AAEvB,SAAA,YAAY;AACZ,SAAA,iCAAiC;AACjC,SAAA,wCAAwC;AAExC,SAAA,0BAA0B;AAC1B,SAAA,sBAAsB;AACtB,SAAA,mBAAmB;AACnB,SAAA,WAAW;AACX,SAAA,cAAc;AACd,SAAA,YAAY;AACZ,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,YAAY;AACZ,SAAA,MAAM;AACN,SAAA,mBAAmB;AACnB,SAAA,sBAAsB;AACtB,SAAA,qBAAqB;AACrB,SAAA,qBAAqB;AAErB,SAAA,qBAAqB;AAErB,SAAA,aAAa;AAEb,SAAA,QAAQ;AAER,SAAA,qBAAqB;AAErB,SAAA,YAAY;AACZ,SAAA,qBAAqB;AAErB,SAAA,oBAAoB;AACpB,SAAA,mBAAmB;AAQtB,SAAK,QAAO;EAChB;;;;EAKgB,QAAK;AACjB,UAAM,MAAK;AACX,SAAK,iBAAiB;AACtB,SAAK,MAAM;AACX,SAAK,gBAAgB;EACzB;;AAGJ,IAAM,sBAAN,cAAkC,qBAAqB,YAAY,EAAC;;AAU9D,IAAgB,kBAAhB,MAAgB,yBAAwB,oBAAmB;;;;EAqd7D,IAAW,oBAAiB;AACxB,WAAO,KAAK;EAChB;EACA,IAAW,kBAAkB,GAAU;AACnC,SAAK,qBAAqB;AAC1B,SAAK,YAAY,CAAA;EACrB;;;;EAMA,IAAW,2BAAwB;AAC/B,WAAO,KAAK;EAChB;EACA,IAAW,yBAAyB,GAAS;AACzC,SAAK,4BAA4B;AACjC,SAAK,YAAY,CAAA;EACrB;;;;EAKA,IAAoB,iBAAc;AAC9B,WAAO;EACX;;;;;;;;EAqHA,YAAYC,OAAc,OAAe,YAAY,OAAK;AACtD,UAAMA,OAAM,OAAO,QAAW,aAAa,iBAAgB,SAAS;AA5iBjE,SAAA,mBAA2B;AAO3B,SAAA,qBAA6B;AAO7B,SAAA,wBAAgC;AAOhC,SAAA,qBAA6B;AAK5B,SAAA,iBAA0B,IAAI,QAAQ,KAAK,kBAAkB,KAAK,oBAAoB,KAAK,uBAAuB,KAAK,kBAAkB;AAM1I,SAAA,kBAA2B;AAM3B,SAAA,iBAAwC;AAMxC,SAAA,qBAA4C;AAM5C,SAAA,+BAAsD;AAMtD,SAAA,kBAAyC;AAMzC,SAAA,0BAAkC;AAQlC,SAAA,0CAAkD,iBAAgB;AAMlE,SAAA,kBAAyC;AAMzC,SAAA,qBAA4C;AAM5C,SAAA,mBAA0C;AAM1C,SAAA,uBAA8C;AAM9C,SAAA,mBAA0C;AAO1C,SAAA,YAA8B;AAO9B,SAAA,aAA+B;AAY/B,SAAA,oBAAoB;AAYpB,SAAA,4BAA4B,OAAO,MAAK;AAOxC,SAAA,iDAAiD;AAOjD,SAAA,8BAAqD;AASrD,SAAA,sBAA6C;AAO7C,SAAA,uBAA8C;AAM9C,SAAA,eAAsC;AAMtC,SAAA,mBAA0C;AAM1C,SAAA,gBAAgB,IAAI,OAAO,GAAG,GAAG,CAAC;AAMlC,SAAA,eAAe,IAAI,OAAO,GAAG,GAAG,CAAC;AAMjC,SAAA,cAAc;AAOd,SAAA,wBAA0C;AAM1C,SAAA,qBAAqB,IAAI,OAAO,GAAG,GAAG,CAAC;AAMvC,SAAA,mBAAmB,IAAI,OAAO,GAAG,GAAG,CAAC;AAMrC,SAAA,iBAAiB,IAAI,OAAO,GAAG,GAAG,CAAC;AAMnC,SAAA,gBAAgB;AAMhB,SAAA,0BAA0B;AAO1B,SAAA,uBAAuB;AAOvB,SAAA,wBAAwB;AAMxB,SAAA,6BAA6B;AAO7B,SAAA,wBAAwB;AAMxB,SAAA,2CAA2C;AAM3C,SAAA,wCAAwC;AAMxC,SAAA,wCAAwC;AAMxC,SAAA,wCAAwC;AAMxC,SAAA,6CAA6C;AAM7C,SAAA,yBAAyB;AAOzB,SAAA,0CAA0C;AAO1C,SAAA,gBAAgB,iBAAgB;AAOhC,SAAA,wBAAwB;AAMxB,SAAA,2BAA2B;AAM3B,SAAA,eAAe;AAMf,SAAA,wBAAwB;AAMxB,SAAA,qBAAqB;AAMrB,SAAA,mBAAmB;AAMnB,SAAA,yBAAyB;AAMzB,SAAA,oBAAoB;AAMpB,SAAA,oBAAoB;AAMpB,SAAA,oBAAoB;AAMpB,SAAA,eAAe;AAOf,SAAA,mBAAmB;AAOnB,SAAA,yBAAyB;AAQzB,SAAA,0BAAiD;AAMjD,SAAA,6BAA6B;AAE5B,SAAA,qBAA8B;AAY9B,SAAA,4BAAoC;AAuBrC,SAAA,sBAAsB;AAQtB,SAAA,8BAA8B;AAK7B,SAAA,iBAAiB,IAAI,WAAgC,EAAE;AAKvD,SAAA,sBAAsB,IAAI,OAAO,GAAG,GAAG,CAAC;AAKxC,SAAA,SAAS;AAKT,SAAA,+BAA+B;AAE/B,SAAA,aAAa;AAEb,SAAA,iBAAiB;AACjB,SAAA,0BAA0B;AAS3B,SAAA,YAAY;AAUZ,SAAA,aAAa;AAQb,SAAA,cAAc;AA0CX,SAAA,gCAAgC;AAYtC,SAAK,OAAO,IAAI,qBAAqB,IAAI;AACzC,SAAK,YAAY,IAAI,0BAA0B,IAAI;AACnD,SAAK,cAAc,IAAI,4BAA4B,IAAI;AACvD,SAAK,aAAa,IAAI,4BAA4B,IAAI;AACtD,SAAK,QAAQ,IAAI,sBAAsB,IAAI;AAC3C,SAAK,aAAa,IAAI,2BAA2B,IAAI;AACrD,SAAK,YAAY,IAAI,uBAAuB,IAAI;AAGhD,SAAK,oCAAoC,IAAI;AAE7C,SAAK,0BAA0B,MAAsC;AACjE,WAAK,eAAe,MAAK;AAEzB,UAAI,cAAc,4BAA4B,KAAK,sBAAsB,KAAK,mBAAmB,gBAAgB;AAC7G,aAAK,eAAe,KAA0B,KAAK,kBAAkB;MACzE;AAEA,WAAK,WAAW,gBAAgB,KAAK;AACrC,WAAK,6CAA6C,KAAK,UAAU;AAEjE,aAAO,KAAK;IAChB;AAEA,SAAK,0BAA0B,0BAA0B,KAAK,SAAQ,CAAE;AACxE,SAAK,uBAAuB,IAAI,qBAAoB;EACxD;;;;EAKA,IAAoB,0BAAuB;AACvC,QAAI,cAAc,4BAA4B,KAAK,sBAAsB,KAAK,mBAAmB,gBAAgB;AAC7G,aAAO;IACX;AAEA,WAAO,KAAK;EAChB;;;;EAKA,IAAoB,mBAAgB;AAChC,WAAO,CAAC,KAAK;EACjB;;;;EAKgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAuB,wBAAqB;AACxC,WACI,KAAK,sBAAsB,iBAAgB,sBAC3C,KAAK,sBAAsB,iBAAgB,yBAC3C,KAAK,YAAY;EAEzB;;;;EAKgB,oBAAiB;AAC7B,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,QAAI,KAAK,uBAAuB;AAC5B,aAAO;IACX;AAEA,WAAO,KAAK,QAAQ,KAAO,KAAK,mBAAmB,QAAQ,KAAK,iCAAgC;EACpG;;;;EAKgB,mBAAgB;AAC5B,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,QAAI,KAAK,YAAY,sBAAsB;AACvC,aAAO;IACX;AAEA,WAAO,KAAK,iBAAgB,MAAO,KAAK,qBAAqB,QAAQ,KAAK,sBAAsB,iBAAgB;EACpH;;;;EAKU,mCAAgC;AACtC,WAAO,KAAK,kBAAkB,QAAQ,KAAK,eAAe,YAAY,KAAK,8BAA8B,KAAK,sBAAsB,iBAAgB;EACxJ;;;;EAKU,mBAAgB;AACtB,WAAQ,KAAK,kBAAkB,QAAQ,KAAK,eAAe,YAAa,KAAK,mBAAmB;EACpG;;;;EAKgB,sBAAmB;AAC/B,WAAO,KAAK;EAChB;;;;;;;;EASgB,kBAAkB,MAAoB,SAAkB,cAAsB;AAC1F,QAAI,CAAC,KAAK,2BAA2B;AACjC,WAAK,mBAAkB;IAC3B;AAEA,UAAM,cAAc,QAAQ;AAE5B,QAAI,YAAY,UAAU,KAAK,UAAU;AACrC,UAAI,YAAY,uBAAuB,YAAY,iCAAiC,cAAc;AAC9F,eAAO;MACX;IACJ;AAEA,QAAI,CAAC,QAAQ,iBAAiB;AAC1B,WAAK,4BAA2B,GAAqC,KAAK,UAAU;AACpF,cAAQ,kBAAkB,IAAI,mBAAmB,KAAK,WAAW,WAAW;IAChF;AAEA,UAAM,UAA8B,QAAQ;AAC5C,QAAI,KAAK,mBAAmB,OAAO,GAAG;AAClC,aAAO;IACX;AAEA,UAAM,QAAQ,KAAK,SAAQ;AAC3B,UAAM,SAAS,MAAM,UAAS;AAE9B,QAAI,QAAQ,mBAAmB;AAC3B,WAAK,WAAW,0BAA0B;AAC1C,WAAK,4CAA4C,KAAK,UAAU;AAChE,WAAK,gCAAgC,KAAK,WAAW;AACrD,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,kBAAkB,cAAc,uBAAuB;AAC5D,cAAI,CAAC,KAAK,eAAe,qBAAoB,GAAI;AAC7C,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,sBAAsB,cAAc,0BAA0B;AACnE,cAAI,CAAC,KAAK,mBAAmB,qBAAoB,GAAI;AACjD,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,gCAAgC,cAAc,oCAAoC;AACvF,cAAI,CAAC,KAAK,6BAA6B,qBAAoB,GAAI;AAC3D,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,cAAI,CAAC,KAAK,gBAAgB,qBAAoB,GAAI;AAC9C,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,cAAI,CAAC,KAAK,gBAAgB,qBAAoB,GAAI;AAC9C,mBAAO;UACX;QACJ;AAEA,cAAM,oBAAoB,KAAK,sBAAqB;AACpD,YAAI,qBAAqB,cAAc,0BAA0B;AAC7D,cAAI,CAAC,kBAAkB,qBAAoB,GAAI;AAC3C,mBAAO;UACX;AACA,cAAI,kBAAkB,mBAAmB;AACrC,gBAAI,CAAC,kBAAkB,kBAAkB,qBAAoB,GAAI;AAC7D,qBAAO;YACX;UACJ,OAAO;AAEH,gBAAI,CAAC,kBAAkB,uBAAuB,kBAAkB,mBAAkB,GAAI,6BAA6B;AAC/G,qBAAO;YACX;UACJ;QACJ;AAEA,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,cAAI,CAAC,KAAK,iBAAiB,qBAAoB,GAAI;AAC/C,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,cAAI,CAAC,KAAK,iBAAiB,qBAAoB,GAAI;AAC/C,mBAAO;UACX;QACJ;AAEA,YAAI,cAAc,wBAAwB;AACtC,cAAI,KAAK,kBAAkB;AACvB,gBAAI,CAAC,KAAK,iBAAiB,qBAAoB,GAAI;AAC/C,qBAAO;YACX;UACJ,WAAW,KAAK,sBAAsB;AAClC,gBAAI,CAAC,KAAK,qBAAqB,qBAAoB,GAAI;AACnD,qBAAO;YACX;UACJ;AAEA,cAAI,KAAK,6BAA6B;AAClC,gBAAI,CAAC,KAAK,4BAA4B,qBAAoB,GAAI;AAC1D,qBAAO;YACX;UACJ;AAEA,cAAI,KAAK,qBAAqB;AAC1B,gBAAI,CAAC,KAAK,oBAAoB,qBAAoB,GAAI;AAClD,qBAAO;YACX;UACJ;AAEA,cAAI,KAAK,sBAAsB;AAC3B,gBAAI,CAAC,KAAK,qBAAqB,qBAAoB,GAAI;AACnD,qBAAO;YACX;UACJ;QACJ;AAEA,YAAI,OAAO,QAAO,EAAG,uBAAuB,KAAK,gBAAgB,cAAc,sBAAsB,CAAC,KAAK,iBAAiB;AAExH,cAAI,CAAC,KAAK,aAAa,QAAO,GAAI;AAC9B,mBAAO;UACX;QACJ;AAEA,YAAI,KAAK,2BAA2B,cAAc,0BAA0B;AAExE,cAAI,CAAC,KAAK,wBAAwB,QAAO,GAAI;AACzC,mBAAO;UACX;QACJ;MACJ;IACJ;AAEA,SAAK,WAAW,oBAAoB;AACpC,SAAK,WAAW,UAAU;AAC1B,SAAK,WAAW,UAAU;AAC1B,SAAK,sCAAsC,KAAK,UAAU;AAE1D,QAAI,CAAC,KAAK,WAAW,mBAAmB;AACpC,aAAO;IACX;AAEA,QAAI,QAAQ,4BAA4B,KAAK,+BAA+B;AACxE,UAAI,CAAC,KAAK,8BAA8B,QAAO,GAAI;AAC/C,eAAO;MACX;IACJ;AAGA,QAAI,QAAQ,eAAe,KAAK,QAAQ,kBAAkB,GAAG;AACzD,eAAS,QAAQ,GAAG,QAAQ,KAAK,aAAa,QAAQ,SAAS;AAC3D,YAAI,CAAC,KAAK,aAAa,KAAK,EAAE,SAAQ,GAAI;AACtC,iBAAO;QACX;MACJ;IACJ;AAEA,QAAI,CAAC,OAAO,QAAO,EAAG,uBAAuB,CAAC,KAAK,sBAAsB,aAAa,UAAU,GAAG;AAC/F,WAAK,cAAc,IAAI;AACvB,aAAO,KAAK,0DAA0D,KAAK,IAAI;IACnF;AAEA,UAAM,iBAAiB,QAAQ;AAC/B,UAAM,gBAAgB,QAAQ;AAC9B,QAAI,SAAS,KAAK,eAAe,MAAM,QAAQ,iBAAgB,GAAI,SAAS,KAAK,YAAY,KAAK,SAAS,cAAc,IAAI;AAE7H,QAAI,6BAA6B;AAEjC,QAAI,QAAQ;AACR,UAAI,KAAK,4BAA4B;AACjC,QAAAD,2BAA0B,SAAS;AACnC,QAAAA,2BAA0B,UAAU;AACpC,aAAK,2BAA2B,gBAAgBA,0BAAyB;MAC7E;AAGA,UAAI,KAAK,0BAA0B,kBAAkB,CAAC,OAAO,QAAO,GAAI;AACpE,iBAAS;AACT,gBAAQ,kBAAiB;AAEzB,qCAA6B,KAAK;AAElC,YAAI,eAAe;AAEf,kBAAQ,qBAAqB;AAC7B,iBAAO;QACX;MACJ,OAAO;AACH,cAAM,oBAAmB;AACzB,gBAAQ,UAAU,QAAQ,SAAS,KAAK,gBAAgB;MAC5D;IACJ;AAEA,QAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,OAAO,QAAO,GAAI;AAC9C,aAAO;IACX;AAEA,YAAQ,YAAY,MAAM,YAAW;AACrC,gBAAY,sBAAsB,6BAA6B,QAAQ;AACvE,gBAAY,+BAA+B,CAAC,CAAC;AAE7C,SAAK,+BAA8B;AAEnC,WAAO;EACX;;;;;EAMO,qBAAkB;AACrB,QAAI,KAAK,aAAa,QAAQ,KAAK,cAAc,QAAQ,KAAK,kBAAkB;AAC5E,aAAO;IACX;AAEA,WAAO;EACX;EAEQ,eACJ,MACA,eACA,SACA,aAAiD,MACjD,UAA8D,MAC9D,eAAkC,MAClC,eAAkC,MAAI;AAEtC,SAAK,gBAAgB,MAAM,eAAe,SAAS,cAAc,YAAY;AAE7E,QAAI,CAAC,QAAQ,SAAS;AAClB,aAAO;IACX;AAEA,YAAQ,gBAAe;AAEvB,UAAM,QAAQ,KAAK,SAAQ;AAC3B,UAAM,SAAS,MAAM,UAAS;AAG9B,UAAM,YAAY,IAAI,gBAAe;AACrC,QAAI,eAAe;AACnB,QAAI,QAAQ,sBAAsB;AAC9B,gBAAU,YAAY,gBAAgB,sBAAsB;IAChE;AAEA,QAAI,QAAQ,KAAK;AACb,gBAAU,YAAY,cAAc,KAAK;IAC7C;AACA,QAAI,QAAQ,YAAY;AACpB,gBAAU,YAAY,cAAc,YAAY;IACpD;AACA,QAAI,QAAQ,WAAW;AACnB,gBAAU,YAAY,cAAc,WAAW;IACnD;AACA,QAAI,QAAQ,kBAAkB;AAC1B,gBAAU,YAAY,cAAc,kBAAkB;IAC1D;AACA,QAAI,QAAQ,UAAU;AAClB,gBAAU,YAAY,cAAc,UAAU;IAClD;AACA,QAAI,QAAQ,cAAc;AACtB,gBAAU,YAAY,cAAc,cAAc;IACtD;AACA,QAAI,QAAQ,mBAAmB;AAC3B,gBAAU,YAAY,gBAAgB,mBAAmB;IAC7D;AAEA,QAAI,QAAQ,iBAAiB;AACzB,gBAAU,YAAY,gBAAgB,iBAAiB;IAC3D;AAEA,QAAI,QAAQ,SAAS;AACjB,gBAAU,YAAY,gBAAgB,SAAS;IACnD;AAEA,QAAI,QAAQ,MAAM;AACd,gBAAU,YAAY,gBAAgB,MAAM;IAChD;AAEA,mBAAe,0BAA0B,SAAS,WAAW,KAAK,wBAAwB,cAAc;AAExG,QAAI,QAAQ,cAAc;AACtB,gBAAU,YAAY,gBAAgB,cAAc;IACxD;AAEA,QAAI,QAAQ,+BAA+B;AACvC,gBAAU,YAAY,gBAAgB,+BAA+B;IACzE;AAEA,QAAI,QAAQ,kBAAkB;AAC1B,gBAAU,YAAY,gBAAgB,kBAAkB;IAC5D;AAEA,QAAI,QAAQ,UAAU;AAClB,gBAAU,YAAY,gBAAgB,UAAU;IACpD;AAEA,QAAI,QAAQ,QAAQ;AAChB,gBAAU,YAAY,gBAAgB,QAAQ;IAClD;AAEA,QAAI,QAAQ,SAAS;AACjB,gBAAU,YAAY,gBAAgB,SAAS;IACnD;AAEA,QAAI,QAAQ,UAAU;AAClB,gBAAU,YAAY,gBAAgB,UAAU;IACpD;AAEA,QAAI,QAAQ,aAAa;AACrB,gBAAU,YAAY,gBAAgB,aAAa;IACvD;AAEA,QAAI,QAAQ,cAAc;AACtB,gBAAU,YAAY,gBAAgB,cAAc;IACxD;AAEA,QAAI,QAAQ,WAAW;AACnB,gBAAU,YAAY,GAAG,WAAW;IACxC;AAGA,UAAM,UAAU,CAAC,aAAa,YAAY;AAE1C,QAAI,QAAQ,QAAQ;AAChB,cAAQ,KAAK,aAAa,UAAU;IACxC;AAEA,QAAI,QAAQ,SAAS;AACjB,cAAQ,KAAK,aAAa,WAAW;IACzC;AAEA,aAAS,IAAI,GAAG,KAAK,GAAA,EAAA,GAAA;AACjB,UAAI,QAAQ,OAAO,CAAC,GAAG;AACnB,gBAAQ,KAAK,KAAK,MAAM,IAAI,KAAK,CAAC,EAAE;MACxC;IACJ;AAEA,QAAI,QAAQ,aAAa;AACrB,cAAQ,KAAK,aAAa,SAAS;IACvC;AAEA,8BAA0B,SAAS,MAAM,SAAS,SAAS;AAC3D,kCAA8B,SAAS,OAAO;AAC9C,qCAAiC,SAAS,MAAM,OAAO;AACvD,6CAAyC,SAAS,MAAM,OAAO;AAE/D,QAAI,aAAa;AAEjB,UAAM,WAAW;MACb;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;AAGJ,UAAM,WAAW;MACb;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;AAGJ,qCAAiC,UAAU,UAAU,IAAI;AAEzD,UAAM,iBAAiB,CAAC,YAAY,SAAS,MAAM;AAEnD,UAAM,kBAAkB,EAAE,uBAAuB,KAAK,wBAAwB,6BAA6B,QAAQ,sBAAqB;AAExI,SAAK,WAAW,YAAY;AAC5B,SAAK,WAAW,eAAe;AAC/B,SAAK,WAAW,UAAU;AAC1B,SAAK,WAAW,WAAW;AAC3B,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,WAAW;AAC3B,SAAK,WAAW,sBAAsB;AACtC,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,OAAO;AACvB,SAAK,WAAW,kBAAkB;AAClC,SAAK,4BAA2B,KAAoC,KAAK,UAAU;AAEnF,oCAAgC,uBAAuB,UAAU,QAAQ;AAEzE,yBAAqB,YAAY,QAAQ;AACzC,yBAAqB,YAAY,QAAQ;AACzC,yBAAqB,QAAQ;AAE7B,QAAI,8BAA8B;AAC9B,mCAA6B,gBAAgB,UAAU,OAAO;AAC9D,mCAA6B,gBAAgB,UAAU,OAAO;IAClE;AAEA,mCAAuD;MACnD,eAAe;MACf,qBAAqB;MACrB;MACA;MACA,uBAAuB,KAAK;KAC/B;AAED,UAAM,cAA+C,CAAA;AAErD,QAAI,KAAK,yBAAyB;AAC9B,mBAAa,KAAK,wBAAwB,YAAY,UAAU,gBAAgB,UAAU,SAAS,SAAS,WAAW;IAC3H;AAEA,UAAM,OAAO,QAAQ,SAAQ;AAC7B,UAAM,SAAS,OAAO,aAClB,YACwB;MACpB,YAAY;MACZ,eAAe;MACf,qBAAqB;MACrB;MACA,SAAS;MACT;MACA;MACA;MACA;MACA,kBAAkB,YAAY;MAC9B,0BAA0B,KAAK,WAAW;MAC1C,aAAa,QAAQ;MACrB,gBAAgB,KAAK;MACrB,2BAA2B,KAAK,iBAC1B,SACA,YAAW;AACP,YAAI,KAAK,mBAAc,GAA0B;AAC7C,gBAAM,QAAQ,IAAI,CAAC,OAAO,0BAAiC,GAAA,OAAO,4BAAoC,CAAA,CAAA;QAC1G,OAAO;AACH,gBAAM,QAAQ,IAAI,CAAC,OAAO,0BAA6B,GAAA,OAAO,4BAAgC,CAAA,CAAA;QAClG;AAEA,aAAK,iBAAiB;MAC1B;OAEV,MAAM;AAGV,SAAK,WAAW,aAAa;AAE7B,WAAO;EACX;EAEQ,gBACJ,MACA,eACA,SACA,eAAkC,MAClC,eAAkC,MAAI;AAEtC,UAAM,mBAAmB,cAAc;AAEvC,UAAM,QAAQ,KAAK,SAAQ;AAC3B,UAAM,SAAS,MAAM,UAAS;AAG9B,4BAAwB,OAAO,MAAM,SAAS,MAAM,KAAK,wBAAwB,KAAK,gBAAgB;AACtG,YAAQ,eAAe;AAGvB,+BAA2B,OAAO,OAAO;AAGzC,UAAM,MAAM,KAAK,yBAAyB,IAAI,KAAK,KAAK,SAAQ,EAAG;AACnE,6BAAyB,OAAO,SAAS,KAAK,kBAAkB,CAAC,GAAG;AAGpE,yBAAqB,OAAO,SAAS,GAAG;AAExC,oCAAgC,eAAe,OAAO,qBAAqB,MAAM,OAAO;AAGxF,YAAQ,mBAAmB,KAAK,mBAAkB;AAClD,QAAI,QAAQ,mBAAmB;AAC3B,cAAQ,WAAW;AACnB,eAAS,IAAI,GAAG,KAAK,GAAA,EAAA,GAAA;AACjB,gBAAQ,WAAW,CAAC,IAAI;MAC5B;AACA,UAAI,MAAM,iBAAiB;AACvB,gBAAQ,iBAAiB;AACzB,gBAAQ,sBAAsB;AAC9B,gBAAQ,iCAAiC;AACzC,gBAAQ,kBAAkB;AAC1B,gBAAQ,kBAAkB;AAC1B,gBAAQ,mBAAmB;AAC3B,gBAAQ,uBAAuB;AAC/B,gBAAQ,0BAA0B;AAClC,gBAAQ,+BAA+B;AACvC,gBAAQ,sBAAsB;AAC9B,gBAAQ,eAAe;AACvB,gBAAQ,mBAAmB;AAE3B,YAAI,OAAO,QAAO,EAAG,YAAY;AAC7B,kBAAQ,uBAAuB;QACnC;AAEA,YAAI,KAAK,kBAAkB,cAAc,uBAAuB;AAC5D,oCAA0B,KAAK,gBAAgB,SAAS,QAAQ;AAChE,kBAAQ,cAAc,KAAK,eAAe;QAC9C,OAAO;AACH,kBAAQ,SAAS;QACrB;AAEA,YAAI,KAAK,sBAAsB,cAAc,0BAA0B;AACnE,oCAA0B,KAAK,oBAAoB,SAAS,aAAa;QAC7E,OAAO;AACH,kBAAQ,cAAc;QAC1B;AAEA,YAAI,KAAK,gCAAgC,cAAc,oCAAoC;AACvF,oCAA0B,KAAK,8BAA8B,SAAS,wBAAwB;QAClG,OAAO;AACH,kBAAQ,yBAAyB;QACrC;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,oCAA0B,KAAK,iBAAiB,SAAS,SAAS;AAClE,kBAAQ,qBAAqB,KAAK;QACtC,OAAO;AACH,kBAAQ,UAAU;QACtB;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,oCAA0B,KAAK,iBAAiB,SAAS,SAAS;AAClE,kBAAQ,aAAa,KAAK,gBAAgB;QAC9C,OAAO;AACH,kBAAQ,UAAU;QACtB;AAEA,cAAM,oBAAoB,KAAK,sBAAqB;AACpD,cAAM,kBACF,KAAK,8BACL,KAAK,qBACL,KAAK,qBACL,OAAO,QAAO,EAAG,qBAAqB,KACtC,KAAK,gCAAgC;AACzC,6BAAqB,OAAO,mBAAmB,SAAS,KAAK,mBAAmB,KAAK,0BAA0B,CAAC,eAAe;AAE/H,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,oCAA0B,KAAK,kBAAkB,SAAS,UAAU;AACpE,kBAAQ,yBAAyB,KAAK;AACtC,kBAAQ,gBAAgB,KAAK,iBAAiB;AAC9C,kBAAQ,eAAe,KAAK,iBAAiB;QACjD,OAAO;AACH,kBAAQ,WAAW;QACvB;AAEA,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,oCAA0B,KAAK,kBAAkB,SAAS,UAAU;AACpE,kBAAQ,gBAAgB,KAAK,iBAAiB;QAClD,OAAO;AACH,kBAAQ,WAAW;QACvB;AAEA,YAAI,cAAc,wBAAwB;AACtC,cAAI,KAAK,kBAAkB;AACvB,sCAA0B,KAAK,kBAAkB,SAAS,cAAc;AACxE,oBAAQ,gCAAgC,KAAK;AAC7C,oBAAQ,gCAAgC,CAAC,KAAK,yCAAyC,KAAK;AAC5F,oBAAQ,gCAAgC,KAAK;AAC7C,oBAAQ,uBAAuB,KAAK;AACpC,oBAAQ,qBAAqB;UACjC,WAAW,KAAK,sBAAsB;AAClC,sCAA0B,KAAK,sBAAsB,SAAS,cAAc;AAC5E,oBAAQ,kCAAkC,KAAK;AAC/C,oBAAQ,wBAAwB,KAAK;AACrC,oBAAQ,qBAAqB,KAAK,qBAAqB;UAC3D,OAAO;AACH,oBAAQ,eAAe;UAC3B;AAEA,cAAI,KAAK,+BAA+B,KAAK,qBAAqB;AAC9D,oBAAQ,sCAAsC,KAAK;AACnD,gBAAI,KAAK,6BAA6B;AAClC,wCAA0B,KAAK,6BAA6B,SAAS,sBAAsB;AAC3F,sBAAQ,6BAA6B,KAAK,4BAA4B;YAC1E,OAAO;AACH,sBAAQ,uBAAuB;YACnC;AACA,gBACI,KAAK,wBACJ,CAAC,KAAK,+BAAgC,KAAK,+BAA+B,KAAK,iDAClF;AACE,wCAA0B,KAAK,qBAAqB,SAAS,aAAa;AAC1E,sBAAQ,oBAAoB,KAAK,oBAAoB;YACzD,OAAO;AACH,sBAAQ,cAAc;YAC1B;UACJ,OAAO;AACH,oBAAQ,uBAAuB;AAC/B,oBAAQ,cAAc;UAC1B;AAEA,cAAI,KAAK,sBAAsB;AAC3B,sCAA0B,KAAK,sBAAsB,SAAS,iBAAiB;UACnF,OAAO;AACH,oBAAQ,kBAAkB;UAC9B;QACJ,OAAO;AACH,kBAAQ,eAAe;AACvB,kBAAQ,kBAAkB;QAC9B;AAEA,YAAI,OAAO,QAAO,EAAG,uBAAuB,KAAK,gBAAgB,cAAc,sBAAsB,CAAC,KAAK,iBAAiB;AACxH,oCAA0B,KAAK,cAAc,SAAS,MAAM;AAE5D,cAAI,KAAK,gBAAgB,KAAK,kBAAkB,cAAc,uBAAuB;AACjF,oBAAQ,WAAW;AACnB,oBAAQ,eAAe,MAAM;AAC7B,oBAAQ,oBAAoB,CAAC,CAAC,KAAK;UACvC,OAAO;AACH,oBAAQ,WAAW;UACvB;AAEA,kBAAQ,wBAAwB,KAAK;QACzC,OAAO;AACH,kBAAQ,OAAO;AACf,kBAAQ,WAAW;AACnB,kBAAQ,eAAe;AACvB,kBAAQ,oBAAoB;AAC5B,kBAAQ,wBAAwB;QACpC;AAEA,YAAI,KAAK,2BAA2B,cAAc,0BAA0B;AACxE,kBAAQ,kBAAkB;AAC1B,kBAAQ,uBAAuB,KAAK,wBAAwB;QAChE,OAAO;AACH,kBAAQ,kBAAkB;AAC1B,kBAAQ,uBAAuB;QACnC;AAEA,YAAI,KAAK,iCAAgC,GAAI;AACzC,kBAAQ,kBAAkB;QAC9B,OAAO;AACH,kBAAQ,kBAAkB;QAC9B;MACJ;AAEA,cAAQ,oBAAoB,KAAK;AAEjC,UAAI,KAAK,kBAAkB,iBAAgB,uBAAuB;AAC9D,gBAAQ,0BAA0B;AAClC,gBAAQ,sBAAsB;MAClC,WAAW,KAAK,kBAAkB,iBAAgB,mBAAmB;AACjE,gBAAQ,0BAA0B;AAClC,gBAAQ,sBAAsB;MAClC,OAAO;AACH,gBAAQ,0BAA0B;AAClC,gBAAQ,sBAAsB;MAClC;AAEA,cAAQ,oBAAoB,KAAK;AAEjC,UAAI,CAAC,KAAK,mBAAmB,KAAK,mBAAmB;AACjD,gBAAQ,mBAAmB;MAC/B,OAAO;AACH,gBAAQ,mBAAmB;MAC/B;AAGA,cAAQ,WAAW,CAAC,CAAC,MAAM;AAE3B,cAAQ,aAAa,OAAO,QAAO,EAAG,uBAAuB,KAAK;IACtE;AAEA,QAAI,QAAQ,qBAAqB,QAAQ,eAAe;AACpD,cAAQ,iBAAiB,GAAG,KAAK,YAAY,GAAG,KAAK,eAAe,MAAM,IAAI,MAAM,EAAE;AACtF,cAAQ,mBAAmB,KAAK,cAAc,KAAA,KAAU,cAAA;AACxD,cAAQ,aAAa,KAAK,yBAAyB,IAAI;AACvD,cAAQ,eAAe,KAAK,oBAAoB,KAAK;AACrD,cAAQ,qBAAqB,KAAK;IACtC;AAEA,QAAI,QAAQ,4BAA4B,KAAK,+BAA+B;AACxE,WAAK,8BAA8B,eAAe,OAAO;IAC7D;AAEA,YAAQ,qBAAqB,KAAK;AAElC,YAAQ,oBAAoB,KAAK;AAEjC,YAAQ,mBAAmB,KAAK;AAGhC,QAAI,QAAQ,eAAe;AACvB,4BACI,MACA,OACA,KAAK,sBACL,KAAK,aACL,KAAK,YACL,KAAK,wBAAwB,IAAI,GACjC,SACA,KAAK,8BACL,KAAK,mBACL,eACA,KAAK,wBAAwB;AAEjC,cAAQ,QAAQ,KAAK,WAAY,KAAK,eAAe,KAAK,cAAc,CAAC,KAAK,sBAAsB,aAAa,UAAU;AAC3H,cAAQ,YAAY,KAAK;IAC7B;AAGA,sCAAkC,OAAO,QAAQ,MAAM,SAAS,eAAe,OAAO,OAAO,cAAc,gBAAgB;AAG3H,SAAK,WAAW,UAAU;AAC1B,SAAK,WAAW,OAAO;AACvB,SAAK,mDAAmD,KAAK,UAAU;AAGvE,gCAA4B,MAAM,SAAS,MAAM,MAAM,MAAM,KAAK,sBAAsB,iBAAgB,kBAAkB;AAG1H,SAAK,mCAAmC,KAAK,UAAU;EAC3D;;;;;;;EAQgB,iBAAiB,MAAoB,YAA2C,SAA8C;AAC1I,UAAM,eAAe;MACjB,WAAW;MACX,cAAc;MACd,GAAG;;AAGP,QAAI,CAAC,KAAK,2BAA2B;AACjC,WAAK,mBAAkB;IAC3B;AAEA,SAAK,4BAA2B,GAAqC,KAAK,UAAU;AACpF,UAAM,aAAa,MAAK;AACpB,UAAI,KAAK,yBAAyB;AAC9B;MACJ;AACA,YAAM,UAAU,IAAI,mBAAmB,KAAK,WAAW,WAAW;AAClE,YAAM,SAAS,KAAK,eAAe,MAAM,MAAM,SAAS,QAAW,QAAW,aAAa,cAAc,aAAa,SAAS;AAC/H,UAAI,KAAK,4BAA4B;AACjC,QAAAA,2BAA0B,SAAS;AACnC,QAAAA,2BAA0B,UAAU;AACpC,aAAK,2BAA2B,gBAAgBA,0BAAyB;MAC7E;AACA,UAAI,OAAO,QAAO,GAAI;AAClB,YAAI,YAAY;AACZ,qBAAW,IAAI;QACnB;MACJ,OAAO;AACH,eAAO,oBAAoB,IAAI,MAAK;AAChC,cAAI,YAAY;AACZ,uBAAW,IAAI;UACnB;QACJ,CAAC;MACL;IACJ;AACA,eAAU;EACd;;;;EAKgB,qBAAkB;AAE9B,UAAM,MAAM,KAAK;AACjB,QAAI,WAAW,gBAAgB,CAAC;AAChC,QAAI,WAAW,oBAAoB,CAAC;AACpC,QAAI,WAAW,8BAA8B,CAAC;AAC9C,QAAI,WAAW,iBAAiB,CAAC;AACjC,QAAI,WAAW,iBAAiB,CAAC;AACjC,QAAI,WAAW,kBAAkB,CAAC;AAClC,QAAI,WAAW,kBAAkB,CAAC;AAClC,QAAI,WAAW,sBAAsB,CAAC;AACtC,QAAI,WAAW,6BAA6B,CAAC;AAC7C,QAAI,WAAW,cAAc,CAAC;AAC9B,QAAI,WAAW,gBAAgB,EAAE;AACjC,QAAI,WAAW,oBAAoB,EAAE;AACrC,QAAI,WAAW,8BAA8B,EAAE;AAC/C,QAAI,WAAW,iBAAiB,EAAE;AAClC,QAAI,WAAW,iBAAiB,EAAE;AAClC,QAAI,WAAW,kBAAkB,EAAE;AACnC,QAAI,WAAW,kBAAkB,EAAE;AACnC,QAAI,WAAW,sBAAsB,EAAE;AACvC,QAAI,WAAW,6BAA6B,EAAE;AAC9C,QAAI,WAAW,cAAc,EAAE;AAC/B,QAAI,WAAW,uBAAuB,CAAC;AACvC,QAAI,WAAW,gBAAgB,CAAC;AAChC,QAAI,WAAW,cAAc,CAAC;AAC9B,QAAI,WAAW,wBAAwB,CAAC;AACxC,QAAI,WAAW,sBAAsB,CAAC;AAEtC,QAAI,WAAW,aAAa,CAAC;AAC7B,QAAI,WAAW,sBAAsB,CAAC;AACtC,QAAI,WAAW,kBAAkB,CAAC;AAClC,QAAI,WAAW,iBAAiB,CAAC;AAEjC,QAAI,WAAW,cAAc,CAAC;AAE9B,QAAI,WAAW,+BAA+B,CAAC;AAC/C,QAAI,WAAW,6BAA6B,CAAC;AAC7C,QAAI,WAAW,6BAA6B,EAAE;AAC9C,QAAI,WAAW,qBAAqB,CAAC;AACrC,QAAI,WAAW,qBAAqB,EAAE;AAEtC,QAAI,WAAW,cAAc,CAAC;AAC9B,+BAA2B,KAAK,MAAM,MAAM,MAAM,MAAM,IAAI;AAC5D,UAAM,mBAAkB;EAC5B;;;;;;;EAQgB,eAAe,OAAe,MAAY,SAAgB;AACtE,UAAM,QAAQ,KAAK,SAAQ;AAE3B,UAAM,UAA8B,QAAQ;AAC5C,QAAI,CAAC,SAAS;AACV;IACJ;AAEA,UAAM,SAAS,QAAQ;AAEvB,QAAI,CAAC,QAAQ;AACT;IACJ;AAEA,SAAK,gBAAgB;AAGrB,SAAK,qBAAoB,EAAG,aAAa,QAAQ,MAAM;AACvD,SAAK,iBAAiB,KAAK;AAE3B,UAAM,SAAS,MAAM,UAAS;AAG9B,SAAK,eAAe,aAAa,QAAQ,UAAU;AAEnD,SAAK,qBAAqB,eAAe,KAAK,eAAe,OAAO,MAAM,OAAO,KAAK,QAAQ;AAE9F,oCAAgC,KAAK,OAAO,qBAAqB,KAAK,eAAe,MAAM,OAAO,IAAI;AAEtG,UAAM,SAAS,MAAM;AACrB,QAAI,QAAQ;AACR,WAAK,eAAe,aAAa,cAAc,OAAO,MAAM,OAAO,MAAM,GAAG,CAAC;IACjF,OAAO;AACH,WAAK,eAAe,aAAa,cAAc,GAAG,GAAG,GAAG,CAAC;IAC7D;AAEA,SAAK,WAAW,UAAU;AAC1B,SAAK,uCAAuC,KAAK,UAAU;AAG3D,QAAI,QAAQ,uBAAuB;AAC/B,YAAM,eAAe,KAAK,aAAa;AACvC,WAAK,qBAAqB,KAAK,aAAa;IAChD;AAEA,UAAM,aAAa,KAAK,YAAY,OAAO,QAAQ,SAAS,KAAK,UAAU;AAG3E,wBAAoB,MAAM,KAAK,eAAe,KAAK,oBAAoB;AAEvE,QAAI,oBAA2C;AAC/C,UAAM,MAAM,KAAK;AACjB,QAAI,YAAY;AACZ,WAAK,mBAAmB,MAAM;AAC9B,0BAAoB,KAAK,sBAAqB;AAE9C,UAAI,CAAC,IAAI,UAAU,CAAC,KAAK,YAAY,CAAC,IAAI,UAAU,QAAQ,aAAa,wBAAwB;AAE7F,YAAI,MAAM,iBAAiB;AACvB,cAAI,KAAK,kBAAkB,cAAc,uBAAuB;AAC5D,gBAAI,aAAa,gBAAgB,KAAK,eAAe,kBAAkB,KAAK,eAAe,KAAK;AAChG,8BAAkB,KAAK,gBAAgB,KAAK,QAAQ;UACxD;AAEA,cAAI,KAAK,sBAAsB,cAAc,0BAA0B;AACnE,gBAAI,aAAa,oBAAoB,KAAK,mBAAmB,kBAAkB,KAAK,mBAAmB,KAAK;AAC5G,8BAAkB,KAAK,oBAAoB,KAAK,YAAY;UAChE;AAEA,cAAI,KAAK,gCAAgC,cAAc,oCAAoC;AACvF,gBAAI,aAAa,8BAA8B,KAAK,6BAA6B,kBAAkB,KAAK,6BAA6B,KAAK;AAC1I,8BAAkB,KAAK,8BAA8B,KAAK,sBAAsB;UACpF;AAEA,cAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,gBAAI,aACA,iBACA,KAAK,gBAAgB,kBACrB,KAAK,gBAAgB,OACrB,KAAK,yBACL,KAAK,uCAAuC;AAEhD,8BAAkB,KAAK,iBAAiB,KAAK,SAAS;UAC1D;AAEA,cAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,gBAAI,aAAa,iBAAiB,KAAK,gBAAgB,kBAAkB,KAAK,gBAAgB,KAAK;AACnG,8BAAkB,KAAK,iBAAiB,KAAK,SAAS;UAC1D;AAEA,cAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,gBAAI,aAAa,kBAAkB,KAAK,iBAAiB,kBAAkB,KAAK,iBAAiB,KAAK;AACtG,8BAAkB,KAAK,kBAAkB,KAAK,UAAU;UAC5D;AAEA,cAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,gBAAI,aAAa,kBAAkB,KAAK,iBAAiB,kBAAkB,KAAK,iBAAiB,KAAK;AACtG,8BAAkB,KAAK,kBAAkB,KAAK,UAAU;UAC5D;AAEA,cAAI,cAAc,wBAAwB;AACtC,gBAAI,KAAK,kBAAkB;AACvB,kBAAI,aAAa,sBAAsB,KAAK,iBAAiB,kBAAkB,KAAK,iBAAiB,OAAO,KAAK,uBAAuB;AACxI,gCAAkB,KAAK,kBAAkB,KAAK,cAAc;YAChE,WAAW,KAAK,sBAAsB;AAClC,kBAAI,aAAa,sBAAsB,KAAK,qBAAqB,kBAAkB,KAAK,qBAAqB,OAAO,CAAG;AACvH,gCAAkB,KAAK,sBAAsB,KAAK,cAAc;YACpE;AAEA,gBAAI,KAAK,6BAA6B;AAClC,kBAAI,aAAa,6BAA6B,KAAK,4BAA4B,kBAAkB,KAAK,4BAA4B,KAAK;AACvI,gCAAkB,KAAK,6BAA6B,KAAK,qBAAqB;YAClF;AAEA,gBAAI,KAAK,uBAAuB,QAAQ,aAAa;AACjD,kBAAI,aAAa,qBAAqB,KAAK,oBAAoB,kBAAkB,KAAK,oBAAoB,KAAK;AAC/G,gCAAkB,KAAK,qBAAqB,KAAK,aAAa;YAClE;AAEA,gBAAI,KAAK,sBAAsB;AAC3B,kBAAI,aAAa,6BAA6B,KAAK,qBAAqB,kBAAkB,KAAK,qBAAqB,KAAK;AACzH,gCAAkB,KAAK,sBAAsB,KAAK,qBAAqB;YAC3E;UACJ;AAEA,cAAI,KAAK,gBAAgB,OAAO,QAAO,EAAG,uBAAuB,cAAc,sBAAsB,CAAC,KAAK,iBAAiB;AACxH,gBAAI,aAAa,cAAc,KAAK,aAAa,kBAAkB,KAAK,aAAa,OAAO,KAAK,kBAAkB;AACnH,8BAAkB,KAAK,cAAc,KAAK,MAAM;AAEhD,gBAAI,MAAM,yBAAyB;AAC/B,kBAAI,aAAa,uBAAuB,KAAK,oBAAoB,IAAM,IAAM,KAAK,oBAAoB,IAAM,EAAI;YACpH,OAAO;AACH,kBAAI,aAAa,uBAAuB,KAAK,oBAAoB,KAAO,GAAK,KAAK,oBAAoB,KAAO,CAAG;YACpH;UACJ;AAEA,4BAAkB,OAAO,SAAS,KAAK,KAAK,kBAAkB,mBAAmB,KAAK,mBAAmB,MAAM,MAAM,MAAM,MAAM,IAAI;QACzI;AAGA,YAAI,KAAK,aAAa;AAClB,cAAI,YAAY,aAAa,KAAK,SAAS;QAC/C;AAGA,YAAI,QAAQ,kBAAkB;AAC1B,oBAAU,OAAO,CAAC,EAAE,IAAI,KAAK,cAAc,UAAa,KAAK,cAAc,OAAO,IAAI,KAAK;AAC3F,oBAAU,OAAO,CAAC,EAAE,IAAI,KAAK,eAAe,UAAa,KAAK,eAAe,OAAO,IAAI,KAAK;AAC7F,gBAAM,MAAM,KAAK,YAAY,sBAAsB;AACnD,gBAAM,aAAa;AACnB,oBAAU,OAAO,CAAC,EAAE,IAAI;AAIxB,gBAAM,KAAK,KAAK,KAAK,MAAM,eAAe,MAAM,aAAa,CAAC;AAC9D,oBAAU,OAAO,CAAC,EAAE,IAAI;AACxB,cAAI,mBAAmB,sBAAsB,UAAU,OAAO,CAAC,CAAC;AAChE,cAAI,aAAa,+BAA+B,KAAK,2BAA2B,KAAK,iBAAiB;QAC1G,OAAO;AACH,cAAI,aAAa,sBAAsB,KAAK,oBAAoB,KAAK,aAAa;QACtF;AAEA,YAAI,aAAa,kBAAkB,cAAc,yBAAyB,KAAK,iBAAiB,OAAO,aAAa;AAEpH,YAAI,CAAC,QAAQ,iBAAiB,KAAK,YAAY,iCAAiC;AAC5E,cAAI,aAAa,gBAAgB,KAAK,cAAc,CAAC;QACzD,OAAO;AACH,cAAI,aAAa,gBAAgB,KAAK,cAAc,KAAK,KAAK;QAClE;AAEA,YAAI,YAAY,cAAc,KAAK,WAAW;AAC9C,YAAI,YAAY,wBAAwB,KAAK,yBAAyB,CAAG;AAGzE,aAAK,eAAe,IAAI,KAAK;AAC7B,aAAK,eAAe,IAAI,KAAK;AAC7B,aAAK,eAAe,IAAI,KAAK,wBAAwB,MAAM;AAC3D,aAAK,eAAe,IAAI,KAAK;AAE7B,YAAI,cAAc,sBAAsB,KAAK,cAAc;AAG3D,cAAM,aAAa,cAAc,KAAK,eAAe,KAAK,mBAAmB;AAE7E,YAAI,aAAa,iBAAiB,KAAK,mBAAmB;AAE1D,YAAI,aAAa,cAAc,KAAK,YAAY,KAAK,WAAW;MACpE;AAGA,UAAI,MAAM,iBAAiB;AACvB,YAAI,KAAK,kBAAkB,cAAc,uBAAuB;AAC5D,cAAI,WAAW,iBAAiB,KAAK,cAAc;QACvD;AAEA,YAAI,KAAK,sBAAsB,cAAc,0BAA0B;AACnE,cAAI,WAAW,qBAAqB,KAAK,kBAAkB;QAC/D;AAEA,YAAI,KAAK,gCAAgC,cAAc,oCAAoC;AACvF,cAAI,WAAW,+BAA+B,KAAK,4BAA4B;QACnF;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,cAAI,WAAW,kBAAkB,KAAK,eAAe;QACzD;AAEA,YAAI,KAAK,mBAAmB,cAAc,uBAAuB;AAC7D,cAAI,WAAW,kBAAkB,KAAK,eAAe;QACzD;AAEA,wBAAgB,OAAO,SAAS,KAAK,mBAAmB,KAAK,iBAAiB;AAE9E,YAAI,QAAQ,iBAAiB;AACzB,cAAI,WAAW,0BAA0B,KAAK,uBAAuB;QACzE;AAEA,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,cAAI,WAAW,mBAAmB,KAAK,gBAAgB;QAC3D;AAEA,YAAI,KAAK,oBAAoB,cAAc,wBAAwB;AAC/D,cAAI,WAAW,mBAAmB,KAAK,gBAAgB;QAC3D;AAEA,YAAI,cAAc,wBAAwB;AACtC,cAAI,KAAK,kBAAkB;AACvB,gBAAI,WAAW,uBAAuB,KAAK,gBAAgB;UAC/D,WAAW,KAAK,sBAAsB;AAClC,gBAAI,WAAW,uBAAuB,KAAK,oBAAoB;UACnE;AAEA,cAAI,KAAK,6BAA6B;AAClC,gBAAI,WAAW,8BAA8B,KAAK,2BAA2B;UACjF;AAEA,cAAI,KAAK,uBAAuB,QAAQ,aAAa;AACjD,gBAAI,WAAW,sBAAsB,KAAK,mBAAmB;UACjE;AAEA,cAAI,KAAK,sBAAsB;AAC3B,gBAAI,WAAW,uBAAuB,KAAK,oBAAoB;UACnE;QACJ;AAEA,YAAI,KAAK,gBAAgB,OAAO,QAAO,EAAG,uBAAuB,cAAc,sBAAsB,CAAC,KAAK,iBAAiB;AACxH,cAAI,WAAW,eAAe,KAAK,YAAY;QACnD;MACJ;AAGA,UAAI,KAAK,SAAQ,EAAG,mCAAmC,KAAK,yBAAyB,IAAI,GAAG;AACxF,aAAK,SAAQ,EAAG,qBAAsB,KAAK,MAAM;MACrD;AAEA,WAAK,WAAW,UAAU;AAC1B,WAAK,mCAAmC,KAAK,UAAU;AAGvD,oBAAc,KAAK,eAAe,MAAM,KAAK;AAE7C,WAAK,gBAAgB,MAAM;IAC/B,WAAW,MAAM,UAAS,EAAG,UAAU,gCAAgC;AACnE,WAAK,sBAAsB;IAC/B;AAEA,QAAI,cAAc,CAAC,KAAK,UAAU;AAE9B,UAAI,MAAM,iBAAiB,CAAC,KAAK,kBAAkB;AAC/C,mBAAW,OAAO,MAAM,KAAK,eAAe,SAAS,KAAK,sBAAsB;MACpF;AAGA,UACK,MAAM,cAAc,KAAK,YAAY,MAAM,YAAY,MAAM,gBAC9D,qBACA,KAAK,WAAW,qBAChB,KAAK,kBACL,QAAQ,WACR,QAAQ,kBAAkB,GAC5B;AACE,aAAK,SAAS,MAAM;MACxB;AAGA,wBAAkB,OAAO,MAAM,KAAK,eAAe,IAAI;AAGvD,UAAI,QAAQ,uBAAuB;AAC/B,kCAA0B,MAAM,KAAK,aAAa;MACtD;AAEA,UAAI,QAAQ,gCAAgC;AACxC,aAAK,6BAA6B,KAAK,QAAQ,QAAQ,SAAS;MACpE;AAGA,WAAK,8BAA8B,KAAK,KAAK,aAAa;AAG1D,mBAAa,SAAS,KAAK,eAAe,KAAK;IACnD;AAEA,SAAK,WAAW,MAAM,KAAK,eAAe,OAAO;AAEjD,QAAI,OAAM;EACd;;;;;;EAOgB,iBAAc;AAC1B,UAAM,UAAU,MAAM,eAAc;AAEpC,QAAI,KAAK,kBAAkB,KAAK,eAAe,cAAc,KAAK,eAAe,WAAW,SAAS,GAAG;AACpG,cAAQ,KAAK,KAAK,cAAc;IACpC;AAEA,QAAI,KAAK,sBAAsB,KAAK,mBAAmB,cAAc,KAAK,mBAAmB,WAAW,SAAS,GAAG;AAChH,cAAQ,KAAK,KAAK,kBAAkB;IACxC;AAEA,QAAI,KAAK,gCAAgC,KAAK,6BAA6B,cAAc,KAAK,6BAA6B,WAAW,SAAS,GAAG;AAC9I,cAAQ,KAAK,KAAK,4BAA4B;IAClD;AAEA,QAAI,KAAK,mBAAmB,KAAK,gBAAgB,cAAc,KAAK,gBAAgB,WAAW,SAAS,GAAG;AACvG,cAAQ,KAAK,KAAK,eAAe;IACrC;AAEA,QAAI,KAAK,mBAAmB,KAAK,gBAAgB,cAAc,KAAK,gBAAgB,WAAW,SAAS,GAAG;AACvG,cAAQ,KAAK,KAAK,eAAe;IACrC;AAEA,QAAI,KAAK,sBAAsB,KAAK,mBAAmB,cAAc,KAAK,mBAAmB,WAAW,SAAS,GAAG;AAChH,cAAQ,KAAK,KAAK,kBAAkB;IACxC;AAEA,QAAI,KAAK,oBAAoB,KAAK,iBAAiB,cAAc,KAAK,iBAAiB,WAAW,SAAS,GAAG;AAC1G,cAAQ,KAAK,KAAK,gBAAgB;IACtC;AAEA,QAAI,KAAK,oBAAoB,KAAK,iBAAiB,cAAc,KAAK,iBAAiB,WAAW,SAAS,GAAG;AAC1G,cAAQ,KAAK,KAAK,gBAAgB;IACtC,WAAW,KAAK,wBAAwB,KAAK,qBAAqB,cAAc,KAAK,qBAAqB,WAAW,SAAS,GAAG;AAC7H,cAAQ,KAAK,KAAK,oBAAoB;IAC1C;AAEA,QAAI,KAAK,gBAAgB,KAAK,aAAa,cAAc,KAAK,aAAa,WAAW,SAAS,GAAG;AAC9F,cAAQ,KAAK,KAAK,YAAY;IAClC;AAEA,QAAI,KAAK,oBAAoB,KAAK,iBAAiB,cAAc,KAAK,iBAAiB,WAAW,SAAS,GAAG;AAC1G,cAAQ,KAAK,KAAK,gBAAgB;IACtC;AAEA,QAAI,KAAK,+BAA+B,KAAK,4BAA4B,cAAc,KAAK,4BAA4B,WAAW,SAAS,GAAG;AAC3I,cAAQ,KAAK,KAAK,2BAA2B;IACjD;AAEA,QAAI,KAAK,uBAAuB,KAAK,oBAAoB,cAAc,KAAK,oBAAoB,WAAW,SAAS,GAAG;AACnH,cAAQ,KAAK,KAAK,mBAAmB;IACzC;AAEA,QAAI,KAAK,wBAAwB,KAAK,qBAAqB,cAAc,KAAK,qBAAqB,WAAW,SAAS,GAAG;AACtH,cAAQ,KAAK,KAAK,oBAAoB;IAC1C;AAEA,WAAO;EACX;;;;;EAMQ,wBAAqB;AACzB,QAAI,KAAK,oBAAoB;AACzB,aAAO,KAAK;IAChB;AAEA,WAAO,KAAK,SAAQ,EAAG;EAC3B;;;;;EAMgB,oBAAiB;AAC7B,UAAM,iBAAiB,MAAM,kBAAiB;AAE9C,QAAI,KAAK,gBAAgB;AACrB,qBAAe,KAAK,KAAK,cAAc;IAC3C;AAEA,QAAI,KAAK,oBAAoB;AACzB,qBAAe,KAAK,KAAK,kBAAkB;IAC/C;AAEA,QAAI,KAAK,8BAA8B;AACnC,qBAAe,KAAK,KAAK,4BAA4B;IACzD;AAEA,QAAI,KAAK,iBAAiB;AACtB,qBAAe,KAAK,KAAK,eAAe;IAC5C;AAEA,QAAI,KAAK,iBAAiB;AACtB,qBAAe,KAAK,KAAK,eAAe;IAC5C;AAEA,QAAI,KAAK,oBAAoB;AACzB,qBAAe,KAAK,KAAK,kBAAkB;IAC/C;AAEA,QAAI,KAAK,kBAAkB;AACvB,qBAAe,KAAK,KAAK,gBAAgB;IAC7C;AAEA,QAAI,KAAK,sBAAsB;AAC3B,qBAAe,KAAK,KAAK,oBAAoB;IACjD;AAEA,QAAI,KAAK,kBAAkB;AACvB,qBAAe,KAAK,KAAK,gBAAgB;IAC7C;AAEA,QAAI,KAAK,6BAA6B;AAClC,qBAAe,KAAK,KAAK,2BAA2B;IACxD;AAEA,QAAI,KAAK,qBAAqB;AAC1B,qBAAe,KAAK,KAAK,mBAAmB;IAChD;AAEA,QAAI,KAAK,sBAAsB;AAC3B,qBAAe,KAAK,KAAK,oBAAoB;IACjD;AAEA,QAAI,KAAK,cAAc;AACnB,qBAAe,KAAK,KAAK,YAAY;IACzC;AAEA,QAAI,KAAK,kBAAkB;AACvB,qBAAe,KAAK,KAAK,gBAAgB;IAC7C;AAEA,WAAO;EACX;;;;;;EAOgB,WAAW,SAAoB;AAC3C,QAAI,MAAM,WAAW,OAAO,GAAG;AAC3B,aAAO;IACX;AAEA,QAAI,KAAK,mBAAmB,SAAS;AACjC,aAAO;IACX;AAEA,QAAI,KAAK,uBAAuB,SAAS;AACrC,aAAO;IACX;AAEA,QAAI,KAAK,iCAAiC,SAAS;AAC/C,aAAO;IACX;AAEA,QAAI,KAAK,oBAAoB,SAAS;AAClC,aAAO;IACX;AAEA,QAAI,KAAK,oBAAoB,SAAS;AAClC,aAAO;IACX;AAEA,QAAI,KAAK,uBAAuB,SAAS;AACrC,aAAO;IACX;AAEA,QAAI,KAAK,qBAAqB,SAAS;AACnC,aAAO;IACX;AAEA,QAAI,KAAK,yBAAyB,SAAS;AACvC,aAAO;IACX;AAEA,QAAI,KAAK,qBAAqB,SAAS;AACnC,aAAO;IACX;AAEA,QAAI,KAAK,gCAAgC,SAAS;AAC9C,aAAO;IACX;AAEA,QAAI,KAAK,wBAAwB,SAAS;AACtC,aAAO;IACX;AAEA,QAAI,KAAK,yBAAyB,SAAS;AACvC,aAAO;IACX;AAEA,QAAI,KAAK,iBAAiB,SAAS;AAC/B,aAAO;IACX;AAEA,QAAI,KAAK,qBAAqB,SAAS;AACnC,aAAO;IACX;AAEA,WAAO;EACX;;;;;;;EAQgB,qBAAkB;AAC9B,QAAI,CAAC,KAAK,YAAY,qBAAqB;AACvC,aAAO;IACX;AAEA,UAAM,0BAA0B,KAAK,SAAQ,EAAG,2BAA0B;AAC1E,QAAI,yBAAyB;AACzB,8BAAwB,UAAU;IACtC;AAEA,WAAO;EACX;;;;;;EAOgB,QAAQ,oBAA8B,sBAA8B;AAChF,SAAK,0BAA0B;AAC/B,QAAI,sBAAsB;AACtB,UAAI,KAAK,2BAA2B,KAAK,SAAQ,EAAG,2BAA2B,KAAK,yBAAyB;AACzG,aAAK,wBAAwB,QAAO;MACxC;AAEA,WAAK,gBAAgB,QAAO;AAC5B,WAAK,oBAAoB,QAAO;AAChC,WAAK,8BAA8B,QAAO;AAC1C,WAAK,iBAAiB,QAAO;AAC7B,WAAK,iBAAiB,QAAO;AAC7B,WAAK,oBAAoB,QAAO;AAChC,WAAK,kBAAkB,QAAO;AAC9B,WAAK,kBAAkB,QAAO;AAC9B,WAAK,sBAAsB,QAAO;AAClC,WAAK,cAAc,QAAO;AAC1B,WAAK,kBAAkB,QAAO;AAC9B,WAAK,6BAA6B,QAAO;AACzC,WAAK,qBAAqB,QAAO;AACjC,WAAK,sBAAsB,QAAO;IACtC;AAEA,SAAK,eAAe,QAAO;AAE3B,QAAI,KAAK,iCAAiC,KAAK,0BAA0B;AACrE,WAAK,8BAA8B,mBAAmB,OAAO,KAAK,wBAAwB;IAC9F;AAEA,UAAM,QAAQ,oBAAoB,oBAAoB;EAC1D;;AA3oEuB,gBAAA,qBAAqB,SAAS;AAK9B,gBAAA,wBAAwB,SAAS;AAKjC,gBAAA,yBAAyB,SAAS;AAMlC,gBAAA,gCAAgC,SAAS;AAMlD,gBAAA,kCAAkC;AAKhB,gBAAA,wBAAwB;AAMxB,gBAAA,oBAAoB;AAMpB,gBAAA,wBAAwB;AAM1C,gBAAA,YAAY;AA6enB,WAAA;EADN,iBAAiB,8BAA8B;;;;ACz0B9C,IAAO,aAAP,MAAO,oBAAmB,kBAAiB;;;;;EAK7C,YAAmBE,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAsB1C,SAAA,gBAAyB;AAMzB,SAAA,sBAA+B;AA1BlC,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACpH,SAAK,cAAc,SAAS,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACjH,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAEpH,SAAK,eACD,SACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,SAAS,MAAI,GAA+C,aAAY,YAAY,CAAC;EAEzI;;;;;EAoBgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,UAAU;AACrC,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,aAAa;AACxC,UAAM,qBAAqB,iBAAiB;EAChD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,eAAe,SAA4B;AACvD,YAAQ,SAAS,SAAS,IAAI;AAC9B,YAAQ,SAAS,wCAAwC,MAAM,IAAI;AACnE,YAAQ,SAAS,wBAAwB,KAAK,qBAAqB,IAAI;AACvE,YAAQ,SAAS,mBAAmB,KAAK,UAAU,aAAa,IAAI;AACpE,YAAQ,SAAS,uBAAuB,KAAK,eAAe,IAAI;EACpE;;;;;;;EAQO,QAAQ,iBAA4C,OAA6B;AACpF,QAAI,OAAO;AAEX,UAAM,QAAQ,KAAK,MAAM,cAAc,KAAK,MAAM,yBAAyB,OAAO,MAAM,OAAO;AAC/F,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AACvF,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AACvF,UAAM,UAAU,OAAO,MAAM,OAAO;AACpC,UAAM,WAAW,MAAM,mBAAc;AAErC,WAAO;cACD,WAAW,iCAAiC,yBAAyB;;cAErE,MAAM,iBAAiB,eAAe,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,IAAI,KAAK,KAAK,SAAS;;;;;oBAK5H,SAAS;;;;oBAIT,OAAO;kBACT,WAAW,KAAK,OAAO,YAAY,EAAE;;;;;;;;;;;;;;oBAcnC,WAAW,cAAc,EAAE,GAAG,iBAAiB,iCAAiC;oBAChF,iBAAiB,qBAAqB;oBACtC,iBAAiB,eAAe;oBAChC,WAAW,cAAc,EAAE;yBACtB,iBAAiB,aAAa;wBAC/B,iBAAiB,gBAAgB;sBACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;wBAE7D,iBAAiB,cAAc;sBACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;;;6BAKtD,iBAAiB,aAAa;4BAC/B,iBAAiB,gBAAgB;0BACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;4BAC7D,iBAAiB,gBAAgB;0BACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;4BAE7D,iBAAiB,cAAc;0BACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;4BAC3D,iBAAiB,cAAc;0BACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;+BAGxD,iBAAiB,iBAAiB;;;+BAGlC,iBAAiB,iBAAiB,8DAA8D,iBAAiB,aAAa;;;;;;;;;;;AAWrJ,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,YAAM,WAAW,kBAAkB,KAAK,IAAI;IAChD;AAEA,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,kBAAc,GAAG,KAAK,iBAAiB,oBAAoB,KAAK,aAAa;;AAC7E,kBAAc,GAAG,KAAK,iBAAiB,0BAA0B,KAAK,mBAAmB;;AAEzF,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,gBAAgB,KAAK;AACzC,wBAAoB,sBAAsB,KAAK;AAE/C,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,gBAAgB,oBAAoB;AACzC,SAAK,sBAAsB,oBAAoB;EACnD;;AAnLO,WAAA;EADN,uBAAuB,kBAAgB,GAAkC,cAAc,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOhI,WAAA;EADN,uBAAuB,0BAAwB,GAAkC,cAAc,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAiLnJ,cAAc,sBAAsB,UAAU;;;ACnNxC,IAAO,kBAAP,MAAO,yBAAwB,kBAAiB;;;;;EAkBlD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAlBzC,SAAA,+BAA+B;AAoBnC,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACpH,SAAK,cAAc,aAAa,sCAAsC,SAAS,MAAM,yBAAyB,QAAQ;AACtH,SAAK,cAAc,MAAM,sCAAsC,SAAS,IAAI;AAC5E,SAAK,cAAc,gBAAgB,sCAAsC,SAAS,IAAI;AACtF,SAAK,cACD,OACA,sCAAsC,QACtC,MACA,yBAAyB,mBACzB,IAAI,wCAAwC,OAAO,MAAI,GAA8C,UAAU,UAAU,CAAC;AAE9H,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAEpH,SAAK,eACD,cACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA+C,kBAAiB,iBAAiB,CAAC;EAExJ;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,gBAAgB;AAC3C,UAAM,qBAAqB,KAAK;EACpC;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,KAAE;AACT,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;;EAMA,IAAW,MAAG;AACV,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEQ,kBAAkB,OAA6B;AACnD,QAAI,OAAO;AAEX,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,KAAK,KAAK;AAChB,UAAM,gBAAgB,KAAK;AAC3B,UAAM,cAAc,KAAK;AACzB,UAAM,eAAe,KAAK;AAC1B,UAAM,WAAW,MAAM,mBAAc;AAErC,QAAI,CAAC,GAAG,aAAa;AAIjB,YAAM,WAAW,gBAAgB,0CAA0C,KAAK,IAAI,SAAS;IACjG;AAEA,UAAM,eAAe,eAAe,iDAAiD;AAErF,UAAM,uBAAuB,EAAE,QAAQ,uBAAuB,SAAS,aAAa,cAAc,qBAAqB,kBAAiB;AAExI,UAAM,MAAM,KAAK;AACjB,QAAI,IAAI,aAAa;AACjB,YAAM,qBAAqB;;cAEzB,WAAW,YAAY,UAAU,MAAM,IAAI,sBAAsB;;;IAGvE,WAAW,aAAa,aAAa;AACjC,cAAQ,GAAG,MAAM,iBAAiB,aAAa,sCAAsC,OAAO,CAAC,gBAAgB,YAAY,sBAAsB;;AAC/I,cAAQ,GAAG,MAAM,iBAAiB,cAAc,sCAAsC,OAAO,CAAC,gBAAgB,aAAa,sBAAsB;;AACjJ,cAAQ,GAAG,MAAM,iBAAiB,gBAAgB,sCAAsC,OAAO,CAAC,qCAAqC,KAAK,4BAA4B;;AACtK,cAAQ,GAAG,WAAW,aAAa,WAAW,MAAM,WAAW,YAAY,MAAM;;IACrF;AAEA,YAAQ;0BACU,aAAa,cAAc,YAAY,QAAQ;kBACvD,WAAW,YAAY,UAAU;;kBAEjC,WAAW,YAAY,UAAU,sBAAsB,YAAY,yBAAyB,MAAM,KAAK,OAAO,cAAc,yBAAyB,MAAM,KACzJ,GAAG,cAAc,GAAG,yBAAyB,UACjD,SAAS,MAAM,OAAO;;;AAG9B,UAAM,yBAAyB,6BAA6B,UAAU;MAClE,gBAAgB,CAAC,oBAAoB;KACxC;AAED,WAAO;EACX;;;;;;;EAQO,QAAQ,OAA+B,mBAAmB,OAAK;AAClE,QAAI,OAAO;AAEX,QAAI,kBAAkB;AAClB,cAAQ,KAAK,kBAAkB,KAAK;IACxC;AACA,UAAM,WAAW,MAAM,mBAAc;AAErC,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AACvF,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AACvF,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AAEvF,YAAQ,GAAG,WAAW,6CAA6C,qCAAqC;;uBAEzF,SAAS,KAAK,SAAS;kBAC5B,SAAS;;;;;;;;;AASnB,WAAO;EACX;EAEgB,eAAe,SAA4B;AACvD,YAAQ,SAAS,eAAe,IAAI;AACpC,YAAQ,SAAS,uBAAuB,OAAO,IAAI;AACnD,YAAQ,SAAS,sBAAsB,CAAC,KAAK,UAAU,WAAW;EACtE;EAEgB,KAAK,QAAgB,cAA4B,MAAW;AACxE,UAAM,KAAK,QAAQ,cAAc,IAAI;AAErC,QAAI,MAAM;AACN,aAAO,SAAS,KAAK,8BAA8B,KAAK,eAAc,EAAG,YAAW,IAAK,IAAI,KAAK,CAAC;IACvG;EACJ;EAEmB,YAAY,OAA6B;AACxD,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,YAAM,WAAW,kBAAkB,KAAK,IAAI;AAC5C,YAAM,WAAW,eAAe,KAAK,IAAI;AAEzC,WAAK,+BAA+B,MAAM,mBAAmB,yBAAyB;AACtF,YAAM,uBAAuB,KAAK,8BAA8B,sCAAsC,KAAK;IAC/G;AAEA,WAAO;EACX;;AAGJ,cAAc,2BAA2B,eAAe;;;ACxNlD,IAAO,kBAAP,MAAO,yBAAwB,2BAA0B;EA2CxC,qCAAkC;AACjD,QAAI,KAAK,SAAS,aAAa;AAC3B,WAAK,2BAA2B,CAAC,KAAK;AACtC,aAAO,MAAM,gEAAgE;AAC7E,aAAO;IACX;AAEA,SAAK,WAAU;AAEf,WAAO;EACX;EAEmB,aAAU;AACzB,UAAM,WAAU;AAChB,SAAK,eAAe,UAAU,EAAG,SAAS,KAAK,2BAA2B,yBAAyB,WAAW,yBAAyB;AACvI,QAAI,KAAK,0BAA0B;AAC/B,WAAK,4BAA4B;IACrC;EACJ;;;;;EAMA,YAAmBC,OAAY;AAC3B,UAAMA,KAAI;AAjCP,SAAA,wBAAiC;AAMjC,SAAA,4BAAqC;AA6BxC,SAAK,YAAY;AAEjB,SAAK,cAAc,YAAY,sCAAsC,YAAY,OAAO,yBAAyB,MAAM;AACvH,SAAK,cAAc,SAAS,sCAAsC,QAAQ,OAAO,yBAAyB,MAAM;AAChH,SAAK,cAAc,SAAS,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AAEjH,SAAK,eACD,cACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA+C,kBAAiB,iBAAiB,CAAC;AAGpJ,SAAK,SAAS,2CACV,sCAAsC,SAAS,sCAAsC,UAAU,sCAAsC,OAAO;EAEpJ;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,CAAC,CAAC,KAAK,YAAW;EAC7B;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK,MAAM,cAAc,KAAK,MAAM,yBAAyB;EACxE;EAEmB,cAAW;AAC1B,QAAI,KAAK,SAAS;AACd,aAAO,KAAK;IAChB;AAEA,WAAO,KAAK,OAAO;EACvB;EAEgB,eAAe,SAA4B;AACvD,UAAM,eAAe,OAAO;AAE5B,UAAM,oBAAoB,KAAK,YAAW;AAC1C,UAAM,aAAa,qBAAqB,kBAAkB;AAE1D,YAAQ,SAAS,cAAc,YAAY,IAAI;AAE/C,QAAI,CAAC,YAAY;AACb;IACJ;AAEA,YAAQ,SAAS,KAAK,2BAA2B,kBAAkB,iBAAiB,IAAI;AACxF,YAAQ,SAAS,KAAK,iCAAiC,kBAAkB,mBAAmB,IAAI;AAChG,YAAQ,SAAS,KAAK,kBAAkB,KAAK,OAAO,uBAAuB,CAAC,kBAAkB,UAAU,kBAAkB,SAAS,IAAI;AAEvI,YAAQ,SAAS,uBAAuB,KAAK,uBAAuB,IAAI;AACxE,YAAQ,SAAS,mBAAmB,kBAAkB,YAAY,IAAI;AACtE,YAAQ,SAAS,kBAAkB,kBAAkB,QAAQ,IAAI;AAEjE,QAAI,qBAAqB,kBAAkB,oBAAoB,QAAQ,aAAa;AAChF,UAAI,kBAAkB,QAAQ;AAC1B,gBAAQ,SAAS,iCAAiC,IAAI;AACtD,gBAAQ,SAAS,oBAAoB,KAAK;AAC1C,YAAI,KAAK,6BAA6B,KAAK,OAAO,UAAS,EAAG,QAAO,EAAG,qBAAqB,GAAG;AAC5F,kBAAQ,SAAS,wBAAwB,KAAK;QAClD,OAAO;AACH,kBAAQ,SAAS,wBAAwB,IAAI;QACjD;MACJ;IACJ;EACJ;EAEgB,KAAK,QAAgB,cAA4B,MAAa,SAAiB;AAC3F,UAAM,KAAK,QAAQ,cAAc,IAAI;AAErC,UAAM,oBAAoB,KAAK,YAAW;AAE1C,QAAI,CAAC,qBAAqB,CAAC,SAAS;AAChC;IACJ;AAEA,QAAI,kBAAkB,QAAQ;AAC1B,aAAO,WAAW,KAAK,kBAAkB,iBAAiB;IAC9D,OAAO;AACH,aAAO,WAAW,KAAK,gBAAgB,iBAAiB;IAC5D;AAEA,WAAO,SAAS,KAAK,mBAAmB,KAAK,OAAO,eAAe,kBAAkB,KAAK;AAE1F,UAAM,QAAQ,kBAAkB,QAAO,EAAG;AAE1C,WAAO,UAAU,KAAK,mCAAmC,OAAO,kBAAkB,oBAAoB,kBAAkB,mBAAmB;AAC3I,WAAO,UAAU,KAAK,+BAA+B,OAAO,KAAK,KAAK,KAAK,CAAC;AAE5E,UAAM,UAAU,QAAQ;AAExB,UAAM,cAAc,kBAAkB;AACtC,QAAI,QAAQ,iCAAiC,aAAa;AACtD,UAAI,QAAQ,qBAAqB;AAC7B,cAAM,qBAAqB,YAAY;AACvC,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;AACzD,eAAO,WAAW,kBAAkB,mBAAmB,IAAI;AAC3D,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;AACzD,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;AACzD,eAAO,WAAW,kBAAkB,mBAAmB,IAAI;AAC3D,eAAO,WAAW,kBAAkB,mBAAmB,IAAI;AAC3D,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;AACzD,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;AACzD,eAAO,WAAW,iBAAiB,mBAAmB,GAAG;MAC7D,OAAO;AACH,eAAO,UAAU,eAAe,YAAY,EAAE,GAAG,YAAY,EAAE,GAAG,YAAY,EAAE,CAAC;AACjF,eAAO,UAAU,eAAe,YAAY,EAAE,GAAG,YAAY,EAAE,GAAG,YAAY,EAAE,CAAC;AACjF,eAAO,UAAU,eAAe,YAAY,EAAE,GAAG,YAAY,EAAE,GAAG,YAAY,EAAE,CAAC;AACjF,eAAO,UAAU,mBAAmB,YAAY,GAAG,IAAI,YAAY,GAAG,GAAG,YAAY,GAAG,IAAI,YAAY,GAAG,GAAG,YAAY,GAAG,IAAI,YAAY,GAAG,CAAC;AACjJ,eAAO,UAAU,mBAAmB,YAAY,GAAG,IAAI,YAAY,GAAG,GAAG,YAAY,GAAG,IAAI,YAAY,GAAG,GAAG,YAAY,GAAG,IAAI,YAAY,GAAG,CAAC;AACjJ,eAAO,UAAU,gBAAgB,YAAY,GAAG,GAAG,YAAY,GAAG,GAAG,YAAY,GAAG,CAAC;AACrF,eAAO,UAAU,gBAAgB,YAAY,GAAG,GAAG,YAAY,GAAG,GAAG,YAAY,GAAG,CAAC;AACrF,eAAO,UAAU,gBAAgB,YAAY,GAAG,GAAG,YAAY,GAAG,GAAG,YAAY,GAAG,CAAC;AACrF,eAAO,UAAU,gBAAgB,YAAY,GAAG,GAAG,YAAY,GAAG,GAAG,YAAY,GAAG,CAAC;MACzF;IACJ;EACJ;;;;;;EAOgB,iBAAiB,OAA6B;AAC1D,QAAI,OAAO,MAAM,iBAAiB,KAAK;AACvC,UAAM,WAAW,MAAM,mBAAc;AAErC,UAAM,yBAAyB,sBAAsB,KAAK,KAAK,IAAI,IAAI;MACnE,gBAAgB;QACZ,EAAE,QAAQ,mEAAmE,SAAS,GAAE;QACxF,EAAE,QAAQ,gEAAgE,SAAS,GAAE;;KAE5F;AAED,UAAM,uBAAuB,MAAM,qBAAqB,kBAAkB;AAE1E,SAAK,8BAA8B,MAAM,qBAAqB,wBAAwB;AAEtF,UAAM,uBACF,KAAK,6BACL,sCAAsC,SACtC,yEAAyE;AAG7E,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAClH,UAAM,uBAAuB,kBAAkB,sCAAsC,SAAS,qBAAqB;AACnH,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAClH,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAClH,UAAM,uBAAuB,kBAAkB,sCAAsC,SAAS,qBAAqB;AACnH,UAAM,uBAAuB,kBAAkB,sCAAsC,SAAS,qBAAqB;AACnH,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAClH,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAClH,UAAM,uBAAuB,iBAAiB,sCAAsC,SAAS,qBAAqB;AAElH,UAAM,uBAAuB,eAAe,sCAAsC,SAAS,uBAAuB,IAAI;AACtH,UAAM,uBAAuB,eAAe,sCAAsC,SAAS,uBAAuB,IAAI;AACtH,UAAM,uBAAuB,eAAe,sCAAsC,SAAS,uBAAuB,IAAI;AACtH,UAAM,uBAAuB,mBAAmB,sCAAsC,SAAS,uBAAuB,IAAI;AAC1H,UAAM,uBAAuB,mBAAmB,sCAAsC,SAAS,uBAAuB,IAAI;AAC1H,UAAM,uBAAuB,gBAAgB,sCAAsC,SAAS,uBAAuB,IAAI;AACvH,UAAM,uBAAuB,gBAAgB,sCAAsC,SAAS,uBAAuB,IAAI;AACvH,UAAM,uBAAuB,gBAAgB,sCAAsC,SAAS,uBAAuB,IAAI;AACvH,UAAM,uBAAuB,gBAAgB,sCAAsC,SAAS,uBAAuB,IAAI;AAEvH,YAAQ;kBACE,MAAM,iBAAiB,sBAAsB,sCAAsC,OAAO,CAAC,QAAQ,WAAW,cAAc,MAAM,KAAK,qBAAqB,UAAU,MAAM,OAAO,cAAc,KAAK,YAAY,sBAAsB;yBACjO,KAAK,gBAAgB;sBACxB,oBAAoB;;kBAExB,WAAW,mBAAmB,EAAE,GAAG,KAAK,2BAA2B,mCAAmC,oBAAoB;;;AAGpI,WAAO;EACX;;;;;;;EAQO,QAAQ,OAA+B,eAAqB;AAC/D,QAAI,OAAO;AAEX,SAAK,wBAAwB,KAAK;AAClC,UAAM,WAAW,MAAM,mBAAc;AAErC,UAAM,yBAAyB,sBAAsB,KAAK,KAAK,IAAI,IAAI;MACnE,gBAAgB;QACZ,EAAE,QAAQ,mEAAmE,SAAS,GAAE;QACxF,EAAE,QAAQ,gEAAgE,SAAS,GAAE;;KAE5F;AAED,QAAI,CAAC,UAAU;AACX,YAAM,cACF,oBACA;yBACS,KAAK,aAAa;;;;;GAK3B,KAAK,KAAK,IAAI,EAAE;AAGpB,YAAM,cACF,uBACA;yBACS,KAAK,aAAa;;;;;GAK3B,KAAK,KAAK,IAAI,EAAE;IAExB;AAEA,UAAM,8BAA8B,WAC9B;;kBAEI,KAAK,uCAAuC,OAAO,eAAe,YAAY,MAAM,IAAI,CAAC;yBAClF,KAAK,qBAAqB;;IAErC;;kBAEI,KAAK,uCAAuC,OAAO,eAAe,YAAY,MAAM,IAAI,CAAC;yBAClF,KAAK,qBAAqB;;;AAG3C,UAAM,cAAc,8BAA8B,6BAA6B,KAAK,KAAK,IAAI,EAAE;AAE/F,SAAK,oCAAoC,MAAM,qBAAqB,8BAA8B;AAElG,UAAM,uBAAuB,KAAK,mCAAmC,sCAAsC,OAAO;AAElH,SAAK,wBAAwB,MAAM,qBAAqB,kBAAkB;AAE1E,SAAK,gCAAgC,MAAM,qBAAqB,0BAA0B;AAE1F,UAAM,uBAAuB,KAAK,+BAA+B,sCAAsC,OAAO;AAE9G,SAAK,oBAAoB,MAAM,qBAAqB,cAAc;AAElE,UAAM,uBAAuB,KAAK,mBAAmB,sCAAsC,KAAK;AAEhG,YAAQ;cACF,MAAM,iBAAiB,KAAK,uBAAuB,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,KAAK,WAAW,cAAc,MAAM,KAAK,iBAAiB;;cAElL,WAAW,2CAA2C,mCAAmC;;;kBAGrF,KAAK,2BAA2B,KAAK,wCAAwC,WAAW,WAAW,MAAM,OAAO,KAAK,cAAc,sBAAsB;oBACvJ,aAAa;;qBAEZ,WAAW,cAAc,MAAM,KAAK,iCAAiC;oBACtE,KAAK,qBAAqB;oBAC1B,KAAK,eAAe;;;;0BAId,KAAK,yBAAyB,iBAAiB,KAAK,iBAAiB;;;qBAG1E,KAAK,+BAA+B;;;qBAGpC,KAAK,aAAa;oBACnB,KAAK,gBAAgB;kBACvB,WAAW,KAAK,KAAK,gBAAgB,YAAY,EAAE;;oBAEjD,KAAK,cAAc;kBACrB,WAAW,KAAK,KAAK,cAAc,YAAY,EAAE;;;oBAG/C,WAAW,WAAW,EAAE,GAAG,KAAK,2BAA2B;;;wBAGvD,KAAK,qBAAqB;;;;kBAIhC,WAAW,+BAA+B,EAAE;;;;;;yBAMrC,KAAK,aAAa;wBACnB,KAAK,gBAAgB;sBACvB,WAAW,KAAK,KAAK,gBAAgB,YAAY,EAAE;wBACjD,KAAK,gBAAgB;sBACvB,WAAW,KAAK,KAAK,gBAAgB,YAAY,EAAE;;wBAEjD,KAAK,cAAc;sBACrB,WAAW,KAAK,KAAK,cAAc,YAAY,EAAE;wBAC/C,KAAK,cAAc;sBACrB,WAAW,KAAK,KAAK,cAAc,YAAY,EAAE;;;;oBAInD,KAAK,6BAA6B;;;sBAGhC,WAAW,yBAAyB,EAAE;;;;;;;;;AASpD,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,SAAK,SAAS,MAAM,WAAW;AAE/B,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,WAAK,4BAA4B,MAAM,mBAAmB,sBAAsB;AAChF,WAAK,kCAAkC,MAAM,mBAAmB,0BAA0B;IAC9F;AAEA,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,QAAI,KAAK,SAAS;AACd,oBAAc,GAAG,KAAK,iBAAiB,yBAAyB,KAAK,QAAQ,UAAU;;IAC3F;AACA,kBAAc,GAAG,KAAK,iBAAiB,4BAA4B,KAAK,qBAAqB;;AAC7F,kBAAc,GAAG,KAAK,iBAAiB,gCAAgC,KAAK,yBAAyB;;AAErG,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,wBAAwB,KAAK;AACjD,wBAAoB,4BAA4B,KAAK;AACrD,wBAAoB,aAAa,KAAK,SAAS,cAAc;AAE7D,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,wBAAwB,oBAAoB;AACjD,SAAK,4BAA4B,oBAAoB;AACrD,QAAI,KAAK,SAAS;AACd,WAAK,QAAQ,aAAa,oBAAoB;IAClD;EACJ;;AA9cO,WAAA;EADN,uBAAuB,uBAAqB,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOnI,WAAA;EADN,uBAAuB,gCAA8B,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AA4cvJ,cAAc,2BAA2B,eAAe;;;AClflD,IAAO,iBAAP,MAAO,wBAAuB,kBAAiB;;;;;EAQjD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAPzC,SAAA,+BAA+B;AA4ChC,SAAA,2BAAoC;AAnCvC,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,OAAO,yBAAyB,QAAQ;AACrH,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACpH,SAAK,cAAc,qBAAqB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAC5H,SAAK,cAAc,kBAAkB,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AAC1H,SAAK,cAAc,MAAM,sCAAsC,SAAS,MAAM,yBAAyB,QAAQ;AAC/G,SAAK,cAAc,aAAa,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACrH,SAAK,cAAc,kBAAkB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACzH,SAAK,cAAc,iBAAiB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACxH,SAAK,cAAc,gBAAgB,sCAAsC,SAAS,IAAI;AACtF,SAAK,cAAc,eAAe,sCAAsC,YAAY,IAAI;AACxF,SAAK,YAAY,2CACb,sCAAsC,SAAS,sCAAsC,UAAU,sCAAsC,OAAO;AAEhJ,SAAK,cACD,OACA,sCAAsC,QACtC,MACA,yBAAyB,mBACzB,IAAI,wCAAwC,OAAO,MAAI,GAA8C,UAAU,UAAU,CAAC;AAG9H,SAAK,eACD,aACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,aAAa,MAAI,GAA+C,iBAAgB,gBAAgB,CAAC;EAErJ;;;;;EAYgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,kBAAkB;AAC7C,UAAM,qBAAqB,sBAAsB;AACjD,UAAM,qBAAqB,4BAA4B;AACvD,UAAM,qBAAqB,8BAA8B;AACzD,UAAM,qBAAqB,2BAA2B;EAC1D;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,oBAAiB;AACxB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,KAAE;AACT,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;;EAMA,IAAW,MAAG;AACV,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,gBAAa;AACzB,QAAI,CAAC,KAAK,UAAU,aAAa;AAC7B,YAAM,iBAAiB,IAAI,WAAW,uBAAuB,yBAAyB,UAAU,sCAAsC,KAAK;AAC3I,qBAAe,QAAQ;AACvB,qBAAe,OAAO,UAAU,KAAK,SAAS;IAClD;EACJ;EAEgB,eAAe,SAA4B;AACvD,YAAQ,SAAS,aAAa,IAAI;AAClC,YAAQ,SAAS,qBAAqB,OAAO,IAAI;AACjD,YAAQ,SAAS,4CAA4C,MAAM,IAAI;AACvE,YAAQ,SAAS,kBAAkB,KAAK,UAAU,eAAe,KAAK,cAAc,eAAe,KAAK,eAAe,aAAa,IAAI;AACxI,YAAQ,SAAS,kBAAkB,KAAK,eAAe,aAAa,IAAI;AACxE,YAAQ,SACJ,wBACA,KAAK,kBAAkB,cAAc,KAAK,kBAAkB,kBAAmB,UAAU,0BAA0B,4BAA4B,MAC/I,IAAI;AAER,YAAQ,SAAS,sBAAsB,KAAK,0BAA0B,IAAI;EAC9E;EAEgB,KAAK,QAAgB,cAA4B,MAAW;AACxE,UAAM,KAAK,QAAQ,cAAc,IAAI;AAGrC,UAAM,oBAAoB,KAAK,kBAAkB,mBAAmB,SAAS,0BAA0B;AAEvG,UAAM,IAAI,IAAI;AACd,UAAM,IAAI,IAAI;AACd,UAAM,KAAK,KAAK,IAAI,CAAC,IAAI,GAAG,CAAC;AAC7B,UAAM,MAAM,IAAI;AAEhB,WAAO,UAAU,8BAA8B,IAAI,KAAK,GAAG,CAAC;AAG5D,UAAM,eAAe,KAAK,UAAU,eAAgB,KAAK,UAAU,UAAU,CAAC,EAAE,aAA2C;AAC3H,UAAM,uBAAuB,cAAc,gBAAgB,cAAe,aAAa,gBAAgB,eAAgB,aAAoC;AAE3J,QAAI,KAAK,OAAO,yBAAyB;AACrC,aAAO,UAAU,gCAAgC,sBAAsB,UAAU,IAAM,IAAM,sBAAsB,UAAU,IAAM,EAAI;IAC3I,OAAO;AACH,aAAO,UAAU,gCAAgC,sBAAsB,UAAU,KAAO,GAAK,sBAAsB,UAAU,KAAO,CAAG;IAC3I;AAEA,QAAI,MAAM;AACN,aAAO,SAAS,KAAK,8BAA8B,KAAK,eAAc,EAAG,YAAW,IAAK,IAAI,KAAK,CAAC;IACvG;EACJ;EAEQ,kBAAkB,OAA+B,sBAA8B,oBAA0B;AAC7G,QAAI,OAAO;AAEX,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,eAAe,KAAK;AAC1B,UAAM,WAAW,MAAM,mBAAc;AAErC,QAAI,CAAC,UAAU;AACX,YAAM,eAAe,eAAe,iDAAiD;IACzF;AAEA,UAAM,uBAAuB,EAAE,QAAQ,uBAAuB,SAAS,aAAa,cAAc,qBAAqB,kBAAiB;AAExI,UAAM,MAAM,KAAK;AACjB,QAAI,IAAI,aAAa;AACjB,YAAM,qBAAqB;;kBAErB,WAAW,YAAY,UAAU,MAAM,IAAI,sBAAsB;;;IAG3E,WAAW,aAAa,aAAa;AACjC,cAAQ,GAAG,MAAM,iBAAiB,aAAa,sCAAsC,OAAO,CAAC,gBAAgB,kBAAkB;;AAC/H,cAAQ,GAAG,MAAM,iBAAiB,cAAc,sCAAsC,OAAO,CAAC,gBAAgB,aAAa,sBAAsB;;AACjJ,cAAQ,GAAG,MAAM,iBAAiB,gBAAgB,sCAAsC,OAAO,CAAC,qCAAqC,KAAK,4BAA4B;;AACtK,cAAQ,GAAG,WAAW,aAAa,WAAW,MAAM,WAAW,YAAY,MAAM;;IACrF;AAEA,UAAM,yBAAyB,6BAA6B,UAAU;MAClE,gBAAgB,CAAC,oBAAoB;KACxC;AAED,WAAO;EACX;;EAGO,OAAO,uBAAuB,OAA+B,SAAiC;AACjG,QAAI,OAAO;AAEX,UAAM,YAAY,SAAS,UAAU,cAAc,QAAQ,UAAU,yBAAyB;AAC9F,UAAM,YAAY,SAAS,UAAU,cAAc,QAAQ,UAAU,yBAAyB;AAE9F,UAAM,YAAY,SAAS,UAAU,cAAc,QAAQ,UAAU,yBAAyB,OAAO,MAAM,OAAO;AAClH,UAAM,gBAAgB,SAAS,cAAc,cAAc,QAAQ,cAAc,yBAAyB;AAE1G,YAAQ;;kBAEE,MAAM,iBAAiB,oBAAoB,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,IAAI,SAAS,KAAK,SAAS;kBAC3I,MAAM,iBAAiB,wBAAwB,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,IAAI,SAAS,KAAK,aAAa;;;AAG7J,WAAO;EACX;;;;;;;;;;;;EAaO,OAAO,QACV,OACA,SACA,iBACA,iBACA,kBACA,eACA,oBAA0B;AAE1B,QAAI,OAAO;AAEX,UAAM,iBAAiB,SAAS,eAAe,cAAc,QAAQ,eAAe,yBAAyB,OAAO,MAAM,OAAO;AACjI,UAAM,KAAK,SAAS,GAAG,cAAc,QAAQ,GAAG,yBAAyB,OAAO,MAAM,OAAO;AAE7F,UAAM,iBAAiB,SAAS,eAAe,cAAc,QAAQ,eAAe,yBAAyB;AAC7G,UAAM,cAAc,OAAO,MAAM,OAAO;AAExC,QAAI,SAAS;AACT,YAAM,uBAAuB,8BAA8B,sCAAsC,OAAO;AACxG,YAAM,uBAAuB,gCAAgC,sCAAsC,OAAO;AAE1G,YAAM,gBAAgB,QAAQ;AAC9B,cAAQ,GAAG,MAAM,iBAAiB,6BAA6B,sCAAsC,OAAO,CAAC,MAAM,cAAc,cAAc,eAAe,cAAc,yBAAyB,UAAU,kBAAkB;;IACrO,OAAO;AACH,cAAQ,GAAG,MAAM,iBAAiB,6BAA6B,sCAAsC,OAAO,CAAC;;IACjH;AAEA,QAAI,oBAAoB,SAAS;AAC7B,cAAQ,QAAQ,kBAAkB,OAAO,iBAAiB,kBAAkB;AAC5E,sBAAgB,QAAQ,aAAa;IACzC;AAEA,UAAM,WAAW,MAAM,mBAAc;AACrC,YAAQ,GAAG,WAAW,yCAAyC,iCAAiC;;;;kBAItF,eAAe;;;;;;wBAMT,MAAM,OAAO;;;;oBAIjB,cAAc;oBACd,WAAW,cAAc,EAAE;;wBAEvB,WAAW;;;;wBAIX,MAAM,OAAO;wBACb,MAAM,OAAO,IAAI,cAAc;oBACnC,EAAE;8BACQ,gBAAgB,YAAY,QAAQ;;;wBAG1C,WAAW,cAAc,EAAE;;;;;;;;;;oBAU/B,WAAW,cAAc,EAAE,GAAG,iBAAiB,iCAAiC;oBAChF,iBAAiB,qBAAqB;oBACtC,iBAAiB,eAAe;oBAChC,WAAW,cAAc,EAAE;yBACtB,iBAAiB,aAAa;wBAC/B,iBAAiB,gBAAgB;sBACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;wBAE7D,iBAAiB,cAAc;sBACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;6BAGtD,iBAAiB,aAAa;4BAC/B,iBAAiB,gBAAgB;0BACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;4BAC7D,iBAAiB,gBAAgB;0BACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;4BAE7D,iBAAiB,cAAc;0BACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;4BAC3D,iBAAiB,cAAc;0BACjC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;;;qBAKlE,MAAM,iBAAiB,MAAM,OAAO,WAAW,+BAA+B,gBAAgB,CAAC;;;;;;;AAO5G,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,SAAK,SAAS,MAAM,WAAW;AAE/B,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,YAAM,WAAW,eAAe,KAAK,IAAI;AACzC,YAAM,WAAW,kBAAkB,KAAK,IAAI;AAE5C,WAAK,+BAA+B,MAAM,mBAAmB,yBAAyB;AACtF,YAAM,uBAAuB,KAAK,8BAA8B,sCAAsC,KAAK;IAC/G;AAEA,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,kBAAc,GAAG,KAAK,iBAAiB,+BAA+B,KAAK,wBAAwB;;AAEnG,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,2BAA2B,KAAK;AAEpD,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,2BAA2B,oBAAoB,4BAA4B;EACpF;;AA1WO,WAAA;EADN,uBAAuB,gCAA8B,GAAkC,YAAY,EAAE,UAAU,KAAI,CAAE;;AA8W1H,cAAc,0BAA0B,cAAc;;;AClahD,IAAO,mBAAP,MAAO,0BAAyB,kBAAiB;;;;;EAKnD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAE7C,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACpH,SAAK,cAAc,qBAAqB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAC5H,SAAK,cAAc,aAAa,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAEpH,SAAK,eACD,eACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,eAAe,MAAI,GAA+C,mBAAkB,kBAAkB,CAAC;EAE3J;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,gBAAgB;AAC3C,UAAM,qBAAqB,oBAAoB;EACnD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,oBAAiB;AACxB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,gBAAa;AACzB,QAAI,CAAC,KAAK,UAAU,aAAa;AAC7B,YAAM,iBAAiB,IAAI,WAAW,yBAAyB,yBAAyB,UAAU,sCAAsC,KAAK;AAC7I,qBAAe,QAAQ;AACvB,qBAAe,OAAO,UAAU,KAAK,SAAS;AAE9C,YAAM,yBAAyB,IAAI,WAAW,mBAAmB,yBAAyB,UAAU,sCAAsC,KAAK;AAC/I,6BAAuB,QAAQ;AAC/B,6BAAuB,OAAO,UAAU,KAAK,iBAAiB;AAE9D,YAAM,iBAAiB,IAAI,WAAW,yBAAyB,yBAAyB,UAAU,sCAAsC,KAAK;AAC7I,qBAAe,QAAQ;AACvB,qBAAe,OAAO,UAAU,KAAK,SAAS;IAClD;EACJ;EAEgB,eAAe,SAA4B;AACvD,YAAQ,SAAS,eAAe,MAAM,IAAI;AAC1C,YAAQ,SAAS,uBAAuB,OAAO,IAAI;AACnD,YAAQ,SAAS,iCAAiC,OAAO,IAAI;EACjE;;;;;;;EAQO,OAAO,QAAQ,kBAA8C,OAA6B;AAC7F,QAAI,OAAO;AAEX,UAAM,gBAAgB,kBAAkB,UAAU,cAAc,iBAAiB,UAAU,yBAAyB;AACpH,UAAM,oBAAoB,kBAAkB,kBAAkB,cACxD,iBAAiB,kBAAkB,yBACnC,4BAA4B;AAClC,UAAM,YAAY,kBAAkB,UAAU,cAAc,iBAAiB,UAAU,yBAAyB,4BAA4B;AAE5I,UAAM,WAAW,MAAM,mBAAc;AAErC,YAAQ,GAAG,WAAW,6CAA6C,qCAAqC;;;;uBAIzF,aAAa,KAAK,iBAAiB,SAAS,SAAS;;;;;;;;;cAS9D,WAAW,QAAQ,OAAO;;;;AAIhC,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,YAAM,WAAW,eAAe,KAAK,IAAI;AACzC,YAAM,WAAW,kBAAkB,KAAK,IAAI;IAChD;AAEA,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;EAC1D;;AAGJ,cAAc,4BAA4B,gBAAgB;;;AC5IpD,IAAO,kBAAP,MAAO,yBAAwB,kBAAiB;;;;;EAgElD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAxB1C,SAAA,iCAA0C;AAM1C,SAAA,oBAA6B;AAM7B,SAAA,sBAA+B;AAclC,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,OAAO,yBAAyB,QAAQ;AACrH,SAAK,cAAc,kBAAkB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACzH,SAAK,cAAc,2BAA2B,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAElI,SAAK,eACD,cACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA+C,kBAAiB,iBAAiB,CAAC;EAExJ;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,qBAAqB;AAChD,UAAM,qBAAqB,iBAAiB;EAChD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,0BAAuB;AAC9B,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,CAAC,CAAC,KAAK,YAAW;EAC7B;EAEU,cAAW;AACjB,QAAI,KAAK,SAAS;AACd,aAAO,KAAK;IAChB;AAEA,WAAO,KAAK,OAAO;EACvB;EAEgB,cAAc,UAAwB,0BAAgE,MAAM,MAAI;AAC5H,QAAI,CAAC,KAAK,UAAU,aAAa;AAC7B,YAAM,iBAAiB,IAAI,WAAW,wBAAwB,yBAAyB,UAAU,sCAAsC,KAAK;AAC5I,qBAAe,QAAQ;AACvB,qBAAe,OAAO,UAAU,KAAK,SAAS;IAClD;AAEA,QAAI,KAAK,QAAQ,CAAC,KAAK,KAAK,aAAa;AACrC,UAAI,YAAY,SAAS,yBAAyB,CAAC,MAAM,EAAE,gBAAgB,yBAAyB,QAAQ,wBAAwB,CAAC,CAAC;AAEtI,UAAI,CAAC,WAAW;AACZ,oBAAY,IAAI,WAAW,MAAM;AACjC,kBAAU,iBAAiB,yBAAyB,IAAI;MAC5D;AACA,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;EACJ;EAEgB,eAAe,SAA4B;AACvD,UAAM,oBAAoB,KAAK,YAAW;AAC1C,UAAM,aAAa,qBAAqB,kBAAkB;AAE1D,YAAQ,SAAS,iBAAiB,YAAY,IAAI;AAElD,QAAI,CAAC,YAAY;AACb;IACJ;AAEA,YAAQ,SAAS,KAAK,eAAe,kBAAkB,QAAQ,IAAI;AACnE,YAAQ,SAAS,KAAK,2BAA2B,kBAAkB,iBAAiB,IAAI;AACxF,YAAQ,SAAS,KAAK,iCAAiC,kBAAkB,mBAAmB,IAAI;AAChG,YAAQ,SAAS,KAAK,kBAAkB,KAAK,OAAO,wBAAwB,kBAAkB,SAAS,CAAC,kBAAkB,UAAU,kBAAkB,SAAS,IAAI;AAEnK,YAAQ,SAAS,mCAAmC,KAAK,gCAAgC,IAAI;AAC7F,YAAQ,SAAS,sBAAsB,kBAAkB,YAAY,IAAI;AACzE,YAAQ,SAAS,qBAAqB,kBAAkB,QAAQ,IAAI;AACpE,YAAQ,SAAS,oCAA0C,kBAAmB,kBAAkB,OAAO,OAAO,IAAI;AAClH,YAAQ,SAAS,6BAA6B,KAAK,qBAAqB,IAAI;EAChF;EAEgB,UAAO;AACnB,UAAM,UAAU,KAAK,YAAW;AAEhC,QAAI,WAAW,CAAC,QAAQ,qBAAoB,GAAI;AAC5C,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,KAAK,QAAgB,cAA4B,MAAW;AACxE,UAAM,KAAK,QAAQ,cAAc,IAAI;AAErC,UAAM,oBAAoB,KAAK,YAAW;AAE1C,QAAI,CAAC,mBAAmB;AACpB;IACJ;AAEA,QAAI,kBAAkB,QAAQ;AAC1B,aAAO,WAAW,KAAK,kBAAkB,iBAAiB;IAC9D,OAAO;AACH,aAAO,WAAW,KAAK,gBAAgB,iBAAiB;IAC5D;AAEA,WAAO,UAAU,KAAK,uBAAuB,kBAAkB,2BAA0B,CAAE;AAE3F,QAAI,QAAQ;AACZ,QAAI,CAAC,kBAAkB,QAAQ;AAC3B,UAAU,kBAAmB,OAAO;AAChC,gBAAc,kBAAmB;MACrC;IACJ;AAEA,UAAM,oBAAoB,KAAK,wBAAwB,mBAAmB,SAAS,KAAK,iCAAiC,mBAAmB,SAAS;AAErJ,WAAO,UAAU,KAAK,uBAAuB,kBAAkB,OAAO,IAAI,mBAAmB,OAAO,KAAK,oBAAoB,KAAK,CAAC;AAEnI,WAAO,UACH,KAAK,mCACL,kBAAkB,QAAO,EAAG,OAC5B,kBAAkB,oBAClB,kBAAkB,qBAClB,IAAI,iBAAiB;AAGzB,UAAM,QAAQ,kBAAkB,QAAO,EAAG;AAE1C,WAAO,UAAU,KAAK,+BAA+B,OAAO,KAAK,KAAK,KAAK,CAAC;AAE5E,QAAU,kBAAmB,iBAAiB;AAC1C,YAAM,cAA2B;AACjC,aAAO,WAAW,uBAAuB,YAAY,mBAAmB;AACxE,aAAO,WAAW,mBAAmB,YAAY,eAAe;IACpE;EACJ;;;;;;EAOO,QAAQ,OAA6B;AACxC,UAAM,OAAO;AAEb,UAAM,WAAW,eAAe,KAAK,IAAI;AACzC,UAAM,WAAW,cAAc,KAAK,IAAI;AAGxC,SAAK,mBAAmB,MAAM,qBAAqB,KAAK,OAAO,aAAa;AAC5E,UAAM,SAAS,KAAK,KAAK,gBAAgB;AAEzC,SAAK,iBAAiB,MAAM,qBAAqB,KAAK,OAAO,WAAW;AACxE,UAAM,SAAS,KAAK,KAAK,cAAc;AAEvC,SAAK,gBAAgB,MAAM,mBAAmB,qBAAqB;AACnE,UAAM,oBAAoB,KAAK,YAAW;AAE1C,QAAI,mBAAmB;AACnB,YAAM,uBAAuB,UAAU,KAAK,aAAa;;AACzD,YAAM,iBAAiB,KAAK,kBAAkB,QAAW,IAAI;AAC7D,YAAM,uBAAuB;;AAC7B,YAAM,eAAe,KAAK,gBAAgB,QAAW,IAAI;AACzD,YAAM,uBAAuB;;IACjC;AAGA,UAAM,WAAW,kBAAkB,KAAK,IAAI;AAC5C,UAAM,WAAW,eAAe,KAAK,IAAI;AAEzC,SAAK,4BAA4B,MAAM,mBAAmB,yBAAyB;AACnF,SAAK,kCAAkC,MAAM,mBAAmB,6BAA6B;AAC7F,SAAK,mBAAmB,MAAM,mBAAmB,4BAA4B;AAE7E,SAAK,wBAAwB,MAAM,qBAAqB,kBAAkB;AAE1E,UAAM,uBAAuB,KAAK,uBAAuB,sCAAsC,MAAM;AAErG,QAAI,MAAM,mBAAc,GAA0B;AAC9C,YAAM,cACF,oBACA;yBACS,KAAK,aAAa;;;;;GAK3B,KAAK,KAAK,IAAI,EAAE;AAGpB,YAAM,cACF,uBACA;yBACS,KAAK,aAAa;;;;;GAK3B,KAAK,KAAK,IAAI,EAAE;IAExB;AAEA,SAAK,oCAAoC,MAAM,qBAAqB,8BAA8B;AAElG,UAAM,uBAAuB,KAAK,mCAAmC,sCAAsC,OAAO;AAElH,SAAK,wBAAwB,MAAM,qBAAqB,kBAAkB;AAE1E,UAAM,uBAAuB,KAAK,uBAAuB,sCAAsC,OAAO;AAEtG,SAAK,gCAAgC,MAAM,qBAAqB,0BAA0B;AAE1F,UAAM,uBAAuB,KAAK,+BAA+B,sCAAsC,OAAO;AAE9G,UAAM,uBAAuB,uBAAuB,sCAAsC,OAAO;AACjG,UAAM,uBAAuB,mBAAmB,sCAAsC,OAAO;AAE7F,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,SAAK,SAAS,MAAM,WAAW;AAE/B,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,QAAI,KAAK,SAAS;AACd,UAAI,KAAK,QAAQ,QAAQ;AACrB,qBAAa,GAAG,KAAK,iBAAiB,uCAAuC,KAAK,QAAQ,IAAI;;MAClG,OAAO;AACH,qBAAa,GAAG,KAAK,iBAAiB,mCAAmC,KAAK,QAAQ,IAAI;;MAC9F;AACA,oBAAc,GAAG,KAAK,iBAAiB,8BAA8B,KAAK,QAAQ,eAAe;;IACrG;AAEA,kBAAc,GAAG,KAAK,iBAAiB,qCAAqC,KAAK,8BAA8B;;AAC/G,kBAAc,GAAG,KAAK,iBAAiB,wBAAwB,KAAK,iBAAiB;;AACrF,kBAAc,GAAG,KAAK,iBAAiB,0BAA0B,KAAK,mBAAmB;;AAEzF,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,QAAI,KAAK,WAAW,CAAC,KAAK,QAAQ,gBAAgB;AAC9C,0BAAoB,UAAU,KAAK,QAAQ,UAAS;IACxD;AAEA,wBAAoB,iCAAiC,KAAK;AAC1D,wBAAoB,oBAAoB,KAAK;AAC7C,wBAAoB,sBAAsB,KAAK;AAE/C,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,QAAI,oBAAoB,SAAS;AAC7B,gBAAU,oBAAoB,QAAQ,IAAI,QAAQ,OAAO,MAAM,IAAI,KAAK;AACxE,UAAI,oBAAoB,QAAQ,QAAQ;AACpC,aAAK,UAAU,YAAY,MAAM,oBAAoB,SAAS,OAAO,OAAO;MAChF,OAAO;AACH,aAAK,UAAU,QAAQ,MAAM,oBAAoB,SAAS,OAAO,OAAO;MAC5E;IACJ;AAEA,SAAK,iCAAiC,oBAAoB;AAC1D,SAAK,oBAAoB,oBAAoB;AAC7C,SAAK,sBAAsB,CAAC,CAAC,oBAAoB;EACrD;;AArVO,WAAA;EADN,uBAAuB,mCAAiC,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAO/I,WAAA;EADN,uBAAuB,uBAAqB,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOnI,WAAA;EADN,uBAAuB,0BAAwB,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AA6UjJ,cAAc,2BAA2B,eAAe;;;ACrYlD,IAAO,kBAAP,MAAO,yBAAwB,kBAAiB;;;;;EAKlD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AA6B1C,SAAA,6BAAsC,2BAA2B;AA3BpE,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,sCAAsC,OAAO,OAAO,yBAAyB,QAAQ;AACrH,SAAK,cAAc,aAAa,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACrH,SAAK,cAAc,yBAAyB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAChI,SAAK,cAAc,6BAA6B,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACrI,SAAK,cACD,cACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA8C,iBAAiB,iBAAiB,CAAC;AAEnJ,SAAK,cAAc,cAAc,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAErH,SAAK,eACD,cACA,sCAAsC,QACtC,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA+C,kBAAiB,iBAAiB,CAAC;EAExJ;;;;;EAYgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,eAAe;AAC1C,UAAM,qBAAqB,iBAAiB;AAC5C,UAAM,qBAAqB,YAAY;AACvC,UAAM,qBAAqB,oBAAoB;AAC/C,UAAM,qBAAqB,sBAAsB;AACjD,UAAM,qBAAqB,YAAY;EAC3C;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,wBAAqB;AAC5B,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,4BAAyB;AAChC,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,gBAAa;AACzB,QAAI,CAAC,KAAK,UAAU,aAAa;AAC7B,YAAM,iBAAiB,IAAI,WAAW,wBAAwB,yBAAyB,UAAU,sCAAsC,KAAK;AAC5I,qBAAe,QAAQ;AACvB,qBAAe,OAAO,UAAU,KAAK,SAAS;IAClD;EACJ;EAEgB,eAAe,SAA4B;AACvD,UAAM,sBAAsB,KAAK,0BAA0B,eAAe,KAAK,sBAAsB;AAErG,YAAQ,SAAS,cAAc,uBAAuB,KAAK,WAAW,aAAa,IAAI;AACvF,YAAQ,SAAS,mBAAmB,qBAAqB,IAAI;AAC7D,YAAQ,SAAS,+BAA+B,OAAO,IAAI;AAC3D,YAAQ,SAAS,kCAAkC,OAAO,IAAI;AAC9D,YAAQ,SAAS,oCAAoC,OAAO,IAAI;AAChE,YAAQ,SAAS,wBAAwB,OAAO,IAAI;AACpD,YAAQ,SAAS,iBAAiB,KAAK,WAAW,aAAa,IAAI;AACnE,YAAQ,SAAS,oCAAoC,KAAK,4BAA4B,IAAI;EAC9F;;;;;;;;;EAUO,OAAO,QAAQ,OAA+B,SAAoC,iBAA4C,iBAAuB;AACxJ,QAAI,OAAO;AAEX,UAAM,YAAY,SAAS,UAAU,cAAc,QAAQ,UAAU,yBAAyB;AAC9F,UAAM,YAAY,SAAS,UAAU,cAAc,QAAQ,UAAU,yBAAyB;AAC9F,UAAM,wBAAwB,SAAS,sBAAsB,cAAc,SAAS,sBAAsB,yBAAyB;AACnI,UAAM,gCAAgC,SAAS,0BAA0B,cAAc,SAAS,0BAA0B,yBAAyB;AAEnJ,UAAM,kBAA8C,SAAS,WAAW,cAAc,SAAS,WAAW,gBAAgB,aAAa;AAEvI,UAAM,2BAA2B,iBAAiB,eAAe,cAAc,gBAAgB,eAAe,yBAAyB;AACvI,UAAM,sBAAsB,iBAAiB,UAAU,cAAc,gBAAgB,UAAU,yBAAyB;AACxH,UAAM,iBAAiB,iBAAiB,KAAK,cAAc,gBAAgB,KAAK,yBAAyB;AAEzG,UAAM,aAAa,SAAS,WAAW,cAAc,SAAS,WAAW,yBAAyB;AAClG,UAAM,WAAW,MAAM,mBAAc;AAErC,YAAQ,iBAAiB,QAAQ,KAAK,KAAK;AAE3C,YAAQ,GAAG,WAAW,2CAA2C,mCAAmC;;;cAG9F,MAAM,iBAAiB,mBAAmB,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,QAAQ,SAAS;cAChI,MAAM,iBAAiB,cAAc,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,IAAI,SAAS,KAAK,wBAAwB;cACpJ,MAAM,iBAAiB,wBAAwB,sCAAsC,OAAO,CAAC,WAAW,mBAAmB,KAAK,qBAAqB;cACrJ,MAAM,iBAAiB,cAAc,sCAAsC,KAAK,CAAC,MAAM,UAAU;;;;;;;;AASvG,YAAQ,WACF,6IACA;AAEN,YAAQ;;;;wBAIQ,MAAM,OAAO;;;;yBAIZ,WAAW,cAAc,MAAM,iBAAiB,qBAAqB;;;;;;gCAM9D,iBAAiB,gBAAgB;8BACnC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;gCAC7D,iBAAiB,6BAA6B;;;;;0BAKpD,WAAW,+BAA+B,EAAE;;;;;;;;oBAQlD,eAAe;;oBAEf,cAAc;qBACb,WAAW,cAAc,OAAO,iBAAiB,yBAAyB,GAAG;qBAC7E,WAAW,cAAc,OAAO,iBAAiB,yBAAyB,GAAG;qBAC7E,WAAW,cAAc,OAAO,iBAAiB,qCAAqC,GAAG;oBAC1F,WAAW,cAAc,EAAE;;;;yBAItB,iBAAiB,6BAA6B,QAAQ;;;yBAGtD,iBAAiB,mCAAmC,QAAQ;;;;yBAI5D,iBAAiB,iBAAiB,QAAQ;wBAC3C,iBAAiB,oBAAoB,EAAE;sBACzC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;wBAE7D,iBAAiB,kBAAkB,EAAE;sBACvC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;6BAGtD,iBAAiB,iBAAiB,QAAQ;4BAC3C,iBAAiB,oBAAoB,EAAE;0BACzC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;4BAC7D,iBAAiB,oBAAoB,EAAE;0BACzC,WAAW,KAAK,iBAAiB,gBAAgB,YAAY,EAAE;;4BAE7D,iBAAiB,kBAAkB,EAAE;0BACvC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;4BAC3D,iBAAiB,kBAAkB,EAAE;0BACvC,WAAW,KAAK,iBAAiB,cAAc,YAAY,EAAE;;;;;;;wBAO/D,iBAAiB,iCAAiC,EAAE;;;;;;;;;;;oBAWxD,6BAA6B;;;4BAGrB,MAAM,OAAO;;;;;;;;;;;;;;;AAejC,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD,YAAM,WAAW,kBAAkB,KAAK,IAAI;IAChD;AAEA,WAAO;EACX;;AAvPO,WAAA;EADN,uBAAuB,kCAAgC,GAAkC,UAAU;;AA2PxG,cAAc,2BAA2B,eAAe;;;ACtQxD,IAAM,sBAA4D;EAC9D,YAAY,CAAC,gBAAgB,EAAE;EAC/B,YAAY,CAAC,gBAAgB,EAAE;EAC/B,aAAa,CAAC,uBAAuB,0CAA0C;EAC/E,cAAc,CAAC,wBAAwB,uCAAuC;EAC9E,UAAU,CAAC,oBAAoB,mCAAmC;EAClE,YAAY,CAAC,mBAAmB,wCAAwC;EACxE,aAAa,CAAC,uBAAuB,wCAAwC;EAC7E,cAAc,CAAC,6CAA6C,8DAA8D;EAC1H,UAAU,CAAC,qCAAqC,sFAAsF;EACtI,YAAY,CAAC,iCAAiC,2CAA2C;EACzF,UAAU,CAAC,kBAAkB,EAAE;EAC/B,QAAQ,CAAC,aAAa,EAAE;EACxB,OAAO,CAAC,SAAS,EAAE;;AAOjB,IAAO,4BAAP,cAAyC,kBAAiB;EAMpD,OAAO,mCAAmC,OAA0B,eAAqB;AAC7F,UAAM,OAAO;AAEb,QAAI,KAAK,cAAc,eAAe,KAAK,YAAY,aAAa;AAChE,WAAK,2BAA2B,CAAC,KAAK;AACtC,aAAO,MAAM,sFAAsF;AACnG,aAAO;IACX;AAEA,SAAK,WAAU;AAEf,WAAO;EACX;EAEQ,aAAU;AACd,SAAK,kBAAkB,KAAK,2BAA2B,yBAAyB,WAAW,yBAAyB,iBAAiB;AACrI,SAAK,eAAe,eAAe,EAAG,SAAS,KAAK,2BAA2B,yBAAyB,WAAW,yBAAyB;AAC5I,SAAK,eAAe,aAAa,EAAG,SAAS,KAAK,2BAA2B,yBAAyB,WAAW,yBAAyB;EAC9I;;;;;EAkBA,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,iBAAiB;AAflD,SAAA,0BAAiD;AAKjD,SAAA,4BAAoC,OAAO,MAAK;AAChD,SAAA,oBAAoB;AAwFrB,SAAA,kBAA0B;AAO1B,SAAA,uBAA+B;AAO/B,SAAA,oBAA4B;AAc5B,SAAA,eAAe;AAMf,SAAA,eAAwB;AAMxB,SAAA,kBAA0B;AAM1B,SAAA,mBAA4B;AAO5B,SAAA,uBAAgC;AAOhC,SAAA,uBAAgC;AAQhC,SAAA,6BAAsC;AAMtC,SAAA,oBAA6B;AAa7B,SAAA,2BAA2B;AAc3B,SAAA,mBAAmB;AAMnB,SAAA,wBAAiC;AAOjC,SAAA,uBAAgC;AAOhC,SAAA,sBAA+B;AAM/B,SAAA,QAAiB;AAMjB,SAAA,qBAA8B;AAM9B,SAAA,2BAA2B;AA+D3B,SAAA,YAAY;AASZ,SAAA,aAAa;AAOb,SAAA,cAAc;AAvSjB,SAAK,YAAY;AAEjB,SAAK,cAAc,iBAAiB,sCAAsC,SAAS,OAAO,yBAAyB,MAAM;AACzH,SAAK,cAAc,eAAe,sCAAsC,SAAS,OAAO,yBAAyB,MAAM;AACvH,SAAK,cAAc,QAAQ,sCAAsC,QAAQ,KAAK;AAC9E,SAAK,cAAc,kBAAkB,sCAAsC,SAAS,OAAO,yBAAyB,QAAQ;AAC5H,SAAK,cAAc,mBAAmB,sCAAsC,SAAS,MAAM,yBAAyB,QAAQ;AAC5H,SAAK,cAAc,aAAa,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACrH,SAAK,cAAc,YAAY,sCAAsC,OAAO,OAAO,yBAAyB,QAAQ;AACpH,SAAK,cAAc,aAAa,sCAAsC,OAAO,OAAO,yBAAyB,QAAQ;AACrH,SAAK,cAAc,cAAc,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AACrH,SAAK,cAAc,WAAW,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAClH,SAAK,cAAc,qBAAqB,sCAAsC,OAAO,MAAM,yBAAyB,QAAQ;AAC5H,SAAK,cAAc,gBAAgB,sCAAsC,QAAQ,MAAM,yBAAyB,QAAQ;AACxH,SAAK,cACD,cACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA8C,iBAAiB,iBAAiB,CAAC;AAEnJ,SAAK,cACD,aACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,aAAa,MAAI,GAA8C,gBAAgB,gBAAgB,CAAC;AAEhJ,SAAK,cACD,SACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,SAAS,MAAI,GAA8C,YAAY,YAAY,CAAC;AAEpI,SAAK,cACD,cACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA8C,iBAAiB,iBAAiB,CAAC;AAEnJ,SAAK,cACD,cACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,cAAc,MAAI,GAA8C,iBAAiB,iBAAiB,CAAC;AAEnJ,SAAK,cACD,eACA,sCAAsC,QACtC,MACA,yBAAyB,UACzB,IAAI,wCAAwC,eAAe,MAAI,GAA8C,kBAAkB,kBAAkB,CAAC;AAGtJ,SAAK,eAAe,cAAc,sCAAsC,QAAQ,yBAAyB,QAAQ;AACjH,SAAK,eAAe,cAAc,sCAAsC,QAAQ,yBAAyB,QAAQ;AACjH,SAAK,eAAe,eAAe,sCAAsC,QAAQ,yBAAyB,QAAQ;AAClH,SAAK,eAAe,gBAAgB,sCAAsC,QAAQ,yBAAyB,QAAQ;AACnH,SAAK,eAAe,YAAY,sCAAsC,QAAQ,yBAAyB,QAAQ;AAC/G,SAAK,eAAe,cAAc,sCAAsC,QAAQ,yBAAyB,QAAQ;AACjH,SAAK,eAAe,eAAe,sCAAsC,QAAQ,yBAAyB,QAAQ;AAClH,SAAK,eAAe,gBAAgB,sCAAsC,QAAQ,yBAAyB,QAAQ;AACnH,SAAK,eAAe,YAAY,sCAAsC,QAAQ,yBAAyB,QAAQ;AAC/G,SAAK,eAAe,cAAc,sCAAsC,QAAQ,yBAAyB,QAAQ;AACjH,SAAK,eAAe,YAAY,sCAAsC,QAAQ,yBAAyB,QAAQ;AAC/G,SAAK,eAAe,UAAU,sCAAsC,OAAO,yBAAyB,QAAQ;AAC5G,SAAK,eAAe,SAAS,sCAAsC,OAAO,yBAAyB,QAAQ;EAC/G;;;;;EAuOgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,oBAAoB;AAE/C,UAAM,qBAAqB,kBAAkB;AAC7C,UAAM,qBAAqB,SAAS;AACpC,UAAM,qBAAqB,YAAY;AAEvC,UAAM,qBAAqB,kBAAkB;AAC7C,UAAM,qBAAqB,eAAe;AAC1C,UAAM,qBAAqB,OAAO;AAElC,UAAM,qBAAqB,OAAO;AAElC,UAAM,qBAAqB,WAAW;AACtC,UAAM,qBAAqB,iBAAiB;AAC5C,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,WAAW;AACtC,UAAM,qBAAqB,oBAAoB;AAE/C,UAAM,qBAAqB,gBAAgB;AAC3C,UAAM,qBAAqB,OAAO;AAClC,UAAM,qBAAqB,QAAQ;AACnC,UAAM,qBAAqB,oBAAoB;AAC/C,UAAM,qBAAqB,iBAAiB;AAC5C,UAAM,qBAAqB,mBAAmB;AAC9C,UAAM,qBAAqB,KAAK;AAChC,UAAM,qBAAqB,KAAK;AAEhC,UAAM,qBAAqB,qBAAqB;AAChD,UAAM,qBAAqB,kBAAkB;AAC7C,UAAM,qBAAqB,uBAAuB;AAElD,UAAM,qBAAqB,aAAa;AACxC,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,SAAS;AACpC,UAAM,qBAAqB,MAAM;AACjC,UAAM,qBAAqB,QAAQ;AAEnC,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,cAAc;AACzC,UAAM,qBAAqB,kCAAkC;AAE7D,UAAM,qBAAqB,YAAY;AAEvC,UAAM,qBAAqB,oBAAoB;AAC/C,UAAM,qBAAqB,YAAY;AACvC,UAAM,qBAAqB,YAAY;AAGvC,SAAK,uBAAuB,MAAM,cAAc;EACpD;EAEQ,MAAM,uBAAuB,gBAA8B;AAC/D,SAAK,eAAe;AACpB,QAAI,mBAAc,GAA0B;AACxC,YAAM,QAAQ,IAAI,CAAC,OAAO,0BAAuC,GAAA,OAAO,4BAA0C,CAAA,CAAA;IACtH,OAAO;AACH,YAAM,QAAQ,IAAI,CAAC,OAAO,0BAAmC,GAAA,OAAO,4BAAsC,CAAA,CAAA;IAC9G;AAEA,SAAK,eAAe;AACpB,SAAK,wBAAwB,gBAAgB,IAAI;EACrD;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,oBAAiB;AACxB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,QAAQ,EAAE;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,SAAS,EAAE;EAC3B;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,EAAE;EAC3B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,EAAE;EAC3B;EAEgB,cAAc,UAAwB,0BAAgE,MAAM,MAAI;AAC5H,QAAI,CAAC,KAAK,eAAe,aAAa;AAClC,UAAI,sBAAsB,SAAS,yBAAyB,CAAC,MAAM,EAAE,gBAAgB,yBAAyB,kBAAkB,wBAAwB,CAAC,CAAC;AAE1J,UAAI,CAAC,qBAAqB;AACtB,8BAAsB,IAAI,WAAW,gBAAgB;AACrD,4BAAoB,iBAAiB,yBAAyB,cAAc;MAChF;AACA,0BAAoB,OAAO,UAAU,KAAK,cAAc;IAC5D;AAEA,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,UAAI,YAAY,SAAS,yBAAyB,CAAC,MAAM,EAAE,gBAAgB,yBAAyB,QAAQ,wBAAwB,CAAC,CAAC;AAEtI,UAAI,CAAC,WAAW;AACZ,oBAAY,IAAI,WAAW,MAAM;AACjC,kBAAU,iBAAiB,yBAAyB,IAAI;MAC5D;AACA,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;EACJ;EAEgB,eAAe,SAA8B,cAA4B,MAAmB;AACxG,QAAI,CAAC,MAAM;AACP;IACJ;AAGA,YAAQ,SAAS,OAAO,IAAI;AAC5B,YAAQ,SAAS,oBAAoB,IAAI;AACzC,YAAQ,SAAS,aAAa,KAAK,WAAW,IAAI;AAClD,YAAQ,SAAS,yBAAyB,IAAI;AAC9C,YAAQ,SAAS,iBAAiB,IAAI;AACtC,YAAQ,SAAS,QAAQ,KAAK,gBAAgB,aAAa,IAAI;AAC/D,YAAQ,SAAS,wBAAwB,KAAK,OAAO,UAAS,EAAG,QAAO,EAAG,UAAU;AAGrF,YAAQ,SAAS,UAAU,OAAO,IAAI;AACtC,YAAQ,SAAS,WAAW,KAAK,QAAQ,aAAa,IAAI;AAG1D,YAAQ,SAAS,WAAW,MAAM,IAAI;AACtC,YAAQ,SAAS,sBAAsB,OAAO,IAAI;AAGlD,YAAQ,SAAS,gBAAgB,OAAO,IAAI;AAC5C,YAAQ,SAAS,wBAAwB,OAAO,IAAI;AACpD,YAAQ,SAAS,iCAAiC,OAAO,IAAI;AAC7D,YAAQ,SAAS,iCAAiC,OAAO,IAAI;AAC7D,YAAQ,SAAS,iCAAiC,OAAO,IAAI;AAG7D,QAAI,KAAK,iBAAiB,gBAAgB,uBAAuB;AAC7D,cAAQ,SAAS,2BAA2B,KAAK;AACjD,cAAQ,SAAS,uBAAuB,KAAK;IACjD,WAAW,KAAK,iBAAiB,gBAAgB,mBAAmB;AAChE,cAAQ,SAAS,2BAA2B,KAAK;AACjD,cAAQ,SAAS,uBAAuB,IAAI;IAChD,OAAO;AACH,cAAQ,SAAS,2BAA2B,IAAI;AAChD,cAAQ,SAAS,uBAAuB,KAAK;IACjD;AAGA,UAAM,wBAAwB,KAAK,gBAAgB,SAAQ;AAE3D,YAAQ,SAAS,cAAc,KAAK,kBAAkB,IAAI;AAC1D,YAAQ,SAAS,mBAAmB,OAAO,IAAI;AAC/C,YAAQ,SAAS,aAAa,KAAK,cAAc,IAAI;AACrD,YAAQ,SAAS,kBAAkB,sBAAsB,QAAQ,GAAG,IAAI,IAAI,wBAAwB,MAAM,uBAAuB,IAAI;AACrI,YAAQ,SAAS,cAAc,OAAO,IAAI;AAG1C,YAAQ,SAAS,qBAAqB,KAAK,sBAAsB,IAAI;AACrE,YAAQ,SAAS,qBAAqB,KAAK,sBAAsB,IAAI;AACrE,YAAQ,SAAS,cAAc,KAAK,OAAO,UAAS,EAAG,QAAO,EAAG,uBAAuB,KAAK,4BAA4B,IAAI;AAC7H,YAAQ,SAAS,sBAAsB,KAAK,mBAAmB,IAAI;AAEnE,UAAM,QAAQ,KAAK,SAAQ;AAC3B,UAAM,SAAS,MAAM,UAAS;AAE9B,QAAI,OAAO,UAAU,iCAAiC;AAClD,cAAQ,SAAS,eAAe,KAAK,2BAA2B,KAAK,IAAI;IAC7E,OAAO;AACH,cAAQ,SAAS,eAAe,KAAK,KAAK,0BAA0B,IAAI;IAC5E;AAEA,YAAQ,SAAS,sBAAsB,KAAK,kBAAkB,IAAI;AAGlE,YAAQ,SAAS,4BAA4B,IAAI;AACjD,YAAQ,SAAS,uCAAuC,IAAI;AAC5D,YAAQ,SAAS,+BAA+B,KAAK,uBAAuB,IAAI;AAChF,YAAQ,SAAS,qBAAqB,KAAK,sBAAsB,IAAI;AACrE,YAAQ,SAAS,oBAAoB,KAAK,qBAAqB,IAAI;AACnE,YAAQ,SAAS,SAAS,KAAK,OAAO,IAAI;AAC1C,YAAQ,SAAS,sBAAsB,KAAK,oBAAoB,IAAI;AAEpE,QAAI,KAAK,2BAA2B,cAAc,0BAA0B;AACxE,cAAQ,SAAS,mBAAmB,IAAI;AACxC,cAAQ,SAAS,wBAAwB,KAAK,wBAAwB,QAAQ,IAAI;IACtF,OAAO;AACH,cAAQ,SAAS,mBAAmB,KAAK;AACzC,cAAQ,SAAS,wBAAwB,KAAK;IAClD;AAEA,QAAI,QAAQ,4BAA4B,aAAa,8BAA8B;AAC/E,mBAAa,6BAA6B,eAAe,OAAO;IACpE;AAEA,QAAI,CAAC,QAAQ,iBAAiB;AAC1B;IACJ;AAEA,QAAI,CAAC,KAAK,OAAO;AAEb,8BAAwB,OAAO,MAAM,SAAS,MAAM,aAAa,qBAAqB;AACtF,cAAQ,eAAe;AAGvB,iCAA2B,OAAO,OAAO;IAC7C,OAAO;AACH,YAAM,QAAQ;QACV,aAAa;QACb,aAAa;QACb,cAAc;QACd,eAAe;QACf,iBAAiB;;AAGrB,6BAAuB,OAAO,MAAM,KAAK,OAAO,KAAK,UAAU,SAAS,MAAM,KAAK;AAEnF,UAAI,MAAM,aAAa;AACnB,gBAAQ,QAAO;MACnB;IACJ;EACJ;EAEgB,yBAAyB,OAA+B,cAA4B,SAA8B,gBAAwB;AACtJ,aAAS,aAAa,GAAG,aAAa,aAAa,uBAAuB,cAAc;AACpF,UAAI,CAAC,QAAQ,UAAU,UAAU,GAAG;AAChC;MACJ;AACA,YAAM,wBAAwB,MAAM,SAAS,QAAQ,eAAe,UAAU,KAAK;AACnF,yCACI,YACA,MAAM,UACN,MAAM,UACN,QAAQ,0BAA0B,UAAU,GAC5C,gBACA,uBACA,QAAQ,oBAAoB,UAAU,GACtC,QAAQ,eAAe,UAAU,CAAC;IAE1C;EACJ;EAEgB,QAAQ,MAAoB,cAA4B,SAA4B;AAChG,QAAI,KAAK,2BAA2B,CAAC,KAAK,wBAAwB,QAAO,GAAI;AACzE,aAAO;IACX;AAEA,QAAI,QAAQ,4BAA4B,aAAa,8BAA8B;AAC/E,UAAI,CAAC,aAAa,6BAA6B,QAAO,GAAI;AACtD,eAAO;MACX;IACJ;AAEA,WAAO;EACX;EAEgB,KAAK,QAAgB,cAA4B,MAAW;AACxE,QAAI,CAAC,MAAM;AACP;IACJ;AAEA,UAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAI,CAAC,KAAK,OAAO;AACb,iBAAW,OAAO,MAAM,QAAQ,MAAM,aAAa,qBAAqB;IAC5E,OAAO;AACH,gBAAU,KAAK,OAAO,KAAK,UAAU,OAAO,QAAQ,IAAI;IAC5D;AAEA,WAAO,WAAW,KAAK,6BAA6B,KAAK,uBAAuB;AAEhF,WAAO,UAAU,cAAc,KAAK,YAAY,KAAK,WAAW;AAEhE,UAAM,eAAe,KAAK,OAAO;AAEjC,QAAI,cAAc;AACd,aAAO,UAAU,oBAAoB,YAAY;IACrD;AAEA,UAAM,eAAe,MAAM,0BAA0B,MAAM,2BAA2B;AAEtF,WAAO,SAAS,KAAK,mBAAmB,eAAe,KAAK,CAAC;AAE7D,WAAO,UAAU,sBAAsB,KAAK,iBAAiB,GAAG,KAAK,uBAAuB,KAAK,OAAO,sBAAsB,KAAK,iBAAiB;AAGpJ,UAAM,cAAc,KAAK;AAEzB,WAAO,UAAU,KAAK,kCAAkC,KAAK,2BAA2B,WAAW;AAEnG,QAAI,aAAa,8BAA8B;AAC3C,mBAAa,6BAA6B,KAAK,MAAM;IACzD;EACJ;EAEQ,kBAAkB,OAA6B;AACnD,UAAM,WAAW,KAAK;AACtB,UAAM,cAAc,KAAK;AACzB,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,WAAW,MAAM,mBAAc;AAGrC,QAAI,CAAC,KAAK,OAAO;AAEb,YAAM,yBAAyB,MAAM,wBAAwB,0BAA0B,8BAA8B,UAAU;QAC3H,WAAW;OACd;AACD,WAAK,WAAW;AAEhB,YAAM,WAAW,qBAAqB,KAAK,IAAI;IACnD,OAAO;AACH,WAAK,YAAY,MAAM,SAAS,cAAc,MAAM,SAAY,MAAM,SAAS,cAAc,IAAI,MAAM;AACvG,YAAM,SAAS,cAAc,IAAI,KAAK;AAEtC,YAAM,yBACF,MAAM,wBAAwB,0BAA0B,8BACxD,UACA;QACI,gBAAgB,CAAC,EAAE,QAAQ,QAAQ,SAAS,KAAK,SAAS,SAAQ,EAAE,CAAE;SAE1E,KAAK,SAAS,SAAQ,CAAE;IAEhC;AAGA,UAAM,sBAAsB,OAAO,SAAS;AAC5C,QAAI,MAAM,uBAAuB,qBAAqB,sCAAsC,OAAO,GAAG;AAClG,YAAM,sBAAsB,WAAW,mBAAmB,MAAM,GAAG,mBAAmB,MAAM,SAAS,sBAAsB;;IAC/H;AAEA,UAAM,yBAAyB,OAAO,YAAY;AAClD,QAAI,MAAM,uBAAuB,wBAAwB,sCAAsC,OAAO,GAAG;AACrG,YAAM,sBAAsB,WAAW,mBAAmB,MAAM,GAAG,sBAAsB,MAAM,YAAY,sBAAsB;;IACrI;AAEA,UAAM,kBAAkB,KAAK,WAAW,cAAe,KAAK,WAAW,gBAAgB,aAAiC;AAExH,QAAI,iBAAiB;AACjB,sBAAgB,sBAAsB,KAAK;IAC/C;AAEA,UAAM,qBAAqB,iBAAiB,iBAAiB,KAAK,KAAK;AAEvE,QAAI,MAAM,uBAAuB,sBAAsB,sCAAsC,SAAS,kCAAkC,GAAG;AACvI,YAAM,gBAAgB;;AACtB,YAAM,iBAAiB,WAAW,mBAAmB,MAAM,wBAAwB,WAAW,2BAA2B,aAAa;;AACtI,YAAM,gBAAgB;;IAC1B;AAEA,QAAI,KAAK,OAAO;AACZ,YAAM,qBAAqB,MAAM,qBAAqB,iBAAiB,UAAU;QAC7E,gBAAgB;UACZ,EAAE,QAAQ,QAAQ,SAAS,KAAK,SAAS,SAAQ,EAAE;UACnD,EAAE,QAAQ,aAAa,SAAS,SAAS,uBAAsB;;OAEtE;IACL,OAAO;AACH,YAAM,qBAAqB,GAAG,MAAM,iBAAiB,YAAY,sCAAsC,OAAO,CAAC,MAAM,SAAS,sBAAsB;;AACpJ,UAAI,KAAK,KAAK,aAAa;AACvB,cAAM,qBAAqB,GAAG,MAAM,iBAAiB,QAAQ,sCAAsC,MAAM,CAAC,MAAM,KAAK,KAAK,sBAAsB;;AAChJ,cAAM,uBAAuB,cAAc,sCAAsC,KAAK;AACtF,cAAM,sBACD,MAAM,mBAAc,IAA2B,mBAAmB,MACnE,iBAAiB,KAAK,KAAK,sBAAsB,MAAM,SAAS,sBAAsB;;MAC9F;AACA,YAAM,qBAAqB,MAAM,qBAAqB,iBAAiB,UAAU;QAC7E,WAAW;OACd;IACL;EACJ;EAEQ,sBAAsB,OAA6B;AACvD,UAAM,WAAW,MAAM,mBAAc;AAErC,QAAI,OAAO,WAAW,oDAAoD;;AAE1E,UAAM,cAAc,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AACzF,UAAM,UAAU,KAAK,QAAQ,cAAc,KAAK,QAAQ,yBAAyB;AAEjF,YAAQ;sBACM,MAAM,OAAO,IAAI,WAAW;;uBAE3B,MAAM,OAAO;uBACb,MAAM,OAAO;;;;uBAIb,MAAM,OAAO,IAAI,OAAO;uBACxB,MAAM,OAAO;;;;cAItB,MAAM,iBAAiB,iBAAiB,sCAAsC,OAAO,CAAC;cACtF,MAAM,iBAAiB,SAAS,sCAAsC,KAAK,CAAC;;AAElF,WAAO;EACX;EAEQ,yBAAyB,OAA6B;AAC1D,UAAM,WAAW,MAAM,mBAAc;AACrC,QAAI,OAAO,WAAW,4CAA4C;;AAElE,UAAM,KAAK,KAAK,WAAW,cAAc,KAAK,WAAW,yBAAyB;AAElF,YAAQ;;sBAEM,MAAM,OAAO,IAAI,EAAE;sBACnB,MAAM,OAAO;;;;AAI3B,WAAO;EACX;EAEQ,qBAAqB,OAA6B;AACtD,UAAM,WAAW,MAAM,mBAAc;AACrC,QAAI,OAAO,WAAW,kDAAkD;;AACxE,UAAM,cAAc;AAEpB,SAAK,mCAAmC,MAAM,qBAAqB,6BAA6B;AAChG,UAAM,uBAAuB,KAAK,kCAAkC,sCAAsC,OAAO;AAEjH,SAAK,4BAA4B,MAAM,qBAAqB,sBAAsB;AAClF,UAAM,uBAAuB,KAAK,2BAA2B,sCAAsC,KAAK;AAExG,UAAM,aAAa;AACnB,UAAM,MAAM,KAAK,kBAAkB,mBAAmB,SAAS;AAG/D,UAAM,KAAK,KAAK,KAAK,MAAM,eAAe,MAAM,aAAa,CAAC;AAE9D,YAAQ,GAAG,MAAM,iBAAiB,aAAa,sCAAsC,OAAO,CAAC;cACvF,WAAW,QAAQ,OAAO,MAAM,OAAO,EAAE,6BAA6B,MAAM,OAAO,IAAI,KAAK,SAAS,sBAAsB,KAAK,KAAK,UAAU,sBAAsB,KAAK,KAAK,kBAAkB,0BAA0B,KAAK,KAAK,EAAE;;;;;qBAKhO,WAAW,cAAc,MAAM,KAAK,gCAAgC;;qBAEpE,WAAW,cAAc,MAAM,KAAK,yBAAyB;;;wBAG1D,MAAM,OAAO;;;wBAGb,MAAM,OAAO,YAAY,WAAW;wBACpC,MAAM,OAAO;;;;;;;;;;cAUvB,MAAM,iBAAiB,gBAAgB,sCAAsC,KAAK,CAAC;cACnF,MAAM,iBAAiB,aAAa,sCAAsC,KAAK,CAAC;cAChF,MAAM,iBAAiB,oBAAoB,sCAAsC,KAAK,CAAC;;;;;;;;;AAS7F,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,SAAK,SAAS,MAAM,WAAW;AAC/B,UAAM,WAAW,MAAM,mBAAc;AAErC,QAAI,CAAC,KAAK,yBAAyB;AAC/B,WAAK,0BAA0B,0BAA0B,KAAK,MAAM;IACxE;AAEA,UAAM,kBAAkB,KAAK,WAAW,cAAe,KAAK,WAAW,gBAAgB,aAAiC;AAExH,QAAI,iBAAiB;AAEjB,sBAAgB,+BAA+B,KAAK;AACpD,sBAAgB,gCAAgC,KAAK;AACrD,sBAAgB,6BAA6B,KAAK;AAClD,sBAAgB,sBAAsB,KAAK;IAC/C;AAEA,QAAI,MAAM,WAAW,yBAAyB,UAAU;AAEpD,WAAK,kBAAkB,KAAK;AAE5B,aAAO;IACX;AAGA,UAAM,WAAW,qBAAqB,KAAK,IAAI;AAC/C,UAAM,WAAW,kBAAkB,KAAK,IAAI;AAC5C,UAAM,WAAW,eAAe,KAAK,IAAI;AACzC,QAAI,KAAK,0BAA0B;AAC/B,YAAM,WAAW,qBAAqB,KAAK,IAAI;IACnD;AAEA,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,gBAAgB,KAAK;AAE3B,QAAI,kBAAkB,KAAK,cAAc;AACzC,QAAI,mBAAmB,KAAK,cAAc;AAC1C,QAAI,qBAAqB,KAAK,YAAY;AAC1C,QAAI,KAAK,0BAA0B;AAC/B,wBAAkB,MAAM,qBAAqB,gBAAgB;AAC7D,YAAM,cAAc,sBAAsB,GAAG,MAAM,iBAAiB,iBAAiB,sCAAsC,SAAS,OAAO,IAAI,CAAC;GAAO,QAAQ;AAC/J,YAAM,qBAAqB,GAAG,eAAe,MAAM,KAAK,cAAc,sBAAsB;;AAE5F,yBAAmB,MAAM,qBAAqB,iBAAiB;AAC/D,YAAM,cAAc,uBAAuB,GAAG,MAAM,iBAAiB,kBAAkB,sCAAsC,SAAS,OAAO,IAAI,CAAC;GAAO,QAAQ;AACjK,YAAM,qBAAqB,GAAG,gBAAgB,MAAM,KAAK,cAAc,sBAAsB;;AAE7F,2BAAqB,MAAM,qBAAqB,mBAAmB;AACnE,YAAM,cAAc,uBAAuB,GAAG,MAAM,iBAAiB,oBAAoB,sCAAsC,SAAS,OAAO,IAAI,CAAC;GAAO,QAAQ;AACnK,YAAM,qBAAqB,GAAG,kBAAkB,MAAM,KAAK,YAAY,sBAAsB;;AAE7F,YAAM,qBAAqB,MAAM,qBAAqB,iBAAiB,UAAU;QAC7E,WAAW;QACX,kBAAkB,YAAY,KAAK,cAAc,sBAAsB;OAC1E;AAED,YAAM,qBAAqB;;AAC3B,YAAM,qBAAqB,GAAG,MAAM,iBAAiB,sBAAsB,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO,SAAS,MAAM,OAAO,IAAI,WAAW,4BAA4B,iBAAiB,WAAW,MAAM,OAAO;;AAC1P,YAAM,qBAAqB;;IAC/B,OAAO;AACH,yBAAmB,WAAW,WAAW,MAAM,OAAO;AACtD,4BAAsB,WAAW,WAAW,MAAM,OAAO;IAC7D;AAEA,SAAK,8BAA8B,MAAM,qBAAqB,wBAAwB;AAEtF,UAAM,eAAe,KAAK,2BAA2B;AAErD,UAAM,WAAW,MAAM,oBAAoB,MAAM,WAAW,MAAM,qBAAqB,KAAK;AAC5F,UAAM,WAAW,MAAM,mBAAmB,MAAM,WAAW,MAAM,oBAAoB,KAAK;AAE1F,UAAM,eAAe,OAAO,iDAAiD,+BAA+B;AAC5G,UAAM,eAAe,eAAe,iDAAiD;AAErF,UAAM,uBAAuB,cAAc,sCAAsC,SAAS,kCAAkC;AAC5H,UAAM,uBAAuB,oBAAoB,sCAAsC,OAAO;AAG9F,UAAM,SAAS,KAAK,gBAAgB;AACpC,UAAM,SAAS,KAAK,UAAU;AAC9B,UAAM,SAAS,KAAK,oBAAoB;AACxC,UAAM,SAAS,KAAK,mBAAmB;AACvC,UAAM,SAAS,KAAK,mBAAmB;AACvC,UAAM,SAAS,KAAK,2BAA2B;AAC/C,UAAM,SAAS,KAAK,0BAA0B;AAC9C,UAAM,SAAS,KAAK,2BAA2B;AAC/C,UAAM,SAAS,KAAK,kBAAkB;AACtC,UAAM,SAAS,KAAK,wBAAwB;AAC5C,UAAM,SAAS,KAAK,iBAAiB;AAKrC,QAAI,CAAC,KAAK,OAAO;AACb,UAAI,KAAK,4BAA4B,KAAK,KAAK,aAAa;AACxD,cAAM,qBAAqB,GAAG,MAAM,iBAAiB,cAAc,sCAAsC,KAAK,CAAC,OAAO,KAAK,KAAK,sBAAsB,MAAM,gBAAgB;;MAChL;AAGA,YAAM,yBAAyB,MAAM,wBAAwB,wBAAwB,4BAA4B,UAAU;QACvH,WAAW;QACX,kBAAkB,KAAK,2BAA2B,aAAa;OAClE;IACL,OAAO;AACH,YAAM,yBACF,MAAM,wBAAwB,wBAAwB,4BACtD,UACA;QACI,gBAAgB,CAAC,EAAE,QAAQ,QAAQ,SAAS,KAAK,SAAS,SAAQ,EAAE,CAAE;SAE1E,KAAK,SAAS,SAAQ,CAAE;IAEhC;AAEA,UAAM,yBAAyB,mBAAmB,QAAQ;AAC1D,UAAM,yBAAyB,sBAAsB,QAAQ;AAC7D,UAAM,yBAAyB,sBAAsB,QAAQ;AAC7D,UAAM,yBAAyB,8BAA8B,QAAQ;AACrE,UAAM,yBAAyB,4BAA4B,QAAQ;AAEnE,UAAM,yBAAyB,4BAA4B,QAAQ;AAEnE,UAAM,yBAAyB,mCAAmC,QAAQ;AAE1E,UAAM,yBAAyB,qCAAqC,QAAQ;AAC5E,UAAM,yBAAyB,oBAAoB,UAAU;MACzD,gBAAgB,CAAC,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB,CAAE;KAC9H;AACD,UAAM,yBAAyB,yBAAyB,QAAQ;AAEhE,UAAM,yBAAyB,8BAA8B,QAAQ;AAErE,UAAM,yBAAyB,mBAAmB,QAAQ;AAE1D,UAAM,yBAAyB,yBAAyB,QAAQ;AAChE,UAAM,yBAAyB,wBAAwB,QAAQ;AAC/D,UAAM,yBAAyB,4BAA4B,QAAQ;AACnE,UAAM,yBAAyB,wBAAwB,QAAQ;AAC/D,UAAM,yBAAyB,uBAAuB,QAAQ;AAE9D,QAAI,CAAC,UAAU;AAEX,YAAM,yBAAyB,iCAAiC,QAAQ;IAC5E;AAMA,UAAM,uBAAuB,sBAAsB,sCAAsC,OAAO;AAEhG,QAAI,iBAAiB,0BAA0B;AAC3C,YAAM,qBAAqB,gBAAgB,iBAAiB,KAAK;IACrE;AAGA,SAAK,gBAAgB,MAAM,qBAAqB,UAAU;AAE1D,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,KAAK,eAAe,sCAAsC,OAAO,CAAC,gBAAgB,kBAAkB;;AAEzJ,QAAI,MAAM,sBAAsB,gBAAgB,GAAG;AAC/C,YAAM,qBAAqB,GAAG,MAAM,iBAAiB,kBAAkB,sCAAsC,OAAO,CAAC,gBAAgB,KAAK,eAAe,sBAAsB,MAAM,eAAe;;IACxM;AAEA,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,oBAAoB,sCAAsC,OAAO,CAAC,MAAM,KAAK,aAAa;;AAE/I,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,WAAW,sCAAsC,OAAO,CAAC,MAAM,cAAc,cAAc,eAAe,cAAc,yBAAyB,UAAU,kBAAkB;;AAElO,SAAK,oBAAoB,MAAM,qBAAqB,cAAc;AAElE,UAAM,uBAAuB,KAAK,mBAAmB,sCAAsC,KAAK;AAEhG,UAAM,qBAAqB,MAAM,qBAAqB,uBAAuB,UAAU;MACnF,gBAAgB;QACZ,EAAE,QAAQ,eAAe,SAAS,kBAAkB,OAAM;QAC1D,EAAE,QAAQ,mBAAmB,SAAS,KAAK,kBAAiB;;KAEnE;AAGD,UAAM,qBAAqB,KAAK,sBAAsB,KAAK;AAE3D,UAAM,qBAAqB,MAAM,qBAAqB,gBAAgB,QAAQ;AAG9E,UAAM,qBAAqB,KAAK,yBAAyB,KAAK;AAE9D,UAAM,qBAAqB,MAAM,qBAAqB,wBAAwB,QAAQ;AAGtF,UAAM,qBAAqB;kBACjB,MAAM,iBAAiB,eAAe,sCAAsC,OAAO,CAAC,UAAU,MAAM,OAAO;;;AAIrH,UAAM,qBAAqB,KAAK,qBAAqB,KAAK;AAG1D,UAAM,qBAAqB,MAAM,qBAAqB,wBAAwB,UAAU;MACpF,gBAAgB;QACZ,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB;QACxG,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;;KAEnG;AAGD,UAAM,kBAAkB,KAAK,WAAW,cAAe,KAAK,WAAW,gBAAgB,aAAiC;AAExH,QAAI,iBAAiB;AACjB,sBAAgB,+BAA+B,KAAK;AACpD,sBAAgB,6BAA6B,KAAK;AAElD,YAAM,qBAAqB,gBAAgB,QAAQ,OAAO,CAAC,KAAK,gBAAgB,WAAW;IAC/F;AAGA,QAAI,mBAAmB,gBAAgB,YAAY;AAC/C,YAAM,qBAAqB,gBAAgB,QAAQ,OAAO,kBAAkB,qCAAqC,SAAS;IAC9H;AAEA,UAAM,yBAAyB,sBAAsB,UAAU;MAC3D,gBAAgB;QACZ,EAAE,QAAQ,4BAA4B,SAAS,6BAA4B;QAC3E,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;QAC5F,EAAE,QAAQ,4BAA4B,SAAS,iBAAiB,oBAAoB,0BAAyB;QAC7G,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,yBAAyB,2BAA0B;QACpH,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB;QACxG,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,6BAA6B,uBAAsB;QAChH,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,mCAAmC,2BAA0B;QAC9H,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,iCAAiC,2BAA0B;;KAEnI;AAGD,UAAM,qBAAqB,MAAM,qBAAqB,wBAAwB,UAAU;MACpF,gBAAgB,CAAC,EAAE,QAAQ,+BAA+B,UAAU,WAAW,cAAc,MAAM,KAAK,iCAAgC,CAAE;KAC7I;AAED,UAAM,aAAa,KAAK,MAAM,cAAe,KAAK,MAAM,gBAAgB,aAA4B;AAEpG,QAAI,YAAY;AACZ,YAAM,qBAAqB,WAAW,QAAQ,iBAAiB,KAAK;IACxE;AAEA,UAAM,yBAAyB,iBAAiB,UAAU;MACtD,gBAAgB;QACZ,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;QAC5F,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB;QACxG,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,6BAA6B,uBAAsB;QAChH,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,mCAAmC,2BAA0B;;KAErI;AAGD,UAAM,iBAAiB,KAAK,UAAU,cAAe,KAAK,UAAU,gBAAgB,aAAgC;AAEpH,UAAM,qBAAqB,eAAe,uBAAuB,OAAO,cAAc;AAGtF,UAAM,mBAAmB,KAAK,YAAY,cAAe,KAAK,YAAY,gBAAgB,aAAkC;AAC5H,UAAM,qBAAqB,iBAAiB,QAAQ,kBAAkB,KAAK;AAE3E,UAAM,yBAAyB,uBAAuB,UAAU;MAC5D,gBAAgB,CAAA;KACnB;AAGD,UAAM,mBAAmB,CAAC,KAAK,gBAAgB,eAAe,CAAC,KAAK,WAAW;AAC/E,UAAM,oCACF,KAAK,gBAAgB,gBAAgB,KAAK,gBAAgB,gBAAgB,YAAkC,cAAc;AAC9H,UAAM,iCAAiC,KAAK,WAAW,gBAAgB,KAAK,WAAW,gBAAgB,YAA+B,aAAa;AACnJ,QAAI,gBAAgB,qCAAsC,CAAC,KAAK,gBAAgB,eAAe;AAE/F,UAAM,qBAAqB,eAAe,QAAQ,OAAO,gBAAgB,iBAAiB,iBAAiB,kBAAkB,eAAe,kBAAkB;AAE9J,QAAI,kBAAkB;AAClB,sBAAgB,gBAAgB,aAAa,eAAe;IAChE;AAEA,UAAM,yBAAyB,qBAAqB,UAAU;MAC1D,gBAAgB;QACZ,EAAE,QAAQ,4BAA4B,SAAS,6BAA4B;QAC3E,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;QAC5F,EAAE,QAAQ,4BAA4B,SAAS,iBAAiB,oBAAoB,0BAAyB;QAC7G,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,yBAAyB,2BAA0B;QACpH,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB;QACxG,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,6BAA6B,uBAAsB;QAChH,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,mCAAmC,2BAA0B;QAC9H,EAAE,QAAQ,uBAAuB,SAAS,gBAAgB,qBAAqB,kBAAiB;;KAEvG;AAGD,UAAM,qBAAqB,MAAM,qBAAqB,uBAAuB,UAAU;MACnF,gBAAgB;QACZ,EAAE,QAAQ,yBAAyB,SAAS,iBAAiB,qBAAqB,uBAAsB;QACxG,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;QAC5F,EAAE,QAAQ,iCAAiC,SAAS,qBAAoB;;KAE/E;AAGD,UAAM,kBAAkB,KAAK,WAAW,cAAe,KAAK,WAAW,gBAAgB,aAAiC;AACxH,UAAM,kBAAkB,KAAK,WAAW,eAChC,KAAK,WAAW,gBAAgB,YAA+B,WAAW,gBAAgB,aAC5F;AAEN,QAAI,iBAAiB;AACjB,sBAAgB,sBAAsB,KAAK;AAC3C,sBAAgB,mCAAmC,KAAK;IAC5D;AAEA,UAAM,qBAAqB,gBAAgB,QAAQ,OAAO,iBAAiB,iBAAiB,eAAe;AAE3G,UAAM,yBAAyB,sBAAsB,UAAU;MAC3D,gBAAgB;QACZ,EAAE,QAAQ,qBAAqB,SAAS,iBAAiB,iBAAiB,mBAAkB;QAC5F,EAAE,QAAQ,4BAA4B,SAAS,iBAAiB,oBAAoB,0BAAyB;QAC7G,EAAE,QAAQ,6BAA6B,SAAS,iBAAiB,yBAAyB,2BAA0B;QACpH,EAAE,QAAQ,wBAAwB,SAAS,iBAAiB,iBAAiB,sBAAqB;QAClG,EAAE,QAAQ,4BAA4B,SAAS,iBAAiB,6BAA6B,0BAAyB;QACtH,EAAE,QAAQ,gCAAgC,SAAS,iBAAiB,mCAAmC,8BAA6B;QACpI,EAAE,QAAQ,+BAA+B,SAAS,iBAAiB,oBAAoB,6BAA4B;;KAE1H;AAGD,UAAM,qBAAqB,MAAM,qBAAqB,0BAA0B,QAAQ;AAExF,QAAI,KAAK,OAAO;AACZ,YAAM,qBAAqB,MAAM,qBAAqB,iBAAiB,UAAU;QAC7E,gBAAgB;UACZ,EAAE,QAAQ,QAAQ,SAAS,KAAK,SAAS,SAAQ,EAAE;UACnD,EAAE,QAAQ,IAAI,OAAO,GAAG,WAAW,oBAAoB,EAAE,cAAc,GAAG,GAAG,SAAS,kBAAkB,OAAM;UAC9G,EAAE,QAAQ,iCAAiC,SAAS,qBAAoB;;OAE/E;IACL,OAAO;AACH,UAAI,mBAAmB,cAAc,eAAe;AAEpD,UAAI,UAAU;AACV,2BAAmB,oBAAoB;AACvC,YAAI,KAAK,0BAA0B;AAC/B,8BAAoB;QACxB;MACJ;AAEA,YAAM,qBAAqB,MAAM,qBAAqB,iBAAiB,UAAU;QAC7E,WAAW;QACX,kBAAkB,mBAAmB;OACxC;IACL;AAGA,UAAM,qBAAqB,MAAM,qBAAqB,8BAA8B,QAAQ;AAG5F,UAAM,qBAAqB;;AAG3B,UAAM,UAAU,KAAK,aAAa,cAAc,KAAK,aAAa,yBAAyB,OAAO,MAAM,OAAO;AAE/G,QAAI,yBAAyB,gBAAgB,gCAAgC,SAAQ;AAErF,QAAI,uBAAuB,QAAQ,GAAG,MAAM,IAAI;AAC5C,gCAA0B;IAC9B;AAEA,QAAI,iBAAiB;MACjB,EAAE,QAAQ,qEAAqE,SAAS,GAAE;MAC1F,EAAE,QAAQ,IAAI,OAAO,GAAG,WAAW,cAAc,EAAE,iBAAiB,GAAG,GAAG,SAAS,UAAU,MAAM,WAAW,cAAc,EAAE,mBAAkB;MAChJ,EAAE,QAAQ,IAAI,OAAO,GAAG,WAAW,cAAc,EAAE,mBAAmB,GAAG,GAAG,SAAS,uBAAsB;;AAG/G,QAAI,UAAU;AACV,qBAAe,CAAC,IAAI,EAAE,QAAQ,6EAA6E,SAAS,GAAE;IAC1H;AAEA,UAAM,qBAAqB,MAAM,qBAAqB,gCAAgC,UAAU;MAC5F;KACH;AAGD,UAAM,qBAAqB,MAAM,qBAAqB,iCAAiC,UAAU;MAC7F,gBAAgB,CAAC,EAAE,QAAQ,kBAAkB,SAAS,OAAO,MAAM,OAAO,OAAM,CAAE;KACrF;AAGD,QAAI,UAAU;AACV,uBAAiB,CAAC,EAAE,QAAQ,oBAAoB,SAAS,KAAI,CAAE;IACnE,OAAO;AACH,uBAAiB,CAAC,EAAE,QAAQ,eAAe,SAAS,KAAI,CAAE;IAC9D;AAEA,UAAM,qBAAqB,MAAM,qBAAqB,2BAA2B,UAAU;MACvF;KACH;AAID,UAAM,cAAc,WAAW,0BAA0B;AACzD,qBAAiB;MACb,EAAE,QAAQ,IAAI,OAAO,GAAG,WAAW,oBAAoB,EAAE,YAAY,GAAG,GAAG,SAAS,KAAK,cAAa;MACtG,EAAE,QAAQ,IAAI,OAAO,GAAG,WAAW,oBAAoB,EAAE,cAAc,GAAG,GAAG,SAAS,gBAAe;MACrG,EAAE,QAAQ,iCAAiC,SAAS,qBAAoB;MACxE;QACI,QAAQ;QACR,SAAS,OAAO,MAAM,OAAO;EAAU,WAAW,uBAAuB,WAAW;;;;AAG5F,UAAM,qBAAqB,MAAM,qBAAqB,YAAY,UAAU;MACxE;KACH;AAGD,eAAW,UAAU,KAAK,UAAU;AAChC,UAAI,OAAO,cAAc;AACrB,cAAM,QAAQ,oBAAoB,OAAO,IAAI;AAC7C,YAAI,OAAO;AACP,gBAAM,CAAC,SAAS,UAAU,IAAI;AAC9B,cAAI,YAAY;AACZ,kBAAM,qBAAqB,OAAO,UAAU;;UAChD;AACA,gBAAM,qBAAqB,GAAG,MAAM,eAAe,MAAM,CAAC,MAAM,OAAO;;AACvE,cAAI,YAAY;AACZ,kBAAM,qBAAqB;;AAC3B,kBAAM,qBAAqB,GAAG,MAAM,eAAe,MAAM,CAAC,UAAU,MAAM,OAAO;;AACjF,kBAAM,qBAAqB;;UAC/B;QACJ,OAAO;AACH,gBAAM,WAAW,gBAAgB,gCAAgC,OAAO,IAAI,+BAA+B;QAC/G;MACJ;IACJ;AAEA,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,kBAAc,GAAG,KAAK,iBAAiB,mBAAmB,KAAK,YAAY;;AAC3E,kBAAc,GAAG,KAAK,iBAAiB,mBAAmB,KAAK,YAAY;;AAC3E,kBAAc,GAAG,KAAK,iBAAiB,sBAAsB,KAAK,eAAe;;AACjF,kBAAc,GAAG,KAAK,iBAAiB,uBAAuB,KAAK,gBAAgB;;AACnF,kBAAc,GAAG,KAAK,iBAAiB,2BAA2B,KAAK,oBAAoB;;AAC3F,kBAAc,GAAG,KAAK,iBAAiB,2BAA2B,KAAK,oBAAoB;;AAC3F,kBAAc,GAAG,KAAK,iBAAiB,iCAAiC,KAAK,0BAA0B;;AACvG,kBAAc,GAAG,KAAK,iBAAiB,wBAAwB,KAAK,iBAAiB;;AACrF,kBAAc,GAAG,KAAK,iBAAiB,+BAA+B,KAAK,wBAAwB;;AACnG,kBAAc,GAAG,KAAK,iBAAiB,4BAA4B,KAAK,qBAAqB;;AAC7F,kBAAc,GAAG,KAAK,iBAAiB,2BAA2B,KAAK,oBAAoB;;AAC3F,kBAAc,GAAG,KAAK,iBAAiB,0BAA0B,KAAK,mBAAmB;;AACzF,kBAAc,GAAG,KAAK,iBAAiB,YAAY,KAAK,KAAK;;AAC7D,kBAAc,GAAG,KAAK,iBAAiB,yBAAyB,KAAK,kBAAkB;;AACvF,kBAAc,GAAG,KAAK,iBAAiB,gBAAgB,KAAK,SAAS;;AACrE,kBAAc,GAAG,KAAK,iBAAiB,iBAAiB,KAAK,UAAU;;AACvE,kBAAc,GAAG,KAAK,iBAAiB,kBAAkB,KAAK,WAAW;;AAEzE,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,QAAI,KAAK,OAAO;AACZ,0BAAoB,UAAU,KAAK,MAAM;IAC7C;AAEA,wBAAoB,eAAe,KAAK;AACxC,wBAAoB,eAAe,KAAK;AACxC,wBAAoB,kBAAkB,KAAK;AAC3C,wBAAoB,mBAAmB,KAAK;AAC5C,wBAAoB,uBAAuB,KAAK;AAChD,wBAAoB,uBAAuB,KAAK;AAChD,wBAAoB,6BAA6B,KAAK;AACtD,wBAAoB,oBAAoB,KAAK;AAC7C,wBAAoB,2BAA2B,KAAK;AACpD,wBAAoB,wBAAwB,KAAK;AACjD,wBAAoB,uBAAuB,KAAK;AAChD,wBAAoB,sBAAsB,KAAK;AAC/C,wBAAoB,QAAQ,KAAK;AACjC,wBAAoB,qBAAqB,KAAK;AAC9C,wBAAoB,YAAY,KAAK;AACrC,wBAAoB,aAAa,KAAK;AACtC,wBAAoB,cAAc,KAAK;AACvC,wBAAoB,2BAA2B,KAAK;AAEpD,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,QAAI,oBAAoB,SAAS;AAC7B,WAAK,QAAQ,MAAM,aAAa,oBAAoB,OAAO;IAC/D;AAEA,SAAK,eAAe,oBAAoB,gBAAgB;AACxD,SAAK,eAAe,oBAAoB;AACxC,SAAK,kBAAkB,oBAAoB;AAC3C,SAAK,mBAAmB,oBAAoB;AAC5C,SAAK,uBAAuB,oBAAoB;AAChD,SAAK,uBAAuB,oBAAoB;AAChD,SAAK,6BAA6B,oBAAoB;AACtD,SAAK,oBAAoB,CAAC,CAAC,oBAAoB;AAC/C,SAAK,2BAA2B,oBAAoB,4BAA4B;AAChF,SAAK,wBAAwB,oBAAoB;AACjD,SAAK,uBAAuB,oBAAoB;AAChD,SAAK,sBAAsB,oBAAoB;AAC/C,SAAK,QAAQ,oBAAoB;AACjC,SAAK,qBAAqB,CAAC,CAAC,oBAAoB;AAChD,SAAK,YAAY,oBAAoB;AACrC,SAAK,aAAa,oBAAoB;AACtC,SAAK,cAAc,oBAAoB;AACvC,SAAK,2BAA2B,CAAC,CAAC,oBAAoB;AAEtD,SAAK,WAAU;EACnB;;AA34CO,WAAA;EADN,uBAAuB,iBAAe,GAAgC,aAAa,EAAE,KAAK,GAAG,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQ5H,WAAA;EADN,uBAAuB,sBAAoB,GAAgC,aAAa,EAAE,KAAK,GAAG,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQjI,WAAA;EADN,uBAAuB,uBAAqB,GAAgC,aAAa,EAAE,KAAK,GAAG,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAelI,WAAA;EARN,uBAAuB,iBAAe,GAA+B,qBAAqB;IACvF,WAAW,EAAE,QAAQ,KAAI;IACzB,SAAS;MACL,EAAE,OAAO,YAAY,OAAO,gBAAgB,sBAAqB;MACjE,EAAE,OAAO,QAAQ,OAAO,gBAAgB,kBAAiB;MACzD,EAAE,OAAO,YAAY,OAAO,gBAAgB,sBAAqB;;GAExE;;AAOM,WAAA;EADN,uBAAuB,iBAAe,GAAkC,SAAS;;AAO3E,WAAA;EADN,uBAAuB,gBAAc,GAAgC,WAAW,EAAE,KAAK,GAAG,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOzH,WAAA;EADN,uBAAuB,kBAAgB,GAAkC,SAAS;;AAQ5E,WAAA;EADN,uBAAuB,uBAAqB,GAAkC,aAAa,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQpH,WAAA;EADN,uBAAuB,uBAAqB,GAAkC,aAAa,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AASpH,WAAA;EADN,uBAAuB,0BAAwB,GAAkC,aAAa,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOvH,WAAA;EADN,uBAAuB,sBAAoB,GAAkC,aAAa,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAcnH,WAAA;EARN,uBAAuB,8BAA4B,GAA+B,aAAa;IAC5F,WAAW,EAAE,QAAQ,KAAI;IACzB,SAAS;MACL,EAAE,OAAO,OAAO,OAAO,EAAA;MACvB,EAAE,OAAO,UAAU,OAAO,GAAA;MAC1B,EAAE,OAAO,QAAQ,OAAO,GAAA;;GAE/B;;AAeM,WAAA;EATN,uBAAuB,iBAAe,GAA+B,aAAa;IAC/E,WAAW,EAAE,QAAQ,KAAI;IACzB,SAAS;MACL,EAAE,OAAO,WAAW,OAAO,EAAA;MAC3B,EAAE,OAAO,UAAU,OAAO,EAAA;MAC1B,EAAE,OAAO,cAAc,OAAO,EAAA;MAC9B,EAAE,OAAO,UAAU,OAAO,EAAA;;GAEjC;;AAOM,WAAA;EADN,uBAAuB,uBAAqB,GAAkC,YAAY,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQnH,WAAA;EADN,uBAAuB,sBAAoB,GAAkC,YAAY,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQlH,WAAA;EADN,uBAAuB,qBAAmB,GAAkC,YAAY,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOjH,WAAA;EADN,uBAAuB,SAAO,GAAkC,YAAY,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOrG,WAAA;EADN,uBAAuB,wBAAsB,GAAkC,YAAY,EAAE,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAOpH,WAAA;EAHN,uBAAuB,+BAA6B,GAAkC,YAAY;IAC/F,WAAW,EAAE,SAAS,MAAM,QAAQ,MAAM,cAAc,0BAA0B,mCAAkC;GACvH;;AAgEM,WAAA;EAzDN,uBAAuB,cAAY,GAA+B,SAAS;IACxE,WAAW,EAAE,QAAQ,KAAI;IACzB,SAAS;MACL,EAAE,OAAO,QAAQ,OAAO,EAAC;;MAEzB,EAAE,OAAO,uBAAuB,OAAO,EAAC;MACxC,EAAE,OAAO,WAAW,OAAO,EAAC;MAC5B,EAAE,OAAO,YAAY,OAAO,EAAC;MAC7B,EAAE,OAAO,cAAc,OAAO,EAAC;MAC/B,EAAE,OAAO,gBAAgB,OAAO,EAAC;;;MAGjC,EAAE,OAAO,qBAAqB,OAAO,EAAC;MACtC,EAAE,OAAO,sBAAsB,OAAO,EAAC;MACvC,EAAE,OAAO,wBAAwB,OAAO,GAAE;MAC1C,EAAE,OAAO,uBAAuB,OAAO,GAAE;MACzC,EAAE,OAAO,wBAAwB,OAAO,GAAE;MAC1C,EAAE,OAAO,0BAA0B,OAAO,GAAE;;;;;MAK5C,EAAE,OAAO,kBAAkB,OAAO,GAAE;MACpC,EAAE,OAAO,kBAAkB,OAAO,GAAE;MACpC,EAAE,OAAO,kBAAkB,OAAO,GAAE;;MAEpC,EAAE,OAAO,kBAAkB,OAAO,GAAE;MACpC,EAAE,OAAO,mBAAmB,OAAO,GAAE;MACrC,EAAE,OAAO,qBAAqB,OAAO,GAAE;MACvC,EAAE,OAAO,gBAAgB,OAAO,GAAE;MAClC,EAAE,OAAO,kBAAkB,OAAO,GAAE;;MAEpC,EAAE,OAAO,kBAAkB,OAAO,GAAE;MACpC,EAAE,OAAO,iBAAiB,OAAO,GAAE;MACnC,EAAE,OAAO,YAAY,OAAO,GAAE;MAC9B,EAAE,OAAO,eAAe,OAAO,GAAE;MACjC,EAAE,OAAO,aAAa,OAAO,GAAE;MAC/B,EAAE,OAAO,UAAU,OAAO,GAAE;MAC5B,EAAE,OAAO,SAAS,OAAO,GAAE;MAC3B,EAAE,OAAO,mBAAmB,OAAO,GAAE;MACrC,EAAE,OAAO,uBAAuB,OAAO,GAAE;MACzC,EAAE,OAAO,mBAAmB,OAAO,GAAE;MACrC,EAAE,OAAO,iBAAiB,OAAO,GAAE;MACnC,EAAE,OAAO,4BAA4B,OAAO,GAAE;;MAE9C,EAAE,OAAO,OAAO,OAAO,GAAE;MACzB,EAAE,OAAO,OAAO,OAAO,GAAE;MACzB,EAAE,OAAO,iBAAiB,OAAO,GAAE;MACnC,EAAE,OAAO,wBAAwB,OAAO,GAAE;MAC1C,EAAE,OAAO,0BAA0B,OAAO,GAAE;MAC5C,EAAE,OAAO,qBAAqB,OAAO,GAAE;MACvC,EAAE,OAAO,wBAAwB,OAAO,GAAE;MAC1C,EAAE,OAAO,SAAS,OAAO,GAAE;MAC3B,EAAE,OAAO,gBAAgB,OAAO,GAAE;MAClC,EAAE,OAAO,2BAA2B,OAAO,GAAE;;GAEpD;;AAUM,WAAA;EADN,uBAAuB,kBAAgB,GAAgC,SAAS,EAAE,KAAK,IAAI,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAQ1H,WAAA;EADN,uBAAuB,iBAAe,GAAgC,SAAS,EAAE,KAAK,GAAG,KAAK,GAAG,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAqrCnI,cAAc,qCAAqC,yBAAyB;;;AC7jDtE,IAAO,WAAP,cAAwB,kBAAiB;;;;;EAK3C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,QAAQ,sCAAsC,UAAU;AAC3E,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAC5E,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAEhF,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;AACvD,SAAK,qBAAqB,GAAG,CAAC;AAE9B,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,KAAK;EACjG;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,QAAI,MAAM,mBAAc,GAA0B;AAC9C,YAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,UAAU,KAAK,KAAK,sBAAsB,KAAK,KAAK,MAAM,sBAAsB;;IAC9I,OAAO;AACH,YAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,OAAO,KAAK,KAAK,sBAAsB,MAAM,KAAK,MAAM,sBAAsB;;IAC5I;AAEA,WAAO;EACX;;AAGJ,cAAc,oBAAoB,QAAQ;;;AC3DpC,IAAO,qBAAP,cAAkC,kBAAiB;;;;;EAKrD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,eAAe,UAAU,sCAAsC,MAAM;EAC9E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,gBAAa;AACzB,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,YAAM,YAAY,IAAI,WAAW,MAAM;AACvC,gBAAU,QAAQ,IAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AACxC,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;AAEA,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,YAAM,YAAY,IAAI,WAAW,MAAM;AACvC,gBAAU,QAAQ,IAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AACxC,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;AAEA,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,YAAM,YAAY,IAAI,WAAW,MAAM;AACvC,gBAAU,QAAQ,IAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AACxC,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;AAEA,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,YAAM,YAAY,IAAI,WAAW,MAAM;AACvC,gBAAU,QAAQ,IAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AACxC,gBAAU,OAAO,UAAU,KAAK,IAAI;IACxC;EACJ;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAElB,UAAM,OAAO,MAAM,mBAAc,IAA2B,YAAY;AAExE,UAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,IAAI,IAAI,KAAK,sBAAsB,KAAK,KAAK,sBAAsB,KAAK,KAAK,sBAAsB,KAAK,KAAK,sBAAsB;;AAE7I,WAAO;EACX;;AAGJ,cAAc,yBAAyB,kBAAkB;;;ACtGzD,IAAY;CAAZ,SAAYC,6BAA0B;AAElC,EAAAA,4BAAAA,4BAAA,OAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,UAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,UAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,gBAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,KAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,IAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,4BAAAA,4BAAA,KAAA,IAAA,CAAA,IAAA;AACJ,GAnBY,+BAAA,6BAA0B,CAAA,EAAA;AAyBhC,IAAO,mBAAP,cAAgC,kBAAiB;;;;;EAyBnD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAPzC,SAAA,YAAY,2BAA2B;AAS1C,SAAK,cAAc,KAAK,sCAAsC,KAAK;AACnE,SAAK,cAAc,KAAK,sCAAsC,KAAK;AACnE,SAAK,cAAc,QAAQ,sCAAsC,YAAY,IAAI;AACjF,SAAK,cAAc,SAAS,sCAAsC,YAAY,IAAI;AAClF,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAEhF,SAAK,qBAAqB,GAAG,CAAC;AAC9B,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;AACvD,SAAK,SAAS,CAAC,EAAE,8BAA8B,sCAAsC;EACzF;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,cAAc,cAA0B;AACpD,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB,YAAM,WAAY,aAAa,oBAAoB,CAAC,MAAM,EAAE,WAAY,EAAiB,UAAU,KAAK,EAAE,SAAS,MAAM,KAAoB,IAAI,WAAW,MAAM;AAClK,eAAS,QAAQ;AACjB,eAAS,OAAO,UAAU,KAAK,IAAI;IACvC;AAEA,QAAI,CAAC,KAAK,MAAM,aAAa;AACzB,YAAM,WAAY,aAAa,oBAAoB,CAAC,MAAM,EAAE,WAAY,EAAiB,UAAU,KAAK,EAAE,SAAS,OAAO,KAAoB,IAAI,WAAW,OAAO;AACpK,eAAS,QAAQ;AACjB,eAAS,OAAO,UAAU,KAAK,KAAK;IACxC;EACJ;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAE9B,UAAM,gBAAgB,KAAK,KAAK,cAAc,KAAK,KAAK,yBAAyB;AACjF,UAAM,iBAAiB,KAAK,MAAM,cAAc,KAAK,MAAM,yBAAyB;AAEpF,YAAQ,KAAK,WAAW;MACpB,KAAK,2BAA2B,OAAO;AACnC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,OAAO,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACvI;MACJ;MACA,KAAK,2BAA2B,UAAU;AACtC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,OAAO,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACvI;MACJ;MACA,KAAK,2BAA2B,UAAU;AACtC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,MAAM,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACtI;MACJ;MACA,KAAK,2BAA2B,aAAa;AACzC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,OAAO,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACvI;MACJ;MACA,KAAK,2BAA2B,aAAa;AACzC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,MAAM,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACtI;MACJ;MACA,KAAK,2BAA2B,gBAAgB;AAC5C,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,GAAG,KAAK,EAAE,sBAAsB,OAAO,KAAK,EAAE,sBAAsB,EAAE,CAAC;;AACvI;MACJ;MACA,KAAK,2BAA2B,KAAK;AACjC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,MAAM,KAAK,EAAE,sBAAsB,MAAM,KAAK,EAAE,sBAAsB,iBAAiB,CAAC;;AACxJ;MACJ;MACA,KAAK,2BAA2B,IAAI;AAChC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,QAAQ,KAAK,EAAE,sBAAsB,MAAM,KAAK,EAAE,sBAAsB,eAAe,CAAC;;AACxJ;MACJ;MACA,KAAK,2BAA2B,KAAK;AACjC,cAAM,qBACF,MAAM,eAAe,MAAM,IAC3B,MAAM,MAAM,iBAAiB,eAAe,gBAAgB,IAAI,KAAK,EAAE,sBAAsB,MAAM,KAAK,EAAE,sBAAsB,SAAS,CAAC;;AAC9I;MACJ;IACJ;AAEA,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,YAAY,KAAK;AAErC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,YAAY,oBAAoB;EACzC;EAEmB,sBAAmB;AAClC,UAAM,aACF,MAAM,oBAAmB,IAAK,GAAG,KAAK,iBAAiB,mDAAmD,2BAA2B,KAAK,SAAS,CAAC;;AACxJ,WAAO;EACX;;AAnKO,WAAA;EAfN,uBAAuB,aAAW,GAA+B,YAAY;IAC1E,WAAW,EAAE,SAAS,KAAI;IAC1B,UAAU;IACV,SAAS;MACL,EAAE,OAAO,SAAS,OAAO,2BAA2B,MAAK;MACzD,EAAE,OAAO,YAAY,OAAO,2BAA2B,SAAQ;MAC/D,EAAE,OAAO,YAAY,OAAO,2BAA2B,SAAQ;MAC/D,EAAE,OAAO,eAAe,OAAO,2BAA2B,YAAW;MACrE,EAAE,OAAO,eAAe,OAAO,2BAA2B,YAAW;MACrE,EAAE,OAAO,kBAAkB,OAAO,2BAA2B,eAAc;MAC3E,EAAE,OAAO,OAAO,OAAO,2BAA2B,IAAG;MACrD,EAAE,OAAO,OAAO,OAAO,2BAA2B,IAAG;MACrD,EAAE,OAAO,MAAM,OAAO,2BAA2B,GAAE;;GAE1D;;AAuKL,cAAc,4BAA4B,gBAAgB;;;ACpNpD,IAAO,aAAP,cAA0B,kBAAiB;;;;;EAS7C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAPzC,SAAA,UAAU;AAQb,SAAK,cAAc,QAAQ,sCAAsC,UAAU;AAC3E,SAAK,cAAc,SAAS,sCAAsC,YAAY,IAAI;AAClF,SAAK,cAAc,WAAW,sCAAsC,OAAO,IAAI;AAC/E,SAAK,cAAc,WAAW,sCAAsC,OAAO,IAAI;AAC/E,SAAK,cAAc,WAAW,sCAAsC,OAAO,IAAI;AAC/E,SAAK,eAAe,UAAU,sCAAsC,KAAK;AAEzE,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,OAAO;AAC/F,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,OAAO;AAC/F,SAAK,qBAAqB,GAAG,CAAC;EAClC;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB;IACJ;AAEA,QAAI,CAAC,KAAK,SAAS,CAAC,EAAE,cAAc;AAChC;IACJ;AAEA,QAAI,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CrB,QAAI,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8B5B,QAAI,MAAM,mBAAc,GAA0B;AAC9C,uBAAiB,MAAM,iBAAiB,cAAc;AACtD,8BAAwB,MAAM,iBAAiB,qBAAqB;IACxE;AAEA,UAAM,aAAa,MAAM,KAAK,OAAO;AACrC,UAAM,cAAc,kBAAkB,gBAAgB,mBAAmB;AACzE,UAAM,cACF,sBAAsB,KAAK,SAC3B,sBAAsB,QAAQ,SAAS,UAAU,EAAE,QAAQ,cAAc,KAAK,UAAU,GAAG,SAAQ,CAAE,GACrG,uBAAuB;AAG3B,UAAM,gBAAgB,MAAM,qBAAqB,IAAI;AACrD,UAAM,WAAW,KAAK,KAAK,gBAAgB,QAAQ,sCAAsC;AAEzF,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,eAAe,QAAQ,CAAC,MAAM,KAAK,KAAK,sBAAsB;;AACnH,QAAI,KAAK,QAAQ,aAAa;AAC1B,YAAM,qBAAqB,GAAG,aAAa,eAAe,KAAK,QAAQ,sBAAsB;;IACjG;AACA,QAAI,KAAK,QAAQ,aAAa;AAC1B,YAAM,qBAAqB,GAAG,aAAa,eAAe,KAAK,QAAQ,sBAAsB;;IACjG;AACA,QAAI,KAAK,QAAQ,eAAe,aAAa,sCAAsC,SAAS;AACxF,YAAM,qBAAqB,GAAG,aAAa,eAAe,KAAK,QAAQ,sBAAsB;;IACjG;AAEA,QAAI,aAAa;AACjB,QAAI,KAAK,MAAM,aAAa;AACxB,mBAAa,KAAK,MAAM;IAC5B,OAAO;AACH,YAAM,OAAO,MAAM;AACnB,mBAAa,KAAK,KAAK,gBAAgB,SAAS,sCAAsC,UAAU,OAAO,IAAI,aAAa,OAAO,IAAI;IACvI;AAEA,UAAM,qBACF,MAAM,eAAe,KAAK,SAAS,CAAC,CAAC,IACrC,MAAM,UAAU,GAAG,KAAK,KAAK,gBAAgB,SAAS,sCAAsC,UAAU,MAAM,GAAG,IAAI,aAAa,KAAK,UAAU;;AAEnJ,WAAO;EACX;EAEmB,sBAAmB;AAClC,UAAM,aAAa,MAAM,oBAAmB,IAAK,GAAG,KAAK,iBAAiB,cAAc,KAAK,OAAO;;AACpG,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,UAAU,KAAK;AAEnC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,UAAU,oBAAoB;EACvC;;AApNO,WAAA;EADN,uBAAuB,WAAS,GAA8B,QAAW,EAAE,UAAU,KAAI,CAAE;;AAwNhG,cAAc,sBAAsB,UAAU;;;AC3NxC,IAAO,oBAAP,cAAiC,kBAAiB;;;;;EAKpD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAC5C,SAAK,cAAc,QAAQ,sCAAsC,OAAO;AACxE,SAAK,cAAc,UAAU,sCAAsC,KAAK;AACxE,SAAK,cAAc,WAAW,sCAAsC,KAAK;AAEzE,SAAK,eAAe,UAAU,sCAAsC,KAAK;AACzE,SAAK,eAAe,SAAS,sCAAsC,KAAK;EAC5E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,CAAC,KAAK,KAAK,aAAa;AACxB;IACJ;AAEA,QAAI,iBAAiB;;;;;AAMrB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D;AAEA,UAAM,cAAc,iBAAiB,gBAAgB,6BAA6B;AAElF,qBAAiB;;;;;;;;;;;;;;;;;;;AAoBjB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D,OAAO;AACH,uBAAiB,MAAM,iBAAiB,cAAc;IAC1D;AAEA,UAAM,cAAc,WAAW,gBAAgB,YAAY;AAE3D,UAAM,aAAa,MAAM,qBAAqB,YAAY;AAC1D,UAAM,YAAY,MAAM,qBAAqB,WAAW;AACxD,UAAM,MAAM,MAAM,mBAAc,IAA2B,MAAM;AAEjE,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,YAAY,sCAAsC,KAAK,CAAC;;AAC7G,UAAM,qBAAqB,GAAG,MAAM,iBAAiB,WAAW,sCAAsC,KAAK,CAAC;;AAC5G,UAAM,qBAAqB,WAAW,KAAK,KAAK,sBAAsB,KAAK,KAAK,OAAO,sBAAsB,KAAK,KAAK,QAAQ,sBAAsB,KAAK,GAAG,GAAG,UAAU,KAAK,GAAG,GAAG,SAAS;;AAE9L,QAAI,KAAK,OAAO,cAAc;AAC1B,YAAM,qBAAqB,MAAM,eAAe,KAAK,MAAM,IAAI,MAAM,UAAU;;IACnF;AAEA,QAAI,KAAK,MAAM,cAAc;AACzB,YAAM,qBAAqB,MAAM,eAAe,KAAK,KAAK,IAAI,MAAM,SAAS;;IACjF;AAEA,WAAO;EACX;;AAGJ,cAAc,6BAA6B,iBAAiB;;;AC/HtD,IAAO,aAAP,cAA0B,kBAAiB;;;;;EAK7C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAC5E,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAEhF,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;EAC3D;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAoB,SAAM;AACtB,UAAM,QAAQ,KAAK,QAAQ,CAAC;AAC5B,QAAI,MAAM,aAAa;AACnB,YAAM,QAAQ,MAAM,eAAgB;AACpC,UAAI,MAAM,WAAW,yBAAyB,mBAAmB;AAC7D,eAAO,MAAM;MACjB;AAEA,UAAI,MAAM,eAAgB,WAAW,yBAAyB,mBAAmB;AAC7E,eAAO,MAAM,eAAgB;MACjC;IACJ;AAEA,WAAO,KAAK;EAChB;EAEA,IAAoB,OAAO,OAA+B;AACtD,SAAK,KAAK,UAAU,WAAW,GAAG;AAC9B;IACJ;AACA,SAAK,UAAU;EACnB;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,QAAQ,KAAK,QAAQ,CAAC;AAE5B,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,MAAM,MAAM,sBAAsB;;AAE5F,WAAO;EACX;;AAGJ,cAAc,sBAAsB,UAAU;;;AC3DxC,IAAO,iBAAP,cAA8B,kBAAiB;;;;EAkBjD,IAAW,UAAO;AACd,QAAI,KAAK,OAAO,aAAa;AACzB,cAAQ,KAAK,OAAO,gBAAgB,YAAgC;IACxE;AACA,WAAO,KAAK;EAChB;EAEA,IAAW,QAAQ,SAA0B;AACzC,QAAI,KAAK,aAAa,SAAS;AAC3B;IACJ;AAEA,UAAM,QAAQ,SAAS,SAAQ,KAAM,YAAY;AAEjD,QAAI,CAAC,WAAW,OAAO;AACnB,YAAM,wBAAwB,GAAA,CAAA,QAAU;AACpC,eAAO,IAAI,WAAW,KAAK,QAAS;MACxC,CAAC;IACL;AAEA,SAAK,WAAW;AAEhB,QAAI,WAAW,OAAO;AAClB,YAAM,wBAAwB,GAAA,CAAA,QAAU;AACpC,eAAO,IAAI,WAAW,OAAO;MACjC,CAAC;IACL;EACJ;;;;EAKA,IAAW,WAAQ;AACf,QAAI,KAAK,QAAQ,aAAa;AAC1B,cAAQ,KAAK,QAAQ,gBAAgB,YAAgC;IACzE;AACA,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,QAAI,KAAK,SAAS,aAAa;AAC3B,cAAQ,KAAK,QAAQ,gBAAgB,YAAgC;IACzE;AACA,WAAO;EACX;EAEU,qBAAqB,iBAAsD;AACjF,WAAO,iBAAiB,cAAe,gBAAgB,eAAgB,aAAkC;EAC7G;;;;EAKA,IAAW,cAAW;AAClB,UAAM,mBAAmB,KAAK,qBAAqB,KAAK,MAAM;AAC9D,QAAI,kBAAkB;AAClB,aAAO,iBAAiB;IAC5B;AACA,WAAO,KAAK;EAChB;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,qBAAqB,KAAK,OAAO,GAAG,eAAe;EACnE;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK,qBAAqB,KAAK,OAAO,GAAG,eAAe;EACnE;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK,OAAO;EACvB;;;;EAMA,IAAW,oBAAoB,OAAc;AACzC,QAAI,UAAU,KAAK,sBAAsB;AACrC;IACJ;AAEA,SAAK,uBAAuB;AAC5B,QAAI,KAAK,SAAS;AACd,YAAM,QAAQ,KAAK,QAAQ,SAAQ,KAAM,YAAY;AACrD,aAAO,wBAAwB,GAAA,CAAA,QAAU;AACrC,eAAO,IAAI,WAAW,KAAK,OAAQ;MACvC,CAAC;IACL;EACJ;EACA,IAAW,sBAAmB;AAC1B,WAAO,KAAK;EAChB;;;;EAMA,IAAW,qBAAqB,OAAc;AAC1C,QAAI,UAAU,KAAK,uBAAuB;AACtC;IACJ;AAEA,SAAK,wBAAwB;AAC7B,QAAI,KAAK,SAAS;AACd,YAAM,QAAQ,KAAK,QAAQ,SAAQ,KAAM,YAAY;AACrD,aAAO,wBAAwB,GAAA,CAAA,QAAU;AACrC,eAAO,IAAI,WAAW,KAAK,OAAQ;MACvC,CAAC;IACL;EACJ;EACA,IAAW,uBAAoB;AAC3B,WAAO,KAAK;EAChB;;;;;;EAYA,YAAmBC,OAAc,cAAc,OAAK;AAChD,UAAMA,OAAM,yBAAyB,OAAO;AAhJzC,SAAA,gBAAyB;AA2FxB,SAAA,uBAAuB;AAqBvB,SAAA,wBAAwB;AAwBzB,SAAA,6BAA6B;AAUhC,SAAK,cAAc,YAAY,sCAAsC,YAAY,KAAK;AACtF,SAAK,cAAc,UAAU,sCAAsC,YAAY,KAAK;AACpF,SAAK,cAAc,aAAa,sCAAsC,OAAO,IAAI;AACjF,SAAK,cACD,UACA,sCAAsC,QACtC,MACA,yBAAyB,mBACzB,IAAI,wCAAwC,UAAU,MAAI,GAA8C,kBAAkB,kBAAkB,CAAC;AAEjJ,SAAK,cACD,WACA,sCAAsC,QACtC,MACA,yBAAyB,mBACzB,IAAI,wCAAwC,WAAW,MAAI,GAA8C,kBAAkB,kBAAkB,CAAC;AAElJ,QAAI,CAAC,aAAa;AACd,WAAK,cACD,WACA,sCAAsC,QACtC,MACA,yBAAyB,mBACzB,IAAI,wCAAwC,WAAW,MAAI,GAA8C,kBAAkB,kBAAkB,CAAC;IAEtJ;AAEA,SAAK,eAAe,QAAQ,sCAAsC,QAAQ,yBAAyB,OAAO;AAC1G,SAAK,eAAe,OAAO,sCAAsC,QAAQ,yBAAyB,OAAO;AACzG,SAAK,eAAe,KAAK,sCAAsC,OAAO,yBAAyB,OAAO;AACtG,SAAK,eAAe,KAAK,sCAAsC,OAAO,yBAAyB,OAAO;AACtG,SAAK,eAAe,KAAK,sCAAsC,OAAO,yBAAyB,OAAO;AACtG,SAAK,eAAe,KAAK,sCAAsC,OAAO,yBAAyB,OAAO;AAEtG,SAAK,eAAe,SAAS,sCAAsC,OAAO,yBAAyB,OAAO;AAE1G,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,SAAS,sCAAsC,UAAU,sCAAsC,OAAO;AAEhJ,SAAK,QAAQ,CAAC,EAAE,2CACZ,sCAAsC,SAAS,sCAAsC,UAAU,sCAAsC,OAAO;EAEpJ;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,MAAG;AACV,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,IAAC;AACR,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEgB,eAAe,SAA4B;AACvD,QAAI,CAAC,QAAQ,mBAAmB;AAC5B;IACJ;AAEA,UAAM,UAAU,KAAK,uBAAuB,KAAK,WAAW,CAAC,KAAK,QAAQ;AAC1E,UAAM,WAAW,KAAK,wBAAwB,KAAK,WAAW,KAAK,QAAQ;AAG3E,YAAQ,SAAS,KAAK,mBAAmB,SAAS,IAAI;AACtD,YAAQ,SAAS,KAAK,kBAAkB,UAAU,IAAI;EAC1D;EAEgB,UAAO;AACnB,QAAI,KAAK,WAAW,CAAC,KAAK,QAAQ,qBAAoB,GAAI;AACtD,aAAO;IACX;AAEA,WAAO;EACX;EAEgB,KAAK,QAAc;AAC/B,QAAI,CAAC,KAAK,SAAS;AACf;IACJ;AAEA,WAAO,SAAS,KAAK,kBAAkB,KAAK,QAAQ,KAAK;AAEzD,QAAI,CAAC,KAAK,cAAc;AACpB,aAAO,WAAW,KAAK,cAAc,KAAK,OAAO;IACrD;EACJ;EAEQ,aAAa,OAA6B;AAC9C,QAAI,MAAM,mBAAc,GAA0B;AAC9C,aAAO;IACX;AACA,WAAO;EACX;EAEQ,uBAAuB,aAAqB,IAAY,OAA6B;AACzF,QAAI,MAAM,mBAAc,GAA0B;AAC9C,aAAO,GAAG,KAAK,aAAa,KAAK,CAAC,IAAI,WAAW,IAAI,cAAc,SAAS,KAAC,EAAA;IACjF;AACA,WAAO,GAAG,KAAK,aAAa,KAAK,CAAC,IAAI,WAAW,KAAK,EAAE;EAC5D;EAEU,uBAAuB,OAA6B;AAC1D,UAAM,cAAc,KAAK;AACzB,UAAM,eAAe,KAAK,gBAAgB;AAC1C,UAAM,eAAe,KAAK,gBAAgB;AAE1C,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AAEvF,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,MAAM,MAAM,qBAAqB,KAAK;AAC5C,UAAM,MAAM,MAAM,qBAAqB,KAAK;AAC5C,UAAM,MAAM,MAAM,qBAAqB,KAAK;AAE5C,UAAM,qBAAqB;cACrB,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,OAAO,sBAAsB;;cAEhH,MAAM,iBAAiB,KAAK,sCAAsC,OAAO,CAAC,MAAM,KAAK,SAAS,sBAAsB;cACpH,MAAM,iBAAiB,KAAK,sCAAsC,OAAO,CAAC,MAAM,KAAK,SAAS,sBAAsB;cACpH,MAAM,iBAAiB,KAAK,sCAAsC,OAAO,CAAC,MAAM,KAAK,SAAS,sBAAsB;;AAG1H,QAAI,KAAK,eAAe;AACpB,YAAM,qBAAqB;kBACrB,GAAG,SAAS,GAAG;;sBAEX,CAAC;sBACD,GAAG,SAAS,GAAG;;sBAEf,CAAC;sBACD,GAAG,SAAS,GAAG;;sBAEf,CAAC;sBACD,GAAG,SAAS,GAAG;;;IAG7B;AAEA,UAAM,SAAS,MAAM;AAErB,UAAM,qBAAqB;cACrB,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,uBAAuB,aAAa,KAAK,KAAK,CAAC;cAClI,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,uBAAuB,cAAc,KAAK,KAAK,CAAC;cACnI,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,uBAAuB,cAAc,KAAK,KAAK,CAAC;;;cAGnI,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,cAAc,CAAC,UAAU,MAAM,IAAI,SAAS;;;cAGpH,MAAM,iBAAiB,KAAK,kBAAkB,sCAAsC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC;;EAE5K;EAEQ,wBAAwB,OAA+B,QAAqC,SAAe;AAC/G,QAAI,eAAe;AAEnB,QACI,MAAM,mBAAc,MACnB,OAAO,SAAS,sCAAsC,WAAW,OAAO,SAAS,sCAAsC,SAC1H;AACE,qBAAe;IACnB;AAEA,QAAI,YAAY,KAAK;AAEjB,UAAI,CAAC,KAAK,WAAW,CAAC,KAAK,QAAQ,YAAY;AAC3C,cAAM,qBAAqB,UAAU,KAAK,iBAAiB;sBACrD,OAAO,sBAAsB,kBAAkB,YAAY,IAAI,OAAO,sBAAsB;;;MAGtG;AAEA,YAAM,qBAAqB,UAAU,KAAK,gBAAgB;kBACpD,OAAO,sBAAsB,mBAAmB,YAAY,IAAI,OAAO,sBAAsB;;;IAGvG;EACJ;EAEQ,aAAa,OAA+B,QAAqC,SAAe;AACpG,QAAI,aAAa;AAEjB,QAAI,CAAC,KAAK,4BAA4B;AAClC,mBAAa,MAAM,MAAM,mBAAc,IAA2B,cAAc,EAAE,GAAG,KAAK,gBAAgB;IAC9G;AAEA,UAAM,qBAAqB,GAAG,MAAM,eAAe,MAAM,CAAC,MAAM,KAAK,gBAAgB,IAAI,OAAO,GAAG,UAAU;;AAC7G,SAAK,wBAAwB,OAAO,QAAQ,OAAO;EACvD;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,KAAK,OAAO,aAAa;AACzB,WAAK,eAAe,KAAK,OAAO,eAAgB;IACpD,OAAO;AACH,WAAK,eAAe;IACxB;AAEA,SAAK,mBAAmB,MAAM,qBAAqB,iBAAiB;AAEpE,SAAK,MAAM,0BAA0B,MAAM,mBAAc,IAA2B,cAAc,MAAM,KAAK;AAE7G,SAAK,mBAAmB,MAAM,qBAAqB,iBAAiB;AACpE,SAAK,oBAAoB,MAAM,mBAAmB,UAAU;AAC5D,SAAK,mBAAmB,MAAM,mBAAmB,SAAS;AAE1D,QAAI,CAAC,KAAK,cAAc;AACpB,WAAK,eAAe,MAAM,qBAAqB,KAAK,OAAO,SAAS;AAEpE,YAAM,eAAe,KAAK,YAAY;IAC1C;AAGA,UAAM,WAAW,eAAe,KAAK,IAAI;AACzC,UAAM,WAAW,cAAc,KAAK,IAAI;AACxC,UAAM,WAAW,kBAAkB,KAAK,IAAI;AAC5C,UAAM,WAAW,eAAe,KAAK,IAAI;AAEzC,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,yBAAyB,mBAAmB,QAAQ;AAE1D,UAAM,uBAAuB,KAAK,kBAAkB,sCAAsC,KAAK;AAE/F,SAAK,uBAAuB,KAAK;AAEjC,eAAW,UAAU,KAAK,UAAU;AAChC,UAAI,OAAO,gBAAgB,OAAO,SAAS,SAAS;AAChD,aAAK,aAAa,OAAO,QAAQ,OAAO,IAAI;MAChD;IACJ;AAEA,WAAO;EACX;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,kBAAc,GAAG,KAAK,iBAAiB,0BAA0B,KAAK,mBAAmB;;AACzF,kBAAc,GAAG,KAAK,iBAAiB,2BAA2B,KAAK,oBAAoB;;AAC3F,kBAAc,GAAG,KAAK,iBAAiB,iCAAiC,KAAK,0BAA0B;;AACvG,kBAAc,GAAG,KAAK,iBAAiB,oBAAoB,KAAK,aAAa;;AAE7E,QAAI,CAAC,KAAK,SAAS;AACf,aAAO;IACX;AAEA,kBAAc,GAAG,KAAK,iBAAiB,mCAAmC,KAAK,QAAQ,IAAI,YAAY,KAAK,QAAQ,QAAQ,KAAK,KAAK,QAAQ,OAAO,KAAK,KAAK,QAAQ,YAAY;;AACnL,kBAAc,GAAG,KAAK,iBAAiB,oBAAoB,KAAK,QAAQ,KAAK;;AAC7E,kBAAc,GAAG,KAAK,iBAAiB,oBAAoB,KAAK,QAAQ,KAAK;;AAC7E,kBAAc,GAAG,KAAK,iBAAiB,mBAAmB,KAAK,QAAQ,IAAI;;AAC3E,kBAAc,GAAG,KAAK,iBAAiB,mBAAmB,KAAK,QAAQ,IAAI;;AAC3E,kBAAc,GAAG,KAAK,iBAAiB,mBAAmB,KAAK,QAAQ,IAAI;;AAC3E,kBAAc,GAAG,KAAK,iBAAiB,sBAAsB,KAAK,QAAQ,OAAO;;AACjF,kBAAc,GAAG,KAAK,iBAAiB,sBAAsB,KAAK,QAAQ,OAAO;;AACjF,kBAAc,GAAG,KAAK,iBAAiB,qBAAqB,KAAK,QAAQ,MAAM;;AAC/E,kBAAc,GAAG,KAAK,iBAAiB,qBAAqB,KAAK,QAAQ,MAAM;;AAC/E,kBAAc,GAAG,KAAK,iBAAiB,8BAA8B,KAAK,QAAQ,eAAe;;AAEjG,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,sBAAsB,KAAK;AAC/C,wBAAoB,uBAAuB,KAAK;AAChD,wBAAoB,6BAA6B,KAAK;AACtD,wBAAoB,gBAAgB,KAAK;AACzC,QAAI,CAAC,KAAK,kBAAkB,KAAK,WAAW,CAAC,KAAK,QAAQ,kBAAkB,KAAK,QAAQ,aAAY,MAAO,gBAAgB;AACxH,0BAAoB,UAAU,KAAK,QAAQ,UAAS;IACxD;AAEA,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,sBAAsB,oBAAoB;AAC/C,SAAK,uBAAuB,CAAC,CAAC,oBAAoB;AAClD,SAAK,6BAA6B,CAAC,CAAC,oBAAoB;AACxD,SAAK,gBAAgB,CAAC,CAAC,oBAAoB;AAE3C,QAAI,oBAAoB,WAAW,CAAC,aAAa,4BAA4B,oBAAoB,QAAQ,QAAQ,QAAW;AACxH,gBAAU,oBAAoB,QAAQ,IAAI,QAAQ,OAAO,MAAM,IAAI,KAAK;AACxE,WAAK,UAAU,QAAQ,MAAM,oBAAoB,SAAS,OAAO,OAAO;IAC5E;EACJ;;AA9gBO,WAAA;EADN,uBAAuB,mBAAiB,GAAkC,YAAY,EAAE,UAAU,MAAM,WAAW,EAAE,QAAQ,KAAI,EAAE,CAAE;;AAkhB1I,cAAc,0BAA0B,cAAc;;;AC3iBhD,IAAO,gBAAP,cAA6B,eAAc;;;;;EAK7C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,IAAI;EACpB;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEQ,wBAAwBA,OAAc,OAA6B;AACvE,QAAI,MAAM,mBAAc,GAA0B;AAC9C,aAAO,OAAOA,KAAI;IACtB,OAAO;AACH,aAAO,SAASA,KAAI;IACxB;EACJ;EAEQ,gBAAgB,OAA+B,aAAmB;AACtE,QAAI,MAAM,mBAAc,GAA0B;AAC9C,aAAO,qBAAqB,WAAW,IAAI,cAAc,SAAS;IACtE;AAEA,WAAO,eAAe,WAAW;EACrC;EAEmB,uBAAuB,OAA6B;AACnE,UAAM,cAAc,KAAK;AACzB,UAAM,eAAe,KAAK,gBAAgB,KAAK;AAE/C,UAAM,YAAY,KAAK,UAAU,cAAc,KAAK,UAAU,yBAAyB;AAEvF,UAAM,OAAO,MAAM,qBAAqB,SAAS;AACjD,UAAM,OAAO,MAAM,qBAAqB,SAAS;AACjD,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,KAAK,MAAM,qBAAqB,IAAI;AAC1C,UAAM,KAAK,MAAM,qBAAqB,IAAI;AAC1C,UAAM,KAAK,MAAM,qBAAqB,IAAI;AAC1C,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AACxC,UAAM,IAAI,MAAM,qBAAqB,GAAG;AAExC,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,WAAW;AACf,UAAM,SAAS,MAAM;AAErB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,cAAQ;AACR,iBAAW;AACX,iBAAW;IACf;AAEA,UAAM,qBAAqB;;cAErB,MAAM,iBAAiB,MAAM,sCAAsC,OAAO,CAAC,MAAM,QAAQ,IAAI,KAAK,SAAS,sBAAsB;cACjI,MAAM,iBAAiB,MAAM,sCAAsC,OAAO,CAAC,MAAM,QAAQ,IAAI,KAAK,SAAS,sBAAsB;cACjI,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,UAAU,KAAK,OAAO,sBAAsB;;;cAGpH,KAAK,wBAAwB,IAAI,KAAK,CAAC,MAAM,MAAM,iBACjD,GAAG,KAAK,WACR,GAAG,MAAM,iBAAiB,GAAG,KAAK,WAAW,GAAG,KAAK,WAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAClF,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CACrC;;;cAGC,KAAK,wBAAwB,IAAI,KAAK,CAAC,OAAO,MAAM,iBAClD,GAAG,KAAK,WACR,GAAG,MAAM,iBAAiB,GAAG,KAAK,WAAW,GAAG,KAAK,WAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAClF,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CACrC;;;cAGC,KAAK,wBAAwB,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,EAAE,MAAM,EAAE;;;cAGrE,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,gBAAgB,OAAO,WAAW,CAAC,SAAS,MAAM,IAAI,KAAK,SAAS,sBAAsB,IAAI,EAAE,QAAQ,KAAK,SAAS,sBAAsB,IAAI,EAAE;0CACzM,MAAM,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI,IAAI,EAAE;0CACrC,MAAM,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI,IAAI,EAAE;cACjE,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,MAAM,KAAK,gBAAgB,OAAO,YAAY,CAAC,SAAS,MAAM,IAAI,KAAK,SAAS,sBAAsB,IAAI,EAAE,QAAQ,KAAK,SAAS,sBAAsB,IAAI,EAAE;0CAC1M,MAAM,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI,IAAI,EAAE;0CACrC,MAAM,IAAI,IAAI,IAAI,EAAE,OAAO,IAAI,IAAI,EAAE;;;cAGjE,MAAM,iBAAiB,GAAG,sCAAsC,OAAO,CAAC,UAAU,MAAM,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE;;cAEjH,CAAC,cAAc,CAAC,8BAA8B,MAAM,cAAc,MAAM;;cAExE,CAAC,WAAW,CAAC,SAAS,MAAM,IAAI,SAAS;;cAEzC,MAAM,iBAAiB,KAAK,kBAAkB,sCAAsC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC;;EAErJ;;AAGJ,cAAc,yBAAyB,aAAa;;;ACvG9C,IAAO,yBAAP,cAAsC,kBAAiB;;;;;EAKzD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,MAAM;AACxE,SAAK,eAAe,UAAU,sCAAsC,KAAK;EAC7E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK;AACpB,UAAM,QAAQ,KAAK;AAEnB,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,kBAAkB,MAAM,sBAAsB;;AAExG,WAAO;EACX;;AAGJ,cAAc,kCAAkC,sBAAsB;;;AC9ChE,IAAO,uBAAP,cAAoC,kBAAiB;;;;;EAKvD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,MAAM;AACxE,SAAK,eAAe,UAAU,sCAAsC,MAAM;EAC9E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK;AACpB,UAAM,QAAQ,KAAK;AAEnB,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,gBAAgB,MAAM,sBAAsB;;AAEtG,WAAO;EACX;;AAGJ,cAAc,gCAAgC,oBAAoB;;;AC7ClE,IAAkB;CAAlB,SAAkBC,gCAA6B;AAC3C,EAAAA,+BAAAA,+BAAA,MAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,QAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,SAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,aAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACA,EAAAA,+BAAAA,+BAAA,KAAA,IAAA,CAAA,IAAA;AACJ,GAXkB,kCAAA,gCAA6B,CAAA,EAAA;AAiBzC,IAAO,2BAAP,cAAwC,kBAAiB;;;;;EAK3D,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AA4FzC,SAAA,gBAAa;AA1FhB,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAC5E,SAAK,cAAc,YAAY,sCAAsC,UAAU;AAC/E,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAEhF,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;AACvD,SAAK,qBAAqB,GAAG,CAAC;AAG9B,SAAK,QAAQ,CAAC,EAAE,uBAAuB,IAAI,CAAC,UAAS;AACjD,UAAI,KAAK,eAAe;AAEpB;MACJ;AACA,YAAM,cAAc,MAAM;AAC1B,UAAI,uBAAuB,cAAc,YAAY,aAAa;AAC9D,gBAAQ,YAAY,MAAM;UACtB,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;QACR;MACJ,WAAW,uBAAuB,mBAAmB;AACjD,gBAAQ,KAAK,MAAM,gBAAgB,MAAM;UACrC,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;UACJ,KAAK;AACD,iBAAK,gBAAa;AAClB;QACR;MACJ;IACJ,CAAC;EACL;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EA0BA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAIC,mBAAiC;AACrC,YAAQ,KAAK,eAAe;MACxB,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;MACJ,KAAA;AACI,QAAAA,mBAAkB;AAClB;IACR;AAEA,UAAM,SAAS,MAAM,eAAe,KAAK,MAAM;AAC/C,QAAIA,kBAAiB;AACjB,YAAM,qBAAqB,UAAUA,gBAAe;;IACxD;AAEA,UAAM,qBAAqB,GAAG,MAAM,MAAM,KAAK,MAAM,sBAAsB;;AAE3E,QAAIA,kBAAiB;AACjB,YAAM,qBAAqB;;AAC3B,YAAM,qBAAqB,GAAG,MAAM,MAAM,KAAK,SAAS,sBAAsB;;AAC9E,YAAM,qBAAqB;;IAC/B;AACA,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,gBAAgB,KAAK;AAEzC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,gBAAgB,oBAAoB,iBAAa;EAC1D;EAEmB,sBAAmB;AAClC,QAAI,aAAa,MAAM,oBAAmB;AAE1C,kBAAc,GAAG,KAAK,iBAAiB,oBAAoB,KAAK,aAAa;;AAE7E,WAAO;EACX;;AA5FO,WAAA;EAhBN,uBAAuB,oBAAkB,GAA+B,QAAW;IAChF,WAAW,EAAE,QAAQ,KAAI;IACzB,UAAU;IACV,SAAS;MACL;QAAE,OAAO;QAAU,OAAK;;MAAoC;MAC5D;QAAE,OAAO;QAAU,OAAK;;MAAsC;MAC9D;QAAE,OAAO;QAAW,OAAK;;MAAuC;MAChE;QAAE,OAAO;QAAgB,OAAK;;MAA2C;MACzE;QAAE,OAAO;QAAO,OAAK;;MAAmC;MACxD;QAAE,OAAO;QAAO,OAAK;;MAAmC;MACxD;QAAE,OAAO;QAAO,OAAK;;MAAmC;MACxD;QAAE,OAAO;QAAO,OAAK;;MAAmC;MACxD;QAAE,OAAO;QAAO,OAAK;;MAAmC;MACxD;QAAE,OAAO;QAAO,OAAK;;MAAmC;;GAE/D;;AAgGL,cAAc,oCAAoC,wBAAwB;;;AChN1E,IAAY;CAAZ,SAAYC,kBAAe;AAEvB,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,cAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,gBAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,CAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,cAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,gBAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,cAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,gBAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,YAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,aAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,eAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,gBAAA,IAAA,EAAA,IAAA;AAEA,EAAAA,iBAAAA,iBAAA,kBAAA,IAAA,EAAA,IAAA;AACJ,GAvDY,oBAAA,kBAAe,CAAA,EAAA;AA4DrB,IAAO,aAAP,cAA0B,kBAAiB;;;;;EA2C7C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAPzC,SAAA,OAAO,gBAAgB;AAS1B,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAC5E,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAEhF,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;AAEvD,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,MAAM;AAC9F,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,MAAM;AAC9F,SAAK,QAAQ,CAAC,EAAE,6BAA6B,KAAK,sCAAsC,GAAG;EAC/F;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEQ,gBAAgB,OAAe,WAAiB;AACpD,WAAO,OAAO,SAAS,MAAM,MAAM,QAAQ,QAAQ,OAAO,SAAS,CAAC;EACxE;EAEQ,sBAAsB,OAAa;AACvC,WAAO,UAAU,MAAM,QAAQ,QAAQ,GAAG,CAAC;EAC/C;EAEQ,iBAAiB,OAAe,WAAmB,QAAe;AACtE,QAAI,cAAc,WAAW,cAAc,OAAO;AAC9C,aAAO,KAAK,sBAAsB,KAAK;IAC3C;AAEA,UAAM,OAAO,SAAS,UAAU,QAAQ,OAAO,EAAE,CAAC;AAClD,QAAI,OAAO,SACL;0BACY,IAAI,UAAU,IAAI;YAE9B;iBACG,IAAI,aAAa,IAAI;;AAG9B,aAAS,IAAI,GAAG,KAAK,MAAM,KAAK;AAC5B,cAAQ,KAAK,gBAAgB,OAAO,MAAM,IAAI,MAAM,MAAM,IAAI,MAAM,MAAM,IAAI,MAAM,GAAG,IAAI;IAC/F;AAEA,YAAQ;AACR,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,QAAI,qBAAqB;AACzB,QAAI,yBAAyB;AAE7B,UAAM,YAAY,MAAM,eAAe,KAAK,MAAM,IAAI;AACtD,UAAM,SAAS,MAAM,mBAAc;AAEnC,6BAAyB,gBAAgB,KAAK,IAAI,IAAI,MAAM,UAAU,QAAQ,KAAK,EAAE,EAAE,QAAQ,KAAK,EAAE;AAEtG,YAAQ,KAAK,MAAM;MACf,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB,eAAe;AAChC,cAAM,QAAQ,MAAM,iBAAiB,mBAAmB,0CAA0C,WAAW;AAC7G,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB,cAAc;AAC/B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,gBAAgB;AACjC,cAAM,QAAQ,MAAM,iBAAiB,yBAAyB,0CAA0C,WAAW;AACnH,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB,cAAc;AAC/B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,gBAAgB;AACjC,cAAM,QAAQ,MAAM,iBAAiB,+BAA+B,0CAA0C,WAAW;AACzH,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB;AACjB,6BAAqB;AACrB;MACJ,KAAK,gBAAgB,cAAc;AAC/B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,gBAAgB;AACjC,cAAM,QAAQ,MAAM,iBAAiB,sCAAsC,0CAA0C,WAAW;AAChI,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,YAAY;AAC7B,cAAM,QAAQ,MAAM,iBAAiB,OAAO,+BAA+B,YAAY;AACvF,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,aAAa;AAC9B,cAAM,QAAQ,MAAM,iBAAiB,OAAO,+BAA+B,YAAY;AACvF,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,eAAe;AAChC,cAAM,QAAQ,MAAM,iBAChB,OACA,MAAM,iBACF,OACA,MAAM,iBAAiB,qCAAqC,8CAA8C,WAAW,GACrH,YAAY,GAEhB,YAAY;AAEhB,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,YAAY;AAC7B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,aAAa;AAC9B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,eAAe;AAChC,cAAM,QAAQ,MAAM,iBAAiB,iDAAiD,wDAAwD,WAAW;AACzJ,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,YAAY;AAC7B,6BAAqB;AACrB;MACJ;MACA,KAAK,gBAAgB,aAAa;AAC9B,cAAM,QAAQ;AACd,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,eAAe;AAChC,cAAM,QAAQ,MAAM,iBAChB,uEACA,yFACA,WAAW;AAEf,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,eAAe;AAChC,cAAM,QAAQ,MAAM,iBAChB,OACA,MAAM,iBAAiB,OAAO,qFAAqF,YAAY,GAC/H,YAAY;AAGhB,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,gBAAgB;AACjC,cAAM,QAAQ,MAAM,iBAChB,OACA,MAAM,iBAAiB,OAAO,mFAAmF,YAAY,GAC7H,YAAY;AAEhB,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;MACA,KAAK,gBAAgB,kBAAkB;AACnC,cAAM,QAAQ,MAAM,iBAChB,OACA,MAAM,iBACF,OACA,MAAM,iBACF,8FACA,oGACA,WAAW,GAEf,YAAY,GAEhB,YAAY;AAGhB,6BAAqB,KAAK,iBAAiB,OAAO,WAAW,MAAM;AACnE;MACJ;IACJ;AAEA,QAAI,QAAQ;AACR,YAAM,cAAc,wBAAwB,MAAM,sBAAsB,OAAO,SAAS,QAAQ,SAAS,MAAM,kBAAkB;GAAQ,EAAE;IAC/I,OAAO;AACH,YAAM,cAAc,wBAAwB,GAAG,SAAS,IAAI,sBAAsB,IAAI,SAAS,QAAQ,kBAAkB;GAAQ,EAAE;IACvI;AAEA,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,MAAM,sBAAsB,IAAI,KAAK,MAAM,sBAAsB;;AAE3H,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,YAAY,KAAK;AAErC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,OAAO,oBAAoB;EACpC;EAEmB,sBAAmB;AAClC,UAAM,aAAa,MAAM,oBAAmB,IAAK,GAAG,KAAK,iBAAiB,mCAAmC,gBAAgB,KAAK,IAAI,CAAC;;AACvI,WAAO;EACX;;AA1QO,WAAA;EAjCN,uBAAuB,QAAM,GAA+B,YAAY;IACrE,WAAW,EAAE,SAAS,KAAI;IAC1B,UAAU;IACV,SAAS;MACL,EAAE,OAAO,cAAc,OAAO,gBAAgB,WAAU;MACxD,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,cAAc,OAAO,gBAAgB,WAAU;MACxD,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,gBAAgB,OAAO,gBAAgB,aAAY;MAC5D,EAAE,OAAO,kBAAkB,OAAO,gBAAgB,eAAc;MAChE,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,gBAAgB,OAAO,gBAAgB,aAAY;MAC5D,EAAE,OAAO,kBAAkB,OAAO,gBAAgB,eAAc;MAChE,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,gBAAgB,OAAO,gBAAgB,aAAY;MAC5D,EAAE,OAAO,kBAAkB,OAAO,gBAAgB,eAAc;MAChE,EAAE,OAAO,cAAc,OAAO,gBAAgB,WAAU;MACxD,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,cAAc,OAAO,gBAAgB,WAAU;MACxD,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,cAAc,OAAO,gBAAgB,WAAU;MACxD,EAAE,OAAO,eAAe,OAAO,gBAAgB,YAAW;MAC1D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,iBAAiB,OAAO,gBAAgB,cAAa;MAC9D,EAAE,OAAO,kBAAkB,OAAO,gBAAgB,eAAc;MAChE,EAAE,OAAO,oBAAoB,OAAO,gBAAgB,iBAAgB;;GAE3E;;AA8QL,cAAc,sBAAsB,UAAU;;;AChXxC,IAAO,sBAAP,cAAmC,kBAAiB;;;;;EAKtD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,QAAQ,sCAAsC,QAAQ,IAAI;AAC7E,SAAK,cAAc,QAAQ,sCAAsC,QAAQ,IAAI;AAE7E,SAAK,eAAe,OAAO,sCAAsC,MAAM;AACvE,SAAK,eAAe,OAAO,sCAAsC,MAAM;EAC3E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,aAAaA,OAAY;AACxC,QAAIA,UAAS,QAAQ;AACjB,aAAO;IACX;AACA,QAAIA,UAAS,QAAQ;AACjB,aAAO;IACX;AACA,WAAOA;EACX;EAEmB,cAAcA,OAAY;AACzC,QAAIA,UAAS,OAAO;AAChB,aAAO;IACX;AACA,QAAIA,UAAS,OAAO;AAChB,aAAO;IACX;AACA,WAAOA;EACX;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK;AAEtB,UAAM,YAAY,KAAK,SAAS,CAAC;AACjC,UAAM,YAAY,KAAK,SAAS,CAAC;AAEjC,UAAM,OAAO,MAAM,eAAe,sCAAsC,OAAO;AAE/E,QAAI,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCd,QAAI,UAAU;;;;;;;;;;;;;;;;;;;;AAqBd,QAAI,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCd,QAAI,MAAM,mBAAc,GAA0B;AAC9C,gBAAU,MAAM,iBAAiB,OAAO;AACxC,gBAAU,MAAM,iBAAiB,OAAO;AACxC,gBAAU,MAAM,iBAAiB,OAAO;IAC5C;AAEA,UAAM,cAAc,WAAW,SAAS,EAAE;AAC1C,UAAM,cAAc,WAAW,SAAS,EAAE;AAC1C,UAAM,cAAc,WAAW,SAAS,EAAE;AAE1C,QAAI,SAAS,aAAa;AACtB,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,MAAM,SAAS,sBAAsB;;MACtG;AAEA,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,cAAc,SAAS,sBAAsB;;MAC9G;IACJ,WAAW,SAAS,aAAa;AAC7B,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,cAAc,SAAS,sBAAsB;;MAC9G;AACA,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,MAAM,SAAS,sBAAsB;;MACtG;IACJ,OAAO;AACH,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,OAAO,IAAI;;MAC5E;AAEA,UAAI,UAAU,cAAc;AACxB,cAAM,qBAAqB,MAAM,eAAe,SAAS,IAAI,OAAO,IAAI;;MAC5E;IACJ;AAEA,WAAO;EACX;;AAGJ,cAAc,+BAA+B,mBAAmB;;;AClN1D,IAAO,YAAP,MAAO,mBAAkB,kBAAiB;;;;;EAY5C,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAPzC,SAAA,aAAa;AAShB,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAC5E,SAAK,cAAc,cAAc,sCAAsC,OAAO,IAAI;AAClF,SAAK,eAAe,UAAU,sCAAsC,YAAY;AAChF,SAAK,eAAe,SAAS,sCAAsC,OAAO,yBAAyB,QAAQ;AAC3G,SAAK,eACD,UACA,sCAAsC,QACtC,QACA,IAAI,wCAAwC,UAAU,MAAI,GAA+C,YAAW,WAAW,CAAC;AAGpI,SAAK,SAAS,CAAC,EAAE,wBAAwB,KAAK,QAAQ,CAAC;AACvD,SAAK,SAAS,CAAC,EAAE,gBAAgB;AAEjC,SAAK,SAAS,CAAC,EAAE,oBAAoB,KAAK,QAAQ,CAAC;AAEnD,SAAK,SAAS,CAAC,EAAE,mBAAmB;AACpC,SAAK,SAAS,CAAC,EAAE,mBAAmB;EACxC;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;;EAMA,IAAW,SAAM;AACb,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,SAAS,KAAK,SAAS,CAAC;AAC9B,UAAM,QAAQ,KAAK,SAAS,CAAC;AAE7B,UAAM,YAAY,MAAM,qBAAqB,OAAO;AAEpD,UAAM,OAAO,MAAM,mBAAc,IAA2B,QAAQ;AACpE,UAAM,YAAY,MAAM,mBAAc,IAA2B,QAAQ;AACzE,UAAM,UAAU,MAAM,mBAAc,IAA2B,QAAQ;AAGvE,UAAM,qBAAqB,MAAM,eAAe,MAAM,IAAI,MAAM,KAAK,MAAM,sBAAsB;;AAGjG,UAAM,aAAa,KAAK,gBAAgB,cAAc,GAAG,OAAO,IAAI,KAAK,gBAAgB,sBAAsB,MAAM,KAAK;AAG1H,UAAM,qBAAqB,QAAQ,IAAI,IAAI,SAAS,SAAS,SAAS,MAAM,UAAU,KAAK,SAAS;;AACpG,UAAM,qBAAqB,GAAG,MAAM,eAAe,KAAK,CAAC,MAAM,SAAS,IAAI,SAAS;;AAErF,WAAO;EACX;EAEmB,gBAAgB,OAA6B;AAC5D,UAAM,gBAAgB,KAAK;AAE3B,UAAM,qBAAqB;;AAE3B,WAAO;EACX;EAEmB,sBAAmB;AAClC,WAAO,MAAM,oBAAmB,IAAK,GAAG,KAAK,iBAAiB,iBAAiB,KAAK,UAAU;;EAClG;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAE3C,wBAAoB,aAAa,KAAK;AAEtC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,aAAa,oBAAoB;EAC1C;;AA1HO,WAAA;EADN,uBAAuB,cAAY,GAA8B,QAAW,EAAE,UAAU,KAAI,CAAE;;AA8HnG,cAAc,qBAAqB,SAAS;;;ACtItC,IAAO,mBAAP,cAAgC,kBAAiB;;;;;EAKnD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cACD,UACA,sCAAsC,QACtC,OACA,QACA,IAAI,wCAAwC,UAAU,MAAI,GAA8C,WAAW,WAAW,CAAC;AAEnI,SAAK,eAAe,SAAS,sCAAsC,UAAU;AAE7E,SAAK,SAAS,CAAC,EAAE,0BAA0B,KAAK,QAAQ,CAAC;EAC7D;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;EAMA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,QAAQ,KAAK;AAEnB,QAAI,CAAC,KAAK,OAAO,aAAa;AAC1B,aAAO;IACX;AAEA,UAAM,YAAY,KAAK,OAAO,eAAgB;AAE9C,UAAM,qBAAqB,MAAM,eAAe,KAAK,IAAI,MAAM,UAAU,OAAO,sBAAsB;;AAEtG,WAAO;EACX;;AAGJ,cAAc,4BAA4B,gBAAgB;;;AC5DpD,IAAO,oBAAP,cAAiC,kBAAiB;;;;;EAKpD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cACD,UACA,sCAAsC,QACtC,OACA,QACA,IAAI,wCAAwC,UAAU,MAAI,GAA8C,WAAW,WAAW,CAAC;AAEnI,SAAK,cAAc,SAAS,sCAAsC,UAAU;AAE5E,SAAK,qBAAqB,GAAG,CAAC;EAClC;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;EAMA,IAAW,SAAM;AACb,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKgB,8BAA2B;AACvC,QAAI,CAAC,KAAK,OAAO,aAAa;AAC1B,aAAO;IACX;AACA,UAAM,YAAY,KAAK,OAAO,eAAgB;AAE9C,WAAO,UAAU,OAAO;EAC5B;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,QAAQ,KAAK;AAEnB,QAAI,CAAC,KAAK,OAAO,aAAa;AAC1B,aAAO;IACX;AAEA,UAAM,YAAY,KAAK,OAAO,eAAgB;AAE9C,UAAM,qBAAqB,GAAG,UAAU,OAAO,sBAAsB,MAAM,MAAM,sBAAsB;;AAEvG,WAAO;EACX;;AAGJ,cAAc,6BAA6B,iBAAiB;;;ACxEtD,IAAO,sBAAP,cAAmC,kBAAiB;;;;;EAKtD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,OAAO;AAE5C,SAAK,cAAc,SAAS,sCAAsC,MAAM;AACxE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;AACzE,SAAK,eAAe,QAAQ,sCAAsC,OAAO;EAC7E;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;EAEQ,cAAc,OAA+B,KAAkC,OAAe,aAAmB;AACrH,UAAM,OAAO,MAAM,mBAAc,IAA2B,UAAU;AACtE,UAAM,qBACF,MAAM,eAAe,GAAG,IAAI,MAAM,IAAI,IAAI,KAAK,OAAO,WAAW,MAAM,KAAK,OAAO,WAAW,MAAM,KAAK,OAAO,WAAW,MAAM,KAAK,OAAO,WAAW;;EAChK;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,UAAM,QAAQ,KAAK,QAAQ,CAAC,EAAE;AAE9B,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAElB,QAAI,KAAK,cAAc;AACnB,YAAM,qBAAqB,MAAM,eAAe,IAAI,IAAI,MAAM,KAAK;;IACvE;AACA,QAAI,KAAK,cAAc;AACnB,YAAM,qBAAqB,MAAM,eAAe,IAAI,IAAI,MAAM,KAAK;;IACvE;AACA,QAAI,KAAK,cAAc;AACnB,YAAM,qBAAqB,MAAM,eAAe,IAAI,IAAI,MAAM,KAAK;;IACvE;AACA,QAAI,KAAK,cAAc;AACnB,YAAM,qBAAqB,MAAM,eAAe,IAAI,IAAI,MAAM,KAAK;;IACvE;AAEA,QAAI,KAAK,cAAc;AACnB,WAAK,cAAc,OAAO,MAAM,OAAO,CAAC;IAC5C;AACA,QAAI,KAAK,cAAc;AACnB,WAAK,cAAc,OAAO,MAAM,OAAO,CAAC;IAC5C;AACA,QAAI,KAAK,cAAc;AACnB,WAAK,cAAc,OAAO,MAAM,OAAO,CAAC;IAC5C;AACA,QAAI,KAAK,cAAc;AACnB,WAAK,cAAc,OAAO,MAAM,OAAO,CAAC;IAC5C;AAEA,WAAO;EACX;;AAGJ,cAAc,+BAA+B,mBAAmB;;;ACxI1D,IAAO,yBAAP,cAAsC,kBAAiB;;;;;EAKzD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,MAAM;AAE3C,SAAK,YAAY;AAEjB,SAAK,cAAc,iBAAiB,sCAAsC,SAAS,OAAO,yBAAyB,MAAM;AACzH,SAAK,cAAc,cAAc,sCAAsC,SAAS,MAAM,yBAAyB,MAAM;AACrH,SAAK,cAAc,SAAS,sCAAsC,QAAQ,OAAO,yBAAyB,MAAM;AAChH,SAAK,cAAc,QAAQ,sCAAsC,QAAQ,OAAO,yBAAyB,MAAM;AAC/G,SAAK,cAAc,cAAc,sCAAsC,QAAQ,OAAO,yBAAyB,MAAM;AAErH,SAAK,eAAe,eAAe,sCAAsC,SAAS,yBAAyB,MAAM;AACjH,SAAK,eAAe,MAAM,sCAAsC,QAAQ,yBAAyB,MAAM;EAC3G;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,KAAE;AACT,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,OAAO;AAClC,UAAM,qBAAqB,aAAa;AACxC,UAAM,qBAAqB,YAAY;AACvC,UAAM,qBAAqB,aAAa;EAC5C;;;;;;;EAOgB,eAAe,SAA8B,cAA4B,MAAmB;AACxG,QAAI,CAAC,MAAM;AACP;IACJ;AAEA,QAAI,KAAK,aAAY,KAAM,yBAAyB;AAChD,cAAQ,SAAS,aAAqC,KAAM,UAAU,IAAI;IAC9E;EACJ;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD;IACJ;AAEA,UAAM,WAAW,kBAAkB,KAAK,IAAI;AAE5C,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,yBAAyB,sCAAsC,QAAQ;AAC7E,UAAM,yBAAyB,qBAAqB,QAAQ;AAC5D,UAAM,yBAAyB,mBAAmB,QAAQ;AAC1D,UAAM,uBAAuB,SAAS,sCAAsC,OAAO;AACnF,UAAM,uBAAuB,eAAe,sCAAsC,OAAO;AACzF,UAAM,uBAAuB,cAAc,sCAAsC,KAAK;AACtF,UAAM,uBAAuB,eAAe,sCAAsC,OAAO;AACzF,UAAM,uBAAuB,uBAAuB,sCAAsC,OAAO;AACjG,UAAM,WAAW,KAAK,aAAa,YAAY;AAC/C,UAAM,WAAW,KAAK,aAAa;AACnC,UAAM,WAAW,KAAK,aAAa;AACnC,UAAM,WAAW,KAAK,aAAa;AACnC,UAAM,WAAW,KAAK,aAAa;AACnC,UAAM,WAAW,aAAa,kBAAkB;AAEhD,UAAM,gBAAgB,KAAK;AAC3B,UAAM,aAAa,KAAK;AACxB,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,KAAK;AAClB,UAAM,aAAa,KAAK;AACxB,UAAM,SAAS,KAAK;AACpB,UAAM,KAAK,KAAK;AAEhB,UAAM,OAAO,MAAM;AACnB,QAAI,sBAAsB,OAAO,IAAI;AACrC,QAAI,WAAW,aAAa;AACxB,4BAAsB,WAAW;IACrC;AAEA,QAAI,QAAQ;AACZ,QAAI,WAAW;AACf,QAAI,MAAM,mBAAc,GAA0B;AAC9C,cAAQ;AACR,iBAAW;IACf;AACA,QAAI,KAAK,GAAG,aAAa;AACrB,YAAM,qBAAqB;;AAE3B,UAAI,MAAM,mBAAc,GAA0B;AAC9C,cAAM,qBAAqB,oCAAoC,MAAM,sBAAsB,YAAY,MAAM,sBAAsB,YAAY,MAAM,sBAAsB;AAC3K,cAAM,qBAAqB;AAC3B,cAAM,qBAAqB,8CAA8C,cAAc,sBAAsB;;AAC7G,cAAM,qBAAqB;;MAC/B,OAAO;AACH,cAAM,qBAAqB,wBAAwB,MAAM,sBAAsB;AAC/E,cAAM,qBAAqB;AAC3B,cAAM,qBAAqB,wCAAwC,cAAc,sBAAsB;;AACvG,cAAM,qBAAqB;;MAC/B;AAEA,YAAM,qBAAqB,GAAG,MAAM,eAAe,EAAE,CAAC;;AACtD,YAAM,qBAAqB;;AAC3B,YAAM,qBAAqB,GAAG,MAAM,eAAe,EAAE,CAAC,UAAU,IAAI;;AACpE,YAAM,qBAAqB;;IAC/B,OAAO;AACH,YAAM,qBAAqB,GAAG,MAAM,eAAe,EAAE,CAAC,UAAU,IAAI;IACxE;AAEA,UAAM,qBAAqB,GAAG,MAAM,eAAe,MAAM,CAAC,wBAAwB,KAAK,QAAQ,cAAc,sBAAsB,KAAK,mBAAmB,iBAAiB,MAAM,sBAAsB,KAAK,KAAK,sBAAsB,KAAK,WAAW,sBAAsB,GAAG,QAAQ;;AACzR,WAAO;EACX;;AAGJ,cAAc,kCAAkC,sBAAsB;;;AC3JtE,IAAM,SAAN,MAAY;EAAZ,cAAA;AACa,SAAA,KAAK,oBAAI,IAAG;EAiBzB;EAfI,IAAI,GAAO,GAAK;AACZ,UAAM,IAAI,KAAK,GAAG,IAAI,CAAC;AACvB,QAAI,MAAM,QAAW;AACjB,aAAO,EAAE,IAAI,CAAC;IAClB;AACA,WAAO;EACX;EAEA,IAAI,GAAO,GAAO,GAAI;AAClB,QAAI,IAAI,KAAK,GAAG,IAAI,CAAC;AACrB,QAAI,MAAM,QAAW;AACjB,WAAK,GAAG,IAAI,GAAI,IAAI,oBAAI,IAAG,CAAG;IAClC;AACA,MAAE,IAAI,GAAG,CAAC;EACd;;AAME,IAAO,qBAAP,MAAyB;;EAc3B,IAAW,aAAU;AACjB,WAAO,KAAK,UAAU,cAAc;EACxC;;EAGA,IAAW,eAAY;AACnB,WAAO,KAAK;EAChB;;EAGA,IAAW,kBAAe;AACtB,WAAO,KAAK,UAAU,mBAAmB;EAC7C;;;;;;;;;;EAWA,YAAY,cAAwB,OAAe,SAAqC;AACpF,SAAK,gBAAgB;AACrB,SAAK,SAAS,SAAgB,YAAY;AAC1C,SAAK,WAAW;AAEhB,SAAK,mBAAmB,oBAAI,IAAG;AAC/B,SAAK,yBAAyB,IAAI,OAAM;AACxC,SAAK,UAAU,oBAAI,IAAG;AAItB,SAAK,2BAA2B,KAAK,cAAc,0BAA0B,IAAI,CAAC,WAA0D;AACxI,YAAM,OAAO,OAAO,SAAS,QAAO;AAEpC,UAAI,QAAQ,CAAC,KAAK,QAAQ,IAAI,IAAI,GAAG;AAEjC,aAAK,QAAQ,IACT,MACA,KAAK,oBAAoB,IAAI,CAACC,UAAc;AACxC,gBAAM,WAAW,KAAK,iBAAiB,KAAI;AAC3C,mBAAS,MAAM,SAAS,KAAI,GAAI,IAAI,SAAS,MAAM,MAAM,SAAS,KAAI,GAAI;AACtE,kBAAM,UAAU,IAAI;AACpB,gBAAI,SAAS,QAAO,MAAQA,OAAuB;AAC/C,mBAAK,iBAAiB,OAAO,OAAO;AACpC,mBAAK,0BAA0B,OAAO;YAC1C;UACJ;QACJ,CAAC,CAAC;MAEV;AAEA,UAAI,KAAK,iBAAiB,IAAI,OAAO,OAAO,IAAI,CAAC,MAAM,OAAO,QAAQ;AAClE,aAAK,iBAAiB,IAAI,OAAO,SAAS,CAAC,OAAO,QAAQ,KAAK,OAAO,UAAS,EAAG,mBAAmB,CAAC;AACtG,aAAK,0BAA0B,OAAO,OAAO;MACjD;IACJ,CAAC;EACL;EAEQ,0BAA0B,SAA0B;AACxD,UAAM,sBAAsB,KAAK,uBAAuB,GAAG,IAAI,OAAO;AACtE,QAAI,qBAAqB;AAErB,0BAAoB,QAAQ,CAAC,iBAAgB;AACzC,qBAAa,gBAAgB,QAAQ,QAAO;MAChD,CAAC;AACD,WAAK,uBAAuB,GAAG,OAAO,OAAO;IACjD;EACJ;;;;;;;;EASO,UAAU,SAA4B,iBAAkC,sBAA4B;AACvG,UAAM,QAAQ,KAAK,uBAAuB,GAAG,IAAI,OAAO,GAAG,IAAI,eAAe;AAC9E,QAAI,CAAC,OAAO;AACR,aAAO;IACX;AACA,QAAI,cAAc,MAAM,YAAY,oBAAoB;AACxD,QAAI,CAAC,aAAa;AACd,oBAAc,MAAM,YAAY,oBAAoB,IAAI,IAAI,YAAY,KAAK,OAAO,UAAS,CAAE;AAC/F,kBAAY,UAAU,MAAM,gBAAgB,QAAQ,MAAM,gBAAgB,OAAO;IACrF;AAEA,WAAO;EACX;;;;;;;;;;EAWO,kBAAkB,SAAkB,SAAmB,iBAAkC,cAAuB,sBAA4B;AAC/I,QAAI,KAAK,YAAY;AAEjB,UAAI,CAAC,KAAK,cAAc,kBAAkB,QAAQ,QAAO,GAAI,SAAS,YAAY,GAAG;AACjF,eAAO;MACX;IACJ;AAEA,WAAO,KAAK,YAAY,SAAS,SAAS,iBAAiB,oBAAoB,GAAG,QAAO,KAAM;EACnG;;;;EAKO,UAAO;AACV,SAAK,cAAc,0BAA0B,OAAO,KAAK,wBAAwB;AACjF,SAAK,2BAA2B;AAEhC,UAAM,WAAW,KAAK,QAAQ,QAAO;AACrC,aAAS,QAAQ,SAAS,KAAI,GAAI,MAAM,SAAS,MAAM,QAAQ,SAAS,KAAI,GAAI;AAC5E,YAAM,CAAC,MAAM,QAAQ,IAAI,MAAM;AAE/B,WAAK,oBAAoB,OAAO,QAAQ;IAC5C;EACJ;EAEQ,YAAY,SAAkB,SAAmB,iBAAkC,sBAA4B;AACnH,UAAM,SAAS,KAAK,OAAO,UAAS;AACpC,UAAM,4BAA4B,KAAK,iBAAiB,IAAI,OAAO;AAEnE,QAAI,CAAC,2BAA2B;AAC5B,aAAO;IACX;AAEA,UAAM,CAAC,YAAY,gBAAgB,IAAI;AAEvC,QAAI,CAAC,WAAW,QAAO,GAAI;AACvB,aAAO;IACX;AAEA,QAAI,SAAS,KAAK,uBAAuB,IAAI,SAAS,eAAe;AACrE,QAAI,CAAC,QAAQ;AACT,YAAM,kBAAkB,IAAI,YAAY,MAAM;AAC9C,sBAAgB,UAAU,QAAQ,gBAAgB,gBAAgB,GAAG,WAAW;AAEhF,eAAS;QACL,aAAa,CAAA;QACb;QACA,cAAc;QACd,OAAO,WAAU;;AAErB,aAAO,YAAY,oBAAoB,IAAI;AAC3C,WAAK,uBAAuB,IAAI,SAAS,iBAAiB,MAAM;IACpE;AAEA,UAAM,OAAO,QAAQ,KAAK,IAAI;AAE9B,QAAI,OAAO,gBAAgB,QAAQ;AAC/B,UAAI,SAAS,OAAO,cAAc;AAE9B,eAAO,OAAO,gBAAgB;MAClC;IACJ;AAEA,WAAO,eAAe;AAEtB,UAAM,WAAW,WAAW,gBAAe,EAAG,MAAK;AAGnD,QAAI,aAAa,WAAW,iCACxB,eAAe,WAAW;AAE9B,QAAI,CAAC,cAAc,CAAC,cAAc;AAC9B,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,iBAAiB;AAEvB,YAAM,uBACE,KAAK,YAAY,KAAK,SAAS,oBACzB,uCAAuC,KAAK,SAAS,kBAAkB,KAAK,GAAG,CAAC,MAChF,uCACV,mBACI,KAAK,YAAY,KAAK,SAAS,oBACzB,mCAAmC,KAAK,SAAS,kBAAkB,KAAK,GAAG,CAAC,MAC5E,mCACV,gCACI,KAAK,YAAY,KAAK,SAAS,oBACzB,oDAAoD,KAAK,SAAS,kBAAkB,KAAK,GAAG,CAAC,MAC7F,oDACV,oBAAoB,+BACpB,wBAAwB;AAG5B,UAAI,WAAW,mBAAc,GAA0B;AACnD,qBAAa,WAAW,QAAQ,iBAAiB;EAAK,qBAAqB;UAAa;MAC5F,OAAO;AACH,qBAAa,WAAW,QAAQ,YAAY;EAAK,qBAAqB;QAAW;MACrF;AACA,mBAAa,WAAW,QAAQ,yEAAyE,oBAAoB;AAE7H,UAAI,WAAW,QAAQ,4BAA4B,MAAM,IAAI;AACzD,qBAAa,WAAW,QAAQ,+BAA+B,gBAAgB;MACnF,OAAO;AACH,qBAAa,WAAW,QAAQ,UAAU,mBAAmB,KAAK;MACtE;AACA,mBAAa,WAAW,QAAQ,qDAAqD,EAAE;AAGvF,YAAM,sCACF,aAAa,QAAQ,2CAA2C,KAAK,KAAK,aAAa,QAAQ,oCAAoC,KAAK;AAC5I,YAAM,yBAAyB,aAAa,QAAQ,8BAA8B,MAAM;AAExF,UAAI,4BAA4B;AAEhC,UAAI,CAAC,qCAAqC;AACtC,oCAA4B,gCAAgC;MAChE,OAAO;AACH,uBAAe,aAAa,QAAQ,iFAAiF,6BAA6B;MACtJ;AAEA,qBAAe,aAAa,QAAQ,iBAAiB,OAAO,qBAAqB,mCAAmC,IAAI,aAAa;AAErI,UAAI,wBAAwB;AACxB,uBAAe,aAAa,QAAQ,iCAAiC,iBAAiB;MAC1F,OAAO;AACH,qCAA6B,oBAAoB;MACrD;AACA,UAAI,2BAA2B;AAC3B,uBAAe,aAAa,QAAQ,UAAU,4BAA4B,GAAG;MACjF;AAEA,eAAS,KAAK,kBAAkB,iBAAiB,eAAe,yBAAyB;IAC7F;AAEA,WAAO,gBAAgB,SAAS,OAAO,aACnC;MACI,cAAc;MACd,gBAAgB;MAChB,aAAa,OAAO;MACpB,eAAe,OAAO;OAEF;MACpB,YAAY,WAAW,mBAAkB;MACzC,eAAe;MACf,qBAAqB,WAAW,uBAAsB;MACtD,UAAU,WAAW,YAAW;MAChC,SAAS,OAAO,OAAO,WAAW,QAAQ,QAAQ,mBAAmB,EAAE,EAAE,QAAQ,qBAAqB,EAAE;MACxG,iBAAiB,WAAW,mBAAkB;MAC9C,gBAAgB,WAAW;OAE/B,MAAM;AAGV,aAAS,KAAK,GAAG,KAAK,OAAO,YAAY,QAAQ,EAAE,IAAI;AACnD,UAAI,OAAO,sBAAsB;AAC7B,eAAO,YAAY,EAAE,GAAG,UAAU,OAAO,gBAAgB,QAAQ,OAAO,gBAAgB,OAAO;MACnG;IACJ;AACA,WAAO,OAAO,gBAAgB;EAClC;;;;AC5UJ,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;AAQf,IAAI,CAAC,YAAY,aAAa,IAAI,GAAG;AACjC,cAAY,aAAa,IAAI,IAAI;AACrC;;;ACRA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;AAKf,IAAI,CAAC,YAAY,aAAaD,KAAI,GAAG;AACjC,cAAY,aAAaA,KAAI,IAAIC;AACrC;;;ACTA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;;;;;;;;;;;;AAkBf,IAAI,CAAC,YAAY,iBAAiBD,KAAI,GAAG;AACrC,cAAY,iBAAiBA,KAAI,IAAIC;AACzC;;;ACpBA,IAAMC,QAAO;AACb,IAAMC,UAAS;;;;;;AAOf,IAAI,CAAC,YAAY,iBAAiBD,KAAI,GAAG;AACrC,cAAY,iBAAiBA,KAAI,IAAIC;AACzC;;;ACuBA,IAAM,mCAAN,cAA+C,gBAAe;;;;EAgB1D,cAAA;AACI,UAAK;AAhBF,SAAA,MAAM;AACN,SAAA,iBAAiB;AACjB,SAAA,mBAAmB;AACnB,SAAA,YAAY;AACZ,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,aAAa;AACb,SAAA,YAAY;AACZ,SAAA,eAAe;AAOlB,SAAK,QAAO;EAChB;;AAOE,IAAO,4BAAP,MAAO,mCAAkC,aAAY;;;;;;EAMvD,YAAYC,OAAc,OAAa;AACnC,UAAMA,OAAM,KAAK;AAmBd,SAAA,aAAa,2BAA0B;AACtC,SAAA,gBAAgB,2BAA0B;AAG1C,SAAA,WAAW;AArBf,SAAK,kBAAkB;AACvB,SAAK,qBAAqB,2BAA0B,yCAAyC,OAAQ,KAAK,cAAc;EAC5H;;;;EAwBA,IAAW,aAAa,OAAc;AAClC,SAAK,WAAW,KAAK,YAAY;AACjC,SAAK,gBAAgB;EACzB;;;;EAKA,IAAW,eAAY;AACnB,WAAO,KAAK;EAChB;;;;EAKA,IAAoB,0BAAuB;AACvC,WAAO;EACX;;;;;EAMgB,mBAAgB;AAC5B,WAAO;EACX;;;;;EAMgB,oBAAiB;AAC7B,WAAO;EACX;;;;;;;EAyBgB,kBAAkB,MAAoB,SAAgB;AAClE,UAAM,eAAe;AAErB,UAAM,cAAc,QAAQ;AAC5B,QAAI,UAA4C,QAAQ;AAExD,QAAI,WAAW,KAAK,UAAU;AAC1B,cAAQ,kBAAiB;IAC7B;AAEA,QAAI,YAAY,UAAU,KAAK,UAAU;AACrC,UAAI,YAAY,uBAAuB,YAAY,iCAAiC,cAAc;AAC9F,eAAO;MACX;IACJ;AAEA,QAAI,CAAC,QAAQ,iBAAiB;AAC1B,gBAAU,QAAQ,kBAAkB,IAAI,iCAAgC;IAC5E;AAEA,UAAM,QAAQ,KAAK,SAAQ;AAE3B,QAAI,KAAK,mBAAmB,OAAO,GAAG;AAClC,aAAO;IACX;AAEA,UAAM,SAAS,MAAM,UAAS;AAC9B,UAAM,SAAS;AAGf,0BACI,MACA,OACA,KAAK,sBACL,KAAK,aACL,KAAK,YACL,OACA,SACA,QACA,QACA,QACA,KAAK,wBAAwB;AAIjC,sCAAkC,OAAO,QAAQ,MAAM,SAAS,cAAc,MAAM,IAAI;AAGxF,gCAA4B,MAAM,SAAS,OAAO,KAAK;AAGvD,QAAI,OAAO,UAAU,KAAK,OAAO,UAAU;AACvC,cAAQ,WAAW,IAAI,OAAO;IAClC;AAGA,UAAM,gBAAgB,OAAO;AAC7B,YAAQ,cAAc,IAAI,iBAAiB,cAAc,eAAe,cAAc,eAAe,2BAA0B;AAG/H,QAAI,QAAQ,SAAS;AACjB,cAAQ,gBAAe;AACvB,YAAM,oBAAmB;AAGzB,oCAA8B,2BAA0B,UAAU,OAAO;AAEzE,qCAAuD;QACnD,eAAe,2BAA0B;QACzC,qBAAqB,2BAA0B;QAC/C,UAAU,2BAA0B;QACpC;OACH;AAED,2BAAqB,2BAA0B,SAAS;AAExD,YAAM,OAAO,QAAQ,SAAQ;AAC7B,YAAM,SAAS,MAAM,UAAS,EAAG,aAC7B,qBACwB;QACpB,YAAY,2BAA0B;QACtC,eAAe,2BAA0B;QACzC,qBAAqB,2BAA0B;QAC/C,UAAU,2BAA0B;QACpC,SAAS;QACT,YAAY,KAAK;QACjB,SAAS,KAAK;QACd,iBAAiB,CAAA;QACjB,gBAAgB,KAAK;QACrB,2BAA2B,YAAW;AAClC,cAAI,KAAK,oBAAe,GAA0B;AAC9C,kBAAM,QAAQ,IAAI,CAAC,OAAO,0CAAiD,GAAA,OAAO,wCAAgD,CAAA,CAAA;UACtI,OAAO;AACH,kBAAM,QAAQ,IAAI,CAAC,OAAO,0CAA6C,GAAA,OAAO,wCAA4C,CAAA,CAAA;UAC9H;QACJ;SAEJ,MAAM;AAEV,cAAQ,UAAU,QAAQ,SAAS,KAAK,gBAAgB;IAC5D;AAEA,QAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,OAAO,QAAO,GAAI;AAC9C,aAAO;IACX;AAEA,YAAQ,YAAY,MAAM,YAAW;AACrC,gBAAY,sBAAsB;AAClC,gBAAY,+BAA+B;AAC3C,SAAK,WAAW;AAEhB,WAAO;EACX;;;;;;;EAQO,OAAO,WAAW,MAAY,QAAgB,OAAY;AAC7D,UAAM,SAAS,MAAM,UAAS;AAC9B,UAAM,SAAS,MAAM;AAErB,UAAM,cAAc,OAAO,eAAc;AACzC,UAAM,eAAe,OAAO,gBAAe;AAE3C,UAAM,SAAS;AACf,UAAM,aAAa,OAAO;AAG1B,UAAM,eAAe,QAAQ,WAAW,WAAW,UAAU;AAE7D,WAAO,UAAU,eAAe,KAAK,cAAc,eAAe,IAAI,YAAY;AAElF,QAAI,QAAQ;AAEZ,QAAI,QAAQ;AAQR,YAAM,IAAI,OAAO,oBAAmB,EAAG,EAAE,CAAC;AAC1C,UAAI,OAAO,WAAW,OAAO,wBAAwB;AACjD,gBAAS,eAAe,IAAK;MACjC,OAAO;AACH,gBAAS,cAAc,IAAK;MAChC;IACJ;AAEA,WAAO,UAAU,SAAS,OAAO,KAAK;AACtC,WAAO,WAAW,uBAAuB,OAAO,mBAAmB;AACnE,WAAO,SAAS,cAAc,cAAc,WAAW,aAAa,WAAW,aAAa,2BAA0B,UAAU;AAChI,UAAM,gBAAgB,QAAQ,eAAe,IAAI;AAEjD,QAAI,OAAO,qBAAqB;AAC5B,YAAM,cAAc,OAAO,oBAAoB,QAAO;AAEtD,aAAO,UAAU,mBAAmB,YAAY,OAAO,YAAY,MAAM;AAEzE,aAAO,WAAW,uBAAuB,OAAO,mBAAmB;AACnE,aAAO,WAAW,uBAAuB,OAAO,mBAAmB;AACnE,aAAO,WAAW,kBAAkB,OAAO,cAAc;AACzD,aAAO,WAAW,iBAAiB,OAAO,aAAa;AAEvD,UAAI,OAAO,YAAY;AACnB,iBAAS,IAAI,GAAG,IAAI,OAAO,YAAY,QAAQ,KAAK;AAChD,iBAAO,WAAW,YAAY,CAAC,IAAI,OAAO,WAAW,CAAC,CAAC;QAC3D;MACJ;IACJ;EACJ;;;;;;;EAOgB,eAAe,OAAe,MAAY,SAAgB;AACtE,UAAM,QAAQ,KAAK,SAAQ;AAE3B,UAAM,UAA4C,QAAQ;AAC1D,QAAI,CAAC,SAAS;AACV;IACJ;AAEA,UAAM,SAAS,QAAQ;AACvB,QAAI,CAAC,QAAQ;AACT;IACJ;AACA,SAAK,gBAAgB;AAGrB,SAAK,qBAAoB,EAAG,aAAa,QAAQ,MAAM;AACvD,SAAK,iBAAiB,KAAK;AAG3B,UAAM,aAAa,KAAK,YAAY,OAAO,QAAQ,SAAS,KAAK,UAAU;AAE3E,QAAI,YAAY;AACZ,WAAK,SAAS,MAAM;AACpB,WAAK,mBAAmB,MAAM;AAC9B,iCAA0B,WAAW,MAAM,KAAK,eAAe,KAAK;AAEpE,oBAAc,QAAQ,MAAM,KAAK;IACrC,WAAW,MAAM,UAAS,EAAG,UAAU,gCAAgC;AACnE,WAAK,sBAAsB;IAC/B;AAGA,sBAAkB,OAAO,MAAM,MAAM;AAGrC,QAAI,KAAK,qBAAqB;AAC1B,mBAAa,SAAS,QAAQ,KAAK;IACvC;AAEA,SAAK,WAAW,MAAM,KAAK,eAAe,OAAO;EACrD;EAEU,OAAO,yCAAyC,OAAc,gBAA8B;AAClG,UAAM,iBAAiB,IAAI,eACvB,0BACA,OACA;MACI,QAAQ;MACR,UAAU;OAEd;MACI,YAAY,2BAA0B;MACtC,UAAU,2BAA0B;MACpC,UAAU,2BAA0B;MACpC,gBAAgB,2BAA0B;MAC1C;KACH;AAGL,UAAM,qBAAqB,IAAI,mBAAmB,gBAAgB,OAAO;MACrE,YAAY;KACf;AAED,mBAAe,iBAAiB,IAAI,CAAC,SAAsB;AACvD,YAAM,SAAS,eAAe,UAAS;AACvC,YAAM,aAAa,KAAK;AACxB,YAAM,SAAS;AAEf,WAAK,qBAAoB,EAAG,aAAa,QAAQ,MAAM;AACvD,qBAAe,SAAS,MAAM;AAC9B,qBAAe,mBAAmB,MAAM;AAExC,YAAM,iBAAiB,MAAM,UAAS,EAAG,eAAc;AACvD,YAAM,kBAAkB,MAAM,UAAS,EAAG,gBAAe;AACzD,aAAO,UAAU,eAAe,IAAI,gBAAgB,IAAI,eAAe;AAEvE,YAAM,aAAa,MAAM,oBAAmB;AAC5C,YAAM,IAAI,WAAW,EAAE,CAAC;AACxB,YAAM,QAAS,iBAAiB,IAAK;AAErC,aAAO,UAAU,SAAS,OAAO,KAAK;AACtC,aAAO,SAAS,cAAc,cAAc,WAAW,aAAa,WAAW,aAAa,2BAA0B,UAAU;AAEhI,UAAI,OAAO,qBAAqB;AAC5B,cAAM,cAAc,OAAO,oBAAoB,QAAO;AACtD,eAAO,UAAU,mBAAmB,YAAY,OAAO,YAAY,MAAM;AAEzE,eAAO,WAAW,uBAAuB,OAAO,mBAAmB;AACnE,eAAO,WAAW,uBAAuB,OAAO,mBAAmB;AACnE,eAAO,WAAW,kBAAkB,OAAO,cAAc;AACzD,eAAO,WAAW,iBAAiB,OAAO,aAAa;MAC3D;IACJ,CAAC;AAED,WAAO;EACX;;;;;;EAOgB,MAAMA,OAAY;AAC9B,WAAO,oBAAoB,MAAM,MAAM,IAAI,2BAA0BA,OAAM,KAAK,SAAQ,CAAE,GAAG,IAAI;EACrG;;;;;EAMgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAC3C,wBAAoB,aAAa;AACjC,WAAO;EACX;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;;;;EASO,OAAgB,MAAM,QAAa,OAAc,SAAe;AACnE,WAAO,oBAAoB,MAAM,MAAM,IAAI,2BAA0B,OAAO,MAAM,KAAK,GAAG,QAAQ,OAAO,OAAO;EACpH;;AAvYc,0BAAA,aAAqB;AAKrB,0BAAA,eAAwB;AAiDrB,0BAAA,WAAW,CAAC,aAAa,cAAc,eAAe,eAAe,eAAe,aAAa;AACjG,0BAAA,YAAY,CAAC,uBAAuB,uBAAuB,kBAAkB,iBAAiB,cAAc,cAAc,YAAY;AACtI,0BAAA,kBAAkB,CAAC,SAAS,MAAM;AAClC,0BAAA,YAAY;EACzB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAqUR,cAAc,qCAAqC,yBAAyB;;;AC5ctE,IAAO,mBAAP,cAAgC,kBAAiB;;;;;EAKnD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,MAAM;AAE3C,SAAK,YAAY;AAEjB,SAAK,cAAc,cAAc,sCAAsC,OAAO,OAAO,yBAAyB,MAAM;AAEpH,SAAK,eAAe,iBAAiB,sCAAsC,SAAS,yBAAyB,MAAM;AACnH,SAAK,eAAe,cAAc,sCAAsC,QAAQ,yBAAyB,MAAM;EACnH;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,MAAM;AACjC,UAAM,qBAAqB,MAAM;AACjC,UAAM,qBAAqB,WAAW;AACtC,UAAM,qBAAqB,qBAAqB;AAChD,UAAM,qBAAqB,qBAAqB;AAChD,UAAM,qBAAqB,gBAAgB;AAC3C,UAAM,qBAAqB,eAAe;AAC1C,UAAM,qBAAqB,iBAAiB;EAChD;EAEgB,KAAK,QAAgB,cAA4B,MAAW;AACxE,QAAI,CAAC,MAAM;AACP;IACJ;AACA,UAAM,QAAQ,KAAK,SAAQ;AAC3B,8BAA0B,WAAW,MAAM,QAAQ,KAAK;EAC5D;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,MAAM,WAAW,yBAAyB,UAAU;AACpD;IACJ;AAEA,UAAM,WAAW,eAAe,KAAK,IAAI;AAGzC,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,eAAe,qBAAqB;AAC1C,UAAM,eAAe,qBAAqB;AAC1C,UAAM,eAAe,gBAAgB;AACrC,UAAM,eAAe,eAAe;AACpC,UAAM,eAAe,cAAc,iBAAiB,QAAW,QAAW,MAAM,OAAO;AACvF,UAAM,eAAe,cAAc,iBAAiB,QAAW,QAAW,MAAM,OAAO;AACvF,UAAM,eAAe,cAAc,iBAAiB,QAAW,QAAW,MAAM,OAAO;AAEvF,UAAM,yBAAyB,sCAAsC,QAAQ;AAC7E,UAAM,yBAAyB,qBAAqB,QAAQ;AAC5D,UAAM,uBAAuB,aAAa,sCAAsC,OAAO;AACvF,UAAM,uBAAuB,mBAAmB,sCAAsC,OAAO;AAC7F,UAAM,gBAAgB,KAAK;AAC3B,UAAM,aAAa,KAAK;AAExB,UAAM,oBAAoB,MAAM,qBAAqB,OAAO;AAE5D,QAAI,MAAM,mBAAc,GAA0B;AAC9C,YAAM,qBAAqB;AAC3B,YAAM,qBAAqB,OAAO,iBAAiB;;AACnD,YAAM,qBAAqB;;AAC3B,YAAM,qBAAqB;IAC/B,OAAO;AACH,YAAM,qBAAqB;AAC3B,YAAM,qBAAqB,SAAS,iBAAiB;;AACrD,YAAM,qBAAqB;;AAC3B,YAAM,qBAAqB;IAC/B;AACA,UAAM,qBAAqB,GAAG,MAAM,eAAe,aAAa,CAAC,MAAM,iBAAiB;;AACxF,UAAM,qBAAqB,GAAG,MAAM,eAAe,UAAU,CAAC,MAAM,iBAAiB;;AAErF,WAAO;EACX;;AAGJ,cAAc,4BAA4B,gBAAgB;;;ACtHpD,IAAO,gBAAP,cAA6B,kBAAiB;;;;;EAKhD,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,QAAQ;AAE7C,SAAK,YAAY;AAEjB,SAAK,cAAc,cAAc,sCAAsC,QAAQ,OAAO,yBAAyB,QAAQ;AAEvH,SAAK,eAAe,QAAQ,sCAAsC,QAAQ,yBAAyB,QAAQ;AAC3G,SAAK,eAAe,OAAO,sCAAsC,QAAQ,yBAAyB,QAAQ;AAC1G,SAAK,eAAe,SAAS,sCAAsC,OAAO,yBAAyB,QAAQ;EAC/G;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;EAKA,IAAW,OAAI;AACX,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,MAAG;AACV,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,SAAS,CAAC;EAC1B;;;;;EAMgB,WAAW,OAA6B;AACpD,UAAM,qBAAqB,WAAW;EAC1C;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,MAAM,WAAW,yBAAyB,QAAQ;AAClD;IACJ;AAGA,UAAM,WAAW,KAAK,KAAK,IAAI;AAC/B,UAAM,yBAAyB,gCAAgC,QAAQ;AACvE,UAAM,yBAAyB,uBAAuB,QAAQ;AAC9D,UAAM,yBAAyB,0BAA0B,QAAQ;AACjE,UAAM,yBAAyB,wCAAwC,QAAQ;AAC/E,UAAM,uBAAuB,aAAa,sCAAsC,OAAO;AAEvF,UAAM,iBAAiB,MAAM,qBAAqB,gBAAgB;AAClE,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,KAAK,SAAS,CAAC;AAC5B,UAAM,MAAM,KAAK,SAAS,CAAC;AAC3B,UAAM,QAAQ,KAAK,SAAS,CAAC;AAE7B,QAAI,MAAM,mBAAc,GAA0B;AAC9C,YAAM,qBAAqB,OAAO,cAAc,0BAA0B,MAAM,sBAAsB;;IAC1G,OAAO;AACH,YAAM,qBAAqB,QAAQ,cAAc,oBAAoB,MAAM,sBAAsB;;IACrG;AAEA,UAAM,qBAAqB,GAAG,MAAM,eAAe,IAAI,CAAC,MAAM,cAAc;AAC5E,UAAM,qBAAqB,GAAG,MAAM,eAAe,GAAG,CAAC,MAAM,cAAc;AAC3E,UAAM,qBAAqB,GAAG,MAAM,eAAe,KAAK,CAAC,MAAM,cAAc;AAE7E,WAAO;EACX;;AAGJ,cAAc,yBAAyB,aAAa;;;ACxGpD,IAAMC,QAAO;AACb,IAAMC,UAAS;AAEf,IAAI,CAAC,YAAY,yBAAyBD,KAAI,GAAG;AAC7C,cAAY,yBAAyBA,KAAI,IAAIC;AACjD;AAEO,IAAM,yCAAyC,EAAE,MAAAD,OAAM,QAAAC,QAAM;;;ACK9D,IAAO,yBAAP,cAAsC,kBAAiB;;;;EAUzD,IAAW,WAAQ;AACf,WAAO,KAAK,aAAa,KAAK,MAAM;EACxC;EAEA,IAAW,SAAS,OAAc;AAC9B,QAAI,KAAK,cAAc,OAAO;AAC1B;IACJ;AAEA,SAAK,YAAY;EACrB;;;;;EAMA,YAAmBC,OAAY;AAC3B,UAAMA,OAAM,yBAAyB,UAAU,MAAM,IAAI;AA1BrD,SAAA,YAAY;AAIb,SAAA,cAAc;AAwBjB,SAAK,cAAc,SAAS,sCAAsC,YAAY,IAAI;AAElF,SAAK,MAAM,6BAA6B,KAAK,sCAAsC,MAAM;EAC7F;;EAGA,IAAoB,0BAAuB;AACvC,WAAO,KAAK;EAChB;;EAGA,IAAoB,iBAAc;AAC9B,WAAO;EACX;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK,QAAQ,CAAC;EACzB;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;EAEmB,YAAY,OAA6B;AACxD,UAAM,YAAY,KAAK;AAEvB,QAAI,CAAC,KAAK,WAAW;AACjB,aAAO;IACX;AAEA,QAAI,eAAe;AACnB,QAAI,MAAM,mBAAc,GAA0B;AAC9C,qBAAe;IACnB;AAEA,UAAM,QAAQ,KAAK;AACnB,QAAI,CAAC,MAAM,gBAAgB;AACvB,aAAO;IACX;AAEA,QAAI,MAAM,eAAe,SAAS,sCAAsC,OAAO;AAC3E,YAAM,qBAAqB,GAAG,YAAY,WAAW,MAAM,OAAO,IAAI,MAAM,sBAAsB,KAAK,MAAM,sBAAsB,KAAK,MAAM,sBAAsB;;IACxK,WAAW,MAAM,eAAe,SAAS,sCAAsC,SAAS;AACpF,YAAM,qBAAqB,GAAG,YAAY,WAAW,MAAM,OAAO,IAAI,MAAM,sBAAsB;;IACtG,WAAW,MAAM,eAAe,SAAS,sCAAsC,UAAU,MAAM,eAAe,SAAS,sCAAsC,SAAS;AAClK,YAAM,qBAAqB,GAAG,YAAY,WAAW,MAAM,OAAO,IAAI,MAAM,sBAAsB;;IACtG,WAAW,KAAK,aAAa;AACzB,YAAM,qBAAqB,GAAG,YAAY,MAAM,MAAM,sBAAsB;;IAChF,OAAO;AACH,YAAM,qBAAqB,GAAG,YAAY,WAAW,MAAM,OAAO,IAAI,MAAM,sBAAsB;;IACtG;AAEA,WAAO;EACX;EAEgB,YAAS;AACrB,UAAM,sBAAsB,MAAM,UAAS;AAC3C,wBAAoB,WAAW,KAAK;AACpC,wBAAoB,cAAc,KAAK;AACvC,WAAO;EACX;EAEgB,aAAa,qBAA0B,OAAc,SAAe;AAChF,UAAM,aAAa,qBAAqB,OAAO,OAAO;AAEtD,SAAK,WAAW,oBAAoB;AACpC,SAAK,cAAc,oBAAoB;EAC3C;;AAlGO,WAAA;EADN,uBAAuB,gBAAc,GAAkC,MAAS;;AAsGrF,cAAc,kCAAkC,sBAAsB;",
  "names": ["NodeMaterialBlockConnectionPointTypes", "NodeMaterialBlockTargets", "NodeMaterialConnectionPointCompatibilityStates", "NodeMaterialConnectionPointDirection", "name", "name", "prefix", "name", "NodeMaterialSystemValues", "AnimatedInputBlockTypes", "name", "name", "name", "name", "name", "name", "PropertyTypeForEdition", "FragmentOutputBlockColorSpace", "name", "NodeMaterialModes", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "textureReadFunc", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "TrigonometryBlockOperations", "name", "name", "result", "effect", "source", "name", "name", "name", "name", "replaceString", "name", "input", "name", "name", "name", "textureReadFunc", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "WaveBlockKind", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "onCreatedEffectParameters", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "name", "ConditionalBlockConditions", "name", "name", "name", "name", "name", "name", "name", "name", "MeshAttributeExistsBlockTypes", "name", "attributeDefine", "CurveBlockTypes", "name", "name", "name", "name", "name", "name", "name", "mesh", "name", "shader", "name", "shader", "name", "shader", "name", "name", "name", "name", "shader", "name"]
}
